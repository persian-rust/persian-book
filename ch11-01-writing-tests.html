<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>چگونه تست بنویسیم - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="چگونه-تست-بنویسیم"><a class="header" href="#چگونه-تست-بنویسیم">چگونه تست بنویسیم</a></h2>
<p>تست‌ها توابعی در Rust هستند که بررسی می‌کنند کد غیرتستی به شکل مورد انتظار کار می‌کند. بدنه توابع تست معمولاً این سه عمل را انجام می‌دهد:</p>
<ul>
<li>تنظیم هر داده یا وضعیت مورد نیاز.</li>
<li>اجرای کدی که می‌خواهید تست کنید.</li>
<li>تأیید اینکه نتایج همان چیزی است که انتظار دارید.</li>
</ul>
<p>بیایید به ویژگی‌هایی که Rust به طور خاص برای نوشتن تست‌هایی که این اقدامات را انجام می‌دهند فراهم کرده است نگاهی بیندازیم. این ویژگی‌ها شامل ویژگی <code>test</code>، چند ماکرو و ویژگی <code>should_panic</code> هستند.</p>
<h3 id="آناتومی-یک-تابع-تست"><a class="header" href="#آناتومی-یک-تابع-تست">آناتومی یک تابع تست</a></h3>
<p>در ساده‌ترین حالت، یک تست در Rust یک تابع است که با ویژگی <code>test</code> حاشیه‌نویسی شده است. ویژگی‌ها متاداده‌هایی درباره بخش‌های کد Rust هستند؛ یک مثال ویژگی <code>derive</code> است که در فصل ۵ با ساختارها استفاده کردیم. برای تغییر یک تابع به یک تابع تست، <code>#[test]</code> را به خط قبل از <code>fn</code> اضافه کنید. وقتی تست‌های خود را با فرمان <code>cargo test</code> اجرا می‌کنید، Rust یک باینری تست رانر ایجاد می‌کند که توابع حاشیه‌نویسی‌شده را اجرا می‌کند و گزارش می‌دهد که آیا هر تابع تست موفق یا ناموفق بوده است.</p>
<p>هر زمان که یک پروژه کتابخانه‌ای جدید با Cargo ایجاد می‌کنیم، یک ماژول تست با یک تابع تست در آن به صورت خودکار برای ما تولید می‌شود. این ماژول یک قالب برای نوشتن تست‌های شما فراهم می‌کند تا نیازی به جستجوی ساختار و نحو دقیق هر بار که یک پروژه جدید شروع می‌کنید نداشته باشید. می‌توانید هر تعداد تابع تست اضافی و هر تعداد ماژول تست اضافی که می‌خواهید اضافه کنید!</p>
<p>ما برخی از جنبه‌های نحوه عملکرد تست‌ها را با آزمایش قالب تست قبل از اینکه واقعاً کدی را تست کنیم بررسی خواهیم کرد. سپس تست‌هایی در دنیای واقعی می‌نویسیم که برخی کدهایی که نوشته‌ایم را فراخوانی می‌کنند و تأیید می‌کنند که رفتار آن صحیح است.</p>
<p>بیایید یک پروژه کتابخانه‌ای جدید به نام <code>adder</code> ایجاد کنیم که دو عدد را با هم جمع کند:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>محتویات فایل <em>src/lib.rs</em> در کتابخانه <code>adder</code> شما باید شبیه به لیست ۱۱-۱ باشد.</p>
<figure class="listing" id="listing-11-1">
<span class="file-name">Filename: src/lib.rs</span>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-1">Listing 11-1</a>: کدی که به طور خودکار توسط <code>cargo new</code> تولید می‌شود</figcaption>
</figure>
<p>این فایل با یک تابع نمونه به نام <code>add</code> شروع می‌شود تا چیزی برای تست کردن داشته باشیم.</p>
<p>فعلاً روی تابع <code>it_works</code> تمرکز می‌کنیم. به حاشیه‌نویسی <code>#[test]</code> توجه کنید: این ویژگی نشان می‌دهد که این یک تابع تست است، بنابراین تست رانر می‌داند که این تابع را به عنوان یک تست در نظر بگیرد. ممکن است توابع غیرتستی نیز در ماژول <code>tests</code> داشته باشیم که به تنظیم سناریوهای مشترک یا انجام عملیات‌های مشترک کمک می‌کنند، بنابراین همیشه باید مشخص کنیم کدام توابع تست هستند.</p>
<p>بدنه تابع نمونه از ماکرو <code>assert_eq!</code> استفاده می‌کند تا اطمینان حاصل کند که <code>result</code>، که حاوی نتیجه فراخوانی <code>add</code> با مقادیر ۲ و ۲ است، برابر با ۴ باشد. این اطمینان به عنوان یک مثال از فرمت یک تست معمولی عمل می‌کند. بیایید آن را اجرا کنیم تا ببینیم این تست پاس می‌شود.</p>
<p>فرمان <code>cargo test</code> تمام تست‌های پروژه ما را اجرا می‌کند، همانطور که در لیست ۱۱-۲ نشان داده شده است.</p>
<figure class="listing" id="listing-11-2">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<figcaption><a href="#listing-11-2">Listing 11-2</a>: خروجی اجرای تستی که به طور خودکار تولید شده است</figcaption>
</figure>
<p>Cargo تست را کامپایل و اجرا کرد. خط <code>running 1 test</code> را می‌بینیم. خط بعدی نام تابع تست تولیدشده را نشان می‌دهد، که <code>tests::it_works</code> نام دارد، و نتیجه اجرای آن تست <code>ok</code> است. خلاصه کلی <code>test result: ok.</code> نشان می‌دهد که تمام تست‌ها پاس شده‌اند، و بخشی که <code>1 passed; 0 failed</code> را می‌خواند تعداد تست‌هایی که پاس شده‌اند یا ناموفق بوده‌اند را نشان می‌دهد.</p>
<p>امکان علامت‌گذاری یک تست به‌عنوان ignored وجود دارد تا در یک اجرای خاص اجرا نشود؛<br />
ما این موضوع را در بخش <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“نادیده گرفتن برخی تست‌ها مگر در صورت درخواست خاص”</a><!-- ignore --><br />
در ادامه‌ی این فصل بررسی خواهیم کرد.<br />
چون در اینجا این کار را انجام نداده‌ایم، خلاصه نشان‌دهنده‌ی <code>0 ignored</code> است.<br />
همچنین می‌توانیم آرگومانی به دستور <code>cargo test</code> بدهیم تا فقط تست‌هایی اجرا شوند که نامشان با رشته‌ای مطابقت دارد؛<br />
این کار <em>filtering</em> نامیده می‌شود و در بخش <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“اجرای زیرمجموعه‌ای از تست‌ها بر اساس نام”</a><!-- ignore --> بررسی خواهد شد.<br />
در اینجا تست‌ها فیلتر نشده‌اند، بنابراین انتهای خلاصه <code>0 filtered out</code> را نشان می‌دهد.</p>
<p>آمار <code>0 measured</code> برای تست‌های بنچمارک است که عملکرد را اندازه‌گیری می‌کنند. تست‌های بنچمارک، در زمان نوشتن این متن، فقط در نسخه شبانه Rust موجود هستند. برای اطلاعات بیشتر مستندات مربوط به <a href="../unstable-book/library-features/test.html">تست‌های بنچمارک</a> را ببینید.</p>
<p>قسمت بعدی خروجی تست که از <code>Doc-tests adder</code> شروع می‌شود، مربوط به نتایج تست‌های مستندات است.
فعلاً تست مستنداتی نداریم، اما Rust می‌تواند هر نمونه کدی که در مستندات API ما آمده است را کامپایل کند.
این ویژگی به هماهنگ نگه‌داشتن مستندات و کد شما کمک می‌کند!
در بخش <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“نظرات مستندات به‌عنوان تست”</a><!-- ignore --> در فصل ۱۴، نحوه‌ی نوشتن تست‌های مستندات را بررسی خواهیم کرد.
فعلاً خروجی <code>Doc-tests</code> را نادیده می‌گیریم.</p>
<p>بیایید تست را مطابق نیازهای خود شخصی‌سازی کنیم. ابتدا نام تابع <code>it_works</code> را به یک نام دیگر، مانند <code>exploration</code> تغییر دهید، به این صورت:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>سپس دوباره <code>cargo test</code> را اجرا کنید. خروجی اکنون به جای <code>it_works</code> نام <code>exploration</code> را نشان می‌دهد:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>حالا یک تست دیگر اضافه می‌کنیم، اما این بار تستی می‌نویسیم که شکست بخورد! تست‌ها زمانی شکست می‌خورند که چیزی در تابع تست باعث ایجاد panic شود. هر تست در یک نخ (thread) جدید اجرا می‌شود، و وقتی نخ اصلی می‌بیند که یک نخ تست متوقف شده است، تست به عنوان شکست‌خورده علامت‌گذاری می‌شود. در فصل ۹، درباره اینکه ساده‌ترین راه برای panic کردن فراخوانی ماکروی <code>panic!</code> است صحبت کردیم. تابع جدیدی به نام <code>another</code> وارد کنید تا فایل <em>src/lib.rs</em> شما شبیه به لیست ۱۱-۳ شود.</p>
<figure class="listing" id="listing-11-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
<figcaption><a href="#listing-11-3">Listing 11-3</a>: اضافه کردن یک تست دوم که به دلیل فراخوانی ماکروی <code>panic!</code> شکست می‌خورد</figcaption>
</figure>
<p>دوباره تست‌ها را با استفاده از <code>cargo test</code> اجرا کنید. خروجی باید شبیه به لیست ۱۱-۴ باشد، که نشان می‌دهد تست <code>exploration</code> موفق شده است و <code>another</code> شکست خورده است.</p>
<figure class="listing" id="listing-11-4">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<figcaption><a href="#listing-11-4">Listing 11-4</a>: نتایج تست زمانی که یک تست موفق می‌شود و یک تست شکست می‌خورد</figcaption>
</figure>
<p>به جای <code>ok</code>، در خط <code>test tests::another</code> عبارت <code>FAILED</code> نمایش داده می‌شود.
دو بخش جدید بین نتایج فردی و خلاصه ظاهر می‌شوند:
اولی دلیل دقیق هر شکست تست را نمایش می‌دهد.
در این مورد، جزئیات نشان می‌دهد که <code>tests::another</code> شکست خورده زیرا در خط ۱۷ فایل <em>src/lib.rs</em>
با پیام <code>Make this test fail</code> دچار panic شده است.
بخش بعدی فقط نام تمام تست‌های شکست‌خورده را فهرست می‌کند،
که وقتی تعداد تست‌ها زیاد و خروجی شکست تست‌ها مفصل است، مفید است.
می‌توانیم از نام تست شکست‌خورده استفاده کنیم تا فقط آن تست را اجرا کنیم و راحت‌تر آن را اشکال‌زدایی کنیم؛
در بخش <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“کنترل نحوه‌ی اجرای تست‌ها”</a><!-- ignore --> بیشتر درباره‌ی روش‌های اجرای تست صحبت خواهیم کرد.</p>
<p>حالا که دیدید نتایج تست در سناریوهای مختلف چگونه به نظر می‌رسند، بیایید به برخی از ماکروهای دیگر به جز <code>panic!</code> که در تست‌ها مفید هستند نگاهی بیندازیم.</p>
<h3 id="بررسی-نتایج-با-ماکروی-assert"><a class="header" href="#بررسی-نتایج-با-ماکروی-assert">بررسی نتایج با ماکروی <code>assert!</code></a></h3>
<p>ماکروی <code>assert!</code> که توسط کتابخانه استاندارد ارائه شده است، زمانی مفید است که بخواهید اطمینان حاصل کنید که یک شرط در یک تست به <code>true</code> ارزیابی می‌شود. ماکروی <code>assert!</code> یک آرگومان می‌گیرد که به یک مقدار بولی ارزیابی می‌شود. اگر مقدار <code>true</code> باشد، هیچ اتفاقی نمی‌افتد و تست پاس می‌شود. اگر مقدار <code>false</code> باشد، ماکروی <code>assert!</code> فراخوانی <code>panic!</code> را انجام می‌دهد تا باعث شکست تست شود. استفاده از ماکروی <code>assert!</code> به ما کمک می‌کند تا بررسی کنیم که کد ما همانطور که قصد داریم عمل می‌کند.</p>
<p>در فصل ۵، لیست ۵-۱۵، از یک ساختار <code>Rectangle</code> و یک متد <code>can_hold</code> استفاده کردیم، که در لیست ۱۱-۵ دوباره تکرار شده است. این کد را در فایل <em>src/lib.rs</em> قرار دهید، سپس با استفاده از ماکروی <code>assert!</code> چند تست برای آن بنویسید.</p>
<figure class="listing" id="listing-11-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<figcaption><a href="#listing-11-5">Listing 11-5</a>: ساختار <code>Rectangle</code> و متد <code>can_hold</code> آن از فصل ۵</figcaption>
</figure>
<p>متد <code>can_hold</code> یک مقدار بولی بازمی‌گرداند، که به این معنی است که یک مورد استفاده عالی برای ماکروی <code>assert!</code> است. در لیست ۱۱-۶، ما تستی می‌نویسیم که متد <code>can_hold</code> را با ایجاد یک نمونه از <code>Rectangle</code> که عرض ۸ و ارتفاع ۷ دارد آزمایش می‌کند و تأیید می‌کند که می‌تواند نمونه دیگری از <code>Rectangle</code> که عرض ۵ و ارتفاع ۱ دارد را در خود جای دهد.</p>
<figure class="listing" id="listing-11-6">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<figcaption><a href="#listing-11-6">Listing 11-6</a>: تستی برای <code>can_hold</code> که بررسی می‌کند آیا یک مستطیل بزرگ‌تر می‌تواند واقعاً یک مستطیل کوچک‌تر را در خود جای دهد</figcaption>
</figure>
<p>به خط <code>use super::*;</code> در داخل ماژول <code>tests</code> توجه کنید. ماژول <code>tests</code> یک ماژول معمولی است که از قوانین دیدپذیری معمولی که در فصل ۷ در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“مسیرها برای اشاره به یک مورد در درخت ماژول”</a><!-- ignore --> پوشش دادیم پیروی می‌کند. از آنجا که ماژول <code>tests</code> یک ماژول داخلی است، باید کدی که در ماژول خارجی است را به دامنه ماژول داخلی بیاوریم. در اینجا از یک glob استفاده می‌کنیم، بنابراین هر چیزی که در ماژول خارجی تعریف کنیم برای این ماژول <code>tests</code> در دسترس است.</p>
<p>تست خود را <code>larger_can_hold_smaller</code> نام‌گذاری کرده‌ایم، و دو نمونه <code>Rectangle</code> که نیاز داشتیم را ایجاد کرده‌ایم. سپس ماکروی <code>assert!</code> را فراخوانی کردیم و نتیجه فراخوانی <code>larger.can_hold(&amp;smaller)</code> را به آن پاس دادیم. این عبارت قرار است <code>true</code> بازگرداند، بنابراین تست ما باید پاس شود. بیایید ببینیم چه اتفاقی می‌افتد!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>پاس شد! حالا یک تست دیگر اضافه کنیم، این بار تأیید می‌کنیم که یک مستطیل کوچک‌تر نمی‌تواند یک مستطیل بزرگ‌تر را در خود جای دهد:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>از آنجا که نتیجه صحیح تابع <code>can_hold</code> در این مورد <code>false</code> است، باید آن نتیجه را قبل از پاس دادن به ماکروی <code>assert!</code> منفی کنیم. به این ترتیب، تست ما زمانی پاس می‌شود که <code>can_hold</code> مقدار <code>false</code> را بازگرداند:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>دو تست که پاس می‌شوند! حالا بیایید ببینیم وقتی باگی به کد خود وارد می‌کنیم چه اتفاقی برای نتایج تست ما می‌افتد. پیاده‌سازی متد <code>can_hold</code> را با جایگزینی علامت بزرگتر (<code>&gt;</code>) با علامت کوچکتر (<code>&lt;</code>) هنگام مقایسه عرض‌ها تغییر می‌دهیم:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>اجرای تست‌ها اکنون خروجی زیر را تولید می‌کند:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>تست‌های ما باگ را پیدا کردند! از آنجا که <code>larger.width</code> مقدار <code>8</code> و <code>smaller.width</code> مقدار <code>5</code> دارد، مقایسه عرض‌ها در <code>can_hold</code> اکنون <code>false</code> بازمی‌گرداند: ۸ کمتر از ۵ نیست.</p>
<h3 id="تست-برابری-با-ماکروهای-assert_eq-و-assert_ne"><a class="header" href="#تست-برابری-با-ماکروهای-assert_eq-و-assert_ne">تست برابری با ماکروهای <code>assert_eq!</code> و <code>assert_ne!</code></a></h3>
<p>یک روش معمول برای بررسی عملکرد، تست برابری بین نتیجه کد تحت تست و مقدار مورد انتظار است. می‌توانید این کار را با استفاده از ماکروی <code>assert!</code> و پاس دادن یک عبارت با استفاده از عملگر <code>==</code> انجام دهید. با این حال، این یک تست بسیار معمول است که کتابخانه استاندارد یک جفت ماکرو—<code>assert_eq!</code> و <code>assert_ne!</code>—برای انجام این تست به صورت راحت‌تر فراهم کرده است. این ماکروها به ترتیب دو آرگومان را برای برابری یا نابرابری مقایسه می‌کنند. اگر ادعا شکست بخورد، این ماکروها دو مقدار را نیز چاپ می‌کنند، که مشاهده دلیل شکست تست را آسان‌تر می‌کند. در مقابل، ماکروی <code>assert!</code> فقط نشان می‌دهد که یک مقدار <code>false</code> برای عبارت <code>==</code> دریافت کرده است، بدون چاپ مقادیری که منجر به مقدار <code>false</code> شده‌اند.</p>
<p>در لیست ۱۱-۷، تابعی به نام <code>add_two</code> می‌نویسیم که <code>۲</code> را به پارامتر خود اضافه می‌کند، سپس این تابع را با استفاده از ماکروی <code>assert_eq!</code> تست می‌کنیم.</p>
<figure class="listing" id="listing-11-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-7">Listing 11-7</a>: تست تابع <code>add_two</code> با استفاده از ماکروی <code>assert_eq!</code></figcaption>
</figure>
<p>بیایید بررسی کنیم که آیا پاس می‌شود!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>ما متغیری به نام <code>result</code> ایجاد می‌کنیم که نتیجه‌ی فراخوانی <code>add_two(2)</code> را نگه می‌دارد.
سپس <code>result</code> و عدد <code>4</code> را به‌عنوان آرگومان به ماکروی <code>assert_eq!</code> می‌دهیم.
خط خروجی این تست به شکل <code>test tests::it_adds_two ... ok</code> است،
و متن <code>ok</code> نشان می‌دهد که تست ما با موفقیت گذشت!</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>تست‌ها را دوباره اجرا کنید:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>تست ما باگ را پیدا کرد! تست <code>tests::it_adds_two</code> شکست خورد،
و پیام نشان می‌دهد که ادعای ناموفق <code>left == right</code> بوده است و مقدارهای <code>left</code> و <code>right</code> چیستند.
این پیام به ما کمک می‌کند تا فرآیند اشکال‌زدایی را شروع کنیم:
آرگومان <code>left</code> که نتیجه‌ی فراخوانی <code>add_two(2)</code> بود، مقدار <code>5</code> داشت،
اما آرگومان <code>right</code> مقدار <code>4</code> بود.
می‌توانید تصور کنید که این موضوع زمانی که تعداد زیادی تست اجرا می‌شود، چقدر مفید است.</p>
<p>توجه کنید که در برخی زبان‌ها و فریم‌ورک‌های تست، پارامترهای تابع ادعای برابری (assertion)
به نام‌های <code>expected</code> و <code>actual</code> شناخته می‌شوند و ترتیب آرگومان‌ها اهمیت دارد.
اما در Rust، این پارامترها <code>left</code> و <code>right</code> نامیده می‌شوند و ترتیب مقدار مورد انتظار و مقدار تولید شده توسط کد اهمیت ندارد.
می‌توانیم ادعای این تست را به صورت <code>assert_eq!(4, result)</code> نیز بنویسیم،
که نتیجه‌ی همان پیام شکست با عنوان <code> assertion `left == right` failed</code> را خواهد داشت.</p>
<p>ماکروی <code>assert_ne!</code> زمانی پاس می‌شود که دو مقداری که به آن می‌دهیم برابر نباشند و شکست می‌خورد اگر برابر باشند. این ماکرو برای مواردی مفید است که مطمئن نیستیم یک مقدار <em>چه خواهد بود</em>، اما می‌دانیم که مقدار به طور قطع <em>چه نباید باشد</em>. برای مثال، اگر تابعی را تست می‌کنیم که تضمین شده است ورودی خود را به نوعی تغییر دهد، اما نحوه تغییر ورودی به روز هفته‌ای که تست‌های خود را اجرا می‌کنیم بستگی دارد، بهترین چیزی که می‌توانیم تأیید کنیم این است که خروجی تابع برابر با ورودی نیست.</p>
<p>در پس‌زمینه، ماکروهای <code>assert_eq!</code> و <code>assert_ne!</code> به ترتیب از عملگرهای <code>==</code> و <code>!=</code> استفاده می‌کنند. وقتی ادعا شکست می‌خورد، این ماکروها آرگومان‌های خود را با استفاده از قالب‌بندی دیباگ چاپ می‌کنند، که به این معنی است که مقادیر مقایسه‌شده باید ویژگی‌های <code>PartialEq</code> و <code>Debug</code> را پیاده‌سازی کنند. تمام نوع‌های اولیه و بیشتر نوع‌های کتابخانه استاندارد این ویژگی‌ها را پیاده‌سازی می‌کنند. برای ساختارها و انوم‌هایی که خودتان تعریف می‌کنید، باید <code>PartialEq</code> را برای تأیید برابری این نوع‌ها پیاده‌سازی کنید. همچنین باید <code>Debug</code> را برای چاپ مقادیر زمانی که ادعا شکست می‌خورد پیاده‌سازی کنید. از آنجا که هر دو ویژگی قابل اشتقاق هستند، همانطور که در لیست ۵-۱۲ فصل ۵ اشاره شد، این معمولاً به سادگی افزودن حاشیه‌نویسی <code>#[derive(PartialEq, Debug)]</code> به تعریف ساختار یا انوم شما است. برای جزئیات بیشتر در مورد این ویژگی‌ها و سایر ویژگی‌های قابل اشتقاق، به ضمیمه ج، <a href="appendix-03-derivable-traits.html">“ویژگی‌های قابل اشتقاق”</a><!-- ignore --> مراجعه کنید.</p>
<h3 id="افزودن-پیامهای-شکست-سفارشی"><a class="header" href="#افزودن-پیامهای-شکست-سفارشی">افزودن پیام‌های شکست سفارشی</a></h3>
<p>شما همچنین می‌توانید یک پیام سفارشی را به‌عنوان آرگومان‌های اختیاری به ماکروهای <code>assert!</code>، <code>assert_eq!</code> و <code>assert_ne!</code> اضافه کنید تا همراه با پیام شکست چاپ شود.
هر آرگومانی که پس از آرگومان‌های ضروری وارد شود، به ماکرو <code>format!</code> (که در بخش <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“ادغام با عملگر <code>+</code> یا ماکرو <code>format!</code>”</a><!-- ignore --> در فصل ۸ توضیح داده شده) ارسال می‌شود،
پس می‌توانید یک رشته‌ی قالب (format string) حاوی جای‌نگهدارهای <code>{}</code> و مقادیری برای جای‌گذاری در آن‌ها ارسال کنید.
پیام‌های سفارشی برای مستندسازی معنای یک assertion مفید هستند؛
وقتی تست شکست می‌خورد، درک بهتری از مشکل کد خواهید داشت.</p>
<p>برای مثال، فرض کنید تابعی داریم که افراد را با نامشان خوشامد می‌گوید و می‌خواهیم تست کنیم که نامی که به تابع پاس می‌دهیم در خروجی ظاهر می‌شود:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>نیازمندی‌های این برنامه هنوز مورد توافق قرار نگرفته‌اند، و ما تقریباً مطمئن هستیم که متن <code>Hello</code> در ابتدای پیام خوشامد تغییر خواهد کرد. تصمیم گرفتیم که نمی‌خواهیم وقتی نیازمندی‌ها تغییر می‌کنند، تست را به‌روزرسانی کنیم، بنابراین به جای بررسی برابری دقیق با مقدار بازگشتی از تابع <code>greeting</code>، فقط تأیید می‌کنیم که خروجی شامل متن پارامتر ورودی است.</p>
<p>حالا بیایید یک باگ به این کد وارد کنیم با تغییر <code>greeting</code> به‌طوری که <code>name</code> را شامل نشود تا ببینیم پیام شکست تست پیش‌فرض چگونه است:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>اجرای این تست خروجی زیر را تولید می‌کند:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>این نتیجه فقط نشان می‌دهد که ادعا شکست خورده است و خطی که ادعا در آن قرار دارد کدام است. یک پیام شکست مفیدتر مقدار بازگشتی از تابع <code>greeting</code> را چاپ می‌کرد. بیایید یک پیام شکست سفارشی اضافه کنیم که از یک رشته قالب با یک نگهدارنده که با مقدار واقعی بازگشتی از تابع <code>greeting</code> پر شده است، تشکیل شده باشد:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>حالا وقتی تست را اجرا می‌کنیم، یک پیام خطای اطلاع‌رسان‌تر دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>ما می‌توانیم مقدار واقعی‌ای که در خروجی تست دریافت کردیم را ببینیم، که به ما کمک می‌کند تا اشکال‌زدایی کنیم که چه اتفاقی افتاد به جای آنچه که انتظار داشتیم اتفاق بیفتد.</p>
<h3 id="بررسی-پانیک-با-should_panic"><a class="header" href="#بررسی-پانیک-با-should_panic">بررسی پانیک با <code>should_panic</code></a></h3>
<p>علاوه بر بررسی مقادیر بازگشتی، مهم است که بررسی کنیم کد ما شرایط خطا را همانطور که انتظار داریم مدیریت می‌کند. برای مثال، نوع <code>Guess</code> را که در فصل ۹، لیست ۹-۱۳ ایجاد کردیم در نظر بگیرید. سایر کدهایی که از <code>Guess</code> استفاده می‌کنند به این تضمین وابسته هستند که نمونه‌های <code>Guess</code> فقط مقادیر بین ۱ و ۱۰۰ را شامل می‌شوند. می‌توانیم تستی بنویسیم که اطمینان حاصل کند که تلاش برای ایجاد یک نمونه <code>Guess</code> با مقداری خارج از این بازه منجر به پانیک می‌شود.</p>
<p>این کار را با افزودن ویژگی <code>should_panic</code> به تابع تست خود انجام می‌دهیم. اگر کد داخل تابع پانیک کند، تست پاس می‌شود؛ اگر کد داخل تابع پانیک نکند، تست شکست می‌خورد.</p>
<p>لیست ۱۱-۸ یک تست را نشان می‌دهد که بررسی می‌کند شرایط خطای <code>Guess::new</code> زمانی که انتظار داریم رخ می‌دهند.</p>
<figure class="listing" id="listing-11-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-8">Listing 11-8</a>: تست کردن اینکه آیا یک شرط باعث یک <code>panic!</code> می‌شود</figcaption>
</figure>
<p>ما ویژگی <code>#[should_panic]</code> را بعد از ویژگی <code>#[test]</code> و قبل از تابع تستی که به آن اعمال می‌شود قرار می‌دهیم. بیایید به نتیجه‌ای که وقتی این تست پاس می‌شود نگاه کنیم:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>به نظر خوب می‌آید! حالا بیایید یک باگ در کد خود وارد کنیم با حذف شرطی که تابع <code>new</code> را مجبور می‌کند اگر مقدار بیشتر از ۱۰۰ باشد پانیک کند:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>وقتی تست در لیست ۱۱-۸ را اجرا می‌کنیم، شکست می‌خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>در این مورد پیام خیلی مفیدی دریافت نمی‌کنیم، اما وقتی به تابع تست نگاه می‌کنیم، می‌بینیم که با <code>#[should_panic]</code> حاشیه‌نویسی شده است. شکست به این معناست که کدی که در تابع تست قرار دارد باعث یک پانیک نشده است.</p>
<p>تست‌هایی که از <code>should_panic</code> استفاده می‌کنند می‌توانند دقیق نباشند. یک تست <code>should_panic</code> حتی اگر تست برای دلیلی غیر از آنچه انتظار داشتیم پانیک کند، پاس می‌شود. برای دقیق‌تر کردن تست‌های <code>should_panic</code>، می‌توانیم یک پارامتر اختیاری <code>expected</code> به ویژگی <code>should_panic</code> اضافه کنیم. تست رانر اطمینان حاصل می‌کند که پیام شکست شامل متن ارائه‌شده است. برای مثال، کد تغییر داده‌شده برای <code>Guess</code> در لیست ۱۱-۹ را در نظر بگیرید که تابع <code>new</code> با پیام‌های مختلف بسته به اینکه مقدار خیلی کوچک یا خیلی بزرگ باشد پانیک می‌کند.</p>
<figure class="listing" id="listing-11-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-9">Listing 11-9</a>: تست کردن یک <code>panic!</code> با یک پیام پانیک که حاوی یک زیررشته مشخص است</figcaption>
</figure>
<p>این تست پاس می‌شود زیرا مقداری که در پارامتر <code>expected</code> ویژگی <code>should_panic</code> قرار داده‌ایم یک زیررشته از پیامی است که تابع <code>Guess::new</code> با آن پانیک می‌کند. می‌توانستیم کل پیام پانیکی که انتظار داریم را مشخص کنیم، که در این مورد می‌شد <code>Guess value must be less than or equal to 100, got 200</code>. آنچه انتخاب می‌کنید بستگی به این دارد که چه مقدار از پیام پانیک منحصر به فرد یا پویا است و چقدر می‌خواهید تست شما دقیق باشد. در این مورد، یک زیررشته از پیام پانیک کافی است تا اطمینان حاصل شود که کد در تابع تست مورد <code>else if value &gt; 100</code> را اجرا می‌کند.</p>
<p>برای دیدن اینکه وقتی یک تست <code>should_panic</code> با یک پیام <code>expected</code> شکست می‌خورد چه اتفاقی می‌افتد، بیایید دوباره یک باگ به کد خود وارد کنیم با جابه‌جا کردن بدنه‌های بلوک‌های <code>if value &lt; 1</code> و <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>این بار وقتی تست <code>should_panic</code> را اجرا می‌کنیم، شکست خواهد خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>پیام شکست نشان می‌دهد که این تست همانطور که انتظار داشتیم پانیک کرد، اما پیام پانیک شامل رشته مورد انتظار <code>less than or equal to 100</code> نبود. پیام پانیکی که در این مورد دریافت کردیم <code>Guess value must be greater than or equal to 1, got 200.</code> بود. حالا می‌توانیم شروع به پیدا کردن محل باگ کنیم!</p>
<h3 id="استفاده-از-resultt-e-در-تستها"><a class="header" href="#استفاده-از-resultt-e-در-تستها">استفاده از <code>Result&lt;T, E&gt;</code> در تست‌ها</a></h3>
<p>تست‌های ما تا اینجا همه زمانی که شکست می‌خورند پانیک می‌کنند. همچنین می‌توانیم تست‌هایی بنویسیم که از <code>Result&lt;T, E&gt;</code> استفاده کنند! در اینجا تست لیست ۱۱-۱ را بازنویسی کرده‌ایم تا از <code>Result&lt;T, E&gt;</code> استفاده کند و به جای پانیک کردن، یک <code>Err</code> بازگرداند:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>تابع <code>it_works</code> اکنون نوع بازگشتی <code>Result&lt;(), String&gt;</code> دارد. در بدنه تابع، به جای فراخوانی ماکروی <code>assert_eq!</code>، وقتی تست پاس می‌شود <code>Ok(())</code> و وقتی تست شکست می‌خورد یک <code>Err</code> با یک <code>String</code> داخل آن بازمی‌گردانیم.</p>
<p>نوشتن تست‌هایی که یک <code>Result&lt;T, E&gt;</code> بازمی‌گردانند به شما اجازه می‌دهد از عملگر سوالی <code>?</code> در بدنه تست‌ها استفاده کنید، که می‌تواند راهی راحت برای نوشتن تست‌هایی باشد که اگر هر عملیاتی در آن‌ها یک واریانت <code>Err</code> بازگرداند، شکست بخورند.</p>
<p>شما نمی‌توانید از حاشیه‌نویسی <code>#[should_panic]</code> در تست‌هایی که از <code>Result&lt;T, E&gt;</code> استفاده می‌کنند استفاده کنید. برای تأیید اینکه یک عملیات یک واریانت <code>Err</code> بازمی‌گرداند، <em>از</em> عملگر سوالی روی مقدار <code>Result&lt;T, E&gt;</code> استفاده نکنید. در عوض، از <code>assert!(value.is_err())</code> استفاده کنید.</p>
<p>حالا که چندین روش برای نوشتن تست‌ها را یاد گرفتید، بیایید نگاهی به آنچه هنگام اجرای تست‌ها اتفاق می‌افتد بیندازیم و گزینه‌های مختلفی را که می‌توانیم با <code>cargo test</code> استفاده کنیم بررسی کنیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
