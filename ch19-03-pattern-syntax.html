<!DOCTYPE HTML>
<html lang="fa" class="light" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>نحو الگوها - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، جعبه‌ها (crates)، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و جعبه‌ها (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گر (Pointer)های هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر (Pointer) هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از تایپ‌های مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html" class="active"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناایمن</a></li><li class="chapter-item expanded "><a href="ch20-02-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> Traits پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-types.html"><strong aria-hidden="true">20.3.</strong> تایپ‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closures پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور single-threaded</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>در این بخش، تمام نحوهایی که در الگوها معتبر هستند را جمع‌آوری کرده و بحث می‌کنیم که چرا و چه زمانی ممکن است بخواهید از هر کدام استفاده کنید.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>همان‌طور که در فصل 6 دیدید، می‌توانید الگوها را مستقیماً با مقادیر ثابت (literals) تطبیق دهید. کد زیر برخی از مثال‌ها را نشان می‌دهد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>این کد <code>one</code> را چاپ می‌کند زیرا مقدار در <code>x</code> برابر با 1 است. این نحو زمانی مفید است که بخواهید کد شما در صورت دریافت یک مقدار مشخص خاص اقدامی انجام دهد.</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h3>
<p>متغیرهای نام‌گذاری‌شده الگوهای غیرقابل‌رد هستند که با هر مقداری مطابقت دارند، و ما بارها در این کتاب از آن‌ها استفاده کرده‌ایم. با این حال، زمانی که از متغیرهای نام‌گذاری‌شده در عبارات <code>match</code>، <code>if let</code>، یا <code>while let</code> استفاده می‌کنید، یک پیچیدگی وجود دارد. زیرا هر یک از این نوع عبارات یک دامنه جدید را شروع می‌کنند، متغیرهایی که به‌عنوان بخشی از یک الگو در داخل عبارت تعریف می‌شوند، متغیرهایی با همان نام در خارج را پوشش می‌دهند، همان‌طور که برای همه متغیرها صدق می‌کند. در فهرست 19-11، یک متغیر به نام <code>x</code> با مقدار <code>Some(5)</code> و یک متغیر <code>y</code> با مقدار <code>10</code> تعریف می‌کنیم. سپس یک عبارت <code>match</code> روی مقدار <code>x</code> ایجاد می‌کنیم. به الگوها در بازوهای match و دستور <code>println!</code> در انتها نگاه کنید و سعی کنید قبل از اجرای این کد یا خواندن بیشتر، حدس بزنید که کد چه چیزی را چاپ خواهد کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-11: یک عبارت <code>match</code> با بازویی که یک متغیر جدید معرفی می‌کند که متغیر موجود <code>y</code> را پوشش می‌دهد</figcaption>
</figure>
<p>بیایید بررسی کنیم که وقتی عبارت <code>match</code> اجرا می‌شود چه اتفاقی می‌افتد. الگوی موجود در بازوی اول match با مقدار تعریف‌شده <code>x</code> مطابقت ندارد، بنابراین کد ادامه می‌یابد.</p>
<p>الگوی موجود در بازوی دوم match یک متغیر جدید به نام <code>y</code> معرفی می‌کند که با هر مقداری درون یک <code>Some</code> مطابقت خواهد داشت. از آنجا که ما در یک دامنه جدید داخل عبارت <code>match</code> هستیم، این یک متغیر جدید <code>y</code> است، نه متغیری که در ابتدا با مقدار 10 تعریف کردیم. این binding جدید <code>y</code> با هر مقداری درون یک <code>Some</code> مطابقت دارد، که همان چیزی است که ما در <code>x</code> داریم. بنابراین، این <code>y</code> جدید به مقدار داخلی <code>Some</code> در <code>x</code> متصل می‌شود. آن مقدار <code>5</code> است، بنابراین عبارت برای آن بازو اجرا می‌شود و <code>Matched, y = 5</code> را چاپ می‌کند.</p>
<p>اگر <code>x</code> به جای <code>Some(5)</code> یک مقدار <code>None</code> بود، الگوهای موجود در دو بازوی اول مطابقت نداشتند، بنابراین مقدار به علامت زیرخط (<code>_</code>) مطابقت داده می‌شد. ما متغیر <code>x</code> را در الگوی بازوی زیرخط معرفی نکردیم، بنابراین <code>x</code> در عبارت همچنان همان <code>x</code> خارجی است که پوشش داده نشده است. در این حالت فرضی، عبارت <code>match</code> پیام <code>Default case, x = None</code> را چاپ می‌کرد.</p>
<p>وقتی عبارت <code>match</code> تمام می‌شود، دامنه آن نیز پایان می‌یابد، و همین‌طور دامنه <code>y</code> داخلی. دستور <code>println!</code> آخر پیام <code>at the end: x = Some(5), y = 10</code> را تولید می‌کند.</p>
<p>برای ایجاد یک عبارت <code>match</code> که مقادیر <code>x</code> و <code>y</code> خارجی را مقایسه کند، به جای معرفی یک متغیر جدید که متغیر موجود <code>y</code> را پوشش می‌دهد، باید از یک نگهبان شرطی (match guard) استفاده کنیم. ما درباره نگهبان‌های شرطی در بخش <a href="#extra-conditionals-with-match-guards">“Extra Conditionals with Match Guards”</a><!-- ignore --> صحبت خواهیم کرد.</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">Multiple Patterns</a></h3>
<p>می‌توانید با استفاده از نحو <code>|</code>، که عملگر <em>یا</em> (or) برای الگوها است، چندین الگو را مطابقت دهید. برای مثال، در کد زیر مقدار <code>x</code> را با بازوهای match تطبیق می‌دهیم، که بازوی اول آن یک گزینه <em>یا</em> دارد، به این معنا که اگر مقدار <code>x</code> با هر کدام از مقادیر در آن بازو مطابقت داشته باشد، کد آن بازو اجرا می‌شود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>این کد <code>one or two</code> را چاپ می‌کند.</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">Matching Ranges of Values with <code>..=</code></a></h3>
<p>نحو <code>..=</code> به ما اجازه می‌دهد یک بازه شامل مقادیر را مطابقت دهیم. در کد زیر، وقتی یک الگو با هر کدام از مقادیر در بازه داده‌شده مطابقت داشته باشد، آن بازو اجرا خواهد شد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>اگر مقدار <code>x</code> برابر با 1، 2، 3، 4 یا 5 باشد، بازوی اول مطابقت خواهد داشت. این نحو برای مقادیر مطابقت چندگانه راحت‌تر از استفاده از عملگر <code>|</code> برای بیان همان ایده است؛ اگر بخواهیم از <code>|</code> استفاده کنیم، باید <code>1 | 2 | 3 | 4 | 5</code> را مشخص کنیم. مشخص کردن یک بازه بسیار کوتاه‌تر است، به‌ویژه اگر بخواهیم، برای مثال، هر عدد بین 1 و 1,000 را مطابقت دهیم!</p>
<p>کامپایلر بررسی می‌کند که بازه در زمان کامپایل خالی نیست، و چون تنها نوع‌هایی که راست می‌تواند تشخیص دهد که آیا یک بازه خالی است یا نه <code>char</code> و مقادیر عددی هستند، بازه‌ها فقط برای مقادیر عددی یا <code>char</code> مجاز هستند.</p>
<p>در اینجا یک مثال با استفاده از بازه‌هایی از مقادیر <code>char</code> آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>راست می‌تواند تشخیص دهد که <code>'c'</code> در بازه الگوی اول است و پیام <code>early ASCII letter</code> را چاپ می‌کند.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>ما همچنین می‌توانیم از الگوها برای تخریب (destructure) ساختارها (structs)، enums، و tuple‌ها استفاده کنیم تا از بخش‌های مختلف این مقادیر استفاده کنیم. بیایید به هر نوع مقدار نگاهی بیندازیم.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>فهرست 19-12 یک struct به نام <code>Point</code> را با دو فیلد، <code>x</code> و <code>y</code> نشان می‌دهد که می‌توانیم با استفاده از یک الگو در یک عبارت <code>let</code> آن را تخریب کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<figcaption>Listing 19-12: تخریب فیلدهای یک struct به متغیرهای جداگانه</figcaption>
</figure>
<p>این کد متغیرهای <code>a</code> و <code>b</code> را ایجاد می‌کند که با مقادیر فیلدهای <code>x</code> و <code>y</code> از struct <code>p</code> مطابقت دارند. این مثال نشان می‌دهد که نام متغیرها در الگو نیازی به مطابقت با نام فیلدهای struct ندارند. با این حال، معمولاً نام متغیرها با نام فیلدها مطابقت داده می‌شوند تا یادآوری اینکه کدام متغیرها از کدام فیلدها آمده‌اند آسان‌تر شود. به‌دلیل این استفاده معمول و به‌دلیل اینکه نوشتن <code>let Point { x: x, y: y } = p;</code> تکرار زیادی دارد، راست یک نحو کوتاه برای الگوهایی که فیلدهای struct را مطابقت می‌دهند فراهم می‌کند: فقط کافی است نام فیلد struct را لیست کنید و متغیرهایی که از الگو ایجاد می‌شوند همان نام‌ها را خواهند داشت. فهرست 19-13 به همان روشی که کد در فهرست 19-12 عمل می‌کند، اما متغیرهای ایجادشده در الگوی <code>let</code> به‌جای <code>a</code> و <code>b</code>، <code>x</code> و <code>y</code> هستند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<figcaption>Listing 19-13: تخریب فیلدهای struct با استفاده از نحو کوتاه فیلد struct</figcaption>
</figure>
<p>این کد متغیرهای <code>x</code> و <code>y</code> را ایجاد می‌کند که با فیلدهای <code>x</code> و <code>y</code> از متغیر <code>p</code> مطابقت دارند. نتیجه این است که متغیرهای <code>x</code> و <code>y</code> مقادیر از ساختار <code>p</code> را شامل می‌شوند.</p>
<p>ما همچنین می‌توانیم با مقادیر ثابت (literals) به‌عنوان بخشی از الگوی struct تخریب کنیم، به‌جای ایجاد متغیرهایی برای همه فیلدها. انجام این کار به ما اجازه می‌دهد برخی از فیلدها را برای مقادیر خاصی تست کنیم، در حالی که متغیرهایی برای تخریب فیلدهای دیگر ایجاد می‌کنیم.</p>
<p>در فهرست 19-14، یک عبارت <code>match</code> داریم که مقادیر <code>Point</code> را به سه حالت تقسیم می‌کند: نقاطی که مستقیماً روی محور <code>x</code> قرار دارند (که در صورتی درست است که <code>y = 0</code>)، روی محور <code>y</code> (<code>x = 0</code>)، یا هیچ‌کدام.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-14: تخریب و تطبیق مقادیر ثابت در یک الگو</figcaption>
</figure>
<p>بازوی اول هر نقطه‌ای که روی محور <code>x</code> قرار دارد را با مشخص کردن اینکه فیلد <code>y</code> در صورتی مطابقت دارد که مقدار آن با مقدار ثابت <code>0</code> مطابقت داشته باشد، تطبیق می‌دهد. الگو همچنان یک متغیر <code>x</code> ایجاد می‌کند که می‌توانیم در کد این بازو از آن استفاده کنیم.</p>
<p>به‌طور مشابه، بازوی دوم هر نقطه روی محور <code>y</code> را با مشخص کردن اینکه فیلد <code>x</code> در صورتی که مقدار آن <code>0</code> باشد مطابقت دارد و یک متغیر <code>y</code> برای مقدار فیلد <code>y</code> ایجاد می‌کند. بازوی سوم هیچ مقدار ثابتی را مشخص نمی‌کند، بنابراین هر <code>Point</code> دیگری را مطابقت می‌دهد و متغیرهایی برای هر دو فیلد <code>x</code> و <code>y</code> ایجاد می‌کند.</p>
<p>در این مثال، مقدار <code>p</code> به لطف <code>x</code> که مقدار <code>0</code> دارد، با بازوی دوم مطابقت دارد، بنابراین این کد پیام <code>On the y axis at 7</code> را چاپ می‌کند.</p>
<p>به یاد داشته باشید که یک عبارت <code>match</code> پس از یافتن اولین الگوی مطابقت متوقف می‌شود، بنابراین حتی اگر <code>Point { x: 0, y: 0 }</code> روی محور <code>x</code> و محور <code>y</code> باشد، این کد فقط پیام <code>On the x axis at 0</code> را چاپ خواهد کرد.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>ما در این کتاب enums را تخریب کرده‌ایم (برای مثال، فهرست 6-5 در فصل 6)، اما هنوز به‌طور خاص بحث نکرده‌ایم که الگوی تخریب یک enum مطابق با نحوه تعریف داده‌های ذخیره‌شده درون enum است. به‌عنوان مثال، در فهرست 19-15 از enum <code>Message</code> از فهرست 6-2 استفاده می‌کنیم و یک <code>match</code> با الگوهایی می‌نویسیم که هر مقدار داخلی را تخریب می‌کنند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-15: تخریب متغیرهای enum که مقادیر مختلفی دارند</figcaption>
</figure>
<p>این کد پیام <code>Change the color to red 0, green 160, and blue 255</code> را چاپ می‌کند. مقدار <code>msg</code> را تغییر دهید تا کد از بازوهای دیگر اجرا شود.</p>
<p>برای متغیرهای enum بدون هیچ داده‌ای، مانند <code>Message::Quit</code>، نمی‌توان مقدار را بیشتر تخریب کرد. فقط می‌توان روی مقدار ثابت <code>Message::Quit</code> مطابقت داد، و هیچ متغیری در آن الگو وجود ندارد.</p>
<p>برای متغیرهای enum شبیه به struct، مانند <code>Message::Move</code>، می‌توانیم از الگویی مشابه الگوی مشخص‌شده برای تطبیق structs استفاده کنیم. پس از نام متغیر، آکولاد باز می‌کنیم و سپس فیلدها را با متغیرها لیست می‌کنیم تا بخش‌ها را برای استفاده در کد این بازو تجزیه کنیم. در اینجا از فرم کوتاه همان‌طور که در فهرست 19-13 استفاده کردیم استفاده می‌کنیم.</p>
<p>برای متغیرهای enum شبیه به tuple، مانند <code>Message::Write</code> که یک tuple با یک عنصر دارد و <code>Message::ChangeColor</code> که یک tuple با سه عنصر دارد، الگو مشابه الگویی است که برای تطبیق tuple‌ها مشخص می‌کنیم. تعداد متغیرها در الگو باید با تعداد عناصر در متغیر که تطبیق می‌دهیم مطابقت داشته باشد.</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>تاکنون، مثال‌های ما همه تطبیق ساختارها یا enums در یک سطح عمیق بوده‌اند، اما تطبیق می‌تواند روی آیتم‌های تو در تو نیز کار کند! برای مثال، می‌توانیم کد در فهرست 19-15 را بازسازی کنیم تا از رنگ‌های RGB و HSV در پیام <code>ChangeColor</code> پشتیبانی کند، همان‌طور که در فهرست 19-16 نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<figcaption>Listing 19-16: تطبیق روی enums تو در تو</figcaption>
</figure>
<p>الگوی بازوی اول در عبارت <code>match</code> یک متغیر enum به نام <code>Message::ChangeColor</code> را تطبیق می‌دهد که شامل یک متغیر <code>Color::Rgb</code> است؛ سپس الگو به سه مقدار داخلی <code>i32</code> متصل می‌شود. الگوی بازوی دوم نیز یک متغیر enum به نام <code>Message::ChangeColor</code> را تطبیق می‌دهد، اما enum داخلی به جای آن <code>Color::Hsv</code> را مطابقت می‌دهد. ما می‌توانیم این شرایط پیچیده را در یک عبارت <code>match</code> مشخص کنیم، حتی اگر دو enum درگیر باشند.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>ما می‌توانیم الگوهای تخریب را به روش‌های پیچیده‌تر ترکیب، تطبیق و تو در تو کنیم. مثال زیر یک تخریب پیچیده را نشان می‌دهد که در آن ساختارها و tuple‌ها را داخل یک tuple تو در تو می‌کنیم و تمام مقادیر اولیه را تخریب می‌کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>این کد به ما اجازه می‌دهد انواع پیچیده را به اجزای سازنده آن‌ها بشکنیم تا بتوانیم مقادیری که به آن‌ها علاقه داریم را جداگانه استفاده کنیم.</p>
<p>تخریب با الگوها یک روش راحت برای استفاده از بخش‌هایی از مقادیر، مانند مقدار هر فیلد در یک ساختار، به‌صورت جداگانه است.</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>گاهی اوقات مفید است که مقادیر را در یک الگو نادیده بگیرید، مانند بازوی آخر یک <code>match</code>، برای دریافت یک catchall که هیچ کاری انجام نمی‌دهد اما تمام مقادیر باقی‌مانده ممکن را در نظر می‌گیرد. چندین روش برای نادیده گرفتن مقادیر کامل یا بخش‌هایی از مقادیر در یک الگو وجود دارد: استفاده از الگوی <code>_</code> (که دیده‌اید)، استفاده از الگوی <code>_</code> درون یک الگوی دیگر، استفاده از نامی که با یک زیرخط شروع می‌شود، یا استفاده از <code>..</code> برای نادیده گرفتن بخش‌های باقی‌مانده یک مقدار. بیایید بررسی کنیم چگونه و چرا از هر یک از این الگوها استفاده کنیم.</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>ما از زیرخط به‌عنوان یک الگوی wildcard استفاده کرده‌ایم که با هر مقداری مطابقت دارد اما به مقدار متصل نمی‌شود. این به‌ویژه به‌عنوان بازوی آخر در یک عبارت <code>match</code> مفید است، اما ما همچنین می‌توانیم آن را در هر الگویی استفاده کنیم، از جمله پارامترهای تابع، همان‌طور که در فهرست 19-17 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<figcaption>Listing 19-17: استفاده از <code>_</code> در یک امضای تابع</figcaption>
</figure>
<p>این کد مقدار <code>3</code> را که به‌عنوان آرگومان اول ارسال شده است، کاملاً نادیده می‌گیرد و پیام <code>This code only uses the y parameter: 4</code> را چاپ می‌کند.</p>
<p>در بیشتر موارد، زمانی که دیگر نیازی به یک پارامتر تابع خاص ندارید، امضای تابع را تغییر می‌دهید تا آن پارامتر استفاده‌نشده را شامل نشود. نادیده گرفتن یک پارامتر تابع می‌تواند به‌ویژه در مواردی مفید باشد که، برای مثال، شما در حال پیاده‌سازی یک trait هستید و به یک امضای خاص نیاز دارید، اما بدنه تابع در پیاده‌سازی شما نیازی به یکی از پارامترها ندارد. در این صورت، از دریافت هشدار کامپایلر درباره پارامترهای استفاده‌نشده جلوگیری می‌کنید، همان‌طور که اگر به جای آن از یک نام استفاده می‌کردید، هشدار دریافت می‌کردید.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>ما همچنین می‌توانیم از <code>_</code> در داخل یک الگوی دیگر استفاده کنیم تا فقط بخشی از یک مقدار را نادیده بگیریم. برای مثال، وقتی می‌خواهیم فقط بخشی از یک مقدار را تست کنیم اما نیازی به استفاده از بخش‌های دیگر در کدی که می‌خواهیم اجرا کنیم نداریم. فهرست 19-18 کدی را نشان می‌دهد که مسئول مدیریت مقدار یک تنظیم است. نیازمندی‌های تجاری این است که کاربر نباید اجازه داشته باشد یک سفارشی‌سازی موجود برای یک تنظیم را بازنویسی کند، اما می‌تواند تنظیم را لغو کند و به آن یک مقدار بدهد اگر در حال حاضر لغو شده باشد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-18: استفاده از یک زیرخط در داخل الگوهایی که با متغیرهای <code>Some</code> مطابقت دارند وقتی نیازی به استفاده از مقدار داخل <code>Some</code> نداریم</figcaption>
</figure>
<p>این کد پیام <code>Can't overwrite an existing customized value</code> را چاپ می‌کند و سپس <code>setting is Some(5)</code> را چاپ می‌کند. در بازوی اول match، نیازی به مطابقت یا استفاده از مقادیر داخل هر یک از متغیرهای <code>Some</code> نداریم، اما باید حالت‌هایی را که در آن‌ها <code>setting_value</code> و <code>new_setting_value</code> در حالت <code>Some</code> هستند، تست کنیم. در این صورت، دلیل تغییر ندادن <code>setting_value</code> را چاپ می‌کنیم و این مقدار تغییر نمی‌کند.</p>
<p>در تمام موارد دیگر (اگر <code>setting_value</code> یا <code>new_setting_value</code> مقدار <code>None</code> داشته باشند) که توسط الگوی <code>_</code> در بازوی دوم بیان شده است، می‌خواهیم اجازه دهیم <code>new_setting_value</code> به <code>setting_value</code> تبدیل شود.</p>
<p>ما همچنین می‌توانیم از زیرخط‌ها در مکان‌های مختلف در یک الگو برای نادیده گرفتن مقادیر خاص استفاده کنیم. فهرست 19-19 مثالی از نادیده گرفتن مقادیر دوم و چهارم در یک tuple پنج آیتمی را نشان می‌دهد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-19: نادیده گرفتن بخش‌های مختلف یک tuple</figcaption>
</figure>
<p>این کد پیام <code>Some numbers: 2, 8, 32</code> را چاپ می‌کند و مقادیر 4 و 16 نادیده گرفته می‌شوند.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>اگر یک متغیر ایجاد کنید اما از آن در هیچ جایی استفاده نکنید، راست معمولاً یک هشدار صادر می‌کند زیرا یک متغیر استفاده‌نشده ممکن است یک باگ باشد. با این حال، گاهی اوقات مفید است که بتوانید متغیری ایجاد کنید که هنوز از آن استفاده نمی‌کنید، مانند زمانی که در حال نمونه‌سازی یا تازه شروع یک پروژه هستید. در این وضعیت، می‌توانید به راست بگویید که درباره متغیر استفاده‌نشده هشدار ندهد، با شروع نام متغیر با یک زیرخط. در فهرست 19-20، دو متغیر استفاده‌نشده ایجاد می‌کنیم، اما وقتی این کد را کامپایل می‌کنیم، باید فقط یک هشدار درباره یکی از آن‌ها دریافت کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<figcaption>Listing 19-20: شروع نام متغیر با یک زیرخط برای جلوگیری از هشدارهای متغیر استفاده‌نشده</figcaption>
</figure>
<p>اینجا درباره استفاده نکردن از متغیر <code>y</code> یک هشدار دریافت می‌کنیم، اما درباره استفاده نکردن از <code>_x</code> هشدار نمی‌گیریم.</p>
<p>توجه داشته باشید که تفاوت ظریفی بین استفاده از فقط <code>_</code> و استفاده از نامی که با یک زیرخط شروع می‌شود وجود دارد. نحو <code>_x</code> همچنان مقدار را به متغیر متصل می‌کند، در حالی که <code>_</code> اصلاً متصل نمی‌شود. برای نشان دادن موردی که این تفاوت اهمیت دارد، فهرست 19-21 به ما یک خطا ارائه می‌دهد.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-21: یک متغیر استفاده‌نشده که با یک زیرخط شروع می‌شود همچنان مقدار را متصل می‌کند، که ممکن است مالکیت مقدار را بگیرد</figcaption>
</figure>
<p>ما یک خطا دریافت خواهیم کرد زیرا مقدار <code>s</code> همچنان به <code>_s</code> منتقل می‌شود، که مانع از استفاده دوباره از <code>s</code> می‌شود. با این حال، استفاده از زیرخط به‌تنهایی هرگز به مقدار متصل نمی‌شود. فهرست 19-22 بدون هیچ خطایی کامپایل خواهد شد زیرا <code>s</code> به <code>_</code> منتقل نمی‌شود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-22: استفاده از یک زیرخط مقدار را متصل نمی‌کند</figcaption>
</figure>
<p>این کد به‌خوبی کار می‌کند زیرا ما هرگز <code>s</code> را به چیزی متصل نمی‌کنیم؛ بنابراین انتقال داده نمی‌شود.</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>برای مقادیری که بخش‌های زیادی دارند، می‌توانیم از نحو <code>..</code> برای استفاده از بخش‌های خاص و نادیده گرفتن باقی بخش‌ها استفاده کنیم، و نیازی به لیست کردن زیرخط‌ها برای هر مقدار نادیده گرفته‌شده نخواهیم داشت. الگوی <code>..</code> هر بخشی از یک مقدار را که به‌طور صریح در بقیه الگو مطابقت داده نشده نادیده می‌گیرد. در فهرست 19-23، یک struct به نام <code>Point</code> داریم که یک مختصات در فضای سه‌بعدی نگه می‌دارد. در عبارت <code>match</code>، می‌خواهیم فقط روی مختصات <code>x</code> عمل کنیم و مقادیر موجود در فیلدهای <code>y</code> و <code>z</code> را نادیده بگیریم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-23: نادیده گرفتن تمام فیلدهای یک <code>Point</code> به‌جز <code>x</code> با استفاده از <code>..</code></figcaption>
</figure>
<p>ما مقدار <code>x</code> را فهرست می‌کنیم و سپس فقط الگوی <code>..</code> را اضافه می‌کنیم. این سریع‌تر از این است که <code>y: _</code> و <code>z: _</code> را فهرست کنیم، به‌ویژه زمانی که با ساختارهایی کار می‌کنیم که فیلدهای زیادی دارند و فقط یکی یا دو فیلد مهم هستند.</p>
<p>نحو <code>..</code> به هر تعداد مقداری که نیاز باشد گسترش می‌یابد. فهرست 19-24 نشان می‌دهد که چگونه از <code>..</code> با یک tuple استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-24: تطبیق فقط اولین و آخرین مقادیر در یک tuple و نادیده گرفتن تمام مقادیر دیگر</figcaption>
</figure>
<p>در این کد، مقدار اول و آخر با <code>first</code> و <code>last</code> مطابقت داده می‌شوند. الگوی <code>..</code> تمام مقادیر میانی را مطابقت داده و نادیده می‌گیرد.</p>
<p>با این حال، استفاده از <code>..</code> باید بدون ابهام باشد. اگر مشخص نباشد کدام مقادیر برای تطبیق و کدام برای نادیده گرفتن در نظر گرفته شده‌اند، راست به ما خطا می‌دهد. فهرست 19-25 مثالی از استفاده از <code>..</code> به شکلی مبهم را نشان می‌دهد، بنابراین کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption>Listing 19-25: تلاشی برای استفاده از <code>..</code> به شکلی مبهم</figcaption>
</figure>
<p>وقتی این مثال را کامپایل می‌کنیم، این خطا را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>برای راست امکان‌پذیر نیست که تعیین کند چند مقدار در tuple باید نادیده گرفته شود قبل از اینکه یک مقدار را با <code>second</code> تطبیق دهد و سپس چند مقدار دیگر را بعد از آن نادیده بگیرد. این کد می‌تواند به این معنا باشد که می‌خواهیم <code>2</code> را نادیده بگیریم، <code>second</code> را به <code>4</code> متصل کنیم، و سپس <code>8</code>، <code>16</code> و <code>32</code> را نادیده بگیریم؛ یا اینکه می‌خواهیم <code>2</code> و <code>4</code> را نادیده بگیریم، <code>second</code> را به <code>8</code> متصل کنیم، و سپس <code>16</code> و <code>32</code> را نادیده بگیریم؛ و غیره. نام متغیر <code>second</code> برای راست معنی خاصی ندارد، بنابراین به دلیل استفاده از <code>..</code> در دو مکان به این شکل مبهم، خطای کامپایل دریافت می‌کنیم.</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>یک <em>match guard</em> یک شرط اضافی <code>if</code> است که پس از الگو در یک بازوی <code>match</code> مشخص می‌شود و باید برای انتخاب آن بازو نیز مطابقت داشته باشد. Match guardها برای بیان ایده‌های پیچیده‌تر از آنچه که یک الگو به‌تنهایی اجازه می‌دهد، مفید هستند. این قابلیت فقط در عبارات <code>match</code> در دسترس است، نه در عبارات <code>if let</code> یا <code>while let</code>.</p>
<p>شرط می‌تواند از متغیرهایی که در الگو ایجاد شده‌اند استفاده کند. فهرست 19-26 یک <code>match</code> را نشان می‌دهد که بازوی اول آن دارای الگوی <code>Some(x)</code> است و همچنین دارای یک match guard <code>if x % 2 == 0</code> است (که در صورتی که عدد زوج باشد، true خواهد بود).</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-26: افزودن یک match guard به یک الگو</figcaption>
</figure>
<p>این مثال پیام <code>The number 4 is even</code> را چاپ می‌کند. وقتی <code>num</code> با الگوی بازوی اول مقایسه می‌شود، مطابقت دارد، زیرا <code>Some(4)</code> با <code>Some(x)</code> مطابقت دارد. سپس match guard بررسی می‌کند که آیا باقی‌مانده تقسیم <code>x</code> بر 2 برابر با 0 است یا نه، و چون این شرط برقرار است، بازوی اول انتخاب می‌شود.</p>
<p>اگر مقدار <code>num</code> برابر با <code>Some(5)</code> بود، match guard در بازوی اول false می‌شد زیرا باقی‌مانده تقسیم 5 بر 2 برابر با 1 است که برابر با 0 نیست. راست سپس به بازوی دوم می‌رود که مطابقت دارد زیرا بازوی دوم match guard ندارد و بنابراین با هر متغیر <code>Some</code> مطابقت دارد.</p>
<p>هیچ راهی برای بیان شرط <code>if x % 2 == 0</code> در داخل یک الگو وجود ندارد، بنابراین match guard به ما امکان بیان این منطق را می‌دهد. نقطه ضعف این قابلیت اضافی این است که کامپایلر سعی نمی‌کند بررسی کند که آیا تمام موارد پوشش داده شده‌اند یا نه وقتی که match guardها درگیر هستند.</p>
<p>در فهرست 19-11 اشاره کردیم که می‌توانیم از match guardها برای حل مشکل shadowing الگو استفاده کنیم. به یاد بیاورید که ما یک متغیر جدید در داخل الگو در عبارت <code>match</code> ایجاد کردیم به جای استفاده از متغیر بیرون از <code>match</code>. آن متغیر جدید به این معنا بود که نمی‌توانستیم مقدار متغیر بیرونی را تست کنیم. فهرست 19-27 نشان می‌دهد که چگونه می‌توانیم از یک match guard برای رفع این مشکل استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<figcaption>Listing 19-27: استفاده از یک match guard برای آزمایش برابری با یک متغیر بیرونی</figcaption>
</figure>
<p>این کد اکنون پیام <code>Default case, x = Some(5)</code> را چاپ می‌کند. الگوی بازوی دوم match یک متغیر جدید <code>y</code> که متغیر بیرونی <code>y</code> را shadow کند معرفی نمی‌کند، به این معنا که می‌توانیم از متغیر بیرونی <code>y</code> در match guard استفاده کنیم. به جای مشخص کردن الگو به‌عنوان <code>Some(y)</code> که متغیر بیرونی <code>y</code> را shadow می‌کرد، ما <code>Some(n)</code> را مشخص می‌کنیم. این یک متغیر جدید <code>n</code> ایجاد می‌کند که هیچ چیزی را shadow نمی‌کند زیرا هیچ متغیر <code>n</code> در خارج از <code>match</code> وجود ندارد.</p>
<p>Match guard <code>if n == y</code> یک الگو نیست و بنابراین متغیرهای جدیدی را معرفی نمی‌کند. این <code>y</code> <em>همان</em> متغیر بیرونی <code>y</code> است و یک متغیر جدید که آن را shadow کند نیست، و می‌توانیم با مقایسه <code>n</code> با <code>y</code> به دنبال مقداری باشیم که با مقدار بیرونی <code>y</code> یکسان باشد.</p>
<p>همچنین می‌توانید از عملگر <em>یا</em> <code>|</code> در یک match guard استفاده کنید تا چندین الگو مشخص کنید؛ شرط match guard برای تمام الگوها اعمال خواهد شد. فهرست 19-28 تقدم هنگام ترکیب یک الگو که از <code>|</code> استفاده می‌کند با یک match guard را نشان می‌دهد. بخش مهم این مثال این است که match guard <code>if y</code> برای <code>4</code>، <code>5</code>، <em>و</em> <code>6</code> اعمال می‌شود، حتی اگر ممکن است به نظر برسد که <code>if y</code> فقط برای <code>6</code> اعمال می‌شود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-28: ترکیب چندین الگو با یک match guard</figcaption>
</figure>
<p>شرط مطابقت بیان می‌کند که بازو فقط زمانی مطابقت دارد که مقدار <code>x</code> برابر با <code>4</code>، <code>5</code>، یا <code>6</code> <em>و</em> مقدار <code>y</code> برابر با <code>true</code> باشد. وقتی این کد اجرا می‌شود، الگوی بازوی اول مطابقت دارد زیرا <code>x</code> برابر با <code>4</code> است، اما match guard <code>if y</code> برابر با false است، بنابراین بازوی اول انتخاب نمی‌شود. کد به بازوی دوم می‌رود که مطابقت دارد، و این برنامه <code>no</code> را چاپ می‌کند. دلیل این است که شرط <code>if</code> برای کل الگوی <code>4 | 5 | 6</code> اعمال می‌شود، نه فقط برای مقدار آخر <code>6</code>. به عبارت دیگر، تقدم یک match guard نسبت به یک الگو به این شکل رفتار می‌کند:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>و نه به این شکل:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>بعد از اجرای کد، رفتار تقدم آشکار می‌شود: اگر match guard فقط برای مقدار نهایی در لیست مقادیر مشخص‌شده با استفاده از عملگر <code>|</code> اعمال می‌شد، بازو مطابقت می‌داشت و برنامه پیام <code>yes</code> را چاپ می‌کرد.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>عملگر <em>at</em> (<code>@</code>) به ما امکان می‌دهد یک متغیر ایجاد کنیم که یک مقدار را نگه می‌دارد و همزمان آن مقدار را برای تطبیق با الگو آزمایش می‌کند. در فهرست 19-29، ما می‌خواهیم بررسی کنیم که آیا فیلد <code>id</code> در <code>Message::Hello</code> در بازه <code>3..=7</code> قرار دارد یا نه. همچنین می‌خواهیم مقدار را به متغیر <code>id_variable</code> متصل کنیم تا بتوانیم در کد مرتبط با بازو از آن استفاده کنیم. می‌توانستیم این متغیر را <code>id</code> بنامیم، مشابه فیلد، اما برای این مثال از نام متفاوتی استفاده خواهیم کرد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-29: استفاده از <code>@</code> برای اتصال به یک مقدار در یک الگو و همزمان آزمایش آن</figcaption>
</figure>
<p>این مثال پیام <code>Found an id in range: 5</code> را چاپ می‌کند. با مشخص کردن <code>id_variable @</code> قبل از بازه <code>3..=7</code>، ما هر مقداری که با بازه مطابقت داشت را ذخیره می‌کنیم و همزمان بررسی می‌کنیم که آیا مقدار با الگوی بازه مطابقت دارد.</p>
<p>در بازوی دوم، جایی که فقط یک بازه در الگو مشخص شده است، کدی که با بازو مرتبط است متغیری ندارد که مقدار واقعی فیلد <code>id</code> را شامل شود. مقدار فیلد <code>id</code> می‌توانست 10، 11، یا 12 باشد، اما کدی که با آن الگو مرتبط است نمی‌داند مقدار چیست. کد بازو نمی‌تواند از مقدار فیلد <code>id</code> استفاده کند، زیرا ما مقدار <code>id</code> را در یک متغیر ذخیره نکرده‌ایم.</p>
<p>در بازوی آخر، جایی که یک متغیر بدون بازه مشخص کرده‌ایم، مقدار برای استفاده در کد بازو در متغیری به نام <code>id</code> در دسترس است. دلیل این است که ما از نحو کوتاه فیلدهای struct استفاده کرده‌ایم. اما در این بازو هیچ آزمایشی برای مقدار در فیلد <code>id</code> اعمال نکرده‌ایم، همان‌طور که در دو بازوی اول انجام دادیم: هر مقداری با این الگو مطابقت خواهد داشت.</p>
<p>استفاده از <code>@</code> به ما امکان می‌دهد یک مقدار را آزمایش کنیم و همزمان آن را در یک متغیر ذخیره کنیم، همه در یک الگو.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>الگوهای راست در تشخیص بین انواع مختلف داده بسیار مفید هستند. وقتی در عبارات <code>match</code> استفاده می‌شوند، راست اطمینان حاصل می‌کند که الگوهای شما تمام مقادیر ممکن را پوشش می‌دهند، وگرنه برنامه شما کامپایل نخواهد شد. الگوها در عبارات <code>let</code> و پارامترهای تابع این ساختارها را مفیدتر می‌کنند و تخریب مقادیر به بخش‌های کوچک‌تر را همزمان با تخصیص به متغیرها ممکن می‌سازند. ما می‌توانیم الگوهای ساده یا پیچیده‌ای ایجاد کنیم که نیازهای ما را برآورده کنند.</p>
<p>در فصل ماقبل آخر این کتاب، به برخی از جنبه‌های پیشرفته از ویژگی‌های مختلف راست خواهیم پرداخت.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
