<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>همزمانی با Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html" class="active"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="همزمانی-concurrency-با-async"><a class="header" href="#همزمانی-concurrency-با-async">همزمانی (Concurrency) با Async</a></h2>
<p>در این بخش، async را به برخی از همان چالش‌های همزمانی که با نخ‌ها در فصل 16 انجام دادیم اعمال می‌کنیم. از آنجا که قبلاً درباره بسیاری از ایده‌های کلیدی در آنجا صحبت کرده‌ایم، در این بخش تمرکز بر تفاوت‌های بین نخ‌ها و آینده‌ها (futures) خواهیم داشت.</p>
<p>در بسیاری از موارد، API‌ها برای کار با همزمانی با استفاده از async بسیار شبیه به آن‌هایی هستند که برای استفاده از نخ‌ها به کار می‌روند. در موارد دیگر، شکل بسیار متفاوتی دارند. حتی زمانی که API‌ها بین نخ‌ها و async <em>شبیه</em> به نظر می‌رسند، اغلب رفتار متفاوتی دارند—و تقریباً همیشه ویژگی‌های عملکردی متفاوتی دارند.</p>
<h3 id="شمارش"><a class="header" href="#شمارش">شمارش</a></h3>
<p>اولین وظیفه‌ای که در فصل 16 به آن پرداختیم، شمارش در دو نخ جداگانه بود. بیایید همین کار را با استفاده از async انجام دهیم. crate <code>trpl</code> یک تابع <code>spawn_task</code> ارائه می‌دهد که بسیار شبیه به API <code>thread::spawn</code> است، و یک تابع <code>sleep</code> که یک نسخه async از API <code>thread::sleep</code> است. می‌توانیم از این دو با هم برای پیاده‌سازی همان مثال شمارش با نخ‌ها استفاده کنیم، همانطور که در فهرست 17-6 آمده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-6: استفاده از <code>spawn_task</code> برای شمارش با دو</figcaption>
</figure>
<p>به‌عنوان نقطه شروع، تابع <code>main</code> خود را با <code>trpl::run</code> راه‌اندازی می‌کنیم، به‌طوری که تابع سطح بالای ما می‌تواند async باشد.</p>
<blockquote>
<p>نکته: از این نقطه به بعد در فصل، هر مثال این کد بسته‌بندی یکسان را با <code>trpl::run</code> در <code>main</code> شامل خواهد شد، بنابراین اغلب آن را مانند <code>main</code> نادیده می‌گیریم. فراموش نکنید که آن را در کد خود بگنجانید!</p>
</blockquote>
<p>سپس دو حلقه درون آن بلوک می‌نویسیم، هرکدام با یک فراخوانی <code>trpl::sleep</code> در آن، که به مدت نیم ثانیه (500 میلی‌ثانیه) قبل از ارسال پیام بعدی منتظر می‌ماند. یک حلقه را در بدنه یک <code>trpl::spawn_task</code> قرار می‌دهیم و دیگری را در یک حلقه <code>for</code> سطح بالا. همچنین بعد از فراخوانی‌های <code>sleep</code> یک <code>await</code> اضافه می‌کنیم.</p>
<p>این کار چیزی شبیه به پیاده‌سازی مبتنی بر نخ انجام می‌دهد—از جمله اینکه ممکن است پیام‌ها در ترمینال شما به ترتیب متفاوتی ظاهر شوند وقتی آن را اجرا می‌کنید.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>این نسخه بلافاصله پس از اتمام حلقه <code>for</code> در بدنه بلوک اصلی async متوقف می‌شود، زیرا تسکی که با <code>spawn_task</code> ایجاد شده است هنگام پایان تابع <code>main</code> خاموش می‌شود. اگر بخواهید برنامه تا تکمیل کامل تسک اجرا شود، باید از یک handle الحاقی برای منتظر ماندن تا تکمیل تسک اول استفاده کنید. با نخ‌ها، از متد <code>join</code> استفاده کردیم تا تا زمانی که نخ کار خود را تمام نکرده است “مسدود” شود. در فهرست 17-7، می‌توانیم از <code>await</code> برای انجام همان کار استفاده کنیم، زیرا خود handle تسک یک آینده است. نوع <code>Output</code> آن یک <code>Result</code> است، بنابراین بعد از منتظر ماندن آن را نیز باز می‌کنیم (<code>unwrap</code>).</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-7: استفاده از <code>await</code> با یک handle الحاقی برای اجرای تسک تا تکمیل</figcaption>
</figure>
<p>نسخه به‌روزرسانی‌شده تا زمانی که <em>هر دو</em> حلقه تمام شوند اجرا می‌شود.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>تا اینجا، به نظر می‌رسد async و نخ‌ها نتایج اصلی یکسانی به ما می‌دهند، فقط با سینتکس متفاوت: استفاده از <code>await</code> به جای فراخوانی <code>join</code> روی handle الحاقی و انتظار برای فراخوانی‌های <code>sleep</code>.</p>
<p>تفاوت بزرگ‌تر این است که نیازی به ایجاد یک نخ سیستم‌عامل جداگانه برای این کار نداشتیم. در واقع، حتی نیازی به ایجاد یک تسک هم در اینجا نداریم. زیرا بلوک‌های async به آینده‌های ناشناس کامپایل می‌شوند، می‌توانیم هر حلقه را در یک بلوک async قرار دهیم و اجازه دهیم runtime هر دو را با استفاده از تابع <code>trpl::join</code> تا تکمیل اجرا کند.</p>
<p>در فصل 16، نشان دادیم چگونه می‌توان از متد <code>join</code> روی نوع <code>JoinHandle</code> که هنگام فراخوانی <code>std::thread::spawn</code> بازمی‌گردد استفاده کرد. تابع <code>trpl::join</code> مشابه است، اما برای آینده‌ها. وقتی دو آینده به آن می‌دهید، یک آینده جدید تولید می‌کند که خروجی آن یک تاپل با خروجی هرکدام از آینده‌هایی که به آن داده‌اید است، زمانی که <em>هر دو</em> کامل شوند. بنابراین، در فهرست 17-8، از <code>trpl::join</code> برای منتظر ماندن تا زمانی که <code>fut1</code> و <code>fut2</code> هر دو تمام شوند استفاده می‌کنیم. ما <em>منتظر</em> <code>fut1</code> و <code>fut2</code> نمی‌مانیم، بلکه آینده جدید تولیدشده توسط <code>trpl::join</code> را منتظر می‌مانیم. خروجی را نادیده می‌گیریم، زیرا فقط یک تاپل با دو مقدار واحد در آن است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-8: استفاده از <code>trpl::join</code> برای منتظر ماندن دو آینده ناشناس</figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، می‌بینیم هر دو futures تا تکمیل اجرا می‌شوند:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>اینجا، هر بار همان ترتیب را خواهید دید، که بسیار متفاوت از چیزی است که با نخ‌ها دیدیم. این به این دلیل است که تابع <code>trpl::join</code> <em>منصفانه</em> است، به این معنی که هر آینده را به‌طور مساوی بررسی می‌کند، بین آن‌ها تناوب ایجاد می‌کند، و هرگز اجازه نمی‌دهد یکی جلوتر بیفتد اگر دیگری آماده باشد. با نخ‌ها، سیستم‌عامل تصمیم می‌گیرد که کدام نخ را بررسی کند و چقدر اجازه دهد اجرا شود. با راست async، runtime تصمیم می‌گیرد که کدام تسک را بررسی کند. (در عمل، جزئیات پیچیده‌تر می‌شوند، زیرا یک runtime async ممکن است از نخ‌های سیستم‌عامل در پشت صحنه به‌عنوان بخشی از نحوه مدیریت همزمانی استفاده کند، بنابراین تضمین انصاف می‌تواند برای یک runtime کار بیشتری باشد—اما همچنان ممکن است!) لازم نیست runtime‌ها برای هر عملیات خاصی انصاف را تضمین کنند، و runtime‌ها اغلب API‌های متفاوتی ارائه می‌دهند که به شما اجازه می‌دهند انتخاب کنید آیا می‌خواهید انصاف یا خیر.</p>
<p>برخی از این تغییرات مختلف برای انتظار آینده‌ها را امتحان کنید و ببینید چه می‌کنند:</p>
<ul>
<li>بلوک async را از اطراف یکی یا هر دو حلقه حذف کنید.</li>
<li>هر بلوک async را بلافاصله پس از تعریف آن منتظر بمانید.</li>
<li>فقط حلقه اول را در یک بلوک async قرار دهید و آینده حاصل را پس از بدنه حلقه دوم منتظر بمانید.</li>
</ul>
<p>برای یک چالش اضافی، ببینید آیا می‌توانید پیش از اجرای کد پیش‌بینی کنید که خروجی چه خواهد بود!</p>
<h3 id="ارسال-پیام"><a class="header" href="#ارسال-پیام">ارسال پیام</a></h3>
<p>اشتراک داده بین آینده‌ها نیز آشنا خواهد بود: دوباره از ارسال پیام استفاده خواهیم کرد، اما این بار با نسخه‌های async از نوع‌ها و توابع. ما مسیری کمی متفاوت از آنچه در فصل 16 انجام دادیم را طی خواهیم کرد تا برخی از تفاوت‌های کلیدی بین همزمانی مبتنی بر نخ و مبتنی بر آینده‌ها را نشان دهیم. در فهرست 17-9، فقط با یک بلوک async شروع می‌کنیم—<em>نه</em> ایجاد یک تسک جداگانه همان‌طور که یک نخ جداگانه ایجاد کردیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-9: ایجاد یک کانال async و اختصاص دو نیمه به <code>tx</code> و <code>rx</code></figcaption>
</figure>
<p>اینجا، از <code>trpl::channel</code> استفاده می‌کنیم، نسخه async از API کانال چندتولیدی، یک‌مصرفی که در فصل 16 با نخ‌ها استفاده کردیم. نسخه async از API فقط کمی با نسخه مبتنی بر نخ متفاوت است: به جای استفاده از یک گیرنده غیرقابل‌تغییر (immutable)، از یک گیرنده قابل‌تغییر (mutable) <code>rx</code> استفاده می‌کند، و متد <code>recv</code> آن یک آینده تولید می‌کند که باید منتظر آن بمانیم، به جای تولید مقدار به‌طور مستقیم. اکنون می‌توانیم پیام‌ها را از فرستنده به گیرنده ارسال کنیم. توجه کنید که نیازی به ایجاد یک نخ جداگانه یا حتی یک تسک نداریم؛ فقط باید فراخوانی <code>rx.recv</code> را منتظر بمانیم.</p>
<p>متد همگام <code>Receiver::recv</code> در <code>std::mpsc::channel</code> تا زمانی که پیامی دریافت شود مسدود می‌شود. متد <code>trpl::Receiver::recv</code> این کار را نمی‌کند، زیرا async است. به جای مسدود شدن، کنترل را به runtime بازمی‌گرداند تا زمانی که یا پیامی دریافت شود یا سمت ارسال کانال بسته شود. در مقابل، ما فراخوانی <code>send</code> را منتظر نمی‌مانیم، زیرا مسدود نمی‌شود. نیازی به این کار ندارد، زیرا کانالی که پیام را به آن ارسال می‌کنیم بدون حد است.</p>
<blockquote>
<p>نکته: از آنجا که تمام این کد async در یک بلوک async در یک فراخوانی <code>trpl::run</code> اجرا می‌شود، همه چیز درون آن می‌تواند از مسدود شدن اجتناب کند. با این حال، کد <em>خارج</em> از آن در انتظار بازگشت تابع <code>run</code> مسدود خواهد شد. این کل هدف تابع <code>trpl::run</code> است: به شما اجازه می‌دهد <em>انتخاب کنید</em> کجا برای مجموعه‌ای از کد async مسدود شوید، و بنابراین کجا بین کد همگام و ناهمگام تغییر دهید. در بیشتر runtime‌های async، <code>run</code> در واقع <code>block_on</code> نامیده می‌شود دقیقاً به همین دلیل.</p>
</blockquote>
<p>به دو نکته در این مثال توجه کنید: اول، پیام بلافاصله می‌رسد! دوم، اگرچه در اینجا از یک آینده استفاده می‌کنیم، هنوز هیچ همزمانی وجود ندارد. همه چیز در این فهرست به ترتیبی اتفاق می‌افتد که انگار هیچ آینده‌ای درگیر نیست.</p>
<p>بیایید به بخش اول با ارسال یک سری پیام‌ها رسیدگی کنیم و بین آن‌ها از <code>sleep</code> استفاده کنیم، همان‌طور که در فهرست 17-10 نشان داده شده است:</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let vals = vec![
</span><span class="boring">            String::from("hi"),
</span><span class="boring">            String::from("from"),
</span><span class="boring">            String::from("the"),
</span><span class="boring">            String::from("future"),
</span><span class="boring">        ];
</span><span class="boring">
</span><span class="boring">        for val in vals {
</span><span class="boring">            tx.send(val).unwrap();
</span><span class="boring">            trpl::sleep(Duration::from_millis(500)).await;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        while let Some(value) = rx.recv().await {
</span><span class="boring">            println!("received '{value}'");
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-10: ارسال و دریافت چندین پیام از طریق کانال async و استفاده از <code>await</code> بین هر پیام</figcaption>
</figure>
<p>علاوه بر ارسال پیام‌ها، ما نیاز داریم آن‌ها را دریافت کنیم. در این حالت، می‌توانستیم به‌صورت دستی این کار را انجام دهیم، با انجام چهار بار <code>rx.recv().await</code>، زیرا می‌دانیم چند پیام دریافت خواهیم کرد. اما در دنیای واقعی، معمولاً منتظر تعدادی پیام <em>نامشخص</em> هستیم. در این حالت، باید تا زمانی که تعیین کنیم پیام دیگری وجود ندارد منتظر بمانیم.</p>
<p>در فهرست 16-10، از یک حلقه <code>for</code> برای پردازش تمام آیتم‌های دریافتی از یک کانال همگام استفاده کردیم. با این حال، راست هنوز راهی برای نوشتن یک حلقه <code>for</code> برای یک سری آیتم‌های <em>ناهمگام</em> ندارد. در عوض، باید از نوع جدیدی از حلقه که قبلاً ندیده‌ایم استفاده کنیم، حلقه شرطی <code>while let</code>. حلقه <code>while let</code> نسخه حلقه‌ای سازه <code>if let</code> است که در فصل 6 دیدیم. این حلقه تا زمانی که الگویی که مشخص می‌کند با مقدار مطابقت داشته باشد، به اجرا ادامه می‌دهد.</p>
<p>فراخوانی <code>rx.recv</code> یک آینده تولید می‌کند که منتظر آن می‌مانیم. runtime آینده را تا زمانی که آماده شود متوقف می‌کند. وقتی پیامی می‌رسد، آینده به <code>Some(message)</code> حل می‌شود، به تعداد دفعاتی که پیام می‌رسد. وقتی کانال بسته می‌شود، صرف‌نظر از اینکه آیا <em>هیچ</em> پیامی رسیده است یا نه، آینده به <code>None</code> حل می‌شود تا نشان دهد هیچ مقداری باقی نمانده است و ما باید polling را متوقف کنیم—یعنی منتظر ماندن را متوقف کنیم.</p>
<p>حلقه <code>while let</code> همه این‌ها را کنار هم قرار می‌دهد. اگر نتیجه فراخوانی <code>rx.recv().await</code> برابر با <code>Some(message)</code> باشد، به پیام دسترسی پیدا می‌کنیم و می‌توانیم از آن در بدنه حلقه استفاده کنیم، همانطور که با <code>if let</code> می‌توانستیم. اگر نتیجه <code>None</code> باشد، حلقه متوقف می‌شود. هر بار که حلقه کامل می‌شود، به نقطه انتظار بازمی‌گردد، بنابراین runtime دوباره آن را متوقف می‌کند تا زمانی که پیام دیگری برسد.</p>
<p>اکنون کد با موفقیت تمام پیام‌ها را ارسال و دریافت می‌کند. متأسفانه، هنوز چند مشکل وجود دارد. برای مثال، پیام‌ها در فواصل نیم‌ثانیه نمی‌رسند. آن‌ها همگی یکباره، دو ثانیه (2000 میلی‌ثانیه) پس از شروع برنامه می‌رسند. علاوه بر این، این برنامه هرگز خارج نمی‌شود! بلکه برای همیشه منتظر پیام‌های جدید می‌ماند. شما باید آن را با استفاده از <span class="keystroke">ctrl-c</span> متوقف کنید.</p>
<p>بیایید با فهمیدن اینکه چرا پیام‌ها همگی یکباره پس از تأخیر کامل می‌رسند، شروع کنیم، به‌جای اینکه با تأخیر بین هر یک برسند. در یک بلوک async خاص، ترتیبی که کلمات کلیدی <code>await</code> در کد ظاهر می‌شوند، همان ترتیبی است که هنگام اجرای برنامه اتفاق می‌افتد.</p>
<p>در فهرست 17-10 فقط یک بلوک async وجود دارد، بنابراین همه چیز در آن به‌صورت خطی اجرا می‌شود. هنوز هم هیچ همزمانی وجود ندارد. تمام فراخوانی‌های <code>tx.send</code> انجام می‌شوند، در میان تمام فراخوانی‌های <code>trpl::sleep</code> و نقاط انتظار مرتبط با آن‌ها. فقط پس از آن، حلقه <code>while let</code> به نقاط انتظار روی فراخوانی‌های <code>recv</code> می‌رسد.</p>
<p>برای به دست آوردن رفتاری که می‌خواهیم، جایی که تأخیر خواب بین دریافت هر پیام اتفاق می‌افتد، باید عملیات‌های <code>tx</code> و <code>rx</code> را در بلوک‌های async جداگانه قرار دهیم. سپس runtime می‌تواند هرکدام از آن‌ها را به‌صورت جداگانه با استفاده از <code>trpl::join</code> اجرا کند، همان‌طور که در مثال شمارش انجام دادیم. دوباره، نتیجه فراخوانی <code>trpl::join</code> را منتظر می‌مانیم، نه آینده‌های فردی. اگر آینده‌های فردی را به ترتیب منتظر بمانیم، فقط دوباره به یک جریان ترتیبی بازمی‌گردیم—دقیقاً چیزی که تلاش می‌کنیم <em>اجتناب</em> کنیم.</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-11: جدا کردن <code>send</code> و <code>recv</code> در بلوک‌های <code>async</code> جداگانه و منتظر ماندن برای آینده‌های این بلوک‌ها</figcaption>
</figure>
<p>با کد به‌روزرسانی‌شده در فهرست 17-11، پیام‌ها به‌جای اینکه همگی یک‌باره پس از دو ثانیه ظاهر شوند، در فواصل 500 میلی‌ثانیه چاپ می‌شوند.</p>
<p>برنامه هنوز هم هرگز خارج نمی‌شود، به دلیل نحوه تعامل حلقه <code>while let</code> با <code>trpl::join</code>:</p>
<ul>
<li>آینده بازگشتی از <code>trpl::join</code> تنها زمانی کامل می‌شود که <em>هر دو</em> آینده‌ای که به آن ارسال شده‌اند کامل شوند.</li>
<li>آینده <code>tx</code> زمانی کامل می‌شود که پس از ارسال آخرین پیام در <code>vals</code> خواب آن به پایان برسد.</li>
<li>آینده <code>rx</code> تا زمانی که حلقه <code>while let</code> به پایان نرسد کامل نخواهد شد.</li>
<li>حلقه <code>while let</code> تنها زمانی پایان می‌یابد که انتظار برای <code>rx.recv</code> مقدار <code>None</code> تولید کند.</li>
<li>انتظار برای <code>rx.recv</code> تنها زمانی مقدار <code>None</code> بازمی‌گرداند که طرف دیگر کانال بسته شود.</li>
<li>کانال تنها زمانی بسته می‌شود که ما <code>rx.close</code> را فراخوانی کنیم یا طرف فرستنده، یعنی <code>tx</code>، حذف شود.</li>
<li>ما در هیچ جایی <code>rx.close</code> را فراخوانی نمی‌کنیم، و <code>tx</code> تا زمانی که بلوک async بیرونی ارسال‌شده به <code>trpl::run</code> به پایان نرسد حذف نمی‌شود.</li>
<li>بلوک نمی‌تواند به پایان برسد زیرا در انتظار تکمیل <code>trpl::join</code> مسدود شده است، که ما را به بالای این لیست بازمی‌گرداند!</li>
</ul>
<p>ما می‌توانیم به‌صورت دستی با فراخوانی <code>rx.close</code> کانال را ببندیم، اما این کار چندان منطقی نیست. توقف پس از پردازش تعداد دلخواهی از پیام‌ها باعث می‌شود برنامه خاموش شود، اما ممکن است پیام‌ها را از دست بدهیم. ما به راه دیگری نیاز داریم تا مطمئن شویم که <code>tx</code> <em>قبل از</em> پایان تابع حذف می‌شود.</p>
<p>در حال حاضر، بلوک async که پیام‌ها را ارسال می‌کند فقط <code>tx</code> را قرض می‌گیرد، زیرا ارسال یک پیام نیازی به مالکیت ندارد، اما اگر بتوانیم <code>tx</code> را به آن بلوک async منتقل کنیم، با پایان آن بلوک حذف خواهد شد. در فصل 13، آموختیم که چگونه از کلمه کلیدی <code>move</code> با closureها استفاده کنیم، و در فصل 16 دیدیم که هنگام کار با نخ‌ها اغلب نیاز داریم داده‌ها را به closureها منتقل کنیم. همان دینامیک اصلی برای بلوک‌های async نیز اعمال می‌شود، بنابراین کلمه کلیدی <code>move</code> با بلوک‌های async همانطور که با closureها کار می‌کند عمل می‌کند.</p>
<p>در فهرست 17-12، بلوک async برای ارسال پیام‌ها را از یک بلوک <code>async</code> ساده به یک بلوک <code>async move</code> تغییر می‌دهیم. وقتی <em>این</em> نسخه از کد را اجرا می‌کنیم، پس از ارسال و دریافت آخرین پیام به درستی خاموش می‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-12: مثالی کارآمد از ارسال و دریافت پیام‌ها بین آینده‌ها که به درستی پس از تکمیل خاموش می‌شود</figcaption>
</figure>
<p>این کانال async همچنین یک کانال چندتولیدی است، بنابراین اگر بخواهیم پیام‌ها را از آینده‌های مختلف ارسال کنیم، می‌توانیم روی <code>tx</code> فراخوانی <code>clone</code> انجام دهیم. در فهرست 17-13، ما <code>tx</code> را کلون می‌کنیم و <code>tx1</code> را خارج از اولین بلوک async ایجاد می‌کنیم. سپس، همان‌طور که قبلاً با <code>tx</code> انجام دادیم، <code>tx1</code> را به آن بلوک منتقل می‌کنیم. سپس، در ادامه، <code>tx</code> اصلی را به یک بلوک async <em>جدید</em> منتقل می‌کنیم، جایی که پیام‌های بیشتری را با کمی تأخیر بیشتر ارسال می‌کنیم. ما این بلوک async جدید را پس از بلوک async برای دریافت پیام‌ها قرار می‌دهیم، اما می‌تواند به همان خوبی قبل از آن قرار گیرد. نکته کلیدی ترتیب انتظار برای آینده‌ها است، نه ترتیب ایجاد آن‌ها.</p>
<p>هر دو بلوک async برای ارسال پیام‌ها باید بلوک‌های <code>async move</code> باشند، به طوری که هم <code>tx</code> و هم <code>tx1</code> با پایان آن بلوک‌ها حذف شوند. در غیر این صورت، دوباره به همان حلقه بی‌نهایتی که ابتدا در آن بودیم بازمی‌گردیم. در نهایت، از <code>trpl::join</code> به <code>trpl::join3</code> تغییر می‌دهیم تا آینده اضافی را مدیریت کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-13: استفاده از تولیدکنندگان متعدد با بلوک‌های async</figcaption>
</figure>
<p>اکنون تمام پیام‌ها از هر دو آینده ارسال‌کننده را می‌بینیم. از آنجا که آینده‌های ارسال‌کننده از تأخیرهای کمی متفاوت پس از ارسال استفاده می‌کنند، پیام‌ها نیز در این فواصل مختلف دریافت می‌شوند.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>این یک شروع خوب است، اما ما را به فقط چند آینده محدود می‌کند: دو آینده با <code>join</code>، یا سه آینده با <code>join3</code>. بیایید ببینیم چگونه می‌توانیم با آینده‌های بیشتری کار کنیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
