<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>اجرای کد هنگام پاک‌سازی با صفت Drop - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="اجرای-کد-هنگام-پاکسازی-با-ویژگی-drop"><a class="header" href="#اجرای-کد-هنگام-پاکسازی-با-ویژگی-drop">اجرای کد هنگام پاکسازی با ویژگی <code>Drop</code></a></h2>
<p>ویژگی دوم که برای الگوی اشاره‌گر (Pointer) هوشمند مهم است، <code>Drop</code> است که به شما امکان می‌دهد سفارشی کنید که وقتی یک مقدار
قرار است از دامنه خارج شود، چه اتفاقی بیفتد. می‌توانید یک پیاده‌سازی برای ویژگی <code>Drop</code> روی هر نوعی ارائه دهید و
این کد می‌تواند برای آزادسازی منابعی مانند فایل‌ها یا اتصالات شبکه استفاده شود.</p>
<p>ما ویژگی <code>Drop</code> را در زمینه اشاره‌گر (Pointer)های هوشمند معرفی می‌کنیم زیرا عملکرد ویژگی <code>Drop</code> تقریباً همیشه هنگام
پیاده‌سازی یک اشاره‌گر (Pointer) هوشمند استفاده می‌شود. برای مثال، وقتی یک <code>Box&lt;T&gt;</code> حذف می‌شود، فضای موجود روی پشته‌ای
که باکس به آن اشاره می‌کند، آزاد خواهد شد.</p>
<p>در برخی زبان‌ها، برای برخی نوع‌ها، برنامه‌نویس باید هر بار که استفاده از یک نمونه از آن نوع‌ها تمام می‌شود، کدی را برای آزادسازی حافظه یا منابع اجرا کند. نمونه‌هایی از این نوع شامل فایل هندل‌ها، سوکت‌ها و لاک‌ها هستند. اگر برنامه‌نویس این کار را فراموش کند، ممکن است سیستم دچار بار اضافی شده و از کار بیفتد. در Rust، می‌توانید مشخص کنید که قطعه کد خاصی هنگام خارج شدن یک مقدار از حوزه‌ی دید (scope) اجرا شود، و کامپایلر این کد را به‌صورت خودکار درج خواهد کرد. در نتیجه، نیازی نیست نگران این باشید که در تمام بخش‌های برنامه، کد پاک‌سازی (cleanup) را درج کنید؛ حتی با این وجود نیز دچار نشت منابع نخواهید شد!</p>
<p>شما کدی که باید هنگام خروج مقدار از دامنه اجرا شود را با پیاده‌سازی ویژگی <code>Drop</code> مشخص می‌کنید. ویژگی <code>Drop</code>
نیازمند این است که یک متد به نام <code>drop</code> را پیاده‌سازی کنید که یک مرجع متغیر به <code>self</code> می‌گیرد. برای دیدن زمانی
که Rust فراخوانی <code>drop</code> را انجام می‌دهد، بیایید <code>drop</code> را با جملات <code>println!</code> برای اکنون پیاده‌سازی کنیم.</p>
<p>لیستینگ 15-14 یک <code>struct</code> به‌نام <code>CustomSmartPointer</code> را نشان می‌دهد که تنها عملکرد سفارشی آن این است که هنگام خارج شدن نمونه از حوزه‌ی دید (scope)، پیام <code>Dropping CustomSmartPointer!</code> را چاپ می‌کند تا نشان دهد چه زمانی Rust متد <code>drop</code> را اجرا می‌کند.</p>
<figure class="listing" id="listing-15-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre></pre>
<figcaption><a href="#listing-15-14">Listing 15-14</a>: ساختار <code>CustomSmartPointer</code> که ویژگی <code>Drop</code> را پیاده‌سازی می‌کند و در آن کد پاکسازی خود را قرار می‌دهیم</figcaption>
</figure>
<p><code>trait</code> مربوط به <code>Drop</code> در prelude زبان Rust گنجانده شده است، بنابراین نیازی نیست آن را به‌طور جداگانه به حوزه‌ی دید (scope) وارد کنیم. ما <code>trait</code> <code>Drop</code> را برای <code>CustomSmartPointer</code> پیاده‌سازی کرده‌ایم و برای متد <code>drop</code> یک پیاده‌سازی ارائه داده‌ایم که در آن از <code>println!</code> استفاده می‌شود. بدنه‌ی متد <code>drop</code> جایی است که می‌توانید هر منطقی را که می‌خواهید هنگام خارج شدن یک نمونه از نوع‌تان از scope اجرا شود، قرار دهید. ما در این‌جا صرفاً با چاپ یک متن، به‌صورت بصری نشان می‌دهیم که Rust چه زمانی متد <code>drop</code> را فراخوانی می‌کند.</p>
<p>در تابع <code>main</code>، دو نمونه از <code>CustomSmartPointer</code> ایجاد می‌کنیم و سپس <code>CustomSmartPointers created</code> را چاپ
می‌کنیم. در پایان <code>main</code>، نمونه‌های ما از <code>CustomSmartPointer</code> از دامنه خارج خواهند شد و Rust کدی که در متد
<code>drop</code> قرار داده‌ایم را فراخوانی خواهد کرد و پیام نهایی ما را چاپ می‌کند. توجه کنید که نیازی به فراخوانی صریح متد
<code>drop</code> نداشتیم.</p>
<p>وقتی این برنامه را اجرا می‌کنیم، خروجی زیر را مشاهده خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust به صورت خودکار <code>drop</code> را برای ما فراخوانی کرد وقتی که نمونه‌های ما از دامنه خارج شدند و کدی که مشخص کرده بودیم
را اجرا کرد. متغیرها به ترتیب معکوس ایجادشان حذف می‌شوند، بنابراین <code>d</code> قبل از <code>c</code> حذف شد. هدف این مثال این است
که یک راهنمای بصری برای نحوه کارکرد متد <code>drop</code> به شما بدهد؛ معمولاً شما کد پاکسازی که نوع شما نیاز دارد را مشخص
می‌کنید نه یک پیام چاپ.</p>
<!-- Old link, do not remove -->
<p><a id="dropping-a-value-early-with-std-mem-drop"></a></p>
<p>متأسفانه غیرفعال‌کردن عملکرد خودکار <code>drop</code> کار ساده‌ای نیست. در اغلب موارد نیز نیازی به غیرفعال‌کردن آن نیست؛ تمام هدف <code>trait</code> مربوط به <code>Drop</code> این است که فرآیند پاک‌سازی به‌طور خودکار مدیریت شود. با این حال، گاهی ممکن است بخواهید یک مقدار را زودتر از زمان معمول پاک‌سازی کنید. یکی از نمونه‌ها زمانی است که از smart pointerهایی استفاده می‌کنید که قفل‌ها (locks) را مدیریت می‌کنند: ممکن است بخواهید متد <code>drop</code> که قفل را آزاد می‌کند را به‌صورت دستی فراخوانی کنید تا سایر کدهای همان scope بتوانند قفل را در اختیار بگیرند.
Rust اجازه نمی‌دهد متد <code>drop</code> مربوط به <code>trait</code> <code>Drop</code> را به‌صورت دستی فراخوانی کنید؛ در عوض، اگر می‌خواهید یک مقدار را قبل از پایان حوزه‌ی دیدش پاک‌سازی کنید، باید از تابع <code>std::mem::drop</code> که در کتابخانه‌ی استاندارد فراهم شده استفاده کنید.</p>
<p>اگر تلاش کنیم تا متد <code>drop</code> مربوط به <code>trait</code> <code>Drop</code> را به‌صورت دستی فراخوانی کنیم و تابع <code>main</code> موجود در لیستینگ 15-14 را تغییر دهیم، همان‌طور که در لیستینگ 15-15 نشان داده شده است، با خطای کامپایل مواجه خواهیم شد.</p>
<figure class="listing" id="listing-15-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre>
<figcaption><a href="#listing-15-15">Listing 15-15</a>: تلاش برای فراخوانی دستی متد <code>drop</code> از ویژگی <code>Drop</code> برای پاکسازی زودهنگام</figcaption>
</figure>
<p>وقتی سعی کنیم این کد را کامپایل کنیم، با این خطا مواجه می‌شویم:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>این پیام خطا نشان می‌دهد که ما اجازه نداریم به‌طور صریح <code>drop</code> را فراخوانی کنیم. پیام خطا از اصطلاح <em>تخریب‌گر</em>
(Destructor) استفاده می‌کند که اصطلاحی کلی برای تابعی است که یک نمونه را تمیز می‌کند. یک تخریب‌گر مشابه یک
<em>سازنده</em> (Constructor) است که یک نمونه را ایجاد می‌کند. تابع <code>drop</code> در Rust یک تخریب‌گر خاص است.</p>
<p>Rust به ما اجازه نمی‌دهد <code>drop</code> را به صورت صریح فراخوانی کنیم زیرا Rust به‌طور خودکار <code>drop</code> را در انتهای تابع
<code>main</code> فراخوانی می‌کند. این موضوع می‌تواند باعث خطای <em>آزادسازی دوگانه</em> شود زیرا Rust سعی می‌کند همان مقدار را دو بار
تمیز کند.</p>
<p>ما نمی‌توانیم قرار دادن خودکار <code>drop</code> را هنگام خروج یک مقدار از حوزه غیرفعال کنیم و همچنین نمی‌توانیم متد <code>drop</code>
را به صورت صریح فراخوانی کنیم. بنابراین، اگر نیاز به حذف زودهنگام یک مقدار داشته باشیم، باید از تابع <code>std::mem::drop</code>
استفاده کنیم.</p>
<p>تابع <code>std::mem::drop</code> با متد <code>drop</code> در <code>trait</code> <code>Drop</code> متفاوت است. این تابع را با ارسال مقداری که می‌خواهیم به‌صورت اجباری drop شود، فراخوانی می‌کنیم. این تابع در prelude قرار دارد، بنابراین می‌توانیم تابع <code>main</code> در لیستینگ 15-15 را تغییر دهیم تا به‌جای فراخوانی مستقیم متد <code>drop</code>، تابع <code>drop</code> را فراخوانی کند؛ همان‌طور که در لیستینگ 15-16 نشان داده شده است.</p>
<figure class="listing" id="listing-15-16">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre></pre>
<figcaption><a href="#listing-15-16">Listing 15-16</a>: فراخوانی <code>std::mem::drop</code> برای حذف صریح یک مقدار قبل از خروج آن از حوزه</figcaption>
</figure>
<p>اجرای این کد خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>متن <code>Dropping CustomSmartPointer with data 'some data'!</code> بین متون <code>CustomSmartPointer created.</code> و
<code>CustomSmartPointer dropped before the end of main.</code> چاپ می‌شود و نشان می‌دهد که کد متد <code>drop</code> برای حذف
<code>c</code> در آن نقطه فراخوانی شده است.</p>
<p>شما می‌توانید از کدی که در پیاده‌سازی ویژگی <code>Drop</code> مشخص کرده‌اید، به روش‌های مختلفی برای ساده و امن کردن عملیات
پاکسازی استفاده کنید: برای مثال، می‌توانید از آن برای ایجاد تخصیص‌دهنده حافظه خودتان استفاده کنید! با ویژگی <code>Drop</code> و
سیستم مالکیت Rust، نیازی به یادآوری پاکسازی ندارید، زیرا Rust این کار را به‌طور خودکار انجام می‌دهد.</p>
<p>همچنین نیازی به نگرانی در مورد مشکلات ناشی از پاکسازی اشتباهی مقادیری که هنوز در حال استفاده هستند، ندارید: سیستم مالکیت
که اطمینان می‌دهد ارجاعات همیشه معتبر هستند، همچنین تضمین می‌کند که <code>drop</code> فقط یک بار و زمانی که مقدار دیگر استفاده نمی‌شود،
فراخوانی شود.</p>
<p>اکنون که <code>Box&lt;T&gt;</code> و برخی از ویژگی‌های اشاره‌گر (Pointer)های هوشمند را بررسی کردیم، بیایید به چند اشاره‌گر (Pointer) هوشمند دیگر که در کتابخانه
استاندارد تعریف شده‌اند، نگاهی بیندازیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-02-deref.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-04-rc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-02-deref.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-04-rc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
