<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>کنترل جریان - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="کنترل-جریان"><a class="header" href="#کنترل-جریان">کنترل جریان</a></h2>
<p>توانایی اجرای کدی که وابسته به درست بودن یا نبودن یک شرط است و اجرای مکرر کدی در حالی که یک شرط درست است، از ساختارهای اساسی در بیشتر زبان‌های برنامه‌نویسی محسوب می‌شود. رایج‌ترین ساختارهایی که به شما امکان کنترل جریان اجرای کد در راست را می‌دهند، عبارتند از عبارات <code>if</code> و حلقه‌ها.</p>
<h3 id="عبارات-if"><a class="header" href="#عبارات-if">عبارات <code>if</code></a></h3>
<p>یک عبارت <code>if</code> به شما امکان می‌دهد کد خود را بسته به شرایطی شاخه‌بندی کنید. شما یک شرط مشخص می‌کنید و سپس می‌گویید: «اگر این شرط برقرار بود، این بلوک کد اجرا شود. اگر شرط برقرار نبود، این بلوک کد اجرا نشود.»</p>
<p>یک پروژه جدید به نام <em>branches</em> در دایرکتوری <em>projects</em> خود ایجاد کنید تا عبارت <code>if</code> را بررسی کنید. در فایل <em>src/main.rs</em> کد زیر را وارد کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}</code></pre></pre>
<p>تمام عبارات <code>if</code> با کلمه کلیدی <code>if</code> شروع می‌شوند و سپس یک شرط دنبال می‌شود. در این مثال، شرط بررسی می‌کند که آیا مقدار متغیر <code>number</code> کمتر از 5 است یا خیر. بلوک کدی که در صورت درست بودن شرط باید اجرا شود، بلافاصله بعد از شرط و داخل کروشه‌ها قرار می‌گیرد. بلوک‌های کدی که با شرایط در عبارات <code>if</code> مرتبط هستند، گاهی <em>بازو</em> (arm) نامیده می‌شوند، همانند بازوهای موجود در عبارات <code>match</code> که در بخش <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“مقایسه حدس با عدد مخفی”</a><!-- ignore --> از فصل 2 مورد بحث قرار گرفت.</p>
<p>به‌صورت اختیاری، می‌توانیم یک عبارت <code>else</code> نیز اضافه کنیم، همان‌طور که اینجا انتخاب کردیم، تا به برنامه یک بلوک کد جایگزین برای اجرا ارائه دهیم، در صورتی که شرط به <code>false</code> ارزیابی شود. اگر عبارت <code>else</code> ارائه ندهید و شرط <code>false</code> باشد، برنامه بلوک <code>if</code> را نادیده گرفته و به بخش بعدی کد می‌رود.</p>
<p>این کد را اجرا کنید؛ باید خروجی زیر را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>بیایید مقدار <code>number</code> را به مقداری تغییر دهیم که شرط <code>false</code> شود تا ببینیم چه اتفاقی می‌افتد:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("condition was true");
</span><span class="boring">    } else {
</span><span class="boring">        println!("condition was false");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>برنامه را دوباره اجرا کنید و خروجی را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>همچنین قابل توجه است که شرط در این کد <em>باید</em> یک <code>bool</code> باشد. اگر شرط یک <code>bool</code> نباشد، خطا دریافت خواهیم کرد. به عنوان مثال، این کد را اجرا کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}</code></pre>
<p>این بار شرط <code>if</code> به مقدار <code>3</code> ارزیابی می‌شود و راست خطا می‌دهد:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>خطا نشان می‌دهد که راست انتظار یک <code>bool</code> داشت اما یک عدد صحیح دریافت کرد. برخلاف زبان‌هایی مانند Ruby و JavaScript، راست به‌صورت خودکار تلاش نمی‌کند انواع غیر <code>bool</code> را به یک <code>bool</code> تبدیل کند. شما باید صریح باشید و همیشه یک <code>bool</code> را به‌عنوان شرط به <code>if</code> بدهید. اگر می‌خواهید بلوک کد <code>if</code> فقط زمانی اجرا شود که یک عدد برابر <code>0</code> نباشد، می‌توانید عبارت <code>if</code> را به این صورت تغییر دهید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}</code></pre></pre>
<p>اجرای این کد <code>number was something other than zero</code> را چاپ خواهد کرد.</p>
<h4 id="مدیریت-شرایط-متعدد-با-else-if"><a class="header" href="#مدیریت-شرایط-متعدد-با-else-if">مدیریت شرایط متعدد با <code>else if</code></a></h4>
<p>شما می‌توانید با ترکیب <code>if</code> و <code>else</code> در یک عبارت <code>else if</code>، شرایط متعددی را مدیریت کنید. به عنوان مثال:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<p>این برنامه چهار مسیر ممکن برای اجرا دارد. پس از اجرای آن، باید خروجی زیر را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>هنگامی که این برنامه اجرا می‌شود، هر عبارت <code>if</code> را به ترتیب بررسی کرده و اولین بلوکی که شرط آن به <code>true</code> ارزیابی شود، اجرا می‌کند. توجه داشته باشید که حتی با وجود اینکه 6 بر 2 بخش‌پذیر است، خروجی <code>number is divisible by 2</code> را نمی‌بینیم و همچنین متن <code>number is not divisible by 4, 3, or 2</code> از بلوک <code>else</code> را نیز نمی‌بینیم. این به این دلیل است که راست فقط بلوک مربوط به اولین شرط درست را اجرا می‌کند و پس از یافتن آن، بقیه را بررسی نمی‌کند.</p>
<p>استفاده از تعداد زیادی عبارت <code>else if</code> می‌تواند کد شما را شلوغ کند، بنابراین اگر بیش از یک مورد دارید، ممکن است بخواهید کد خود را بازنویسی کنید. فصل 6 یک ساختار شاخه‌بندی قدرتمند در راست به نام <code>match</code> را برای این موارد توضیح می‌دهد.</p>
<h4 id="استفاده-از-if-در-یک-عبارت-let"><a class="header" href="#استفاده-از-if-در-یک-عبارت-let">استفاده از <code>if</code> در یک عبارت <code>let</code></a></h4>
<p>از آنجایی که <code>if</code> یک عبارت است، می‌توانیم از آن در سمت راست یک عبارت <code>let</code> برای تخصیص نتیجه به یک متغیر استفاده کنیم، همان‌طور که در لیست 3-2 نشان داده شده است.</p>
<figure class="listing" id="listing-3-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}</code></pre></pre>
<figcaption><a href="#listing-3-2">Listing 3-2</a>: تخصیص نتیجه یک عبارت <code>if</code> به یک متغیر</figcaption>
</figure>
<p>متغیر <code>number</code> به مقداری بر اساس نتیجه عبارت <code>if</code> متصل خواهد شد. این کد را اجرا کنید تا ببینید چه اتفاقی می‌افتد:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>به خاطر داشته باشید که بلوک‌های کد به آخرین عبارت در آن‌ها ارزیابی می‌شوند و اعداد به تنهایی نیز عبارات محسوب می‌شوند. در این حالت، مقدار کل عبارت <code>if</code> بستگی به این دارد که کدام بلوک کد اجرا شود. این بدان معناست که مقادیری که می‌توانند نتایج هر بازوی <code>if</code> باشند، باید از یک نوع باشند. در لیست 3-2، نتایج بازوی <code>if</code> و بازوی <code>else</code> هر دو اعداد صحیح <code>i32</code> بودند. اگر انواع ناسازگار باشند، مانند مثال زیر، خطایی دریافت خواهیم کرد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}</code></pre>
<p>هنگامی که تلاش می‌کنیم این کد را کامپایل کنیم، خطایی دریافت می‌کنیم. بازوهای <code>if</code> و <code>else</code> دارای انواع مقداری ناسازگار هستند و راست دقیقاً نشان می‌دهد که مشکل در برنامه کجاست:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>عبارت موجود در بلوک <code>if</code> به یک عدد صحیح ارزیابی می‌شود و عبارت موجود در بلوک <code>else</code> به یک رشته ارزیابی می‌شود. این کار نمی‌کند زیرا متغیرها باید یک نوع مشخص داشته باشند و راست باید در زمان کامپایل بداند که نوع متغیر <code>number</code> چیست. دانستن نوع <code>number</code> به کامپایلر این امکان را می‌دهد که بررسی کند نوع آن در هر جایی که از <code>number</code> استفاده می‌کنیم معتبر است. راست نمی‌توانست این کار را انجام دهد اگر نوع <code>number</code> تنها در زمان اجرا مشخص می‌شد. کامپایلر پیچیده‌تر می‌شد و تضمین‌های کمتری درباره کد ارائه می‌داد اگر مجبور بود انواع فرضی مختلفی را برای هر متغیر پیگیری کند.</p>
<h3 id="تکرار-با-حلقهها"><a class="header" href="#تکرار-با-حلقهها">تکرار با حلقه‌ها</a></h3>
<p>اغلب مفید است که یک بلوک کد بیش از یک بار اجرا شود. برای این کار، Rust چندین <em>حلقه</em> ارائه می‌دهد که کد داخل بدنه حلقه را اجرا کرده و سپس بلافاصله به ابتدای حلقه بازمی‌گردند. برای آزمایش با حلقه‌ها، یک پروژه جدید به نام <em>loops</em> ایجاد کنید.</p>
<p>Rust سه نوع حلقه دارد: <code>loop</code>، <code>while</code> و <code>for</code>. بیایید هر کدام را امتحان کنیم.</p>
<h4 id="تکرار-کد-با-loop"><a class="header" href="#تکرار-کد-با-loop">تکرار کد با <code>loop</code></a></h4>
<p>کلمه کلیدی <code>loop</code> به Rust می‌گوید که یک بلوک کد را بارها و بارها اجرا کند، تا زمانی که شما به طور صریح به آن بگویید متوقف شود.</p>
<p>به عنوان مثال، فایل <em>src/main.rs</em> را در دایرکتوری <em>loops</em> خود به شکل زیر تغییر دهید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("again!");
    }
}</code></pre>
<p>وقتی این برنامه را اجرا کنیم، <code>again!</code> بارها و بارها به طور مداوم چاپ می‌شود تا زمانی که برنامه را به صورت دستی متوقف کنیم. اکثر ترمینال‌ها از میانبر صفحه کلید <kbd>ctrl</kbd>-<kbd>c</kbd> برای متوقف کردن برنامه‌ای که در یک حلقه بی‌پایان گیر کرده است، پشتیبانی می‌کنند. آن را امتحان کنید:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>نماد <code>^C</code> نشان‌دهنده جایی است که کلیدهای <kbd>ctrl</kbd>-<kbd>c</kbd>
را فشار داده‌اید.</p>
<p>ممکن است پس از <code>^C</code> کلمه‌ی <code>again!</code> چاپ شود یا نشود،
بسته به این که کد در کدام قسمت از حلقه هنگام دریافت سیگنال
قطع اجرا قرار داشته باشد.</p>
<p>خوشبختانه، Rust همچنین روشی برای خروج از یک حلقه با استفاده از کد ارائه می‌دهد. شما می‌توانید کلمه کلیدی <code>break</code> را درون حلقه قرار دهید تا به برنامه بگویید که چه زمانی اجرای حلقه را متوقف کند. به یاد داشته باشید که این کار را در بازی حدس عدد در بخش <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“خروج پس از یک حدس درست”</a><!-- ignore --> در فصل 2 انجام دادیم تا زمانی که کاربر با حدس درست بازی را برنده شد، برنامه خاتمه یابد.</p>
<p>ما همچنین از <code>continue</code> در بازی حدس عدد استفاده کردیم که در یک حلقه به برنامه می‌گوید هر کد باقی‌مانده در این تکرار حلقه را نادیده بگیرد و به تکرار بعدی برود.</p>
<h4 id="بازگرداندن-مقادیر-از-حلقهها"><a class="header" href="#بازگرداندن-مقادیر-از-حلقهها">بازگرداندن مقادیر از حلقه‌ها</a></h4>
<p>یکی از کاربردهای <code>loop</code> این است که یک عملیات را که ممکن است شکست بخورد دوباره امتحان کنید، مثلاً بررسی کنید که آیا یک نخ (thread) کار خود را تمام کرده است یا نه. همچنین ممکن است نیاز داشته باشید نتیجه این عملیات را از حلقه به بقیه کد خود منتقل کنید. برای انجام این کار، می‌توانید مقداری که می‌خواهید برگردانده شود را پس از عبارت <code>break</code> اضافه کنید. این مقدار از حلقه بازگردانده می‌شود تا بتوانید از آن استفاده کنید، همان‌طور که در اینجا نشان داده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}</code></pre></pre>
<p>قبل از حلقه، یک متغیر به نام <code>counter</code> اعلام می‌کنیم و مقدار آن را <code>0</code> مقداردهی اولیه می‌کنیم. سپس یک متغیر به نام <code>result</code> اعلام می‌کنیم تا مقدار بازگشتی از حلقه را نگه دارد. در هر تکرار حلقه، مقدار <code>1</code> را به متغیر <code>counter</code> اضافه می‌کنیم و سپس بررسی می‌کنیم که آیا مقدار <code>counter</code> برابر با <code>10</code> است یا نه. زمانی که این شرط برقرار باشد، از کلمه کلیدی <code>break</code> با مقدار <code>counter * 2</code> استفاده می‌کنیم. پس از حلقه، با استفاده از یک سمی‌کالن، مقدار به <code>result</code> تخصیص داده می‌شود. در نهایت، مقدار <code>result</code> را چاپ می‌کنیم که در این مثال برابر با <code>20</code> است.</p>
<p>شما همچنین می‌توانید از داخل یک حلقه <code>return</code> استفاده کنید. در حالی که <code>break</code> فقط از حلقه جاری خارج می‌شود، <code>return</code> همیشه از تابع جاری خارج می‌شود.</p>
<h4 id="برچسب-حلقهها-برای-رفع-ابهام-بین-چندین-حلقه"><a class="header" href="#برچسب-حلقهها-برای-رفع-ابهام-بین-چندین-حلقه">برچسب حلقه‌ها برای رفع ابهام بین چندین حلقه</a></h4>
<p>اگر حلقه‌هایی تو در تو داشته باشید، <code>break</code> و <code>continue</code> به حلقه داخلی‌ترین حلقه در آن نقطه اعمال می‌شوند. به طور اختیاری می‌توانید یک <em>برچسب حلقه</em> روی یک حلقه مشخص کنید که سپس می‌توانید از آن برچسب با <code>break</code> یا <code>continue</code> استفاده کنید تا مشخص کنید که این کلمات کلیدی به حلقه برچسب‌دار اعمال می‌شوند نه حلقه داخلی‌ترین. برچسب‌های حلقه باید با یک آپاستروف شروع شوند. در اینجا یک مثال با دو حلقه تو در تو آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}</code></pre></pre>
<p>حلقه بیرونی دارای برچسب <code>'counting_up</code> است و از 0 تا 2 شمارش می‌کند. حلقه داخلی بدون برچسب از 10 تا 9 شمارش معکوس می‌کند. اولین <code>break</code> که برچسبی مشخص نمی‌کند فقط از حلقه داخلی خارج می‌شود. عبارت <code>break 'counting_up;</code> از حلقه بیرونی خارج می‌شود. این کد موارد زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="حلقههای-شرطی-با-while"><a class="header" href="#حلقههای-شرطی-با-while">حلقه‌های شرطی با <code>while</code></a></h4>
<p>یک برنامه اغلب نیاز دارد که یک شرط را درون یک حلقه ارزیابی کند. تا زمانی که شرط <code>true</code> باشد، حلقه اجرا می‌شود. زمانی که شرط دیگر <code>true</code> نباشد، برنامه با فراخوانی <code>break</code>، حلقه را متوقف می‌کند. امکان پیاده‌سازی چنین رفتاری با استفاده از ترکیب <code>loop</code>، <code>if</code>، <code>else</code> و <code>break</code> وجود دارد. می‌توانید این را اکنون در یک برنامه امتحان کنید، اگر مایل هستید. با این حال، این الگو آن‌قدر رایج است که Rust یک سازه زبان داخلی برای آن دارد که به آن حلقه <code>while</code> گفته می‌شود. در Listing 3-3، از <code>while</code> برای اجرای برنامه سه بار، شمارش معکوس در هر بار، و سپس چاپ یک پیام و خروج از حلقه استفاده می‌کنیم.</p>
<figure class="listing" id="listing-3-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}</code></pre></pre>
<figcaption><a href="#listing-3-3">Listing 3-3</a>: استفاده از حلقه‌ی <code>while</code> برای اجرای کد تا زمانی که شرط مقدار <code>true</code> داشته باشد</figcaption>
</figure>
<p>این سازه مقدار زیادی از تو در تویی که در صورت استفاده از <code>loop</code>، <code>if</code>، <code>else</code> و <code>break</code> لازم بود را حذف می‌کند و واضح‌تر است. تا زمانی که یک شرط به مقدار <code>true</code> ارزیابی شود، کد اجرا می‌شود؛ در غیر این صورت، حلقه متوقف می‌شود.</p>
<h4 id="تکرار-از-طریق-یک-مجموعه-با-for"><a class="header" href="#تکرار-از-طریق-یک-مجموعه-با-for">تکرار از طریق یک مجموعه با <code>for</code></a></h4>
<p>می‌توانید از ساختار <code>while</code> برای تکرار روی عناصر
یک مجموعه، مانند آرایه، استفاده کنید. به‌عنوان مثال،
حلقه‌ی موجود در فهرست 3-4، هر عنصر موجود در آرایه
<code>a</code> را چاپ می‌کند.</p>
<figure class="listing" id="listing-3-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
<figcaption><a href="#listing-3-4">Listing 3-4</a>: تکرار در هر عنصر یک مجموعه با استفاده از حلقه <code>while</code></figcaption>
</figure>
<p>در اینجا، کد از طریق عناصر آرایه شمارش می‌کند. از اندیس (index)<code>0</code> شروع می‌کند و سپس تا زمانی که به آخرین اندیس (index)در آرایه برسد (یعنی وقتی که <code>index &lt; 5</code> دیگر <code>true</code> نباشد) حلقه می‌زند. اجرای این کد هر عنصر در آرایه را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>همه پنج مقدار آرایه همانطور که انتظار می‌رود در ترمینال ظاهر می‌شوند. حتی اگر <code>index</code> در نهایت به مقدار <code>5</code> برسد، حلقه قبل از تلاش برای گرفتن مقدار ششم از آرایه متوقف می‌شود.</p>
<p>با این حال، این روش مستعد خطاست؛ ما می‌توانیم باعث شویم برنامه در صورت اشتباه بودن مقدار اندیس (index)یا شرط آزمایشی متوقف شود. به عنوان مثال، اگر تعریف آرایه <code>a</code> را به چهار عنصر تغییر دهید اما فراموش کنید شرط را به <code>while index &lt; 4</code> به‌روزرسانی کنید، کد متوقف خواهد شد. همچنین این روش کند است، زیرا کامپایلر کد زمان اجرا را برای انجام بررسی شرطی در مورد اینکه آیا اندیس (index)در محدوده آرایه است یا نه در هر تکرار حلقه اضافه می‌کند.</p>
<p>به عنوان یک جایگزین مختصرتر، می‌توانید از حلقه <code>for</code> استفاده کنید و برای هر مورد در یک مجموعه، کدی اجرا کنید. یک حلقه <code>for</code> شبیه کدی در Listing 3-5 است.</p>
<figure class="listing" id="listing-3-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}</code></pre></pre>
<figcaption><a href="#listing-3-5">Listing 3-5</a>: تکرار در هر عنصر یک مجموعه با استفاده از حلقه <code>for</code></figcaption>
</figure>
<p>وقتی این کد را اجرا کنیم، خروجی مشابه فهرست 3-4
را خواهیم دید. مهم‌تر اینکه، اکنون ایمنی کد افزایش
یافته و احتمال بروز خطاهایی که ممکن است از دسترسی
فراتر از انتهای آرایه یا عدم پیمایش کامل عناصر
نشأت بگیرند، حذف شده است. همچنین، کد ماشینی که
از حلقه‌های <code>for</code> تولید می‌شود می‌تواند کارآمدتر
باشد، زیرا در هر تکرار نیازی به مقایسه‌ی اندیس با
طول آرایه نیست.</p>
<p>با استفاده از حلقه <code>for</code>، نیازی به به خاطر سپردن تغییر کد دیگری ندارید اگر تعداد مقادیر در آرایه را تغییر دهید، همانطور که با روش استفاده شده در Listing 3-4 باید انجام می‌دادید.</p>
<p>ایمنی و مختصر بودن حلقه‌های <code>for</code> آنها را به رایج‌ترین سازه حلقه‌ای در Rust تبدیل کرده است. حتی در موقعیت‌هایی که می‌خواهید کدی را تعداد مشخصی از دفعات اجرا کنید، مانند مثال شمارش معکوس که از حلقه <code>while</code> در Listing 3-3 استفاده می‌کرد، اکثر برنامه‌نویسان Rust از حلقه <code>for</code> استفاده می‌کنند. روش انجام این کار استفاده از <code>Range</code>، که توسط کتابخانه استاندارد ارائه می‌شود، است که تمام اعداد را به ترتیب از یک عدد شروع کرده و قبل از عدد دیگری به پایان می‌رساند.</p>
<p>این چیزی است که شمارش معکوس با استفاده از یک حلقه <code>for</code> و روش دیگری که هنوز در مورد آن صحبت نکرده‌ایم، یعنی <code>rev</code> برای معکوس کردن محدوده، به نظر می‌رسد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}</code></pre></pre>
<p>این کد کمی بهتر نیست؟</p>
<h2 id="خلاصه"><a class="header" href="#خلاصه">خلاصه</a></h2>
<p>شما موفق شدید! این یک فصل بزرگ بود: شما درباره متغیرها، انواع داده اسکالر و مرکب، توابع، نظرات، عبارات <code>if</code> و حلقه‌ها یاد گرفتید! برای تمرین با مفاهیم مطرح‌شده در این فصل، سعی کنید برنامه‌هایی برای انجام موارد زیر بسازید:</p>
<ul>
<li>تبدیل دما بین فارنهایت و سلسیوس.</li>
<li>تولید عدد <em>n</em>ام دنباله فیبوناچی.</li>
<li>چاپ متن سرود کریسمس “The Twelve Days of Christmas”، با استفاده از تکرار موجود در این آهنگ.</li>
</ul>
<p>وقتی آماده شدید تا به مرحله بعد بروید، ما درباره مفهومی در Rust صحبت خواهیم کرد که <em>معمولاً</em> در زبان‌های برنامه‌نویسی دیگر وجود ندارد: مالکیت.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
