<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures و نحو Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html" class="active"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="futures-و-سینتکس-async"><a class="header" href="#futures-و-سینتکس-async">Futures و سینتکس Async</a></h2>
<p>عناصر کلیدی برنامه‌نویسی ناهمگام (asynchronous) در راست عبارت‌اند از <em>آینده‌ها</em>
(Futures) و کلمات کلیدی <code>async</code> و <code>await</code> راست.</p>
<p>یک <em>آینده</em> مقداری است که ممکن است اکنون آماده نباشد، اما در مقطعی در آینده آماده
خواهد شد. (این مفهوم در بسیاری از زبان‌ها وجود دارد، گاهی با نام‌های دیگر مانند
“task” یا “promise”.) راست یک ویژگی (trait) به نام <code>Future</code> ارائه می‌دهد که به‌عنوان
یک سازه پایه عمل می‌کند تا عملیات‌های ناهمگام مختلف بتوانند با ساختارهای داده
مختلف پیاده‌سازی شوند، اما با یک رابط مشترک. در راست، می‌گوییم نوع‌هایی که
ویژگی <code>Future</code> را پیاده‌سازی می‌کنند آینده‌ها هستند. هر نوعی که <code>Future</code> را
پیاده‌سازی می‌کند، اطلاعات خود را درباره پیشرفتی که انجام شده و اینکه “آماده”
به چه معناست نگه می‌دارد.</p>
<p>کلمه کلیدی <code>async</code> می‌تواند به بلوک‌ها و توابع اعمال شود تا مشخص کند که آن‌ها می‌توانند
متوقف و از سر گرفته شوند. درون یک بلوک یا تابع async، می‌توانید از کلمه کلیدی
<code>await</code> برای منتظر ماندن تا یک آینده آماده شود استفاده کنید، که <em>منتظر ماندن یک
آینده</em> (awaiting a future) نامیده می‌شود. هر جایی که شما منتظر یک آینده درون یک
بلوک یا تابع async می‌مانید، جایی است که آن بلوک یا تابع ممکن است متوقف و از سر
گرفته شود. فرآیند بررسی اینکه آیا مقدار یک آینده هنوز آماده است یا نه، <em>پول کردن</em>
(polling) نامیده می‌شود.</p>
<p>برخی از زبان‌های دیگر نیز از کلمات کلیدی <code>async</code> و <code>await</code> برای برنامه‌نویسی
ناهمگام استفاده می‌کنند. اگر با آن زبان‌ها آشنا هستید، ممکن است متوجه تفاوت‌های
قابل توجهی در نحوه عملکرد راست، از جمله نحوه مدیریت سینتکس، شوید. این تفاوت‌ها
به دلایل خوبی وجود دارند، همانطور که خواهیم دید!</p>
<p>اغلب اوقات هنگام نوشتن برنامه ناهمگام در راست، از کلمات کلیدی <code>async</code> و <code>await</code>
استفاده می‌کنیم. راست آن‌ها را به کد معادل با استفاده از ویژگی <code>Future</code> کامپایل
می‌کند، همانطور که حلقه‌های <code>for</code> را به کد معادل با استفاده از ویژگی <code>Iterator</code>
کامپایل می‌کند. با این حال، از آنجا که راست ویژگی <code>Future</code> را ارائه می‌دهد،
می‌توانید آن را برای نوع‌های داده خود نیز زمانی که نیاز دارید پیاده‌سازی کنید.
بسیاری از توابعی که در طول این فصل خواهیم دید نوع‌هایی با پیاده‌سازی‌های
خودشان از <code>Future</code> بازمی‌گردانند. ما در انتهای فصل به تعریف ویژگی برمی‌گردیم
و جزئیات بیشتری درباره نحوه عملکرد آن بررسی می‌کنیم، اما این توضیحات برای ادامه
پیشرفت کافی است.</p>
<p>این توضیحات ممکن است کمی انتزاعی به نظر برسند. بیایید اولین برنامه ناهمگام خود
را بنویسیم: یک اسکرپر وب کوچک. ما دو URL از خط فرمان می‌گیریم، هر دو را
هم‌زمان واکشی می‌کنیم و نتیجه‌ای که زودتر تمام می‌شود را بازمی‌گردانیم. این مثال
مقداری سینتکس جدید خواهد داشت، اما نگران نباشید. ما هر چیزی که باید بدانید را
در طول مسیر توضیح خواهیم داد.</p>
<h3 id="اولین-برنامه-ناهمگام-ما"><a class="header" href="#اولین-برنامه-ناهمگام-ما">اولین برنامه ناهمگام ما</a></h3>
<p>برای تمرکز این فصل بر یادگیری async به جای جابه‌جایی بین قسمت‌های اکوسیستم، ما
crate‌ای به نام <code>trpl</code> ایجاد کرده‌ایم (<code>trpl</code> مخفف “The Rust Programming Language”).
این crate تمام نوع‌ها، ویژگی‌ها و توابعی که نیاز دارید، عمدتاً از crate‌های
<a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore --> و <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore --> را دوباره
صادر می‌کند.</p>
<ul>
<li>
<p>crate <code>futures</code> خانه رسمی آزمایش راست برای کد async است و در واقع جایی است
که نوع <code>Future</code> در ابتدا طراحی شده است.</p>
</li>
<li>
<p>Tokio امروزه پراستفاده‌ترین runtime async در راست است، به خصوص (اما نه فقط!)
برای برنامه‌های وب. runtime‌های عالی دیگری نیز وجود دارند و ممکن است برای
اهداف شما مناسب‌تر باشند. ما از Tokio برای زیرساخت <code>trpl</code> استفاده می‌کنیم زیرا
به خوبی تست شده و پراستفاده است.</p>
</li>
</ul>
<p>در برخی موارد، <code>trpl</code> API‌های اصلی را تغییر نام داده یا درون‌پوشانی (wrap)
می‌کند تا ما بتوانیم بر جزئیات مربوط به این فصل تمرکز کنیم. اگر می‌خواهید
بفهمید این crate چه کاری انجام می‌دهد، ما شما را به مشاهده <a href="https://github.com/persian-rust/book/tree/main/packages/trpl">سورس کد آن</a><!-- ignore -->
تشویق می‌کنیم. شما می‌توانید ببینید هر دوباره صادرات از کدام crate می‌آید، و ما
نظرات گسترده‌ای برای توضیح اینکه این crate چه می‌کند گذاشته‌ایم.</p>
<p>یک پروژه باینری جدید به نام <code>hello-async</code> ایجاد کنید و crate <code>trpl</code> را به‌عنوان
یک وابستگی اضافه کنید:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>اکنون می‌توانیم از قطعات مختلفی که توسط <code>trpl</code> ارائه شده‌اند برای نوشتن اولین برنامه
ناهمگام خود استفاده کنیم. ما یک ابزار خط فرمان کوچک ایجاد خواهیم کرد که دو صفحه
وب را واکشی می‌کند، عنصر <code>&lt;title&gt;</code> را از هرکدام استخراج می‌کند و عنوان صفحه‌ای را
چاپ می‌کند که زودتر تمام شده است.</p>
<p>بیایید با نوشتن تابعی شروع کنیم که یک URL صفحه را به‌عنوان پارامتر می‌گیرد،
درخواستی به آن ارسال می‌کند و متن عنصر عنوان (title) را بازمی‌گرداند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
<figcaption>Listing 17-1: تعریف یک تابع ناهمگام برای دریافت عنصر عنوان از یک صفحه HTML</figcaption>
</figure>
<p>در فهرست 17-1، ما تابعی به نام <code>page_title</code> تعریف می‌کنیم و آن را با کلمه کلیدی
<code>async</code> علامت‌گذاری می‌کنیم. سپس از تابع <code>trpl::get</code> برای واکشی URL ارسال‌شده
استفاده می‌کنیم و با استفاده از کلمه کلیدی <code>await</code> منتظر پاسخ می‌مانیم. سپس متن
پاسخ را با فراخوانی متد <code>text</code> دریافت می‌کنیم و باز هم با کلمه کلیدی <code>await</code>
منتظر آن می‌مانیم. هر دو این مراحل ناهمگام هستند. برای <code>get</code>، باید منتظر بمانیم
تا سرور قسمت اول پاسخ خود، شامل هدرهای HTTP، کوکی‌ها و غیره را ارسال کند. آن قسمت
از پاسخ می‌تواند جدا از بدنه درخواست ارسال شود. به خصوص اگر بدنه بسیار بزرگ باشد،
ممکن است مدتی طول بکشد تا همه آن برسد. بنابراین، باید منتظر <em>تمامیت</em> پاسخ بمانیم،
بنابراین متد <code>text</code> نیز async است.</p>
<p>باید به‌صراحت منتظر هر دو این آینده‌ها باشیم، زیرا آینده‌ها در راست <em>تنبل</em> (lazy)
هستند: آن‌ها کاری انجام نمی‌دهند مگر اینکه با <code>await</code> از آن‌ها بخواهید. (در واقع،
راست اگر از یک آینده استفاده نکنید، یک هشدار کامپایلر نمایش می‌دهد.) این باید
شما را به یاد بحث ما درباره iteratorها <a href="ch13-02-iterators.html">در فصل 13</a><!-- ignore -->
بیندازد. iteratorها کاری انجام نمی‌دهند مگر اینکه متد <code>next</code> آن‌ها را—به‌طور
مستقیم یا با استفاده از حلقه‌های <code>for</code> یا متدهایی مانند <code>map</code> که از <code>next</code> در
پشت‌صحنه استفاده می‌کنند—فراخوانی کنید. با آینده‌ها، همان ایده اصلی اعمال می‌شود:
آن‌ها کاری انجام نمی‌دهند مگر اینکه صریحاً از آن‌ها بخواهید. این تنبلی به راست
اجازه می‌دهد تا از اجرای کد async تا زمانی که واقعاً مورد نیاز است اجتناب کند.</p>
<blockquote>
<p>نکته: این رفتار با چیزی که هنگام استفاده از <code>thread::spawn</code> در فصل قبلی دیدیم
متفاوت است، جایی که closure‌ای که به نخ دیگر ارسال می‌کردیم بلافاصله شروع به
اجرا می‌کرد. همچنین با نحوه بسیاری از زبان‌های دیگر در برخورد با async متفاوت
است! اما این برای راست مهم است. در ادامه خواهیم دید چرا.</p>
</blockquote>
<p>وقتی <code>response_text</code> را دریافت کردیم، می‌توانیم آن را به یک نمونه از نوع <code>Html</code>
با استفاده از <code>Html::parse</code> تجزیه کنیم. به جای یک رشته خام، اکنون یک نوع داده
داریم که می‌توانیم از آن برای کار با HTML به‌عنوان یک ساختار داده غنی‌تر استفاده
کنیم. به طور خاص، می‌توانیم از متد <code>select_first</code> برای یافتن اولین نمونه از یک
CSS selector داده‌شده استفاده کنیم. با ارسال رشته <code>"title"</code>، اولین عنصر <code>&lt;title&gt;</code>
در سند را دریافت می‌کنیم، اگر وجود داشته باشد. زیرا ممکن است هیچ عنصری مطابقت
نداشته باشد، <code>select_first</code> یک <code>Option&lt;ElementRef&gt;</code> بازمی‌گرداند. در نهایت،
از متد <code>Option::map</code> استفاده می‌کنیم که به ما اجازه می‌دهد اگر آیتمی در
<code>Option</code> موجود است با آن کار کنیم، و اگر موجود نیست هیچ کاری انجام ندهیم.
(ما همچنین می‌توانستیم از یک عبارت <code>match</code> در اینجا استفاده کنیم، اما <code>map</code>
بیشتر idiomatic است.) در بدنه تابعی که به <code>map</code> ارائه می‌دهیم، متد <code>inner_html</code>
را روی <code>title_element</code> فراخوانی می‌کنیم تا محتوای آن را که یک <code>String</code> است،
دریافت کنیم. وقتی همه چیز تمام شد، یک <code>Option&lt;String&gt;</code> خواهیم داشت.</p>
<p>توجه داشته باشید که کلمه کلیدی <code>await</code> راست بعد از عبارت مورد انتظار می‌آید،
نه قبل از آن. به عبارت دیگر، این یک <em>کلمه کلیدی پسوندی</em> است. این ممکن است
با چیزی که ممکن است به آن عادت کرده باشید اگر از async در زبان‌های دیگر
استفاده کرده‌اید متفاوت باشد. راست این را انتخاب کرده است زیرا کار کردن با
زنجیره‌های متد را بسیار راحت‌تر می‌کند. در نتیجه، می‌توانیم بدنه <code>page_url_for</code>
را تغییر دهیم تا فراخوانی‌های توابع <code>trpl::get</code> و <code>text</code> را با <code>await</code> بین آن‌ها
زنجیره کنیم، همانطور که در فهرست 17-2 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-2: زنجیره کردن با کلمه کلیدی <code>await</code></figcaption>
</figure>
<p>با این، ما اولین تابع async خود را با موفقیت نوشتیم! قبل از اینکه کدی به <code>main</code>
اضافه کنیم تا آن را فراخوانی کنیم، بیایید کمی بیشتر درباره چیزی که نوشتیم و معنای
آن صحبت کنیم.</p>
<p>وقتی راست یک بلوک را که با کلمه کلیدی <code>async</code> علامت‌گذاری شده است می‌بیند، آن را به یک نوع داده منحصربه‌فرد و ناشناس کامپایل می‌کند که ویژگی <code>Future</code> را پیاده‌سازی می‌کند. وقتی راست یک تابع را که با <code>async</code> علامت‌گذاری شده است می‌بیند، آن را به یک تابع غیرناهمگام کامپایل می‌کند که بدنه آن یک بلوک async است. نوع بازگشتی یک تابع async نوع داده ناشناس ایجادشده برای آن بلوک async است.</p>
<p>بنابراین، نوشتن <code>async fn</code> معادل نوشتن یک تابع است که یک <em>آینده</em> (future) از نوع بازگشتی ارائه می‌دهد. وقتی کامپایلر یک تعریف تابع مانند <code>async fn page_title</code> را در فهرست 17-1 می‌بیند، معادل یک تابع غیرناهمگام تعریف‌شده مانند این است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>بیایید هر قسمت از نسخه تبدیل‌شده را مرور کنیم:</p>
<ul>
<li>از سینتکس <code>impl Trait</code> استفاده می‌کند که در بخش <a href="ch10-02-traits.html#traits-as-parameters">«Traits به‌عنوان پارامتر»</a><!-- ignore --> در فصل 10 درباره آن بحث کردیم.</li>
<li>ویژگی بازگشتی یک <code>Future</code> با نوع مرتبط <code>Output</code> است. توجه کنید که نوع <code>Output</code>، <code>Option&lt;String&gt;</code> است که همان نوع بازگشتی نسخه اصلی تابع <code>async fn</code> <code>page_title</code> است.</li>
<li>تمام کدی که در بدنه تابع اصلی فراخوانی شده است، در یک بلوک <code>async move</code> قرار داده شده است. به یاد داشته باشید که بلوک‌ها عبارت (expression) هستند. این بلوک کامل عبارت بازگشتی از تابع است.</li>
<li>این بلوک async مقداری با نوع <code>Option&lt;String&gt;</code> تولید می‌کند، همانطور که در بالا توضیح داده شد. آن مقدار با نوع <code>Output</code> در نوع بازگشتی مطابقت دارد. این درست مانند بلوک‌های دیگری است که قبلاً دیده‌اید.</li>
<li>بدنه جدید تابع یک بلوک <code>async move</code> است به دلیل نحوه استفاده آن از پارامتر <code>url</code>. (بعداً در فصل درباره <code>async</code> و <code>async move</code> بیشتر صحبت خواهیم کرد.)</li>
<li>نسخه جدید تابع نوعی از طول عمر (lifetime) دارد که قبلاً در نوع بازگشتی ندیده‌ایم: <code>'_</code>. زیرا تابع یک <code>Future</code> بازمی‌گرداند که به یک ارجاع اشاره می‌کند—در اینجا، ارجاع از پارامتر <code>url</code>—باید به راست بگوییم که منظور ما این است که آن ارجاع در نظر گرفته شود. نیازی به نام‌گذاری طول عمر در اینجا نیست، زیرا راست به اندازه کافی هوشمند است که بداند تنها یک ارجاع می‌تواند درگیر باشد، اما <em>باید</em> صراحتاً بیان کنیم که نتیجه <code>Future</code> محدود به آن طول عمر است.</li>
</ul>
<p>حالا می‌توانیم <code>page_title</code> را در <code>main</code> فراخوانی کنیم. برای شروع، فقط عنوان یک صفحه را دریافت می‌کنیم. در فهرست 17-3، از همان الگوی دریافت آرگومان‌های خط فرمان که در فصل 12 استفاده کردیم پیروی می‌کنیم. سپس اولین URL را به <code>page_title</code> می‌دهیم و نتیجه را منتظر می‌مانیم. زیرا مقدار تولیدشده توسط آینده یک <code>Option&lt;String&gt;</code> است، از یک عبارت <code>match</code> برای چاپ پیام‌های مختلف استفاده می‌کنیم تا مشخص کنیم که آیا صفحه یک <code>&lt;title&gt;</code> داشت یا نه.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-3: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument</figcaption>
</figure>
<p>متأسفانه، این کد کامپایل نمی‌شود. تنها جایی که می‌توانیم از کلمه کلیدی <code>await</code> استفاده کنیم در توابع یا بلوک‌های async است، و راست به ما اجازه نمی‌دهد که تابع خاص <code>main</code> را با <code>async</code> علامت‌گذاری کنیم.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>دلیل اینکه نمی‌توان <code>main</code> را با <code>async</code> علامت‌گذاری کرد این است که کد async به یک <em>runtime</em> نیاز دارد: یک crate راست که جزئیات اجرای کد ناهمگام را مدیریت می‌کند. تابع <code>main</code> یک برنامه می‌تواند یک runtime را <em>مقداردهی اولیه</em> کند، اما خود runtime <em>نیست</em>. (کمی بعد بیشتر درباره این موضوع خواهیم دید.) هر برنامه راست که کد async را اجرا می‌کند حداقل یک جایی دارد که یک runtime راه‌اندازی می‌کند و آینده‌ها (futures) را اجرا می‌کند.</p>
<p>بیشتر زبان‌هایی که از async پشتیبانی می‌کنند یک runtime را با زبان همراه دارند. راست این کار را نمی‌کند. در عوض، بسیاری از runtime‌های async مختلف در دسترس هستند که هرکدام معاملات متفاوتی دارند که برای مورد استفاده هدف‌گذاری‌شده مناسب هستند. برای مثال، یک سرور وب با توان بالا با هسته‌های CPU متعدد و مقدار زیادی RAM نیازهای بسیار متفاوتی نسبت به یک میکروکنترلر با یک هسته، مقدار کمی RAM، و بدون توانایی تخصیص heap دارد. crate‌هایی که این runtime‌ها را ارائه می‌دهند معمولاً نسخه‌های async از قابلیت‌های رایج مانند I/O فایل یا شبکه را نیز فراهم می‌کنند.</p>
<p>اینجا و در طول بقیه این فصل، ما از تابع <code>run</code> از crate <code>trpl</code> استفاده خواهیم کرد، که یک آینده را به‌عنوان آرگومان می‌گیرد و آن را تا تکمیل اجرا می‌کند. در پشت صحنه، فراخوانی <code>run</code> یک runtime را برای استفاده جهت اجرای آینده‌ای که ارسال شده است تنظیم می‌کند. وقتی آینده تکمیل شد، <code>run</code> هر مقداری که آینده تولید کرده است بازمی‌گرداند.</p>
<p>ما می‌توانستیم آینده بازگشتی از <code>page_title</code> را مستقیماً به <code>run</code> ارسال کنیم. وقتی تکمیل شد، می‌توانستیم بر روی <code>Option&lt;String&gt;</code> حاصل، همان‌طور که سعی کردیم در فهرست 17-3 انجام دهیم، match کنیم. با این حال، برای بیشتر مثال‌های این فصل (و بیشتر کدهای async در دنیای واقعی!)، بیشتر از یک فراخوانی تابع async انجام می‌دهیم، بنابراین به جای آن، یک بلوک <code>async</code> را ارسال می‌کنیم و نتیجه فراخوانی <code>page_title</code> را به‌صراحت منتظر می‌مانیم، همان‌طور که در فهرست 17-4 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-4: منتظر ماندن یک بلوک async با <code>trpl::run</code></figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، رفتاری را که ممکن است ابتدا انتظار داشتیم دریافت می‌کنیم:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>بالاخره به کد ناهمگام کارآمد رسیدیم! این کد اکنون کامپایل می‌شود و می‌توانیم آن را اجرا کنیم.
قبل از اینکه کدی اضافه کنیم تا دو سایت را در برابر یکدیگر مسابقه دهیم، بیایید مختصراً
توجه خود را به نحوه عملکرد آینده‌ها (futures) بازگردانیم.</p>
<p>هر <em>نقطه انتظار</em> (await point)—یعنی هر جایی که کد از کلمه کلیدی <code>await</code> استفاده می‌کند—
نمایانگر جایی است که کنترل به runtime بازگردانده می‌شود. برای انجام این کار، راست باید
وضعیت مرتبط با بلوک async را پیگیری کند تا runtime بتواند کار دیگری را شروع کند و
سپس وقتی آماده شد به این کار بازگردد و سعی کند آن را پیش ببرد. این یک ماشین حالت
نامرئی است، گویی که شما یک enum به این شکل نوشتید تا وضعیت فعلی را در هر نقطه
<code>await</code> ذخیره کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>نوشتن کدی که به صورت دستی بین هر حالت جابه‌جا شود خسته‌کننده و مستعد خطا خواهد
بود، به خصوص هنگام اضافه کردن عملکرد و حالات بیشتر به کد در آینده. در عوض،
کامپایلر راست ساختارهای داده ماشین حالت را برای کد async به‌طور خودکار ایجاد و
مدیریت می‌کند. اگر این سوال برایتان پیش آمده که آیا قوانین معمول وام‌دهی و مالکیت
در مورد ساختارهای داده اعمال می‌شوند: بله! خوشبختانه، کامپایلر همچنین بررسی
این قوانین را برای ما انجام می‌دهد و پیام‌های خطای خوبی دارد. در ادامه فصل،
چند مورد از این خطاها را بررسی خواهیم کرد.</p>
<p>در نهایت، چیزی باید آن ماشین حالت را اجرا کند. آن چیزی یک runtime است. (به
همین دلیل است که ممکن است گاهی به <em>اجراکننده‌ها (executors)</em> در هنگام بررسی
runtime‌ها اشاره شود: یک اجراکننده بخشی از runtime است که مسئول اجرای کد async
است.)</p>
<p>حالا می‌توانیم بفهمیم چرا کامپایلر ما را از تبدیل <code>main</code> به یک تابع async در
فهرست 17-3 متوقف کرد. اگر <code>main</code> یک تابع async بود، چیزی دیگری باید ماشین حالت
را برای هر آینده‌ای که <code>main</code> بازمی‌گرداند مدیریت می‌کرد، اما <code>main</code> نقطه شروع
برنامه است! در عوض، ما تابع <code>trpl::run</code> را در <code>main</code> فراخوانی می‌کنیم که یک runtime
راه‌اندازی می‌کند و آینده بازگشتی از بلوک <code>async</code> را اجرا می‌کند تا زمانی که
<code>Ready</code> بازگرداند.</p>
<blockquote>
<p>نکته: برخی runtime‌ها ماکروهایی ارائه می‌دهند که به شما امکان می‌دهند
یک تابع async main بنویسید. این ماکروها <code>async fn main() { ... }</code> را به
یک <code>fn main</code> عادی تبدیل می‌کنند که همان کاری را که ما در فهرست 17-5 به‌صورت
دستی انجام دادیم انجام می‌دهد: فراخوانی یک تابع که یک آینده را تا تکمیل اجرا می‌کند
همانطور که <code>trpl::run</code> انجام می‌دهد.</p>
</blockquote>
<p>بیایید این قطعات را کنار هم قرار دهیم و ببینیم چگونه می‌توانیم کدی همزمان بنویسیم
با فراخوانی <code>page_title</code> با دو URL مختلف ارسال‌شده از خط فرمان و مسابقه دادن
آن‌ها.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title is: '{title}'"),
            None =&gt; println!("Its title could not be parsed."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption>Listing 17-5: </figcaption>
</figure>
<p>در فهرست 17-5، ما با فراخوانی <code>page_title</code> برای هر یک از URLهای ارسال‌شده توسط
کاربر شروع می‌کنیم. آینده‌های تولیدشده با فراخوانی <code>page_title</code> را به‌عنوان
<code>title_fut_1</code> و <code>title_fut_2</code> ذخیره می‌کنیم. به یاد داشته باشید که این آینده‌ها
هنوز کاری انجام نمی‌دهند، زیرا آینده‌ها تنبل هستند و ما هنوز منتظر آن‌ها نبوده‌ایم. سپس
آینده‌ها را به <code>trpl::race</code> ارسال می‌کنیم که مقداری بازمی‌گرداند تا نشان دهد کدام
یک از آینده‌های ارسال‌شده زودتر تکمیل می‌شود.</p>
<blockquote>
<p>نکته: در پشت صحنه، <code>race</code> بر اساس یک تابع عمومی‌تر به نام <code>select</code> ساخته شده است، که در کد راست دنیای واقعی بیشتر با آن روبه‌رو خواهید شد. تابع <code>select</code> می‌تواند کارهای زیادی انجام دهد که تابع <code>trpl::race</code> نمی‌تواند، اما همچنین دارای پیچیدگی‌های اضافی است که می‌توانیم فعلاً از آن صرف‌نظر کنیم.</p>
</blockquote>
<p>هر یک از آینده‌ها می‌تواند به‌طور مشروع “برنده” باشد، بنابراین بازگرداندن یک <code>Result</code> منطقی نیست. در عوض، <code>race</code> نوعی را بازمی‌گرداند که قبلاً ندیده‌ایم: <code>trpl::Either</code>. نوع <code>Either</code> تا حدی شبیه به <code>Result</code> است، زیرا دو حالت دارد. با این حال، برخلاف <code>Result</code>، هیچ مفهومی از موفقیت یا شکست درون <code>Either</code> وجود ندارد. در عوض، از <code>Left</code> و <code>Right</code> برای نشان دادن “یکی یا دیگری” استفاده می‌کند.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>تابع <code>race</code> مقدار <code>Left</code> را بازمی‌گرداند اگر آرگومان اول زودتر تمام شود، همراه با خروجی آن آینده، و مقدار <code>Right</code> را با خروجی آرگومان آینده دوم بازمی‌گرداند اگر <em>آن</em> یکی زودتر تمام شود. این با ترتیب آرگومان‌ها هنگام فراخوانی تابع مطابقت دارد: آرگومان اول در سمت چپ آرگومان دوم قرار دارد.</p>
<p>ما همچنین <code>page_title</code> را به‌روزرسانی می‌کنیم تا همان URL ارسال‌شده را بازگرداند. به این ترتیب، اگر صفحه‌ای که ابتدا بازمی‌گردد <code>&lt;title&gt;</code> قابل‌تشخیصی نداشته باشد، همچنان می‌توانیم یک پیام معنادار چاپ کنیم. با در دسترس داشتن این اطلاعات، خروجی <code>println!</code> خود را به‌روزرسانی می‌کنیم تا مشخص کنیم کدام URL زودتر تمام شده است و <code>&lt;title&gt;</code> صفحه وب در آن URL چه بوده است، اگر وجود داشته باشد.</p>
<p>شما اکنون یک اسکرپر وب کوچک و کارآمد ساخته‌اید! چند URL انتخاب کنید و ابزار خط فرمان را اجرا کنید. ممکن است متوجه شوید که برخی سایت‌ها به طور قابل اعتمادی سریع‌تر از دیگران هستند، در حالی که در موارد دیگر اینکه کدام سایت “برنده” می‌شود از اجرا به اجرا متفاوت است. مهم‌تر از همه، شما اصول اولیه کار با آینده‌ها را آموخته‌اید، بنابراین اکنون می‌توانیم به موارد بیشتری که می‌توانیم با async انجام دهیم بپردازیم.</p>
<!-- TODO: map source link version to version of Rust? -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
