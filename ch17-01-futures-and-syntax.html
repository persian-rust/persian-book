<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures و نحو Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="futures-و-سینتکس-async"><a class="header" href="#futures-و-سینتکس-async">Futures و سینتکس Async</a></h2>
<p>عناصر کلیدی برنامه‌نویسی ناهمزمان در Rust شامل <em>futures</em> و کلمات کلیدی <code>async</code> و <code>await</code> هستند.</p>
<p>یک <em>future</em> مقداری است که ممکن است اکنون آماده نباشد، اما در آینده در نقطه‌ای آماده خواهد شد. (این مفهوم در بسیاری از زبان‌ها وجود دارد، گاهی با نام‌های دیگر مانند <em>task</em> یا <em>promise</em>.) Rust یک ویژگی <code>Future</code> به عنوان یک بلوک سازنده فراهم می‌کند تا عملیات‌های async مختلف با ساختارهای داده متفاوت اما با یک رابط مشترک پیاده‌سازی شوند. در Rust، futures نوع‌هایی هستند که ویژگی <code>Future</code> را پیاده‌سازی می‌کنند. هر future اطلاعات خود را در مورد پیشرفت و اینکه “آماده” به چه معناست نگه می‌دارد.</p>
<p>می‌توانید کلمه کلیدی <code>async</code> را به بلوک‌ها و توابع اعمال کنید تا مشخص کنید که می‌توانند متوقف شده و از سر گرفته شوند. درون یک بلوک async یا تابع async، می‌توانید از کلمه کلیدی <code>await</code> برای <em>انتظار یک future</em> (یعنی منتظر ماندن تا آماده شود) استفاده کنید. هر نقطه‌ای که در آن یک future را در یک بلوک یا تابع async انتظار می‌کشید، یک نقطه بالقوه برای متوقف و از سر گرفتن آن بلوک یا تابع async است. فرآیند بررسی یک future برای اینکه ببیند مقدار آن هنوز آماده است یا خیر، <em>polling</em> نامیده می‌شود.</p>
<p>برخی زبان‌های دیگر، مانند C# و JavaScript، نیز از کلمات کلیدی <code>async</code> و <code>await</code> برای برنامه‌نویسی ناهمزمان استفاده می‌کنند. اگر با این زبان‌ها آشنا هستید، ممکن است تفاوت‌های قابل توجهی در نحوه عملکرد Rust، از جمله نحوه مدیریت سینتکس آن، مشاهده کنید. این تفاوت‌ها دلایل خوبی دارند، همان‌طور که خواهیم دید!</p>
<p>هنگام نوشتن کد async در Rust، بیشتر اوقات از کلمات کلیدی <code>async</code> و <code>await</code> استفاده می‌کنیم. Rust آن‌ها را به کدی معادل با استفاده از ویژگی <code>Future</code> کامپایل می‌کند، همان‌طور که حلقه‌های <code>for</code> را به کدی معادل با استفاده از ویژگی <code>Iterator</code> کامپایل می‌کند. با این حال، از آنجا که Rust ویژگی <code>Future</code> را ارائه می‌دهد، می‌توانید آن را برای نوع‌های داده خودتان نیز پیاده‌سازی کنید. بسیاری از توابعی که در طول این فصل مشاهده خواهیم کرد نوع‌هایی را بازمی‌گردانند که پیاده‌سازی‌های خود از <code>Future</code> را دارند. در انتهای فصل به تعریف این ویژگی بازمی‌گردیم و بیشتر در مورد نحوه عملکرد آن بحث می‌کنیم، اما این توضیحات برای ادامه کافی است.</p>
<p>ممکن است این توضیحات کمی انتزاعی به نظر برسند، بنابراین بیایید اولین برنامه async خود را بنویسیم: یک web scraper کوچک. ما دو URL را از خط فرمان دریافت می‌کنیم، هر دو را به صورت همزمان دریافت می‌کنیم و نتیجه اولین URL که به پایان می‌رسد را بازمی‌گردانیم. این مثال دارای سینتکس جدیدی خواهد بود، اما نگران نباشید—همه چیزهایی که باید بدانید را در طول مسیر توضیح خواهیم داد.</p>
<h2 id="اولین-برنامه-async-ما"><a class="header" href="#اولین-برنامه-async-ما">اولین برنامه Async ما</a></h2>
<p>برای تمرکز این فصل روی یادگیری async به جای مدیریت بخش‌های اکوسیستم، یک crate به نام <code>trpl</code> ایجاد کرده‌ایم (<code>trpl</code> مخفف “The Rust Programming Language” است). این crate همه نوع‌ها، ویژگی‌ها، و توابع مورد نیاز شما را بازصادر می‌کند، عمدتاً از crateهای <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore --> و <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore -->. crate <code>futures</code> خانه رسمی برای آزمایش کد async در Rust است و در واقع جایی است که ویژگی <code>Future</code> در ابتدا طراحی شد. <code>tokio</code> امروز رایج‌ترین Runtime async در Rust است، به ویژه برای برنامه‌های وب. Runtimeهای عالی دیگری نیز وجود دارند که ممکن است برای اهداف شما مناسب‌تر باشند. ما از crate <code>tokio</code> در زیرساخت <code>trpl</code> استفاده می‌کنیم زیرا به خوبی تست شده و به طور گسترده استفاده می‌شود.</p>
<p>در برخی موارد، <code>trpl</code> همچنین APIهای اصلی را تغییر نام داده یا آن‌ها را پوشش می‌دهد تا شما را بر روی جزئیات مرتبط با این فصل متمرکز نگه دارد. اگر می‌خواهید بفهمید این crate چه می‌کند، ما شما را تشویق می‌کنیم که <a href="https://github.com/persian-rust/book/tree/main/packages/trpl">سورس کد آن</a><!-- ignore --> را بررسی کنید. می‌توانید ببینید که هر بازصادر از کدام crate می‌آید، و توضیحات گسترده‌ای در مورد آنچه که crate انجام می‌دهد گذاشته‌ایم.</p>
<p>یک پروژه باینری جدید به نام <code>hello-async</code> ایجاد کنید و crate <code>trpl</code> را به عنوان وابستگی اضافه کنید:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>اکنون می‌توانیم از بخش‌های مختلف ارائه‌شده توسط <code>trpl</code> استفاده کنیم تا اولین برنامه async خود را بنویسیم. ما یک ابزار کوچک خط فرمان ایجاد خواهیم کرد که دو صفحه وب را دریافت می‌کند، عنصر <code>&lt;title&gt;</code> را از هرکدام استخراج می‌کند و عنوان صفحه‌ای که سریع‌تر کل این فرآیند را تکمیل می‌کند، چاپ می‌کند.</p>
<h3 id="تعریف-تابع-page_title"><a class="header" href="#تعریف-تابع-page_title">تعریف تابع <code>page_title</code></a></h3>
<p>بیایید با نوشتن یک تابع که یک URL صفحه را به عنوان پارامتر می‌گیرد، یک درخواست به آن ارسال می‌کند و متن عنصر <code>&lt;title&gt;</code> را بازمی‌گرداند شروع کنیم (نگاه کنید به لیست ۱۷-۱).</p>
<figure class="listing" id="listing-17-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre></pre>
<figcaption><a href="#listing-17-1">Listing 17-1</a>: تعریف یک تابع async برای دریافت عنصر <code>&lt;title&gt;</code> از یک صفحه HTML</figcaption>
</figure>
<p>ابتدا یک تابع به نام <code>page_title</code> تعریف می‌کنیم و آن را با کلمه کلیدی <code>async</code> علامت‌گذاری می‌کنیم. سپس از تابع <code>trpl::get</code> برای دریافت هر URL که به آن ارسال می‌شود استفاده می‌کنیم و کلمه کلیدی <code>await</code> را اضافه می‌کنیم تا منتظر پاسخ بمانیم. برای دریافت متن پاسخ، متد <code>text</code> را فراخوانی می‌کنیم و دوباره با کلمه کلیدی <code>await</code> منتظر آن می‌مانیم. هر دو این مراحل ناهمزمان هستند. برای تابع <code>get</code>، باید منتظر باشیم تا سرور اولین قسمت از پاسخ خود را ارسال کند که شامل هدرهای HTTP، کوکی‌ها و غیره است و می‌تواند جدا از بدنه پاسخ ارسال شود. به ویژه اگر بدنه بسیار بزرگ باشد، ممکن است مدتی طول بکشد تا همه آن برسد. از آنجا که باید منتظر <em>تمامیت</em> پاسخ بمانیم، متد <code>text</code> نیز async است.</p>
<p>باید به‌صراحت منتظر هر دو future باشیم، زیرا futures در Rust <em>تنبل</em> هستند: تا زمانی که از آن‌ها با کلمه کلیدی <code>await</code> درخواست نشود، هیچ کاری انجام نمی‌دهند. (در واقع، Rust یک هشدار کامپایلر نمایش می‌دهد اگر از یک future استفاده نکنید.) این ممکن است شما را به یاد بحث فصل ۱۳ درباره iteratorها در بخش <a href="ch13-02-iterators.html">پردازش یک سری از آیتم‌ها با iteratorها</a><!-- ignore --> بیندازد. iteratorها هیچ کاری انجام نمی‌دهند مگر اینکه متد <code>next</code> آن‌ها را فراخوانی کنید—چه به صورت مستقیم یا با استفاده از حلقه‌های <code>for</code> یا متدهایی مانند <code>map</code> که در پشت صحنه از <code>next</code> استفاده می‌کنند. به همین ترتیب، futures هیچ کاری انجام نمی‌دهند مگر اینکه به‌صراحت از آن‌ها درخواست شود. این ویژگی تنبلی به Rust اجازه می‌دهد تا کد async را تا زمانی که واقعاً مورد نیاز است، اجرا نکند.</p>
<blockquote>
<p>توجه: این رفتار با چیزی که در فصل قبل هنگام استفاده از <code>thread::spawn</code> در <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">ایجاد یک نخ جدید با spawn</a><!--ignore--> دیدیم متفاوت است، جایی که closure‌ای که به نخ دیگر منتقل کردیم بلافاصله شروع به اجرا کرد. همچنین این رفتار با رویکرد بسیاری از زبان‌های دیگر در مورد async نیز تفاوت دارد. اما این موضوع برای Rust اهمیت دارد تا بتواند تضمین‌های عملکردی خود را همانند کاری که با پیمایشگرها انجام می‌دهد، حفظ کند.</p>
</blockquote>
<p>زمانی که <code>response_text</code> را دریافت کردیم، می‌توانیم آن را با استفاده از <code>Html::parse</code> به نمونه‌ای از نوع <code>Html</code> تبدیل کنیم. به جای یک رشته‌ی خام، اکنون یک نوع داده داریم که می‌توانیم از آن برای کار با HTML به‌عنوان یک ساختار داده‌ی غنی‌تر استفاده کنیم. به‌ویژه می‌توانیم از متد <code>select_first</code> برای یافتن اولین نمونه از یک سلکتور CSS مشخص استفاده کنیم. با ارسال رشته‌ی <code>"title"</code>، اولین عنصر <code>&lt;title&gt;</code> موجود در سند را دریافت خواهیم کرد، اگر عنصری وجود داشته باشد. از آن‌جایی که ممکن است هیچ عنصر مطابقت‌یافته‌ای وجود نداشته باشد، <code>select_first</code> یک <code>Option&lt;ElementRef&gt;</code> بازمی‌گرداند. در نهایت، از متد <code>Option::map</code> استفاده می‌کنیم که به ما اجازه می‌دهد اگر مقداری در <code>Option</code> وجود داشت با آن کار کنیم، و اگر وجود نداشت، هیچ کاری انجام ندهیم. (می‌توانستیم از یک عبارت <code>match</code> نیز استفاده کنیم، اما استفاده از <code>map</code> در این‌جا ایدیاتیک‌تر است.) در بدنه‌ی تابعی که به <code>map</code> می‌دهیم، متد <code>inner_html</code> را روی <code>title</code> فراخوانی می‌کنیم تا محتوای آن را به‌صورت یک <code>String</code> دریافت کنیم. در پایان، نتیجه‌ی ما یک <code>Option&lt;String&gt;</code> خواهد بود.</p>
<p>توجه داشته باشید که کلمه‌ی کلیدی <code>await</code> در Rust <strong>پس از</strong> عبارتی که منتظر آن هستید می‌آید، نه قبل از آن. به عبارت دیگر، این یک کلمه‌ی کلیدی <strong>پسوندی</strong> است. این ممکن است با چیزی که در زبان‌های دیگر هنگام استفاده از <code>async</code> تجربه کرده‌اید متفاوت باشد، اما در Rust این موضوع باعث می‌شود زنجیره‌های توابع خواناتر و قابل‌مدیریت‌تر شوند. بنابراین، می‌توانیم بدنه‌ی تابع <code>page_title</code> را طوری تغییر دهیم که توابع <code>trpl::get</code> و <code>text</code> را با استفاده از <code>await</code> بین آن‌ها به‌صورت زنجیره‌ای صدا بزنیم، همان‌طور که در لیست 17-2 نشان داده شده است.</p>
<figure class="listing" id="listing-17-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-2">Listing 17-2</a>: زنجیره کردن با کلمه کلیدی <code>await</code></figcaption>
</figure>
<p>با این توضیحات، ما اولین تابع async خود را با موفقیت نوشتیم! پیش از اضافه کردن کدی در <code>main</code> برای فراخوانی آن، بیایید کمی بیشتر درباره آنچه نوشته‌ایم و معنای آن صحبت کنیم.</p>
<p>هنگامی که Rust یک بلوک که با کلمه کلیدی <code>async</code> علامت‌گذاری شده است را می‌بیند، آن را به یک نوع داده منحصربه‌فرد و ناشناس که ویژگی <code>Future</code> را پیاده‌سازی می‌کند، کامپایل می‌کند. هنگامی که Rust یک تابع که با <code>async</code> علامت‌گذاری شده است را می‌بیند، آن را به یک تابع غیر-async که بدنه آن یک بلوک async است، کامپایل می‌کند. نوع بازگشتی یک تابع async نوع داده ناشناسی است که کامپایلر برای آن بلوک async ایجاد می‌کند.</p>
<p>بنابراین، نوشتن <code>async fn</code> معادل نوشتن تابعی است که یک <em>future</em> از نوع بازگشتی برمی‌گرداند. برای کامپایلر، یک تعریف تابع مانند <code>async fn page_title</code> در لیست ۱۷-۱ معادل یک تابع غیر-async به شکل زیر است:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>بیایید هر بخش از نسخه تبدیل‌شده را بررسی کنیم:</p>
<ul>
<li>این تابع از سینتکس <code>impl Trait</code> استفاده می‌کند که در فصل ۱۰ در بخش [«Traits به‌عنوان پارامتر»][impl-trait]<!-- ignore --> بررسی کردیم.</li>
<li>trait بازگشتی یک <code>Future</code> است با نوع مرتبطی به نام <code>Output</code>. دقت کنید که نوع <code>Output</code> مقدار <code>Option&lt;String&gt;</code> است، که همان نوع بازگشتی نسخه‌ی اصلی <code>async fn</code> تابع <code>page_title</code> می‌باشد.</li>
<li>تمام کدی که در بدنه‌ی تابع اصلی فراخوانی می‌شد، اکنون درون یک بلاک <code>async move</code> قرار گرفته است. به یاد داشته باشید که بلاک‌ها در Rust یک عبارت محسوب می‌شوند. این بلاک به‌طور کامل همان عبارتی است که از تابع بازگردانده می‌شود.</li>
<li>این بلاک async یک مقدار با نوع <code>Option&lt;String&gt;</code> تولید می‌کند، همان‌طور که توصیف شد. این مقدار با نوع <code>Output</code> در نوع بازگشتی مطابقت دارد. این موضوع مشابه بلاک‌های دیگری است که تاکنون دیده‌اید.</li>
<li>بدنه‌ی تابع جدید یک بلاک <code>async move</code> است، به دلیل نحوه‌ی استفاده از پارامتر <code>url</code> درون بلاک. (در ادامه‌ی این فصل، به‌طور مفصل‌تر درباره‌ی تفاوت <code>async</code> و <code>async move</code> صحبت خواهیم کرد.)</li>
</ul>
<p>حالا می‌توانیم <code>page_title</code> را در <code>main</code> فراخوانی کنیم.</p>
<h2 id="تعیین-عنوان-یک-صفحه"><a class="header" href="#تعیین-عنوان-یک-صفحه">تعیین عنوان یک صفحه</a></h2>
<p>برای شروع، فقط عنوان یک صفحه را دریافت می‌کنیم. در لیست ۱۷-۳، همان الگویی که در فصل ۱۲ برای دریافت آرگومان‌های خط فرمان در بخش <a href="ch12-01-accepting-command-line-arguments.html">پذیرفتن آرگومان‌های خط فرمان</a><!-- ignore --> استفاده کردیم را دنبال می‌کنیم. سپس URL اول را به <code>page_title</code> ارسال کرده و نتیجه را انتظار می‌کشیم. چون مقداری که توسط future تولید می‌شود یک <code>Option&lt;String&gt;</code> است، از یک عبارت <code>match</code> برای چاپ پیام‌های مختلف استفاده می‌کنیم تا مشخص شود آیا صفحه یک <code>&lt;title&gt;</code> داشته است یا خیر.</p>
<figure class="listing" id="listing-17-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-3">Listing 17-3</a>: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument</figcaption>
</figure>
<p>متأسفانه، این کد کامپایل نمی‌شود. تنها جایی که می‌توانیم از کلمه کلیدی <code>await</code> استفاده کنیم، در توابع یا بلوک‌های async است، و Rust اجازه نمی‌دهد تابع ویژه <code>main</code> را به‌عنوان <code>async</code> علامت‌گذاری کنیم.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>دلیل اینکه نمی‌توان <code>main</code> را به‌عنوان <code>async</code> علامت‌گذاری کرد این است که کد async به یک <em>runtime</em> نیاز دارد: یک crate در Rust که جزئیات اجرای کد ناهمزمان را مدیریت می‌کند. تابع <code>main</code> یک برنامه می‌تواند یک runtime را <em>مقداردهی اولیه</em> کند، اما خودش یک runtime نیست. (در ادامه، بیشتر خواهیم دید که چرا این‌گونه است.) هر برنامه Rust که کد async اجرا می‌کند، حداقل یک مکان دارد که در آن یک runtime راه‌اندازی کرده و futures را اجرا می‌کند.</p>
<p>بیشتر زبان‌هایی که از async پشتیبانی می‌کنند، یک runtime همراه دارند، اما Rust این کار را نمی‌کند. در عوض، بسیاری از runtimeهای async مختلف موجود هستند که هرکدام موازنه‌های متفاوتی برای موارد استفاده خاص خود ارائه می‌دهند. برای مثال، یک وب سرور با توان عملیاتی بالا که دارای هسته‌های CPU متعدد و مقدار زیادی RAM است، نیازهای بسیار متفاوتی نسبت به یک میکروکنترلر با یک هسته، مقدار کمی RAM و بدون قابلیت تخصیص heap دارد. crateهایی که این runtimeها را فراهم می‌کنند اغلب نسخه‌های async از قابلیت‌های عمومی مانند I/O فایل یا شبکه را نیز ارائه می‌دهند.</p>
<p>اینجا و در بقیه این فصل، از تابع <code>run</code> از crate <code>trpl</code> استفاده خواهیم کرد، که یک future را به‌عنوان آرگومان می‌گیرد و آن را تا پایان اجرا می‌کند. در پشت صحنه، فراخوانی <code>run</code> یک runtime راه‌اندازی می‌کند که برای اجرای future ارسال‌شده استفاده می‌شود. وقتی future کامل شد، <code>run</code> هر مقداری که future تولید کرده باشد، بازمی‌گرداند.</p>
<p>می‌توانستیم future بازگردانده‌شده توسط <code>page_title</code> را مستقیماً به <code>run</code> ارسال کنیم، و وقتی کامل شد، می‌توانستیم بر اساس <code>Option&lt;String&gt;</code> نتیجه، یک <code>match</code> انجام دهیم، همان‌طور که در لیست ۱۷-۳ تلاش کردیم. با این حال، برای بیشتر مثال‌های این فصل (و بیشتر کد async در دنیای واقعی)، بیش از یک فراخوانی تابع async انجام خواهیم داد، بنابراین به‌جای آن یک بلوک <code>async</code> ارسال می‌کنیم و صراحتاً نتیجه فراخوانی <code>page_title</code> را انتظار می‌کشیم، همان‌طور که در لیست ۱۷-۴ نشان داده شده است.</p>
<figure class="listing" id="listing-17-4">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-4">Listing 17-4</a>: منتظر ماندن یک بلوک async با <code>trpl::run</code></figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، رفتاری را که ممکن است ابتدا انتظار داشتیم دریافت می‌کنیم:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>پوووف—بالاخره مقداری کد async کارا داریم! اما قبل از اینکه کدی اضافه کنیم که دو سایت را در مقابل یکدیگر رقابت دهد، بیایید به‌طور مختصر دوباره به نحوه کار futures توجه کنیم.</p>
<p>هر <em>نقطه انتظار</em>—یعنی هر جایی که کد از کلمه کلیدی <code>await</code> استفاده می‌کند—نمایانگر جایی است که کنترل به runtime بازمی‌گردد. برای اینکه این کار انجام شود، Rust نیاز دارد وضعیت مربوط به بلوک async را پیگیری کند تا runtime بتواند کار دیگری را آغاز کند و سپس وقتی آماده شد دوباره برای پیشرفت بلوک اول بازگردد. این یک ماشین حالت نامرئی است، گویی که شما یک enum مانند این نوشته‌اید تا وضعیت فعلی را در هر نقطه انتظار ذخیره کند:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>نوشتن کدی که به صورت دستی بین هر حالت انتقال یابد خسته‌کننده و مستعد خطا خواهد بود، به‌ویژه زمانی که بخواهید عملکرد بیشتری اضافه کرده و حالات بیشتری به کد اضافه کنید. خوشبختانه، کامپایلر Rust به طور خودکار ساختارهای داده مربوط به ماشین حالت را برای کد async ایجاد و مدیریت می‌کند. قوانین عادی مالکیت و قرض‌گیری در مورد ساختارهای داده همچنان اعمال می‌شوند، و خوشبختانه، کامپایلر بررسی این موارد را نیز برای ما انجام می‌دهد و پیام‌های خطای مفیدی ارائه می‌دهد. در ادامه فصل چند مورد از این پیام‌ها را بررسی خواهیم کرد.</p>
<p>در نهایت، چیزی باید این ماشین حالت را اجرا کند، و آن چیز یک runtime است. (به همین دلیل ممکن است در بررسی runtimeها به ارجاعاتی به <em>executors</em> برخورد کنید: یک executor بخشی از runtime است که مسئول اجرای کد async است.)</p>
<p>اکنون می‌توانید دلیل این‌که چرا کامپایلر اجازه نداد تابع <code>main</code> را در لیستینگ 17-3 به‌صورت <code>async</code> تعریف کنیم، بهتر درک کنید. اگر <code>main</code> یک تابع async بود، باید یک جزء دیگر مسئول مدیریت ماشین حالت برای <code>future</code>ای می‌بود که <code>main</code> بازمی‌گرداند؛ اما <code>main</code> نقطه‌ی شروع برنامه است! بنابراین، به‌جای آن در تابع <code>main</code>، تابع <code>trpl::run</code> را فراخوانی کردیم تا یک runtime راه‌اندازی کند و <code>future</code> بازگردانده‌شده از بلاک async را تا زمان اتمام اجرا کند.</p>
<blockquote>
<p>نکته: برخی runtimeها ماکروهایی فراهم می‌کنند که به شما اجازه می‌دهند یک تابع <code>main</code> به‌صورت async بنویسید. این ماکروها عبارت <code>async fn main() { ... }</code> را بازنویسی می‌کنند به یک تابع <code>fn main</code> معمولی که همان کاری را انجام می‌دهد که ما در لیستینگ 17-4 به‌صورت دستی انجام دادیم: فراخوانی تابعی که یک future را تا تکمیل اجرا می‌کند، مانند کاری که <code>trpl::run</code> انجام می‌دهد.</p>
</blockquote>
<p>حالا بیایید این بخش‌ها را کنار هم قرار دهیم و ببینیم چگونه می‌توان کدی همزمان نوشت.</p>
<h3 id="رقابت-بین-دو-url"><a class="header" href="#رقابت-بین-دو-url">رقابت بین دو URL</a></h3>
<p>در لیست ۱۷-۵، ما <code>page_title</code> را با دو URL مختلف که از خط فرمان ارسال شده‌اند، فراخوانی کرده و آن‌ها را با یکدیگر رقابت می‌دهیم.</p>
<figure class="listing" id="listing-17-5">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title was: '{title}'"),
            None =&gt; println!("It had no title."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption><a href="#listing-17-5">Listing 17-5</a>: </figcaption>
</figure>
<p>ما با فراخوانی <code>page_title</code> برای هر یک از URLهایی که توسط کاربر ارسال شده‌اند، شروع می‌کنیم. Futureهای حاصل را به نام‌های <code>title_fut_1</code> و <code>title_fut_2</code> ذخیره می‌کنیم. به یاد داشته باشید، این‌ها هنوز کاری انجام نمی‌دهند، زیرا futures تنبل هستند و هنوز منتظر آن‌ها نمانده‌ایم. سپس این futures را به <code>trpl::race</code> ارسال می‌کنیم، که مقداری بازمی‌گرداند تا نشان دهد کدام یک از futures ارسال‌شده به آن ابتدا کامل شده است.</p>
<blockquote>
<p>نکته: در پشت صحنه، <code>race</code> بر اساس یک تابع عمومی‌تر به نام <code>select</code> ساخته شده است، که اغلب در کدهای واقعی Rust با آن مواجه خواهید شد. یک تابع <code>select</code> می‌تواند کارهایی انجام دهد که تابع <code>trpl::race</code> نمی‌تواند، اما همچنین دارای پیچیدگی‌های اضافی است که فعلاً می‌توانیم از آن صرف‌نظر کنیم.</p>
</blockquote>
<p>هرکدام از futures می‌توانند به طور قانونی “برنده” شوند، بنابراین بازگرداندن یک <code>Result</code> منطقی نیست. در عوض، <code>race</code> نوعی را بازمی‌گرداند که قبلاً ندیده‌ایم: <code>trpl::Either</code>. نوع <code>Either</code> تا حدودی شبیه به <code>Result</code> است به این معنا که دو حالت دارد. اما برخلاف <code>Result</code>، هیچ مفهومی از موفقیت یا شکست در <code>Either</code> وجود ندارد. در عوض، از <code>Left</code> و <code>Right</code> برای نشان دادن “یکی یا دیگری” استفاده می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>تابع <code>race</code> در صورتی که اولین future‌ ارائه‌شده زودتر به پایان برسد، مقدار <code>Left</code> را همراه با خروجی آن بازمی‌گرداند، و اگر دومین future زودتر به پایان برسد، مقدار <code>Right</code> را همراه با خروجی آن بازمی‌گرداند. این رفتار با ترتیبی که آرگومان‌ها هنگام فراخوانی تابع ظاهر می‌شوند مطابقت دارد: آرگومان اول در سمت چپ آرگومان دوم قرار دارد.</p>
<p>همچنین تابع <code>page_title</code> را به‌روزرسانی می‌کنیم تا همان URL ارسال‌شده را بازگرداند. به این ترتیب، اگر صفحه‌ای که ابتدا بازمی‌گردد، دارای یک <code>&lt;title&gt;</code> نباشد که بتوانیم آن را استخراج کنیم، همچنان می‌توانیم یک پیام معنادار چاپ کنیم. با در دسترس بودن این اطلاعات، خروجی <code>println!</code> خود را به‌روزرسانی می‌کنیم تا مشخص کند کدام URL اول کامل شده است و <code>&lt;title&gt;</code> صفحه وب در آن URL چیست (اگر وجود داشته باشد).</p>
<p>شما اکنون یک web scraper کوچک و کارا ساخته‌اید! چند URL انتخاب کنید و ابزار خط فرمان را اجرا کنید. ممکن است متوجه شوید که برخی سایت‌ها به طور مداوم سریع‌تر از بقیه هستند، در حالی که در موارد دیگر، سایت سریع‌تر از اجرای به اجرای دیگر متفاوت است. مهم‌تر از همه، شما اصول کار با futures را آموخته‌اید، بنابراین حالا می‌توانیم عمیق‌تر به آنچه می‌توان با async انجام داد، بپردازیم.</p>
<!-- TODO: map source link version to version of Rust? -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
