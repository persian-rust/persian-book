<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ذخیره-متنهای-کدگذاری-شده-utf-8-با--رشتهها-strings"><a class="header" href="#ذخیره-متنهای-کدگذاری-شده-utf-8-با--رشتهها-strings">ذخیره متن‌های کدگذاری شده UTF-8 با  رشته‌ها (strings)</a></h2>
<p>ما در فصل ۴ درباره رشته‌ها صحبت کردیم، اما اکنون به آن‌ها با عمق بیشتری نگاه خواهیم کرد.
Rustaceanهای تازه‌وارد معمولاً به دلیل ترکیبی از سه عامل در رشته‌ها دچار مشکل می‌شوند:
گرایش Rust به آشکارسازی خطاهای ممکن، رشته‌ها به عنوان یک ساختار داده پیچیده‌تر از آنچه
بسیاری از برنامه‌نویسان تصور می‌کنند، و UTF-8. این عوامل به نحوی ترکیب می‌شوند که می‌توانند
برای کسانی که از زبان‌های برنامه‌نویسی دیگر می‌آیند دشوار باشند.</p>
<p>ما رشته‌ها را در زمینه مجموعه‌ها بررسی می‌کنیم، زیرا رشته‌ها به عنوان مجموعه‌ای از بایت‌ها
پیاده‌سازی شده‌اند، به علاوه تعدادی متد برای ارائه قابلیت‌های مفید زمانی که این بایت‌ها
به عنوان متن تفسیر می‌شوند. در این بخش، درباره عملیات‌هایی که روی <code>String</code> انجام می‌شود
و هر نوع مجموعه‌ای آن‌ها را دارد، مانند ایجاد، به‌روزرسانی، و خواندن صحبت خواهیم کرد.
همچنین تفاوت‌های <code>String</code> با سایر مجموعه‌ها را مورد بحث قرار می‌دهیم، به‌ویژه نحوه پیچیدگی
اندیس‌گذاری در یک <code>String</code> به دلیل تفاوت‌های بین تفسیر داده‌های <code>String</code> توسط انسان‌ها
و کامپیوترها.</p>
<h3 id="رشته-string-چیست"><a class="header" href="#رشته-string-چیست">رشته (string) چیست؟</a></h3>
<p>ابتدا تعریف می‌کنیم که منظور ما از اصطلاح <em>رشته</em> چیست. Rust فقط یک نوع رشته در زبان
هسته خود دارد که همان قطعه رشته <code>str</code> است که معمولاً به صورت قرض گرفته شده <code>&amp;str</code>
دیده می‌شود. در فصل ۴ درباره <em>قطعه‌های رشته</em> صحبت کردیم، که ارجاعاتی به داده‌های رشته‌ای
کدگذاری شده UTF-8 هستند که در جای دیگری ذخیره شده‌اند. به عنوان مثال، رشته‌های
لیترال در باینری برنامه ذخیره می‌شوند و بنابراین قطعه‌های رشته هستند.</p>
<p>نوع <code>String</code>، که توسط کتابخانه استاندارد Rust ارائه شده است و نه مستقیماً در زبان هسته
کدگذاری شده، یک نوع رشته رشدپذیر، قابل تغییر، و مالک UTF-8 است. وقتی Rustaceanها
به “رشته‌ها” در Rust اشاره می‌کنند، ممکن است به نوع <code>String</code> یا قطعه رشته <code>&amp;str</code> اشاره
کنند، نه فقط یکی از این دو نوع. اگرچه این بخش عمدتاً درباره <code>String</code> است، اما هر دو نوع
در کتابخانه استاندارد Rust به شدت مورد استفاده قرار می‌گیرند و هر دو <code>String</code> و قطعه‌های
رشته کدگذاری UTF-8 دارند.</p>
<h3 id="ایجاد-یک-رشته-strings-جدید"><a class="header" href="#ایجاد-یک-رشته-strings-جدید">ایجاد یک رشته (strings) جدید</a></h3>
<p>بسیاری از عملیات مشابه موجود در <code>Vec&lt;T&gt;</code> برای <code>String</code> نیز در دسترس است، زیرا <code>String</code>
در واقع به عنوان یک پوششی بر روی یک بردار از بایت‌ها پیاده‌سازی شده است، با برخی
ضمانت‌ها، محدودیت‌ها، و قابلیت‌های اضافی. مثالی از یک تابع که به همان روش با
<code>Vec&lt;T&gt;</code> و <code>String</code> کار می‌کند، تابع <code>new</code> برای ایجاد یک نمونه است، همانطور که در لیست
۸-۱۱ نشان داده شده است.</p>
<figure class="listing" id="listing-8-11">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-11">Listing 8-11</a>: ایجاد یک <code>String</code> جدید و خالی</figcaption>
</figure>
<p>این خط یک رشته جدید و خالی به نام <code>s</code> ایجاد می‌کند که می‌توانیم داده‌ها را در آن بارگذاری کنیم.
اغلب، داده‌های اولیه‌ای خواهیم داشت که می‌خواهیم رشته را با آن‌ها شروع کنیم. برای این کار،
از متد <code>to_string</code> استفاده می‌کنیم که بر روی هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی
می‌کند، همانند رشته‌های لیترال، در دسترس است. لیست ۸-۱۲ دو مثال را نشان می‌دهد.</p>
<figure class="listing" id="listing-8-12">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // The method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-12">Listing 8-12</a>: استفاده از متد <code>to_string</code> برای ایجاد یک <code>String</code> از یک رشته لیترال</figcaption>
</figure>
<p>این کد یک رشته حاوی <code>initial contents</code> ایجاد می‌کند.</p>
<p>ما همچنین می‌توانیم از تابع <code>String::from</code> برای ایجاد یک <code>String</code> از یک رشته لیترال
استفاده کنیم. کد در لیست ۸-۱۳ معادل کدی است که در لیست ۸-۱۲ از <code>to_string</code> استفاده می‌کند.</p>
<figure class="listing" id="listing-8-13">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-13">Listing 8-13</a>: استفاده از تابع <code>String::from</code> برای ایجاد یک <code>String</code> از یک رشته لیترال</figcaption>
</figure>
<p>از آنجا که رشته‌ها برای موارد بسیاری استفاده می‌شوند، می‌توانیم از بسیاری از APIهای
جنریک مختلف برای رشته‌ها استفاده کنیم که گزینه‌های زیادی را در اختیار ما قرار می‌دهند.
برخی از این‌ها ممکن است به نظر اضافی بیایند، اما هرکدام جایگاه خاص خود را دارند!
در این مورد، <code>String::from</code> و <code>to_string</code> عملکرد یکسانی دارند، بنابراین انتخاب بین آن‌ها
مسئله سبک و خوانایی کد است.</p>
<p>به یاد داشته باشید که رشته‌ها با کدگذاری UTF-8 هستند، بنابراین می‌توانیم هر داده‌ای که
به طور صحیح کدگذاری شده باشد را در آن‌ها قرار دهیم، همانطور که در لیست ۸-۱۴ نشان داده شده است.</p>
<figure class="listing" id="listing-8-14">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-14">Listing 8-14</a>: ذخیره سلام‌ها به زبان‌های مختلف در رشته‌ها</figcaption>
</figure>
<p>تمام این موارد مقادیر معتبر <code>String</code> هستند.</p>
<h3 id="بهروزرسانی-یک-رشته"><a class="header" href="#بهروزرسانی-یک-رشته">به‌روزرسانی یک رشته</a></h3>
<p>یک <code>String</code> می‌تواند از نظر اندازه رشد کند و محتوای آن تغییر کند، همانطور که محتوای
یک <code>Vec&lt;T&gt;</code> تغییر می‌کند، اگر داده بیشتری به آن اضافه کنیم. علاوه بر این، می‌توانیم به راحتی
از عملگر <code>+</code> یا ماکروی <code>format!</code> برای الحاق مقادیر <code>String</code> استفاده کنیم.</p>
<h4 id="الحاق-به-یک-رشته-string-با-push_str-و-push"><a class="header" href="#الحاق-به-یک-رشته-string-با-push_str-و-push">الحاق به یک رشته (string) با <code>push_str</code> و <code>push</code></a></h4>
<p>ما می‌توانیم یک <code>String</code> را با استفاده از متد <code>push_str</code> برای الحاق یک قطعه رشته رشد دهیم،
همانطور که در لیست ۸-۱۵ نشان داده شده است.</p>
<figure class="listing" id="listing-8-15">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-15">Listing 8-15</a>: الحاق یک قطعه رشته به یک <code>String</code> با استفاده از متد <code>push_str</code></figcaption>
</figure>
<p>بعد از این دو خط، مقدار <code>s</code> شامل <code>foobar</code> خواهد بود. متد <code>push_str</code> یک قطعه رشته را به عنوان آرگومان می‌گیرد
زیرا ما لزوماً نمی‌خواهیم مالکیت پارامتر را بگیریم. برای مثال، در کدی که در لیست ۸-۱۶ نشان داده شده است،
ما می‌خواهیم بتوانیم پس از الحاق محتوای <code>s2</code> به <code>s1</code> همچنان از <code>s2</code> استفاده کنیم.</p>
<figure class="listing" id="listing-8-16">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-16">Listing 8-16</a>: استفاده از یک قطعه رشته پس از الحاق محتوای آن به یک <code>String</code></figcaption>
</figure>
<p>اگر متد <code>push_str</code> مالکیت <code>s2</code> را می‌گرفت، نمی‌توانستیم مقدار آن را در خط آخر چاپ کنیم. با این حال،
این کد همانطور که انتظار می‌رود کار می‌کند!</p>
<p>متد <code>push</code> یک کاراکتر را به عنوان پارامتر می‌گیرد و آن را به <code>String</code> اضافه می‌کند. لیست ۸-۱۷
حرف <em>l</em> را با استفاده از متد <code>push</code> به یک <code>String</code> اضافه می‌کند.</p>
<figure class="listing" id="listing-8-17">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-17">Listing 8-17</a>: اضافه کردن یک کاراکتر به مقدار <code>String</code> با استفاده از <code>push</code></figcaption>
</figure>
<p>در نتیجه، مقدار <code>s</code> شامل <code>lol</code> خواهد بود.</p>
<h4 id="الحاق-با-استفاده-از-عملگر--یا-ماکروی-format"><a class="header" href="#الحاق-با-استفاده-از-عملگر--یا-ماکروی-format">الحاق با استفاده از عملگر <code>+</code> یا ماکروی <code>format!</code></a></h4>
<p>اغلب، ممکن است بخواهید دو رشته موجود را با هم ترکیب کنید. یکی از راه‌های انجام این کار
استفاده از عملگر <code>+</code> است، همانطور که در لیست ۸-۱۸ نشان داده شده است.</p>
<figure class="listing" id="listing-8-18">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-18">Listing 8-18</a>: استفاده از عملگر <code>+</code> برای ترکیب دو مقدار <code>String</code> در یک مقدار <code>String</code> جدید</figcaption>
</figure>
<p>مقدار <code>s3</code> شامل <code>Hello, world!</code> خواهد بود. دلیل اینکه <code>s1</code> پس از این الحاق دیگر معتبر نیست
و دلیل اینکه ما از یک مرجع به <code>s2</code> استفاده کردیم، به امضای متدی که هنگام استفاده از
عملگر <code>+</code> فراخوانی می‌شود مربوط است. عملگر <code>+</code> از متد <code>add</code> استفاده می‌کند که امضای آن به شکل زیر است:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>در کتابخانه استاندارد، شما <code>add</code> را خواهید دید که با استفاده از جنریک‌ها و انواع مرتبط تعریف شده است.
اینجا، ما انواع مشخصی را جایگزین کرده‌ایم، که این همان چیزی است که هنگام فراخوانی این متد با مقادیر
<code>String</code> اتفاق می‌افتد. درباره جنریک‌ها در فصل ۱۰ صحبت خواهیم کرد. این امضا به ما سرنخ‌هایی می‌دهد
تا بتوانیم بخش‌های چالش‌برانگیز عملگر <code>+</code> را درک کنیم.</p>
<p>اول، <code>s2</code> یک <code>&amp;</code> دارد، به این معنی که ما یک <em>مرجع</em> از رشته دوم را به رشته اول اضافه می‌کنیم.
این به دلیل پارامتر <code>s</code> در تابع <code>add</code> است: ما فقط می‌توانیم یک <code>&amp;str</code> را به یک <code>String</code> اضافه کنیم؛
نمی‌توانیم دو مقدار <code>String</code> را با هم جمع کنیم. اما صبر کنید—نوع <code>&amp;s2</code>، <code>&amp;String</code> است، نه <code>&amp;str</code>
همانطور که در پارامتر دوم <code>add</code> مشخص شده است. پس چرا کد در لیست ۸-۱۸ کامپایل می‌شود؟</p>
<p>دلیل اینکه می‌توانیم از <code>&amp;s2</code> در فراخوانی <code>add</code> استفاده کنیم این است که کامپایلر می‌تواند آرگومان
<code>&amp;String</code> را به <code>&amp;str</code> تبدیل کند. هنگامی که ما متد <code>add</code> را فراخوانی می‌کنیم، Rust از یک
<em>coercion deref</em> استفاده می‌کند که در اینجا <code>&amp;s2</code> را به <code>&amp;s2[..]</code> تبدیل می‌کند. ما این موضوع
را در فصل ۱۵ به طور عمیق‌تری بررسی خواهیم کرد. از آنجا که <code>add</code> مالکیت پارامتر <code>s</code> را نمی‌گیرد،
<code>s2</code> پس از این عملیات همچنان یک <code>String</code> معتبر باقی خواهد ماند.</p>
<p>دوم، می‌توانیم در امضا ببینیم که <code>add</code> مالکیت <code>self</code> را می‌گیرد زیرا <code>self</code> یک <code>&amp;</code> ندارد.
این بدان معناست که <code>s1</code> در لیست ۸-۱۸ به فراخوانی <code>add</code> منتقل می‌شود و پس از آن دیگر معتبر نخواهد بود.
بنابراین، اگرچه <code>let s3 = s1 + &amp;s2;</code> به نظر می‌رسد که هر دو رشته را کپی می‌کند و یک رشته جدید ایجاد
می‌کند، این عبارت در واقع مالکیت <code>s1</code> را می‌گیرد، یک کپی از محتوای <code>s2</code> را اضافه می‌کند، و سپس مالکیت
نتیجه را بازمی‌گرداند. به عبارت دیگر، به نظر می‌رسد که کپی‌های زیادی انجام می‌دهد، اما اینطور نیست؛
پیاده‌سازی کارآمدتر از کپی کردن است.</p>
<p>اگر نیاز به الحاق چندین رشته داشته باشیم، رفتار عملگر <code>+</code> دست‌وپاگیر می‌شود:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>در این نقطه، مقدار <code>s</code> برابر با <code>tic-tac-toe</code> خواهد بود. با تمام این <code>+</code> و کاراکترهای <code>"</code>،
دیدن اینکه چه اتفاقی می‌افتد دشوار است. برای ترکیب رشته‌ها به روش‌های پیچیده‌تر، می‌توانیم
به جای آن از ماکروی <code>format!</code> استفاده کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>این کد نیز مقدار <code>s</code> را به <code>tic-tac-toe</code> تنظیم می‌کند. ماکروی <code>format!</code> شبیه به <code>println!</code> کار می‌کند،
اما به جای چاپ خروجی روی صفحه، یک <code>String</code> با محتوای مورد نظر بازمی‌گرداند. نسخه کد با استفاده از
<code>format!</code> بسیار خواناتر است و کدی که توسط ماکروی <code>format!</code> تولید می‌شود از مراجع استفاده می‌کند،
بنابراین این فراخوانی مالکیت هیچ‌یک از پارامترهایش را نمی‌گیرد.</p>
<h3 id="اندیسگذاری-در-رشتهها"><a class="header" href="#اندیسگذاری-در-رشتهها">اندیس‌گذاری در رشته‌ها</a></h3>
<p>در بسیاری از زبان‌های برنامه‌نویسی دیگر، دسترسی به کاراکترهای منفرد در یک رشته با اشاره به آن‌ها
توسط اندیس (index)یک عملیات معتبر و رایج است. با این حال، اگر تلاش کنید در Rust با استفاده از سینتکس
اندیس‌گذاری به بخش‌هایی از یک <code>String</code> دسترسی پیدا کنید، با خطا مواجه می‌شوید. کد نامعتبر
در لیست ۸-۱۹ را در نظر بگیرید.</p>
<figure class="listing" id="listing-8-19">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hi");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-8-19">Listing 8-19</a>: تلاش برای استفاده از سینتکس اندیس‌گذاری با یک <code>String</code></figcaption>
</figure>
<p>این کد به خطای زیر منجر خواهد شد:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
          but trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>خطا و توضیحات آن گویای موضوع است: رشته‌های Rust از اندیس‌گذاری پشتیبانی نمی‌کنند. اما چرا؟
برای پاسخ به این سؤال، باید درباره نحوه ذخیره‌سازی رشته‌ها در حافظه توسط Rust صحبت کنیم.</p>
<h4 id="نمایش-داخلی"><a class="header" href="#نمایش-داخلی">نمایش داخلی</a></h4>
<p>یک <code>String</code> در واقع یک پوشش بر روی <code>Vec&lt;u8&gt;</code> است. بیایید به برخی از مثال‌های رشته‌های کدگذاری
شده UTF-8 در لیست ۸-۱۴ نگاه کنیم. ابتدا این مورد:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>در این حالت، مقدار <code>len</code> برابر با <code>4</code> خواهد بود، به این معنی که برداری که رشته <code>"Hola"</code> را
ذخیره می‌کند ۴ بایت طول دارد. هر یک از این حروف هنگام کدگذاری در UTF-8 یک بایت می‌گیرد.
با این حال، خط زیر ممکن است شما را شگفت‌زده کند (توجه داشته باشید که این رشته با حرف بزرگ
سیریلیک <em>Ze</em> آغاز می‌شود، نه عدد ۳):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>اگر از شما پرسیده شود طول این رشته چقدر است، ممکن است بگویید ۱۲. اما در واقع، پاسخ Rust
۲۴ است: این تعداد بایت‌هایی است که برای کدگذاری “Здравствуйте” در UTF-8 نیاز است، زیرا هر مقدار
اسکالر Unicode در این رشته ۲ بایت فضای ذخیره‌سازی می‌گیرد. بنابراین، یک اندیس (index)در بایت‌های رشته
همیشه با یک مقدار اسکالر Unicode معتبر مطابقت ندارد. برای نشان دادن این موضوع، کد نامعتبر
زیر در Rust را در نظر بگیرید:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>شما قبلاً می‌دانید که مقدار <code>answer</code> برابر با <code>З</code>، اولین حرف، نخواهد بود. وقتی در UTF-8 کدگذاری
می‌شود، اولین بایت از <code>З</code> برابر با <code>208</code> و دومین بایت برابر با <code>151</code> است، بنابراین ممکن است به نظر
برسد که <code>answer</code> باید در واقع <code>208</code> باشد، اما <code>208</code> به تنهایی یک کاراکتر معتبر نیست. بازگرداندن
<code>208</code> احتمالاً چیزی نیست که یک کاربر بخواهد اگر درخواست اولین حرف این رشته را داشته باشد؛
با این حال، این تنها داده‌ای است که Rust در اندیس (index)بایت ۰ دارد. کاربران به طور کلی نمی‌خواهند
مقدار بایت بازگردانده شود، حتی اگر رشته فقط حروف لاتین داشته باشد: اگر <code>&amp;"hi"[0]</code> یک کد معتبر
بود که مقدار بایت را بازمی‌گرداند، مقدار <code>104</code> و نه <code>h</code> را بازمی‌گرداند.</p>
<p>پاسخ این است که برای جلوگیری از بازگرداندن یک مقدار غیرمنتظره و ایجاد باگ‌هایی که ممکن است فوراً
کشف نشوند، Rust این کد را اصلاً کامپایل نمی‌کند و از سوءتفاهم‌ها در اوایل فرآیند توسعه جلوگیری می‌کند.</p>
<h4 id="بایتها-مقادیر-اسکالر-و-خوشههای-گرافیمی-اوه-خدای-من"><a class="header" href="#بایتها-مقادیر-اسکالر-و-خوشههای-گرافیمی-اوه-خدای-من">بایت‌ها، مقادیر اسکالر و خوشه‌های گرافیمی! اوه خدای من!</a></h4>
<p>نکته دیگری درباره UTF-8 این است که در واقع سه روش مرتبط برای مشاهده رشته‌ها از دیدگاه Rust وجود دارد:
به صورت بایت، مقادیر اسکالر، و خوشه‌های گرافیمی (نزدیک‌ترین چیز به چیزی که ما <em>حروف</em> می‌نامیم).</p>
<p>اگر به کلمه هندی “नमस्ते” نوشته شده در اسکریپت Devanagari نگاه کنیم، این کلمه به صورت یک بردار
از مقادیر <code>u8</code> ذخیره می‌شود که به شکل زیر است:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>این ۱۸ بایت است و این همان چیزی است که کامپیوترها در نهایت این داده را ذخیره می‌کنند.
اگر به آن‌ها به عنوان مقادیر اسکالر Unicode نگاه کنیم، که همان نوع <code>char</code> در Rust است، این بایت‌ها
به این صورت به نظر می‌رسند:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>اینجا شش مقدار <code>char</code> وجود دارد، اما مقدار چهارم و ششم حروف نیستند: این‌ها دیاکریتیک‌هایی هستند که
به تنهایی معنایی ندارند. در نهایت، اگر به آن‌ها به عنوان خوشه‌های گرافیمی نگاه کنیم، همان چیزی
که یک فرد به عنوان حروف کلمه هندی تشخیص می‌دهد، اینطور خواهد بود:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust روش‌های مختلفی برای تفسیر داده خام رشته ارائه می‌دهد که کامپیوترها ذخیره می‌کنند، بنابراین هر
برنامه می‌تواند تفسیری را که نیاز دارد انتخاب کند، صرف نظر از اینکه داده به چه زبان انسانی است.</p>
<p>یکی دیگر از دلایل اینکه Rust به ما اجازه نمی‌دهد در یک <code>String</code> اندیس‌گذاری کنیم تا یک کاراکتر را
دریافت کنیم این است که عملیات اندیس‌گذاری باید همیشه در زمان ثابت (O(1)) انجام شود. اما امکان
تضمین این عملکرد با یک <code>String</code> وجود ندارد، زیرا Rust باید محتویات را از ابتدا تا اندیس (index)مرور کند تا
تعیین کند که چند کاراکتر معتبر وجود دارد.</p>
<h3 id="برش-رشتهها"><a class="header" href="#برش-رشتهها">برش رشته‌ها</a></h3>
<p>اندیس‌گذاری در یک رشته اغلب ایده خوبی نیست زیرا مشخص نیست که نوع بازگشتی عملیات اندیس‌گذاری
رشته چه باید باشد: یک مقدار بایت، یک کاراکتر، یک خوشه گرافیمی، یا یک قطعه رشته. بنابراین،
اگر واقعاً نیاز به استفاده از اندیس‌ها برای ایجاد قطعه‌های رشته دارید، Rust از شما می‌خواهد
بیشتر مشخص کنید.</p>
<p>به جای اندیس‌گذاری با استفاده از <code>[]</code> و یک عدد، می‌توانید از <code>[]</code> با یک بازه استفاده کنید
تا یک قطعه رشته که شامل بایت‌های خاصی است ایجاد کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>اینجا، <code>s</code> یک <code>&amp;str</code> خواهد بود که شامل چهار بایت اول رشته است. پیش‌تر اشاره کردیم که هر
یک از این کاراکترها دو بایت طول دارند، که به این معنی است که مقدار <code>s</code> برابر با <code>Зд</code> خواهد بود.</p>
<p>اگر سعی کنیم فقط بخشی از بایت‌های یک کاراکتر را با چیزی مثل <code>&amp;hello[0..1]</code> برش دهیم،
Rust در زمان اجرا دچار خطا می‌شود، به همان شکلی که اگر یک اندیس (index)نامعتبر در یک بردار
دسترسی داده شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>هنگام ایجاد قطعه‌های رشته با بازه‌ها باید احتیاط کنید، زیرا این کار ممکن است باعث خرابی
برنامه شما شود.</p>
<h3 id="متدهایی-برای-پیمایش-در-رشتهها"><a class="header" href="#متدهایی-برای-پیمایش-در-رشتهها">متدهایی برای پیمایش در رشته‌ها</a></h3>
<p>بهترین راه برای کار با بخش‌هایی از رشته‌ها این است که به وضوح مشخص کنید که آیا می‌خواهید
روی کاراکترها یا بایت‌ها کار کنید. برای مقادیر اسکالر Unicode منفرد، از متد <code>chars</code> استفاده کنید.
فراخوانی <code>chars</code> روی <code>"Зд"</code> دو مقدار از نوع <code>char</code> را جدا کرده و بازمی‌گرداند، و می‌توانید
با استفاده از نتیجه پیمایش کنید تا به هر عنصر دسترسی پیدا کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>این کد خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>به صورت جایگزین، متد <code>bytes</code> هر بایت خام را بازمی‌گرداند که ممکن است برای حوزه کاری شما مناسب باشد:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>این کد چهار بایتی که این رشته را تشکیل می‌دهند چاپ خواهد کرد:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>اما حتماً به یاد داشته باشید که مقادیر اسکالر Unicode معتبر ممکن است از بیش از یک بایت تشکیل شده باشند.</p>
<p>دریافت خوشه‌های گرافیمی از رشته‌ها، همانند اسکریپت Devanagari، پیچیده است، بنابراین این قابلیت
توسط کتابخانه استاندارد ارائه نمی‌شود. اگر به این قابلیت نیاز دارید، کرایت‌هایی در
<a href="https://crates.io/">crates.io</a><!-- ignore --> موجود هستند.</p>
<h3 id="رشتهها-اینقدر-ساده-نیستند"><a class="header" href="#رشتهها-اینقدر-ساده-نیستند">رشته‌ها اینقدر ساده نیستند</a></h3>
<p>به طور خلاصه، رشته‌ها پیچیده هستند. زبان‌های برنامه‌نویسی مختلف انتخاب‌های متفاوتی درباره نحوه
نمایش این پیچیدگی به برنامه‌نویس می‌کنند. Rust انتخاب کرده است که مدیریت صحیح داده‌های
<code>String</code> رفتار پیش‌فرض برای تمام برنامه‌های Rust باشد، که به این معنی است که برنامه‌نویسان
باید در ابتدا بیشتر درباره مدیریت داده‌های UTF-8 فکر کنند. این معامله پیچیدگی بیشتری از رشته‌ها
را نسبت به سایر زبان‌های برنامه‌نویسی نشان می‌دهد، اما از مواجهه با خطاهای مربوط به کاراکترهای
غیر-ASCII در مراحل بعدی چرخه توسعه جلوگیری می‌کند.</p>
<p>خبر خوب این است که کتابخانه استاندارد عملکردهای زیادی را بر اساس انواع <code>String</code> و <code>&amp;str</code>
برای کمک به مدیریت صحیح این شرایط پیچیده ارائه می‌دهد. حتماً مستندات را برای متدهای مفیدی مانند
<code>contains</code> برای جستجو در یک رشته و <code>replace</code> برای جایگزینی بخش‌هایی از یک رشته با رشته‌ای دیگر
بررسی کنید.</p>
<p>بیایید به چیزی کمی کمتر پیچیده برویم: هش مپ‌ها!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
