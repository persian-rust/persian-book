<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>بازسازی برای بهبود ماژولاریت و مدیریت خطا - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refactoring-to-improve-modularity-and-error-handling"><a class="header" href="#refactoring-to-improve-modularity-and-error-handling">Refactoring to Improve Modularity and Error Handling</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors. First, our <code>main</code>
function now performs two tasks: it parses arguments and reads files. As our
program grows, the number of separate tasks the <code>main</code> function handles will
increase. As a function gains responsibilities, it becomes more difficult to
reason about, harder to test, and harder to change without breaking one of its
parts. It’s best to separate functionality so each function is responsible for
one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>file_path</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints <code>Should have been able to read the file</code>. Reading a file can fail in a number of ways: for
example, the file could be missing, or we might not have permission to open it.
Right now, regardless of the situation, we’d print the same error message for
everything, which wouldn’t give the user any information!</p>
<p>Fourth, we use <code>expect</code> to handle an error, and if the user runs our program
without specifying enough arguments, they’ll get an <code>index out of bounds</code> error
from Rust that doesn’t clearly explain the problem. It would be best if all the
error-handling code were in one place so future maintainers had only one place
to consult the code if the error-handling logic needed to change. Having all the
error-handling code in one place will also ensure that we’re printing messages
that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<h3 id="separation-of-concerns-for-binary-projects"><a class="header" href="#separation-of-concerns-for-binary-projects">Separation of Concerns for Binary Projects</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed guidelines for splitting the separate concerns of a
binary program when <code>main</code> starts getting large. This process has the following
steps:</p>
<ul>
<li>Split your program into a <em>main.rs</em> file and a <em>lib.rs</em> file and move your
program’s logic to <em>lib.rs</em>.</li>
<li>As long as your command line parsing logic is small, it can remain in
<em>main.rs</em>.</li>
<li>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it into functions in <em>lib.rs</em>. The code that
remains in <em>main.rs</em> will be small enough to verify its correctness by reading
it. Let’s rework our program by following this process.</p>
<h4 id="extracting-the-argument-parser"><a class="header" href="#extracting-the-argument-parser">Extracting the Argument Parser</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<figure class="listing" id="listing-12-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption><a href="#listing-12-5">Listing 12-5</a>: استخراج تابع <code>parse_config</code> از <code>main</code></figcaption>
</figure>
<p>ما همچنان آرگومان‌های خط فرمان را به یک بردار جمع‌آوری می‌کنیم، اما به جای اینکه مقدار آرگومان در اندیس (index)۱ را به متغیر <code>query</code> و مقدار آرگومان در اندیس (index)۲ را به متغیر <code>file_path</code> در تابع <code>main</code> اختصاص دهیم، کل بردار را به تابع <code>parse_config</code> ارسال می‌کنیم. تابع <code>parse_config</code> سپس منطق مشخص می‌کند که کدام آرگومان در کدام متغیر قرار می‌گیرد و مقادیر را به تابع <code>main</code> بازمی‌گرداند. ما همچنان متغیرهای <code>query</code> و <code>file_path</code> را در <code>main</code> ایجاد می‌کنیم، اما <code>main</code> دیگر مسئول تعیین ارتباط آرگومان‌های خط فرمان و متغیرها نیست.</p>
<p>این تغییر ممکن است برای برنامه کوچک ما زیاده‌روی به نظر برسد، اما ما در حال بازسازی کد به صورت گام‌های کوچک و تدریجی هستیم. پس از اعمال این تغییر، دوباره برنامه را اجرا کنید تا اطمینان حاصل کنید که تجزیه آرگومان همچنان کار می‌کند. بررسی مداوم پیشرفت کد کمک می‌کند تا در صورت بروز مشکلات، علت آن‌ها را سریع‌تر شناسایی کنید.</p>
<h4 id="گروهبندی-مقادیر-پیکربندی"><a class="header" href="#گروهبندی-مقادیر-پیکربندی">گروه‌بندی مقادیر پیکربندی</a></h4>
<p>می‌توانیم یک گام کوچک دیگر برای بهبود بیشتر تابع <code>parse_config</code> برداریم. در حال حاضر، ما یک tuple بازمی‌گردانیم، اما بلافاصله آن tuple را به قسمت‌های جداگانه تقسیم می‌کنیم. این نشانه‌ای است که شاید هنوز انتزاع درستی نداریم.</p>
<p>نشانه دیگری که نشان می‌دهد جا برای بهبود وجود دارد، قسمت <code>config</code> در <code>parse_config</code> است، که نشان می‌دهد دو مقداری که بازمی‌گردانیم به هم مرتبط هستند و هر دو بخشی از یک مقدار پیکربندی هستند. ما در حال حاضر این معنا را در ساختار داده‌ها به جز با گروه‌بندی دو مقدار در یک tuple منتقل نمی‌کنیم؛ در عوض، این دو مقدار را در یک struct قرار می‌دهیم و به هر یک از فیلدهای struct نامی معنادار می‌دهیم. انجام این کار درک نحوه ارتباط مقادیر مختلف و هدف آن‌ها را برای نگهداری‌کنندگان آینده این کد آسان‌تر می‌کند.</p>
<p>لیست ۱۲-۶ بهبودهای تابع <code>parse_config</code> را نشان می‌دهد.</p>
<figure class="listing" id="listing-12-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption><a href="#listing-12-6">Listing 12-6</a>: بازسازی <code>parse_config</code> برای بازگرداندن یک نمونه از struct <code>Config</code></figcaption>
</figure>
<p>ما یک ساختار جدید به نام <code>Config</code> تعریف کرده‌ایم که دارای فیلدهایی با نام‌های <code>query</code> و <code>file_path</code> است. امضای تابع <code>parse_config</code> اکنون نشان می‌دهد که این تابع یک مقدار <code>Config</code> را بازمی‌گرداند. در بدنه تابع <code>parse_config</code>، جایی که قبلاً اسلایس‌های رشته‌ای را که به مقادیر <code>String</code> در <code>args</code> اشاره می‌کردند بازمی‌گرداندیم، اکنون <code>Config</code> را طوری تعریف می‌کنیم که دارای مقادیر <code>String</code> متعلق به خود باشد.</p>
<p>متغیر <code>args</code> در تابع <code>main</code> مالک مقادیر آرگومان است و فقط به تابع <code>parse_config</code> اجازه قرض گرفتن آن‌ها را می‌دهد، به این معنی که اگر <code>Config</code> بخواهد مالک مقادیر در <code>args</code> شود، قوانین قرض‌گیری Rust را نقض می‌کنیم.</p>
<p>چندین روش برای مدیریت داده‌های <code>String</code> وجود دارد؛ ساده‌ترین و شاید ناکارآمدترین روش، فراخوانی متد <code>clone</code> روی مقادیر است. این کار یک کپی کامل از داده‌ها برای نمونه <code>Config</code> ایجاد می‌کند که مالک آن است. این روش زمان و حافظه بیشتری نسبت به ذخیره یک مرجع به داده‌ها نیاز دارد. با این حال، کپی کردن داده‌ها باعث می‌شود که کد ما بسیار ساده شود زیرا نیازی به مدیریت طول عمر مراجع نداریم؛ در این شرایط، از دست دادن کمی کارایی برای دستیابی به سادگی ارزشمند است.</p>
<section class="note" aria-role="note">
<h3 id="هزینهها-و-مزایای-استفاده-از-clone"><a class="header" href="#هزینهها-و-مزایای-استفاده-از-clone">هزینه‌ها و مزایای استفاده از <code>clone</code></a></h3>
<p>در بین بسیاری از برنامه‌نویسان Rust، تمایلی به استفاده از <code>clone</code> برای رفع مشکلات مالکیت به دلیل هزینه اجرای آن وجود دارد. در <a href="ch13-00-functional-features.html">فصل ۱۳</a><!-- ignore -->، یاد خواهید گرفت که چگونه در این نوع موقعیت‌ها از روش‌های کارآمدتر استفاده کنید. اما در حال حاضر، کپی کردن چند رشته برای ادامه پیشرفت اشکالی ندارد زیرا این کپی‌ها فقط یک‌بار انجام می‌شوند و مسیر فایل و رشته جستجوی شما بسیار کوچک هستند. بهتر است یک برنامه کارا که کمی ناکارآمد است داشته باشید تا اینکه در اولین تلاش خود برای نوشتن کد، بهینه‌سازی بیش از حد انجام دهید. با تجربه بیشتر در Rust، شروع با راه‌حل کارآمدتر آسان‌تر خواهد بود، اما در حال حاضر استفاده از <code>clone</code> کاملاً قابل قبول است.</p>
</section>
<p>ما تابع <code>main</code> را به‌روزرسانی کردیم تا نمونه‌ای از <code>Config</code> که توسط <code>parse_config</code> بازگردانده می‌شود را در یک متغیر به نام <code>config</code> قرار دهد، و کدی که قبلاً از متغیرهای جداگانه <code>query</code> و <code>file_path</code> استفاده می‌کرد، اکنون از فیلدهای موجود در struct <code>Config</code> استفاده می‌کند.</p>
<p>اکنون کد ما به‌وضوح نشان می‌دهد که <code>query</code> و <code>file_path</code> به هم مرتبط هستند و هدف آن‌ها تنظیم نحوه کار برنامه است. هر کدی که از این مقادیر استفاده می‌کند می‌داند که باید آن‌ها را در نمونه <code>config</code> در فیلدهایی که نام آن‌ها برای هدفشان انتخاب شده است، پیدا کند.</p>
<h4 id="ایجاد-سازنده-برای-config"><a class="header" href="#ایجاد-سازنده-برای-config">ایجاد سازنده برای <code>Config</code></a></h4>
<p>تا اینجا، منطق مسئول تجزیه آرگومان‌های خط فرمان را از <code>main</code> استخراج کرده و در تابع <code>parse_config</code> قرار داده‌ایم. این کار به ما کمک کرد ببینیم که مقادیر <code>query</code> و <code>file_path</code> به هم مرتبط هستند و این رابطه باید در کد ما منتقل شود. سپس یک struct به نام <code>Config</code> اضافه کردیم تا هدف مشترک <code>query</code> و <code>file_path</code> را نام‌گذاری کنیم و بتوانیم نام مقادیر را به‌عنوان فیلدهای struct از تابع <code>parse_config</code> بازگردانیم.</p>
<p>حالا که هدف تابع <code>parse_config</code> ایجاد یک نمونه از <code>Config</code> است، می‌توانیم <code>parse_config</code> را از یک تابع معمولی به یک تابع با نام <code>new</code> تغییر دهیم که به struct <code>Config</code> مرتبط است. این تغییر کد را به‌صورت idiomatic‌تر می‌کند. ما می‌توانیم نمونه‌هایی از انواع موجود در کتابخانه استاندارد، مانند <code>String</code>، را با فراخوانی <code>String::new</code> ایجاد کنیم. به همین ترتیب، با تغییر <code>parse_config</code> به تابع <code>new</code> مرتبط با <code>Config</code>، می‌توانیم نمونه‌هایی از <code>Config</code> را با فراخوانی <code>Config::new</code> ایجاد کنیم. لیست ۱۲-۷ تغییرات لازم را نشان می‌دهد.</p>
<figure class="listing" id="listing-12-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption><a href="#listing-12-7">Listing 12-7</a>: تغییر <code>parse_config</code> به <code>Config::new</code></figcaption>
</figure>
<p>ما تابع <code>main</code> را که در آن <code>parse_config</code> را فراخوانی می‌کردیم به‌روزرسانی کرده‌ایم تا به‌جای آن <code>Config::new</code> را فراخوانی کند. نام <code>parse_config</code> را به <code>new</code> تغییر داده و آن را در یک بلوک <code>impl</code> قرار داده‌ایم که تابع <code>new</code> را به <code>Config</code> مرتبط می‌کند. کد را دوباره کامپایل کنید تا مطمئن شوید که کار می‌کند.</p>
<h3 id="رفع-مشکلات-مدیریت-خطا"><a class="header" href="#رفع-مشکلات-مدیریت-خطا">رفع مشکلات مدیریت خطا</a></h3>
<p>حالا روی رفع مشکلات مدیریت خطا کار می‌کنیم. به خاطر بیاورید که تلاش برای دسترسی به مقادیر موجود در بردار <code>args</code> در اندیس (index)۱ یا ۲ باعث می‌شود برنامه در صورت داشتن کمتر از سه آیتم، دچار وحشت شود. برنامه را بدون هیچ آرگومانی اجرا کنید؛ این حالت به شکل زیر خواهد بود:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>خط <code>index out of bounds: the len is 1 but the index is 1</code> یک پیام خطا است که برای برنامه‌نویسان در نظر گرفته شده است. این پیام به کاربران نهایی کمکی نمی‌کند تا بفهمند باید چه کار کنند. حالا این مشکل را رفع می‌کنیم.</p>
<h4 id="بهبود-پیام-خطا"><a class="header" href="#بهبود-پیام-خطا">بهبود پیام خطا</a></h4>
<p>در لیست ۱۲-۸، یک بررسی در تابع <code>new</code> اضافه می‌کنیم که بررسی می‌کند آیا آرایه به‌اندازه کافی طولانی است تا بتوان به اندیس‌های ۱ و ۲ دسترسی داشت. اگر طول آرایه کافی نباشد، برنامه دچار وحشت می‌شود و یک پیام خطای بهتر نمایش می‌دهد.</p>
<figure class="listing" id="listing-12-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-8">Listing 12-8</a>: افزودن بررسی برای تعداد آرگومان‌ها</figcaption>
</figure>
<p>این کد شبیه به <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">تابع <code>Guess::new</code> که در لیست ۹-۱۳ نوشتیم</a><!-- ignore --> است، جایی که وقتی آرگومان <code>value</code> خارج از محدوده مقادیر معتبر بود، <code>panic!</code> فراخوانی کردیم. به جای بررسی محدوده مقادیر، در اینجا بررسی می‌کنیم که طول <code>args</code> حداقل برابر با <code>3</code> باشد و بقیه تابع می‌تواند با فرض اینکه این شرط برقرار شده است، عمل کند. اگر <code>args</code> کمتر از سه آیتم داشته باشد، این شرط <code>true</code> خواهد بود و ما ماکرو <code>panic!</code> را برای خاتمه برنامه بلافاصله فراخوانی می‌کنیم.</p>
<p>با این چند خط اضافی در <code>new</code>، بیایید دوباره برنامه را بدون هیچ آرگومانی اجرا کنیم تا ببینیم اکنون پیام خطا چگونه است:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>این خروجی بهتر است: اکنون یک پیام خطای منطقی داریم. با این حال، هنوز اطلاعات اضافی داریم که نمی‌خواهیم به کاربران خود ارائه دهیم. شاید تکنیکی که در لیست ۹-۱۳ استفاده کردیم بهترین گزینه برای اینجا نباشد: یک فراخوانی به <code>panic!</code> برای مشکل برنامه‌نویسی مناسب‌تر است تا یک مشکل استفاده، <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">همان‌طور که در فصل ۹ بحث شد</a><!-- ignore -->. در عوض، از تکنیک دیگری که در فصل ۹ یاد گرفتید استفاده می‌کنیم—<a href="ch09-02-recoverable-errors-with-result.html">بازگرداندن یک <code>Result</code></a><!-- ignore --> که نشان‌دهنده موفقیت یا خطا است.</p>
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="بازگرداندن-یک-result-به-جای-فراخوانی-panic"><a class="header" href="#بازگرداندن-یک-result-به-جای-فراخوانی-panic">بازگرداندن یک <code>Result</code> به جای فراخوانی <code>panic!</code></a></h4>
<p>ما می‌توانیم به جای آن، یک مقدار <code>Result</code> بازگردانیم که در صورت موفقیت شامل یک نمونه از <code>Config</code> باشد و در صورت خطا مشکل را توصیف کند. همچنین قصد داریم نام تابع را از <code>new</code> به <code>build</code> تغییر دهیم زیرا بسیاری از برنامه‌نویسان انتظار دارند که توابع <code>new</code> هرگز شکست نخورند. وقتی <code>Config::build</code> با <code>main</code> ارتباط برقرار می‌کند، می‌توانیم از نوع <code>Result</code> برای اعلام مشکل استفاده کنیم. سپس می‌توانیم <code>main</code> را تغییر دهیم تا یک واریانت <code>Err</code> را به یک پیام خطای عملی‌تر برای کاربران خود تبدیل کنیم، بدون متن‌های اضافی مربوط به <code>thread 'main'</code> و <code>RUST_BACKTRACE</code> که یک فراخوانی به <code>panic!</code> ایجاد می‌کند.</p>
<p>لیست ۱۲-۹ تغییراتی را که باید در مقدار بازگشتی تابع که اکنون آن را <code>Config::build</code> می‌نامیم و بدنه تابع برای بازگرداندن یک <code>Result</code> ایجاد کنیم، نشان می‌دهد. توجه داشته باشید که این کد تا زمانی که <code>main</code> را نیز به‌روزرسانی نکنیم کامپایل نمی‌شود، که این کار را در لیست بعدی انجام خواهیم داد.</p>
<figure class="listing" id="listing-12-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption><a href="#listing-12-9">Listing 12-9</a>: بازگرداندن یک <code>Result</code> از <code>Config::build</code></figcaption>
</figure>
<h4 id="تابع-build-و-بازگشت-مقدار-result"><a class="header" href="#تابع-build-و-بازگشت-مقدار-result">تابع <code>build</code> و بازگشت مقدار <code>Result</code></a></h4>
<p>تابع <code>build</code> ما اکنون یک مقدار <code>Result</code> را بازمی‌گرداند که در صورت موفقیت شامل یک نمونه از <code>Config</code> و در صورت خطا یک مقدار رشته‌ای ثابت (<code>string literal</code>) است. مقادیر خطای ما همیشه رشته‌های ثابت با طول عمر <code>'static</code> خواهند بود.</p>
<p>ما دو تغییر در بدنه تابع ایجاد کرده‌ایم: به جای فراخوانی <code>panic!</code> زمانی که کاربر آرگومان‌های کافی ارائه نمی‌دهد، اکنون یک مقدار <code>Err</code> بازمی‌گردانیم و مقدار بازگشتی <code>Config</code> را در یک <code>Ok</code> قرار داده‌ایم. این تغییرات باعث می‌شوند تابع با امضای نوع جدید خود سازگار باشد.</p>
<p>بازگرداندن مقدار <code>Err</code> از <code>Config::build</code> به تابع <code>main</code> اجازه می‌دهد که مقدار <code>Result</code> بازگشتی از تابع <code>build</code> را مدیریت کرده و در صورت بروز خطا، فرآیند را به شکلی تمیزتر خاتمه دهد.</p>
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="فراخوانی-configbuild-و-مدیریت-خطاها"><a class="header" href="#فراخوانی-configbuild-و-مدیریت-خطاها">فراخوانی <code>Config::build</code> و مدیریت خطاها</a></h4>
<p>برای مدیریت حالت خطا و چاپ یک پیام دوستانه برای کاربر، باید تابع <code>main</code> را به‌روزرسانی کنیم تا مقدار <code>Result</code> بازگردانده‌شده توسط <code>Config::build</code> را مدیریت کند. این کار در لیست ۱۲-۱۰ نشان داده شده است. همچنین مسئولیت خاتمه دادن ابزار خط فرمان با کد خطای غیر صفر را از <code>panic!</code> گرفته و به صورت دستی پیاده‌سازی خواهیم کرد. کد خروجی غیر صفر به عنوان یک قرارداد برای اعلام وضعیت خطا به فرآیندی که برنامه ما را فراخوانده است، استفاده می‌شود.</p>
<figure class="listing" id="listing-12-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-10">Listing 12-10</a>: خروج با کد خطا در صورت شکست در ساخت یک <code>Config</code></figcaption>
</figure>
<p>در این لیستینگ، ما از متدی استفاده کرده‌ایم که هنوز جزئیات آن را به‌طور کامل پوشش نداده‌ایم: <code>unwrap_or_else</code>. این متد که در استاندارد کتابخانه Rust برای <code>Result&lt;T, E&gt;</code> تعریف شده است، به ما امکان می‌دهد مدیریت خطاهای سفارشی و بدون استفاده از <code>panic!</code> را تعریف کنیم. اگر مقدار <code>Result</code> از نوع <code>Ok</code> باشد، رفتار این متد مشابه <code>unwrap</code> است: مقدار داخلی که <code>Ok</code> در خود قرار داده را بازمی‌گرداند. با این حال، اگر مقدار از نوع <code>Err</code> باشد، این متد کدی را که در <em>closure</em> تعریف کرده‌ایم اجرا می‌کند. <em>Closure</em> یک تابع ناشناس است که آن را تعریف کرده و به‌عنوان آرگومان به <code>unwrap_or_else</code> ارسال می‌کنیم.</p>
<p>ما closures را به تفصیل در <a href="ch13-00-functional-features.html">فصل ۱۳</a> توضیح خواهیم داد. فعلاً کافی است بدانید که <code>unwrap_or_else</code> مقدار داخلی <code>Err</code> را به <em>closure</em> می‌دهد. در اینجا، مقدار استاتیک <code>"not enough arguments"</code> که در لیستینگ 12-9 اضافه کردیم، به <em>closure</em> ارسال شده و به آرگومان <code>err</code> تخصیص داده می‌شود، که بین خط عمودی‌ها قرار دارد. کد درون <em>closure</em> سپس می‌تواند از مقدار <code>err</code> استفاده کند.</p>
<p>ما همچنین یک خط جدید <code>use</code> اضافه کرده‌ایم تا <code>process</code> را از کتابخانه استاندارد به محدوده بیاوریم. کدی که در حالت خطا اجرا می‌شود تنها شامل دو خط است: ابتدا مقدار <code>err</code> را چاپ می‌کنیم و سپس <code>process::exit</code> را فراخوانی می‌کنیم. تابع <code>process::exit</code> بلافاصله برنامه را متوقف کرده و عددی که به‌عنوان کد وضعیت خروج ارسال شده است را بازمی‌گرداند. این روش شبیه مدیریت مبتنی بر <code>panic!</code> است که در لیستینگ 12-8 استفاده کردیم، اما دیگر خروجی اضافی تولید نمی‌شود. حالا آن را آزمایش کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>عالی! این خروجی برای کاربران ما بسیار دوستانه‌تر است.</p>
<h3 id="extracting-logic-from-main"><a class="header" href="#extracting-logic-from-main">Extracting Logic from <code>main</code></a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in <a href="#separation-of-concerns-for-binary-projects">“Separation of Concerns for Binary
Projects”</a><!-- ignore -->, we’ll
extract a function named <code>run</code> that will hold all the logic currently in the
<code>main</code> function that isn’t involved with setting up configuration or handling
errors. When we’re done, <code>main</code> will be concise and easy to verify by
inspection, and we’ll be able to write tests for all the other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>.</p>
<figure class="listing" id="listing-12-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-11">Listing 12-11</a>: استخراج تابع <code>run</code> از <code>main</code></figcaption>
</figure>
<p>با این تغییرات، <code>main</code> اکنون تابع <code>run</code> را فراخوانی می‌کند و مسئولیت اجرای منطق اصلی برنامه را به آن واگذار می‌کند. این جداسازی باعث می‌شود تابع <code>main</code> ساده‌تر شود و ما بتوانیم تست‌های دقیقی برای بخش‌های مختلف کد بنویسیم. این روش به بهبود قابلیت نگهداری و خوانایی کد کمک شایانی می‌کند.</p>
<h3 id="بازگرداندن-خطاها-از-تابع-run"><a class="header" href="#بازگرداندن-خطاها-از-تابع-run">بازگرداندن خطاها از تابع <code>run</code></a></h3>
<p>اکنون که منطق باقی‌مانده برنامه را در تابع <code>run</code> جدا کرده‌ایم، می‌توانیم مانند <code>Config::build</code> در لیستینگ 12-9، مدیریت خطا را بهبود بخشیم. به جای اجازه دادن به برنامه برای اجرای <code>panic</code> با فراخوانی <code>expect</code>، تابع <code>run</code> در صورت بروز مشکل یک <code>Result&lt;T, E&gt;</code> بازمی‌گرداند. این رویکرد به ما امکان می‌دهد منطق مرتبط با مدیریت خطا را به صورت کاربرپسندانه‌ای در تابع <code>main</code> متمرکز کنیم. تغییرات لازم برای امضا و بدنه تابع <code>run</code> در لیستینگ 12-12 نشان داده شده است:</p>
<figure class="listing" id="listing-12-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-12">Listing 12-12</a>: تغییر تابع <code>run</code> برای بازگرداندن <code>Result</code></figcaption>
</figure>
<h3 id="تغییرات-مهم"><a class="header" href="#تغییرات-مهم">تغییرات مهم</a></h3>
<ul dir="rtl">
  <li>
    <strong>تغییر نوع بازگشتی:</strong>  
    نوع بازگشتی تابع <code>run</code> به <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> تغییر داده شده است. این تابع قبلاً نوع واحد (<code>()</code>) را بازمی‌گرداند، که همچنان برای حالت موفقیت حفظ شده است.  
    برای نوع خطا از یک <strong>شیء صفات</strong> به نام <code>Box&lt;dyn Error&gt;</code> استفاده کرده‌ایم (و با استفاده از <code>use</code>، <code>std::error::Error</code> را به محدوده آورده‌ایم). در فصل 18 بیشتر درباره شیء صفات صحبت خواهیم کرد. فعلاً کافی است بدانید که <code>Box&lt;dyn Error&gt;</code> به این معنا است که تابع می‌تواند نوعی از مقدار را که صفت <code>Error</code> را پیاده‌سازی کرده بازگرداند، بدون اینکه نوع خاصی را مشخص کند. کلمه کلیدی <code>dyn</code> به معنای <strong>دینامیک</strong> است.
  </li>
  <li>
    <strong>حذف <code>expect</code> و استفاده از عملگر <code>?</code>:</strong>  
    به جای استفاده از <code>panic!</code> در صورت بروز خطا، عملگر <code>?</code> مقدار خطا را از تابع جاری بازمی‌گرداند تا فراخوانی‌کننده بتواند آن را مدیریت کند.
  </li>
  <li>
    <strong>بازگرداندن مقدار <code>Ok</code> در حالت موفقیت:</strong>  
    تابع <code>run</code> اکنون در حالت موفقیت مقدار <code>Ok</code> را بازمی‌گرداند. ما نوع موفقیت تابع را به عنوان <code>()</code> در امضا تعریف کرده‌ایم، که به این معنا است که باید مقدار نوع واحد را در مقدار <code>Ok</code> قرار دهیم. نحو <code>Ok(())</code> ممکن است در ابتدا کمی عجیب به نظر برسد، اما استفاده از <code>()</code> به این صورت روش استاندارد برای نشان دادن این است که تابع <code>run</code> تنها برای تأثیرات جانبی فراخوانی شده و مقداری بازنمی‌گرداند که به آن نیاز داشته باشیم.
  </li>
</ul>
```
<h3 id="بررسی-کد"><a class="header" href="#بررسی-کد">بررسی کد</a></h3>
<p>اجرای این کد باعث می‌شود که کد کامپایل شود اما یک هشدار نمایش دهد:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust به ما یادآوری می‌کند که کد ما مقدار <code>Result</code> را نادیده گرفته است و این مقدار ممکن است نشان‌دهنده بروز خطا باشد. اما ما بررسی نمی‌کنیم که آیا خطایی رخ داده است یا خیر، و کامپایلر به ما یادآوری می‌کند که احتمالاً نیاز به مدیریت خطا در این بخش داریم. اکنون این مشکل را اصلاح خواهیم کرد.</p>
<h4 id="مدیریت-خطاهای-بازگرداندهشده-از-run-در-main"><a class="header" href="#مدیریت-خطاهای-بازگرداندهشده-از-run-در-main">مدیریت خطاهای بازگردانده‌شده از <code>run</code> در <code>main</code></a></h4>
<p>ما خطاها را بررسی کرده و با استفاده از تکنیکی مشابه آنچه در <code>Config::build</code> در لیست ۱۲-۱۰ استفاده کردیم مدیریت می‌کنیم، اما با یک تفاوت کوچک:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ما به جای <code>unwrap_or_else</code> از <code>if let</code> استفاده می‌کنیم تا بررسی کنیم آیا <code>run</code> یک مقدار <code>Err</code> بازمی‌گرداند یا خیر و در صورت وقوع، <code>process::exit(1)</code> را فراخوانی کنیم. تابع <code>run</code> مقداری بازنمی‌گرداند که بخواهیم به همان شیوه‌ای که <code>Config::build</code> نمونه <code>Config</code> را بازمی‌گرداند آن را <code>unwrap</code> کنیم. از آنجایی که <code>run</code> در صورت موفقیت مقدار <code>()</code> بازمی‌گرداند، ما فقط به شناسایی یک خطا اهمیت می‌دهیم، بنابراین نیازی به <code>unwrap_or_else</code> برای بازگرداندن مقدار آن نداریم، که تنها <code>()</code> خواهد بود.</p>
<p>بدنه‌های <code>if let</code> و <code>unwrap_or_else</code> در هر دو حالت یکسان هستند: ما خطا را چاپ کرده و خارج می‌شویم.</p>
<h3 id="splitting-code-into-a-library-crate"><a class="header" href="#splitting-code-into-a-library-crate">Splitting Code into a Library Crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file. That way, we
can test the code and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t in the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::build</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify <em>src/main.rs</em> in Listing 12-14.</p>
<figure class="listing" id="listing-12-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    unimplemented!();
}</code></pre>
<figcaption><a href="#listing-12-13">Listing 12-13</a>: Moving <code>Config</code> and <code>run</code> into <em>src/lib.rs</em></figcaption>
</figure>
<p>We’ve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its
<code>build</code> method, and on the <code>run</code> function. We now have a library crate that has
a public API we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>
<figure class="listing" id="listing-12-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>// --snip--
use minigrep::search;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="#listing-12-14">Listing 12-14</a>: Using the <code>minigrep</code> library crate in <em>src/main.rs</em></figcaption>
</figure>
<p>We add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type from the
library crate into the binary crate’s scope, and we prefix the <code>run</code> function
with our crate name. Now all the functionality should be connected and should
work. Run the program with <code>cargo run</code> and make sure everything works correctly.</p>
<p>وای! این یک کار سخت بود، اما ما خودمان را برای موفقیت در آینده آماده کردیم. اکنون مدیریت خطاها بسیار آسان‌تر شده است و کد ما ماژولارتر شده است. از اینجا به بعد تقریباً تمام کارهای ما در فایل <em>src/lib.rs</em> انجام خواهد شد.</p>
<p>بیایید از این ماژولاریت جدید برای انجام کاری استفاده کنیم که با کد قبلی دشوار بود اما با کد جدید آسان است: نوشتن چند تست!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
