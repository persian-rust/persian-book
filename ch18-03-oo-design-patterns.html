<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>پیاده‌سازی یک الگوی طراحی شی‌گرا - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="پیادهسازی-یک-الگوی-طراحی-شیگرا"><a class="header" href="#پیادهسازی-یک-الگوی-طراحی-شیگرا">پیاده‌سازی یک الگوی طراحی شی‌گرا</a></h2>
<p><em>الگوی وضعیت</em> یک الگوی طراحی شی‌گرا است. هسته این الگو این است که مجموعه‌ای از وضعیت‌ها را که یک مقدار می‌تواند
به‌طور داخلی داشته باشد، تعریف کنیم. این وضعیت‌ها با مجموعه‌ای از <em>اشیای وضعیت</em> نمایش داده می‌شوند و رفتار مقدار
بر اساس وضعیت آن تغییر می‌کند. قصد داریم مثالی از یک ساختار blog post (پست وبلاگ) را بررسی کنیم که یک فیلد برای
نگه‌داشتن وضعیت دارد. این وضعیت یک شیء از مجموعه “پیش‌نویس” (draft)، “در حال بررسی” (review)، یا “منتشرشده”
(published) خواهد بود.</p>
<p>اشیای وضعیت قابلیت‌هایی را به اشتراک می‌گذارند: در Rust، البته، ما از ساختارها (structs) و صفت‌ها (traits) به جای
اشیا و ارث‌بری استفاده می‌کنیم. هر شیء وضعیت مسئول رفتار خود و مدیریت زمانی است که باید به وضعیت دیگری تغییر کند.
مقداری که یک شیء وضعیت را نگه می‌دارد، هیچ اطلاعی از رفتارهای مختلف وضعیت‌ها یا زمان تغییر وضعیت ندارد.</p>
<p>مزیت استفاده از الگوی وضعیت این است که وقتی نیازهای تجاری برنامه تغییر می‌کنند، نیازی به تغییر کد مقداری که وضعیت
را نگه می‌دارد یا کدی که از آن مقدار استفاده می‌کند، نداریم. تنها لازم است کد داخل یکی از اشیای وضعیت را برای تغییر
قوانین آن یا شاید اضافه کردن اشیای وضعیت جدید به‌روزرسانی کنیم.</p>
<p>ابتدا الگوی وضعیت را به روش سنتی شی‌گرایی پیاده‌سازی می‌کنیم، سپس از رویکردی که در Rust طبیعی‌تر است استفاده خواهیم
کرد. بیایید به‌صورت مرحله‌به‌مرحله پیاده‌سازی یک فرآیند کاری پست وبلاگ با استفاده از الگوی وضعیت را بررسی کنیم.</p>
<p>قابلیت نهایی به این شکل خواهد بود:</p>
<ol>
<li>یک پست وبلاگ به‌صورت یک پیش‌نویس خالی شروع می‌شود.</li>
<li>وقتی پیش‌نویس تمام شد، بررسی پست درخواست می‌شود.</li>
<li>وقتی پست تأیید شد، منتشر می‌شود.</li>
<li>تنها پست‌های وبلاگی که منتشر شده‌اند متن را برای چاپ بازمی‌گردانند، بنابراین پست‌های تأییدنشده نمی‌توانند به‌طور
تصادفی منتشر شوند.</li>
</ol>
<p>هر تغییر دیگری که روی یک پست تلاش شود نباید تأثیری داشته باشد. برای مثال، اگر بخواهیم یک پست وبلاگ پیش‌نویس را
قبل از درخواست بررسی تأیید کنیم، پست باید به‌عنوان پیش‌نویس منتشرنشده باقی بماند.</p>
<p>لیستینگ 18-11 این فرآیند کاری را به‌صورت کدی نشان می‌دهد: این یک نمونه از استفاده از API است که قصد داریم در یک
crate کتابخانه‌ای به نام <code>blog</code> پیاده‌سازی کنیم. این کد هنوز کامپایل نخواهد شد زیرا هنوز crate <code>blog</code> را پیاده‌سازی
نکرده‌ایم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption>Listing 18-11: کدی که رفتار مورد نظر ما برای crate <code>blog</code> را نشان می‌دهد</figcaption>
</figure>
<p>ما می‌خواهیم به کاربر اجازه دهیم یک پست وبلاگ پیش‌نویس جدید با <code>Post::new</code> ایجاد کند. می‌خواهیم امکان اضافه کردن
متن به پست وبلاگ را فراهم کنیم. اگر فوراً بخواهیم محتوای پست را دریافت کنیم، قبل از تأیید، نباید هیچ متنی دریافت
کنیم، زیرا پست هنوز یک پیش‌نویس است. ما از <code>assert_eq!</code> در کد برای اهداف نمایشی استفاده کرده‌ایم. یک تست واحد عالی
برای این مورد این است که تأیید کنیم یک پست وبلاگ پیش‌نویس یک رشته خالی از متد <code>content</code> بازمی‌گرداند، اما قصد نداریم
برای این مثال تست بنویسیم.</p>
<p>سپس می‌خواهیم امکان درخواست بررسی برای پست فراهم شود و می‌خواهیم <code>content</code> در حین انتظار برای بررسی یک رشته خالی
بازگرداند. وقتی پست تأیید شود، باید منتشر شود، به این معنی که متن پست هنگام فراخوانی <code>content</code> بازگردانده خواهد شد.</p>
<p>توجه داشته باشید که تنها نوعی که از crate تعامل داریم، نوع <code>Post</code> است. این نوع از الگوی وضعیت استفاده خواهد کرد و
مقداری نگه می‌دارد که یکی از سه شیء وضعیت نمایش‌دهنده وضعیت‌های مختلف یک پست باشد—پیش‌نویس، در انتظار بررسی، یا
منتشرشده. تغییر از یک وضعیت به وضعیت دیگر به‌صورت داخلی در نوع <code>Post</code> مدیریت می‌شود. تغییر وضعیت‌ها در پاسخ به
متدهایی که کاربران کتابخانه ما روی نمونه <code>Post</code> فراخوانی می‌کنند اتفاق می‌افتد، اما کاربران مجبور نیستند تغییر
وضعیت‌ها را مستقیماً مدیریت کنند. همچنین، کاربران نمی‌توانند در مورد وضعیت‌ها اشتباه کنند، مانند انتشار یک پست قبل
از بررسی آن.</p>
<h3 id="تعریف-post-و-ایجاد-یک-نمونه-جدید-در-وضعیت-پیشنویس"><a class="header" href="#تعریف-post-و-ایجاد-یک-نمونه-جدید-در-وضعیت-پیشنویس">تعریف <code>Post</code> و ایجاد یک نمونه جدید در وضعیت پیش‌نویس</a></h3>
<p>بیایید پیاده‌سازی کتابخانه را شروع کنیم! می‌دانیم که به یک ساختار <code>Post</code> عمومی نیاز داریم که مقداری محتوا را نگه
می‌دارد، بنابراین با تعریف این ساختار و یک تابع مرتبط <code>new</code> عمومی برای ایجاد یک نمونه از <code>Post</code> شروع می‌کنیم. این
تعاریف در لیستینگ 18-12 آمده‌اند. همچنین، یک صفت خصوصی <code>State</code> ایجاد خواهیم کرد که رفتاری را که تمام اشیای وضعیت
برای <code>Post</code> باید داشته باشند تعریف می‌کند.</p>
<p>سپس، <code>Post</code> یک شیء صفت <code>Box&lt;dyn State&gt;</code> را درون یک <code>Option&lt;T&gt;</code> در یک فیلد خصوصی به نام <code>state</code> نگه خواهد داشت تا
شیء وضعیت را مدیریت کند. در ادامه خواهید دید که چرا <code>Option&lt;T&gt;</code> ضروری است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<figcaption>Listing 18-12: تعریف یک ساختار <code>Post</code> و یک تابع <code>new</code> که یک نمونه جدید از <code>Post</code> ایجاد می‌کند، یک صفت <code>State</code>، و یک ساختار <code>Draft</code></figcaption>
</figure>
<p>صفت <code>State</code> رفتاری را که وضعیت‌های مختلف پست‌ها به اشتراک می‌گذارند تعریف می‌کند. اشیای وضعیت شامل <code>Draft</code>,
<code>PendingReview</code> و <code>Published</code> هستند و همه آن‌ها صفت <code>State</code> را پیاده‌سازی خواهند کرد. فعلاً صفت هیچ متدی ندارد و
ما با تعریف تنها وضعیت <code>Draft</code> شروع می‌کنیم، زیرا این وضعیت است که می‌خواهیم پست در آن شروع شود.</p>
<p>وقتی یک <code>Post</code> جدید ایجاد می‌کنیم، فیلد <code>state</code> آن را به یک مقدار <code>Some</code> تنظیم می‌کنیم که یک <code>Box</code> را نگه می‌دارد.
این <code>Box</code> به یک نمونه جدید از ساختار <code>Draft</code> اشاره می‌کند. این کار تضمین می‌کند که هرگاه یک نمونه جدید از <code>Post</code>
ایجاد شود، به‌عنوان یک پیش‌نویس شروع شود. از آنجا که فیلد <code>state</code> در <code>Post</code> خصوصی است، هیچ راهی برای ایجاد یک
<code>Post</code> در وضعیت دیگری وجود ندارد! در تابع <code>Post::new</code>، فیلد <code>content</code> را به یک <code>String</code> جدید و خالی تنظیم
می‌کنیم.</p>
<h3 id="ذخیره-متن-محتوای-پست"><a class="header" href="#ذخیره-متن-محتوای-پست">ذخیره متن محتوای پست</a></h3>
<p>در لیستینگ 18-11 دیدیم که می‌خواهیم بتوانیم یک متد به نام <code>add_text</code> فراخوانی کنیم و یک <code>&amp;str</code> به آن بدهیم که به
عنوان محتوای متنی پست وبلاگ اضافه شود. این کار را به‌صورت یک متد پیاده‌سازی می‌کنیم تا فیلد <code>content</code> را به‌جای
تعریف آن به‌صورت <code>pub</code> کنترل کنیم و بتوانیم در آینده متدی برای کنترل چگونگی خواندن داده فیلد <code>content</code>
پیاده‌سازی کنیم. متد <code>add_text</code> نسبتاً ساده است، بنابراین بیایید پیاده‌سازی آن را به بلوک <code>impl Post</code> در لیستینگ
18-13 اضافه کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption>Listing 18-13: پیاده‌سازی متد <code>add_text</code> برای افزودن متن به <code>content</code> یک پست</figcaption>
</figure>
<p>متد <code>add_text</code> یک ارجاع متغیر به <code>self</code> می‌گیرد، زیرا در حال تغییر نمونه <code>Post</code> هستیم که <code>add_text</code> روی آن فراخوانی
شده است. سپس، متد <code>push_str</code> را روی <code>String</code> موجود در <code>content</code> فراخوانی می‌کنیم و آرگومان <code>text</code> را برای افزودن
به محتوای ذخیره‌شده به آن می‌دهیم. این رفتار به وضعیتی که پست در آن قرار دارد وابسته نیست، بنابراین بخشی از الگوی
وضعیت نیست. متد <code>add_text</code> هیچ تعاملی با فیلد <code>state</code> ندارد، اما بخشی از رفتاری است که می‌خواهیم پشتیبانی کنیم.</p>
<h3 id="اطمینان-از-خالی-بودن-محتوای-یک-پست-پیشنویس"><a class="header" href="#اطمینان-از-خالی-بودن-محتوای-یک-پست-پیشنویس">اطمینان از خالی بودن محتوای یک پست پیش‌نویس</a></h3>
<p>حتی پس از فراخوانی <code>add_text</code> و افزودن محتوایی به پست، همچنان می‌خواهیم متد <code>content</code> یک برش رشته خالی بازگرداند،
زیرا پست هنوز در وضعیت پیش‌نویس است، همان‌طور که در خط 7 لیستینگ 18-11 نشان داده شده است. فعلاً متد <code>content</code> را
با ساده‌ترین چیزی که این نیاز را برآورده می‌کند پیاده‌سازی می‌کنیم: همیشه بازگرداندن یک برش رشته خالی. بعداً این را
تغییر خواهیم داد تا قابلیت تغییر وضعیت پست به حالت منتشرشده را اضافه کنیم. تاکنون، پست‌ها فقط می‌توانند در وضعیت
پیش‌نویس باشند، بنابراین محتوای پست باید همیشه خالی باشد. لیستینگ 18-14 این پیاده‌سازی موقت را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption>Listing 18-14: افزودن یک پیاده‌سازی موقت برای متد <code>content</code> در <code>Post</code> که همیشه یک برش رشته خالی بازمی‌گرداند</figcaption>
</figure>
<p>با افزودن این متد <code>content</code>، تمام موارد تا خط 7 لیستینگ 18-11 به درستی کار می‌کنند.</p>
<h3 id="درخواست-بررسی-پست-و-تغییر-وضعیت-آن"><a class="header" href="#درخواست-بررسی-پست-و-تغییر-وضعیت-آن">درخواست بررسی پست و تغییر وضعیت آن</a></h3>
<p>در مرحله بعد، باید قابلیت درخواست بررسی پست را اضافه کنیم، که باید وضعیت آن را از <code>Draft</code> به <code>PendingReview</code>
تغییر دهد. لیستینگ 18-15 این کد را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption>Listing 18-15: پیاده‌سازی متدهای <code>request_review</code> برای <code>Post</code> و صفت <code>State</code></figcaption>
</figure>
<p>ما یک متد عمومی به نام <code>request_review</code> به <code>Post</code> اضافه می‌کنیم که یک ارجاع متغیر به <code>self</code> می‌گیرد. سپس یک متد
داخلی <code>request_review</code> را روی وضعیت فعلی <code>Post</code> فراخوانی می‌کنیم، و این متد دوم وضعیت فعلی را مصرف کرده و یک وضعیت
جدید بازمی‌گرداند.</p>
<p>ما متد <code>request_review</code> را به صفت <code>State</code> اضافه می‌کنیم؛ تمام انواعی که این صفت را پیاده‌سازی می‌کنند اکنون باید
متد <code>request_review</code> را پیاده‌سازی کنند. توجه داشته باشید که به جای <code>self</code>، <code>&amp;self</code> یا <code>&amp;mut self</code> به‌عنوان اولین
پارامتر متد، از <code>self: Box&lt;Self&gt;</code> استفاده کرده‌ایم. این نحو به این معنی است که متد فقط زمانی معتبر است که روی
یک <code>Box</code> نگه‌دارنده نوع فراخوانی شود. این نحو مالکیت <code>Box&lt;Self&gt;</code> را می‌گیرد و وضعیت قدیمی را باطل می‌کند تا مقدار
وضعیت <code>Post</code> بتواند به یک وضعیت جدید تبدیل شود.</p>
<p>برای مصرف وضعیت قدیمی، متد <code>request_review</code> نیاز به گرفتن مالکیت مقدار وضعیت دارد. اینجاست که <code>Option</code> در فیلد
<code>state</code> از <code>Post</code> وارد عمل می‌شود: ما متد <code>take</code> را فراخوانی می‌کنیم تا مقدار <code>Some</code> را از فیلد <code>state</code> خارج کرده
و یک مقدار <code>None</code> به جای آن قرار دهیم، زیرا Rust به ما اجازه نمی‌دهد فیلدهای ساختار را بدون مقدار رها کنیم. این
کار به ما امکان می‌دهد مقدار <code>state</code> را از <code>Post</code> منتقل کنیم، نه اینکه آن را قرض بگیریم. سپس مقدار <code>state</code> پست را
به نتیجه این عملیات تنظیم خواهیم کرد.</p>
<p>باید به‌طور موقت <code>state</code> را به <code>None</code> تنظیم کنیم، نه اینکه مستقیماً آن را با کدی مانند
<code>self.state = self.state.request_review();</code> تنظیم کنیم، تا مالکیت مقدار <code>state</code> را بدست آوریم. این کار اطمینان
می‌دهد که <code>Post</code> نمی‌تواند از مقدار قدیمی <code>state</code> پس از تبدیل آن به یک وضعیت جدید استفاده کند.</p>
<p>متد <code>request_review</code> در <code>Draft</code> یک نمونه جدید از ساختار <code>PendingReview</code> را که نشان‌دهنده وضعیت زمانی است که یک
پست منتظر بررسی است بازمی‌گرداند. ساختار <code>PendingReview</code> نیز متد <code>request_review</code> را پیاده‌سازی می‌کند، اما هیچ
تبدیلی انجام نمی‌دهد. بلکه خودش را بازمی‌گرداند، زیرا وقتی برای یک پست در وضعیت <code>PendingReview</code> درخواست بررسی
می‌کنیم، باید در همان وضعیت باقی بماند.</p>
<p>اکنون می‌توانیم مزایای الگوی وضعیت را مشاهده کنیم: متد <code>request_review</code> در <code>Post</code> بدون توجه به مقدار <code>state</code> آن
یکسان است. هر وضعیت مسئول قوانین خاص خود است.</p>
<p>ما متد <code>content</code> در <code>Post</code> را به همان صورت باقی می‌گذاریم که یک برش رشته خالی بازمی‌گرداند. اکنون می‌توانیم
یک <code>Post</code> در وضعیت <code>PendingReview</code> و همچنین در وضعیت <code>Draft</code> داشته باشیم، اما می‌خواهیم همان رفتار در وضعیت
<code>PendingReview</code> نیز باشد. لیستینگ 18-11 اکنون تا خط 10 کار می‌کند!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="افزودن-approve-برای-تغییر-رفتار-content"><a class="header" href="#افزودن-approve-برای-تغییر-رفتار-content">افزودن <code>approve</code> برای تغییر رفتار <code>content</code></a></h3>
<p>متد <code>approve</code> شبیه متد <code>request_review</code> خواهد بود: این متد مقدار <code>state</code> را به مقداری تنظیم می‌کند که وضعیت فعلی هنگام
تأیید باید داشته باشد، همان‌طور که در لیستینگ 18-16 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption>Listing 18-16: پیاده‌سازی متد <code>approve</code> در <code>Post</code> و صفت <code>State</code></figcaption>
</figure>
<p>ما متد <code>approve</code> را به صفت <code>State</code> اضافه می‌کنیم و یک ساختار جدید که صفت <code>State</code> را پیاده‌سازی می‌کند، یعنی وضعیت
<code>Published</code>، اضافه می‌کنیم.</p>
<p>مشابه کاری که <code>request_review</code> در <code>PendingReview</code> انجام می‌دهد، اگر متد <code>approve</code> را روی یک <code>Draft</code> فراخوانی کنیم،
هیچ تأثیری نخواهد داشت زیرا <code>approve</code> مقدار <code>self</code> را بازمی‌گرداند. وقتی <code>approve</code> را روی <code>PendingReview</code> فراخوانی
می‌کنیم، یک نمونه جدید از ساختار <code>Published</code> که در یک <code>Box</code> قرار دارد، بازمی‌گرداند. ساختار <code>Published</code> صفت
<code>State</code> را پیاده‌سازی می‌کند، و برای متدهای <code>request_review</code> و <code>approve</code> خودش را بازمی‌گرداند، زیرا در این موارد
پست باید در وضعیت <code>Published</code> باقی بماند.</p>
<p>اکنون باید متد <code>content</code> در <code>Post</code> را به‌روزرسانی کنیم. می‌خواهیم مقدار بازگشتی از <code>content</code> به وضعیت فعلی <code>Post</code>
بستگی داشته باشد، بنابراین می‌خواهیم <code>Post</code> این وظیفه را به متد <code>content</code> تعریف‌شده در وضعیت خود واگذار کند، همان‌طور
که در لیستینگ 18-17 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 18-17: به‌روزرسانی متد <code>content</code> در <code>Post</code> برای ارجاع به متد <code>content</code> در <code>State</code></figcaption>
</figure>
<p>چون هدف این است که تمام این قوانین در داخل ساختارهایی که صفت <code>State</code> را پیاده‌سازی می‌کنند باقی بماند، ما یک متد
<code>content</code> را روی مقدار <code>state</code> فراخوانی می‌کنیم و نمونه پست (یعنی <code>self</code>) را به‌عنوان آرگومان به آن می‌دهیم. سپس
مقداری که از متد <code>content</code> روی مقدار <code>state</code> بازمی‌گردد را بازمی‌گردانیم.</p>
<p>ما متد <code>as_ref</code> را روی <code>Option</code> فراخوانی می‌کنیم زیرا می‌خواهیم یک ارجاع به مقدار داخل <code>Option</code> داشته باشیم، نه
مالکیت مقدار. چون <code>state</code> یک <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> است، وقتی <code>as_ref</code> را فراخوانی می‌کنیم، یک
<code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> بازمی‌گردد. اگر <code>as_ref</code> را فراخوانی نکنیم، با یک خطا مواجه می‌شویم زیرا نمی‌توانیم
<code>state</code> را از <code>&amp;self</code> که به‌عنوان پارامتر به تابع داده شده است خارج کنیم.</p>
<p>سپس متد <code>unwrap</code> را فراخوانی می‌کنیم که می‌دانیم هرگز وحشت (panic) نخواهد کرد، زیرا می‌دانیم متدهای <code>Post</code>
تضمین می‌کنند که <code>state</code> همیشه یک مقدار <code>Some</code> دارد وقتی این متدها کارشان را تمام می‌کنند. این یکی از مواردی است
که در بخش <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“مواردی که شما اطلاعات بیشتری نسبت به کامپایلر دارید”</a><!-- ignore --> در فصل 9
در مورد آن صحبت کردیم، زمانی که می‌دانیم یک مقدار <code>None</code> هرگز ممکن نیست، حتی اگر کامپایلر نتواند این موضوع را
درک کند.</p>
<p>در این مرحله، وقتی <code>content</code> را روی <code>&amp;Box&lt;dyn State&gt;</code> فراخوانی می‌کنیم، تبدیل خودکار به نوع ارجاع (<code>deref coercion</code>)
روی <code>&amp;</code> و <code>Box</code> اعمال می‌شود تا متد <code>content</code> در نهایت روی نوعی که صفت <code>State</code> را پیاده‌سازی می‌کند، فراخوانی شود.
این بدان معناست که باید <code>content</code> را به تعریف صفت <code>State</code> اضافه کنیم، و اینجا جایی است که منطق مربوط به بازگرداندن
محتوا بر اساس وضعیت فعلی قرار خواهد گرفت، همان‌طور که در لیستینگ 18-18 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<figcaption>Listing 18-18: Adding the <code>content</code> method to the <code>State</code> trait</figcaption>
</figure>
<p>ما برای متد <code>content</code> یک پیاده‌سازی پیش‌فرض اضافه می‌کنیم که یک برش رشته خالی بازمی‌گرداند. این کار باعث می‌شود
نیازی به پیاده‌سازی <code>content</code> روی ساختارهای <code>Draft</code> و <code>PendingReview</code> نداشته باشیم. ساختار <code>Published</code> متد
<code>content</code> را بازنویسی کرده و مقدار موجود در <code>post.content</code> را بازمی‌گرداند.</p>
<p>توجه داشته باشید که برای این متد نیاز به حاشیه‌نویسی طول عمر داریم، همان‌طور که در فصل 10 توضیح داده شد. چون یک
ارجاع به یک <code>post</code> را به‌عنوان آرگومان می‌گیریم و یک ارجاع به بخشی از آن <code>post</code> را بازمی‌گردانیم، طول عمر ارجاع
بازگشتی به طول عمر آرگومان <code>post</code> مرتبط است.</p>
<p>و تمام—اکنون تمام لیستینگ 18-11 کار می‌کند! ما الگوی وضعیت را با قوانین مربوط به فرآیند کاری پست وبلاگ پیاده‌سازی
کرده‌ایم. منطق مربوط به قوانین در اشیای وضعیت قرار دارد، نه اینکه در سراسر <code>Post</code> پراکنده باشد.</p>
<section class="note" aria-role="note">
<h4 id="چرا-از-enum-استفاده-نکردیم"><a class="header" href="#چرا-از-enum-استفاده-نکردیم">چرا از Enum استفاده نکردیم؟</a></h4>
<p>ممکن است این سؤال برای شما پیش آمده باشد که چرا از یک <code>enum</code> با حالت‌های مختلف پست به‌عنوان متغیرها استفاده
نکردیم. این قطعاً یک راه‌حل ممکن است؛ آن را امتحان کنید و نتایج نهایی را مقایسه کنید تا ببینید کدام را ترجیح
می‌دهید! یکی از معایب استفاده از <code>enum</code> این است که هر جا مقدار <code>enum</code> بررسی می‌شود نیاز به یک عبارت <code>match</code> یا
چیزی مشابه برای مدیریت تمام متغیرهای ممکن داریم. این می‌تواند نسبت به راه‌حل اشیای صفتی که استفاده کردیم
تکراری‌تر باشد.</p>
</section>
<h3 id="مزایا-و-معایب-الگوی-وضعیت"><a class="header" href="#مزایا-و-معایب-الگوی-وضعیت">مزایا و معایب الگوی وضعیت</a></h3>
<p>ما نشان داده‌ایم که Rust قادر است الگوی وضعیت شی‌گرا را برای کپسوله کردن رفتارهای مختلف یک پست در هر حالت
پیاده‌سازی کند. متدهای <code>Post</code> هیچ اطلاعی از رفتارهای مختلف ندارند. با روشی که کد را سازمان‌دهی کرده‌ایم، تنها
باید در یک مکان به‌دنبال راه‌های مختلف رفتار یک پست منتشرشده بگردیم: پیاده‌سازی صفت <code>State</code> روی ساختار
<code>Published</code>.</p>
<p>اگر بخواهیم یک پیاده‌سازی جایگزین ایجاد کنیم که از الگوی وضعیت استفاده نمی‌کند، ممکن است به‌جای آن از عبارات
<code>match</code> در متدهای <code>Post</code> یا حتی در کد <code>main</code> استفاده کنیم که وضعیت پست را بررسی کرده و رفتار را در همان مکان‌ها
تغییر می‌دهد. این به این معناست که باید در مکان‌های مختلفی جست‌وجو کنیم تا تمام پیامدهای یک پست در حالت منتشرشده
را بفهمیم! و با اضافه شدن حالت‌های بیشتر، این موضوع فقط بدتر خواهد شد: هر یک از آن عبارات <code>match</code> نیاز به یک
شاخه دیگر خواهند داشت.</p>
<p>با الگوی وضعیت، متدهای <code>Post</code> و مکان‌هایی که از <code>Post</code> استفاده می‌کنیم نیازی به عبارات <code>match</code> ندارند، و برای
اضافه کردن یک حالت جدید، فقط کافی است یک ساختار جدید اضافه کرده و متدهای صفت را روی همان ساختار پیاده‌سازی کنیم.</p>
<p>پیاده‌سازی با استفاده از الگوی وضعیت به‌راحتی قابلیت گسترش برای اضافه کردن عملکردهای بیشتر را دارد. برای دیدن
سادگی نگهداری کدی که از الگوی وضعیت استفاده می‌کند، چند پیشنهاد زیر را امتحان کنید:</p>
<ul>
<li>یک متد <code>reject</code> اضافه کنید که وضعیت پست را از <code>PendingReview</code> به <code>Draft</code> تغییر دهد.</li>
<li>دو فراخوانی به <code>approve</code> نیاز داشته باشید تا وضعیت به <code>Published</code> تغییر کند.</li>
<li>اجازه دهید کاربران فقط زمانی که یک پست در حالت <code>Draft</code> است متن محتوا اضافه کنند. نکته: بگذارید شیء وضعیت
مسئول تغییراتی باشد که ممکن است در محتوا ایجاد شود، اما مسئول اصلاح مستقیم <code>Post</code> نباشد.</li>
</ul>
<p>یکی از معایب الگوی وضعیت این است که به دلیل اینکه وضعیت‌ها انتقال بین حالت‌ها را پیاده‌سازی می‌کنند، برخی از
وضعیت‌ها به یکدیگر وابسته هستند. اگر یک حالت دیگر بین <code>PendingReview</code> و <code>Published</code> اضافه کنیم، مانند
<code>Scheduled</code>، باید کد در <code>PendingReview</code> را تغییر دهیم تا به <code>Scheduled</code> منتقل شود. اگر نیازی نبود که
<code>PendingReview</code> با اضافه شدن یک حالت جدید تغییر کند، کار کمتری می‌داشتیم، اما این به معنای تغییر به یک الگوی
طراحی دیگر خواهد بود.</p>
<p>یکی دیگر از معایب این است که ما برخی از منطق‌ها را تکرار کرده‌ایم. برای حذف برخی از این تکرارها، ممکن است سعی
کنیم برای متدهای <code>request_review</code> و <code>approve</code> در صفت <code>State</code> پیاده‌سازی پیش‌فرضی ایجاد کنیم که <code>self</code> را
بازمی‌گرداند؛ با این حال، این با <code>dyn</code> سازگار نخواهد بود، زیرا صفت دقیقاً نمی‌داند <code>self</code> چه خواهد بود. ما
می‌خواهیم بتوانیم از <code>State</code> به‌عنوان یک شیء صفت استفاده کنیم، بنابراین متدهای آن باید با <code>dyn</code> سازگار باشند.</p>
<p>پیاده‌سازی مشابه متدهای <code>request_review</code> و <code>approve</code> روی <code>Post</code> نیز نوعی تکرار است. هر دو متد اجرای متد مشابه
روی مقدار موجود در فیلد <code>state</code> از <code>Option</code> را به آن واگذار کرده و مقدار جدید فیلد <code>state</code> را به نتیجه تنظیم
می‌کنند. اگر متدهای زیادی روی <code>Post</code> داشته باشیم که این الگو را دنبال می‌کنند، ممکن است تعریف یک ماکرو را برای حذف
این تکرار در نظر بگیریم (بخش <a href="ch20-06-macros.html#macros">“ماکروها”</a><!-- ignore --> در فصل 20 را ببینید).</p>
<p>با پیاده‌سازی الگوی وضعیت دقیقاً همان‌طور که برای زبان‌های شی‌گرا تعریف شده است، به‌طور کامل از نقاط قوت Rust
استفاده نمی‌کنیم. بیایید نگاهی به تغییراتی بیندازیم که می‌توانیم در crate <code>blog</code> ایجاد کنیم تا وضعیت‌ها و
انتقالات نامعتبر به خطاهای زمان کامپایل تبدیل شوند.</p>
<h4 id="کدگذاری-وضعیتها-و-رفتار-بهعنوان-انواع"><a class="header" href="#کدگذاری-وضعیتها-و-رفتار-بهعنوان-انواع">کدگذاری وضعیت‌ها و رفتار به‌عنوان انواع</a></h4>
<p>به شما نشان خواهیم داد که چگونه الگوی وضعیت را دوباره طراحی کنید تا مجموعه‌ای متفاوت از مزایا و معایب به دست
آورید. به‌جای اینکه وضعیت‌ها و انتقالات را کاملاً کپسوله کنیم تا کد خارجی از آن‌ها اطلاعی نداشته باشد، وضعیت‌ها را
به انواع مختلف کدگذاری می‌کنیم. در نتیجه، سیستم بررسی نوع Rust تلاش برای استفاده از پست‌های پیش‌نویس در جاهایی که
فقط پست‌های منتشرشده مجاز هستند را با صدور یک خطای کامپایلر متوقف می‌کند.</p>
<p>ابتدا قسمت اول <code>main</code> در لیستینگ 18-11 را در نظر بگیرید:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</figure>
<p>ما همچنان امکان ایجاد پست‌های جدید در وضعیت پیش‌نویس با استفاده از <code>Post::new</code> و افزودن متن به محتوای پست را فراهم
می‌کنیم. اما به‌جای داشتن متد <code>content</code> روی یک پست پیش‌نویس که یک رشته خالی بازمی‌گرداند، آن را به گونه‌ای طراحی
می‌کنیم که پست‌های پیش‌نویس اصلاً متد <code>content</code> نداشته باشند. به این ترتیب، اگر بخواهیم محتوای یک پست پیش‌نویس
را دریافت کنیم، خطای کامپایلر دریافت خواهیم کرد که به ما می‌گوید این متد وجود ندارد. در نتیجه، نمایش محتوای
پست‌های پیش‌نویس در محیط تولید به‌طور تصادفی غیرممکن می‌شود، زیرا آن کد حتی کامپایل نخواهد شد. لیستینگ 18-19
تعریف یک ساختار <code>Post</code> و یک ساختار <code>DraftPost</code> و همچنین متدهایی روی هرکدام را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<figcaption>Listing 18-19: یک <code>Post</code> با یک متد <code>content</code> و یک <code>DraftPost</code> بدون متد <code>content</code></figcaption>
</figure>
<p>هر دو ساختار <code>Post</code> و <code>DraftPost</code> دارای یک فیلد خصوصی به نام <code>content</code> هستند که متن پست وبلاگ را ذخیره می‌کند. این
ساختارها دیگر فیلد <code>state</code> ندارند زیرا کدگذاری وضعیت را به انواع ساختارها منتقل کرده‌ایم. ساختار <code>Post</code> نماینده
یک پست منتشرشده است و دارای متد <code>content</code> است که مقدار <code>content</code> را بازمی‌گرداند.</p>
<p>ما همچنان یک تابع <code>Post::new</code> داریم، اما به‌جای بازگرداندن نمونه‌ای از <code>Post</code>، یک نمونه از <code>DraftPost</code> بازمی‌گرداند.
از آنجا که <code>content</code> خصوصی است و هیچ تابعی وجود ندارد که <code>Post</code> را بازگرداند، در حال حاضر امکان ایجاد نمونه‌ای از
<code>Post</code> وجود ندارد.</p>
<p>ساختار <code>DraftPost</code> یک متد <code>add_text</code> دارد، بنابراین می‌توانیم همانند قبل متن را به <code>content</code> اضافه کنیم، اما
توجه کنید که <code>DraftPost</code> متد <code>content</code> تعریف‌شده ندارد! بنابراین اکنون برنامه تضمین می‌کند که تمام پست‌ها به‌صورت
پست‌های پیش‌نویس شروع می‌شوند و پست‌های پیش‌نویس محتوای خود را برای نمایش در دسترس ندارند. هر تلاشی برای دور زدن
این محدودیت‌ها منجر به خطای کامپایلر خواهد شد.</p>
<h4 id="پیادهسازی-انتقالها-بهعنوان-تبدیل-به-انواع-مختلف"><a class="header" href="#پیادهسازی-انتقالها-بهعنوان-تبدیل-به-انواع-مختلف">پیاده‌سازی انتقال‌ها به‌عنوان تبدیل به انواع مختلف</a></h4>
<p>چگونه می‌توانیم یک پست منتشرشده داشته باشیم؟ ما می‌خواهیم قانون را اجرا کنیم که یک پست پیش‌نویس باید بررسی و
تأیید شود قبل از اینکه بتواند منتشر شود. یک پست در حالت “در انتظار بررسی” همچنان نباید هیچ محتوایی نمایش دهد. بیایید
این محدودیت‌ها را با اضافه کردن یک ساختار دیگر به نام <code>PendingReviewPost</code>، تعریف متد <code>request_review</code> روی
<code>DraftPost</code> برای بازگرداندن یک <code>PendingReviewPost</code> و تعریف یک متد <code>approve</code> روی <code>PendingReviewPost</code> برای
بازگرداندن یک <code>Post</code>، همان‌طور که در لیستینگ 18-20 نشان داده شده است، پیاده‌سازی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<figcaption>Listing 18-20: یک <code>PendingReviewPost</code> که با فراخوانی <code>request_review</code> روی <code>DraftPost</code> ایجاد می‌شود و یک متد <code>approve</code> که یک <code>PendingReviewPost</code> را به یک <code>Post</code> منتشرشده تبدیل می‌کند</figcaption>
</figure>
<p>متدهای <code>request_review</code> و <code>approve</code> مالکیت <code>self</code> را می‌گیرند، بنابراین نمونه‌های <code>DraftPost</code> و <code>PendingReviewPost</code>
را مصرف کرده و آن‌ها را به‌ترتیب به یک <code>PendingReviewPost</code> و یک <code>Post</code> منتشرشده تبدیل می‌کنند. به این ترتیب،
پس از فراخوانی <code>request_review</code> روی یک <code>DraftPost</code> و به همین ترتیب، هیچ نمونه‌ای از <code>DraftPost</code> باقی نمی‌ماند.
ساختار <code>PendingReviewPost</code> متد <code>content</code> تعریف‌شده‌ای ندارد، بنابراین تلاش برای خواندن محتوای آن منجر به خطای
کامپایلر می‌شود، همان‌طور که در مورد <code>DraftPost</code> اتفاق می‌افتد. چون تنها راه برای گرفتن یک نمونه از <code>Post</code> منتشرشده
که متد <code>content</code> تعریف‌شده‌ای دارد، فراخوانی متد <code>approve</code> روی یک <code>PendingReviewPost</code> است، و تنها راه برای گرفتن
یک <code>PendingReviewPost</code> فراخوانی متد <code>request_review</code> روی یک <code>DraftPost</code> است، ما اکنون فرآیند کاری پست وبلاگ را به
سیستم نوع کدگذاری کرده‌ایم.</p>
<p>اما همچنین باید تغییرات کوچکی در <code>main</code> ایجاد کنیم. متدهای <code>request_review</code> و <code>approve</code> نمونه‌های جدیدی بازمی‌گردانند
به‌جای اینکه ساختاری که روی آن فراخوانی شده‌اند را تغییر دهند، بنابراین باید تخصیص‌های مجدد با <code>let post =</code> اضافه کنیم
تا نمونه‌های بازگشتی را ذخیره کنیم. همچنین نمی‌توانیم تأییدیه‌های مربوط به خالی بودن محتوای پست‌های پیش‌نویس و در
انتظار بررسی را داشته باشیم، و نیازی به آن‌ها نیست: دیگر نمی‌توانیم کدی که سعی می‌کند محتوای پست‌های در این حالت‌ها را
استفاده کند، کامپایل کنیم. کد به‌روزشده در <code>main</code> در لیستینگ 18-21 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption>Listing 18-21: تغییرات در <code>main</code> برای استفاده از پیاده‌سازی جدید فرآیند کاری پست وبلاگ</figcaption>
</figure>
<p>تغییراتی که باید در <code>main</code> برای تخصیص مجدد <code>post</code> انجام می‌دادیم، به این معناست که این پیاده‌سازی دیگر کاملاً از
الگوی وضعیت شی‌گرا پیروی نمی‌کند: انتقالات بین حالت‌ها دیگر به‌طور کامل در پیاده‌سازی <code>Post</code> کپسوله نشده‌اند.
اما، مزیت ما این است که اکنون وضعیت‌های نامعتبر به دلیل سیستم نوع و بررسی نوعی که در زمان کامپایل انجام می‌شود،
غیرممکن هستند! این تضمین می‌کند که برخی از باگ‌ها، مانند نمایش محتوای یک پست منتشرنشده، قبل از رسیدن به تولید
کشف شوند.</p>
<p>تکالیف پیشنهادی در ابتدای این بخش را روی crate <code>blog</code> همان‌طور که پس از لیستینگ 18-21 است امتحان کنید تا ببینید
درباره طراحی این نسخه از کد چه نظری دارید. توجه داشته باشید که برخی از تکالیف ممکن است در این طراحی از پیش
انجام شده باشند.</p>
<p>دیدیم که حتی با وجود اینکه Rust قادر به پیاده‌سازی الگوهای طراحی شی‌گرا است، الگوهای دیگر، مانند کدگذاری حالت
در سیستم نوع، نیز در Rust در دسترس هستند. این الگوها مزایا و معایب متفاوتی دارند. اگرچه ممکن است با الگوهای شی‌گرا
بسیار آشنا باشید، بازاندیشی مسئله برای بهره‌بردن از ویژگی‌های Rust می‌تواند مزایایی مانند جلوگیری از برخی باگ‌ها
در زمان کامپایل را فراهم کند. الگوهای شی‌گرا همیشه بهترین راه‌حل در Rust نخواهند بود، به دلیل ویژگی‌هایی مانند
مالکیت که زبان‌های شی‌گرا ندارند.</p>
<h2 id="خلاصه"><a class="header" href="#خلاصه">خلاصه</a></h2>
<p>فارغ از اینکه پس از خواندن این فصل فکر می‌کنید Rust یک زبان شی‌گرا است یا نه، اکنون می‌دانید که می‌توانید از
اشیای صفت برای دریافت برخی ویژگی‌های شی‌گرایی در Rust استفاده کنید. تخصیص پویا (Dynamic Dispatch) می‌تواند
انعطاف‌پذیری به کد شما بدهد، اما در ازای آن کمی از عملکرد زمان اجرا را قربانی می‌کند. می‌توانید از این انعطاف‌پذیری
برای پیاده‌سازی الگوهای شی‌گرا که می‌توانند به نگه‌داری کد شما کمک کنند، استفاده کنید. Rust همچنین دارای ویژگی‌های
دیگری مانند مالکیت است که زبان‌های شی‌گرا ندارند. یک الگوی شی‌گرا همیشه بهترین راه برای بهره‌بردن از نقاط قوت
Rust نخواهد بود، اما به‌عنوان یک گزینه در دسترس است.</p>
<p>در ادامه، به بررسی الگوها خواهیم پرداخت که یکی دیگر از ویژگی‌های Rust است که انعطاف‌پذیری زیادی را فراهم
می‌کنند. در طول کتاب به‌طور مختصر به آن‌ها اشاره کرده‌ایم، اما هنوز به‌طور کامل توانایی آن‌ها را ندیده‌ایم. برویم!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
