<!DOCTYPE HTML>
<html lang="fa" class="light" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>کار با تعداد دلخواهی از Futures - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، جعبه‌ها (crates)، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و جعبه‌ها (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گر (Pointer)های هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر (Pointer) هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html" class="active"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از تایپ‌های مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> تایپ‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور single-threaded</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="کار-با-هر-تعداد-آینده"><a class="header" href="#کار-با-هر-تعداد-آینده">کار با هر تعداد آینده</a></h2>
<p>وقتی در بخش قبلی از استفاده از دو آینده به سه آینده تغییر دادیم، مجبور شدیم از <code>join</code> به <code>join3</code> تغییر دهیم. این که هر بار که تعداد آینده‌هایی که می‌خواهیم منتظرشان بمانیم تغییر کند، مجبور باشیم تابع متفاوتی فراخوانی کنیم آزاردهنده است. خوشبختانه، فرم ماکروی <code>join</code> وجود دارد که می‌توانیم هر تعداد آرگومان دلخواه به آن ارسال کنیم. این ماکرو همچنین منتظر ماندن برای آینده‌ها را خود مدیریت می‌کند. بنابراین، می‌توانیم کد فهرست 17-13 را بازنویسی کنیم تا به جای <code>join3</code> از <code>join!</code> استفاده کنیم، همان‌طور که در فهرست 17-14 آمده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-14: استفاده از <code>join!</code> برای منتظر ماندن چندین آینده</figcaption>
</figure>
<p>این قطعاً بهبود خوبی نسبت به نیاز به تعویض بین <code>join</code>، <code>join3</code>، <code>join4</code> و … است! با این حال، حتی این فرم ماکرو فقط زمانی کار می‌کند که تعداد آینده‌ها را از قبل بدانیم. اما در راست دنیای واقعی، افزودن آینده‌ها به یک مجموعه و سپس منتظر ماندن برای برخی یا همه آینده‌های آن مجموعه تا تکمیل، یک الگوی رایج است.</p>
<p>برای بررسی تمام آینده‌ها در یک مجموعه، باید روی <em>همه</em> آن‌ها تکرار کرده و منتظر بمانیم. تابع <code>trpl::join_all</code> هر نوعی را که ویژگی <code>Iterator</code> را پیاده‌سازی کرده باشد می‌پذیرد، که درباره آن در فصل 13 آموختیم، بنابراین به نظر می‌رسد دقیقاً چیزی است که نیاز داریم. بیایید آینده‌های خود را در یک بردار قرار دهیم و <code>join!</code> را با <code>join_all</code> جایگزین کنیم.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-15: ذخیره آینده‌های ناشناس در یک بردار و فراخوانی <code>join_all</code></figcaption>
</figure>
<p>متأسفانه، این کد کامپایل نمی‌شود. در عوض، این خطا را دریافت می‌کنیم:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>این ممکن است تعجب‌آور باشد. بالاخره هیچ‌کدام چیزی برنمی‌گردانند، بنابراین هر بلوک یک <code>Future&lt;Output = ()&gt;</code> تولید می‌کند. با این حال، <code>Future</code> یک ویژگی (trait) است، نه یک نوع مشخص (concrete type). نوع‌های مشخص، ساختارهای داده‌ای هستند که توسط کامپایلر برای بلوک‌های async تولید می‌شوند. نمی‌توانید دو ساختار مختلف نوشته‌شده با دست را در یک <code>Vec</code> قرار دهید، و همین امر در مورد ساختارهای مختلف تولیدشده توسط کامپایلر نیز صدق می‌کند.</p>
<p>برای کار کردن این کد، باید از <em>شیءهای ویژگی</em> (trait objects) استفاده کنیم، همانطور که در <a href="ch12-03-improving-error-handling-and-modularity.html">«بازگرداندن خطاها از تابع run»</a><!-- ignore --> در فصل 12 انجام دادیم. (در فصل 18 شیءهای ویژگی را به‌طور مفصل بررسی خواهیم کرد.) استفاده از شیءهای ویژگی به ما اجازه می‌دهد که هر یک از آینده‌های ناشناس تولیدشده توسط این نوع‌ها را به‌عنوان یک نوع مشابه در نظر بگیریم، زیرا همه آن‌ها ویژگی <code>Future</code> را پیاده‌سازی می‌کنند.</p>
<blockquote>
<p>نکته: در فصل 8، روش دیگری برای شامل کردن چندین نوع در یک <code>Vec</code> را بررسی کردیم: استفاده از یک enum برای نشان دادن هر یک از نوع‌های مختلف که می‌توانند در بردار ظاهر شوند. با این حال، اینجا نمی‌توانیم از آن استفاده کنیم. اولاً، راهی برای نام‌گذاری نوع‌های مختلف نداریم، زیرا آن‌ها ناشناس هستند. ثانیاً، دلیلی که در ابتدا به بردار و <code>join_all</code> روی آوردیم این بود که بتوانیم با مجموعه‌ای پویا از آینده‌ها کار کنیم که نمی‌دانیم همه آن‌ها چه خواهند بود تا زمان اجرا.</p>
</blockquote>
<p>ابتدا هر یک از آینده‌ها در <code>vec!</code> را در یک <code>Box::new</code> قرار می‌دهیم، همانطور که در فهرست 17-16 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-16: تلاش برای استفاده از <code>Box::new</code> برای یکسان کردن نوع آینده‌ها در یک <code>Vec</code></figcaption>
</figure>
<p>متأسفانه، این همچنان کامپایل نمی‌شود. در واقع، همان خطای اصلی قبلی را دریافت می‌کنیم، اما این بار برای هر دو فراخوانی <code>Box::new</code> دوم و سوم، و همچنین خطاهای جدیدی مربوط به ویژگی <code>Unpin</code>. به خطاهای مربوط به <code>Unpin</code> در لحظه بازمی‌گردیم. ابتدا خطاهای نوع روی فراخوانی‌های <code>Box::new</code> را با صراحتاً حاشیه‌نویسی کردن نوع متغیر <code>futures</code> برطرف کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-17: برطرف کردن بقیه خطاهای ناسازگاری نوع با استفاده از اعلان صریح نوع</figcaption>
</figure>
<p>نوعی که اینجا باید می‌نوشتیم کمی پیچیده است، بنابراین بیایید آن را بررسی کنیم:</p>
<ul>
<li>نوع داخلی‌ترین، آینده خود است. به‌طور صریح بیان می‌کنیم که خروجی آینده نوع واحد <code>()</code> است، با نوشتن <code>Future&lt;Output = ()&gt;</code>.</li>
<li>سپس ویژگی را با <code>dyn</code> برای علامت‌گذاری آن به‌عنوان پویا (dynamic) حاشیه‌نویسی می‌کنیم.</li>
<li>کل مرجع ویژگی در یک <code>Box</code> قرار داده می‌شود.</li>
<li>در نهایت، به‌صراحت بیان می‌کنیم که <code>futures</code> یک <code>Vec</code> است که این آیتم‌ها را شامل می‌شود.</li>
</ul>
<p>این تغییرات تأثیر زیادی داشت. حالا وقتی کامپایلر را اجرا می‌کنیم، فقط خطاهایی که به <code>Unpin</code> اشاره دارند باقی می‌مانند. اگرچه سه خطا وجود دارند، توجه کنید که هرکدام در محتوا بسیار مشابه هستند.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/main.rs:46:46
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
24  |         let rx_fut = async {
    |                      ----- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                     -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                     |
    |                                     arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:24:22: 24:27}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0308]: mismatched types
   --&gt; src/main.rs:46:64
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
30  |         let tx_fut = async move {
    |                      ---------- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                                       -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                                       |
    |                                                       arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:30:22: 30:32}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
   --&gt; src/main.rs:48:24
    |
48  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:9
   |
48 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>این یک <em>مقدار</em> برای هضم است، بنابراین بیایید آن را جدا کنیم. بخش اول پیام به ما می‌گوید که بلوک async اول (<code>src/main.rs:8:23: 20:10</code>) ویژگی <code>Unpin</code> را پیاده‌سازی نمی‌کند و پیشنهاد می‌دهد از <code>pin!</code> یا <code>Box::pin</code> برای حل آن استفاده کنیم. بعداً در فصل، به جزئیات بیشتری درباره <code>Pin</code> و <code>Unpin</code> خواهیم پرداخت. اما فعلاً، می‌توانیم فقط از توصیه کامپایلر برای برطرف کردن مشکل پیروی کنیم! در فهرست 17-18، ابتدا با اضافه کردن حاشیه‌نویسی نوع برای <code>futures</code>، با یک <code>Pin</code> که هر <code>Box</code> را می‌پیچد، شروع می‌کنیم. دوم، از <code>Box::pin</code> برای pin کردن آینده‌ها استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-18: استفاده از <code>Pin</code> و <code>Box::pin</code> برای برطرف کردن نوع <code>Vec</code></figcaption>
</figure>
<p>اگر این کد را کامپایل و اجرا کنیم، در نهایت خروجی موردنظر خود را دریافت می‌کنیم:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>آه!</p>
<p>هنوز کمی بیشتر برای بررسی وجود دارد. برای مثال، استفاده از <code>Pin&lt;Box&lt;T&gt;&gt;</code> با مقدار کمی سربار اضافی همراه است، زیرا این آینده‌ها را با <code>Box</code> روی heap قرار می‌دهیم—و ما فقط این کار را انجام می‌دهیم تا نوع‌ها را هماهنگ کنیم. اما در واقع نیازی به تخصیص heap نداریم، زیرا این آینده‌ها محلی برای این تابع خاص هستند. همان‌طور که در بالا ذکر شد، <code>Pin</code> خود یک نوع wrapper است، بنابراین می‌توانیم از مزیت داشتن یک نوع یکتا در <code>Vec</code>—دلیل اصلی که به سمت <code>Box</code> رفتیم—بدون انجام تخصیص heap استفاده کنیم. می‌توانیم مستقیماً از <code>Pin</code> با هر آینده استفاده کنیم، با استفاده از ماکروی <code>std::pin::pin</code>.</p>
<p>با این حال، باید به‌صراحت نوع مرجع pinned را مشخص کنیم؛ در غیر این صورت، راست همچنان نمی‌داند که این‌ها را به‌عنوان شیءهای ویژگی دینامیک تفسیر کند، که همان چیزی است که برای قرار گرفتن در <code>Vec</code> نیاز داریم. بنابراین، هر آینده را وقتی تعریف می‌کنیم <code>pin!</code> می‌کنیم و <code>futures</code> را به‌عنوان یک <code>Vec</code> که شامل مراجع متغیر pinned به نوع ویژگی دینامیک <code>Future</code> است تعریف می‌کنیم، همانطور که در فهرست 17-19 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-19: استفاده مستقیم از <code>Pin</code> با ماکروی <code>pin!</code> برای اجتناب از تخصیص‌های غیرضروری heap</figcaption>
</figure>
<p>تا اینجا با نادیده گرفتن این واقعیت که ممکن است نوع‌های <code>Output</code> مختلفی داشته باشیم، پیش رفتیم. برای مثال، در فهرست 17-20، آینده ناشناس برای <code>a</code> ویژگی <code>Future&lt;Output = u32&gt;</code> را پیاده‌سازی می‌کند، آینده ناشناس برای <code>b</code> ویژگی <code>Future&lt;Output = &amp;str&gt;</code> را پیاده‌سازی می‌کند، و آینده ناشناس برای <code>c</code> ویژگی <code>Future&lt;Output = bool&gt;</code> را پیاده‌سازی می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-20: سه آینده با نوع‌های متفاوت</figcaption>
</figure>
<p>ما می‌توانیم از <code>trpl::join!</code> برای منتظر ماندن این آینده‌ها استفاده کنیم، زیرا این ماکرو به شما اجازه می‌دهد چندین نوع آینده را ارسال کنید و یک تاپل از آن نوع‌ها تولید می‌کند. ما <em>نمی‌توانیم</em> از <code>trpl::join_all</code> استفاده کنیم، زیرا این تابع نیاز دارد که همه آینده‌های ارسال‌شده به آن نوع یکسانی داشته باشند. به یاد داشته باشید، این همان خطایی است که ما را در این ماجراجویی با <code>Pin</code> شروع کرد!</p>
<p>این یک معامله اساسی است: ما می‌توانیم با یک تعداد دینامیک از آینده‌ها با <code>join_all</code> کار کنیم، تا زمانی که همه آن‌ها نوع یکسانی داشته باشند، یا می‌توانیم با یک تعداد ثابت از آینده‌ها با توابع <code>join</code> یا ماکروی <code>join!</code> کار کنیم، حتی اگر نوع‌های متفاوتی داشته باشند. این درست مثل کار با هر نوع دیگری در راست است. آینده‌ها خاص نیستند، حتی اگر سینتکس خوبی برای کار با آن‌ها داشته باشیم، و این چیز خوبی است.</p>
<h3 id="racing-futures"><a class="header" href="#racing-futures">Racing futures</a></h3>
<p>وقتی آینده‌ها را با خانواده توابع و ماکروهای <code>join</code> “منتظر می‌مانیم”، نیاز داریم <em>همه</em> آن‌ها تمام شوند قبل از اینکه به مرحله بعدی برویم. گاهی اوقات، اما، فقط نیاز داریم <em>یکی</em> از آینده‌ها از مجموعه‌ای تمام شود قبل از اینکه به مرحله بعدی برویم—کمی شبیه به مسابقه دادن یک آینده در برابر دیگری.</p>
<p>در فهرست 17-21، دوباره از <code>trpl::race</code> برای اجرای دو آینده، <code>slow</code> و <code>fast</code>، در برابر یکدیگر استفاده می‌کنیم. هرکدام پیامی را هنگام شروع اجرا چاپ می‌کنند، مدتی با فراخوانی و انتظار <code>sleep</code> متوقف می‌شوند، و سپس پیامی دیگر را هنگام اتمام چاپ می‌کنند. سپس هر دو را به <code>trpl::race</code> ارسال می‌کنیم و منتظر می‌مانیم تا یکی از آن‌ها تمام شود. (نتیجه در اینجا چندان تعجب‌آور نخواهد بود: <code>fast</code> برنده می‌شود!) برخلاف زمانی که در <a href="ch17-01-futures-and-syntax.html#our-first-async-program">«اولین برنامه async ما»</a><!-- ignore --> از <code>race</code> استفاده کردیم، اینجا نمونه <code>Either</code> که بازمی‌گرداند را نادیده می‌گیریم، زیرا تمام رفتار جالب در بدنه بلوک‌های async اتفاق می‌افتد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-21: استفاده از <code>race</code> برای دریافت نتیجه اولین آینده‌ای که تمام می‌شود</figcaption>
</figure>
<p>توجه داشته باشید که اگر ترتیب آرگومان‌ها را در <code>race</code> تغییر دهید، ترتیب پیام‌های “started” تغییر می‌کند، حتی اگر آینده <code>fast</code> همیشه زودتر تمام شود. این به این دلیل است که پیاده‌سازی این تابع خاص <code>race</code> منصفانه نیست. همیشه آینده‌هایی که به‌عنوان آرگومان ارسال شده‌اند را به ترتیبی که ارسال شده‌اند اجرا می‌کند. پیاده‌سازی‌های دیگر <em>منصفانه</em> هستند و به‌طور تصادفی انتخاب می‌کنند که کدام آینده را ابتدا بررسی (poll) کنند. با این حال، صرف‌نظر از اینکه پیاده‌سازی <code>race</code> که استفاده می‌کنیم منصفانه است یا نه، <em>یکی</em> از آینده‌ها تا اولین <code>await</code> در بدنه خود اجرا می‌شود قبل از اینکه تسک دیگری بتواند شروع شود.</p>
<p>به یاد بیاورید از <a href="ch17-01-futures-and-syntax.html#our-first-async-program">اولین برنامه async ما</a><!-- ignore --> که در هر نقطه انتظار (await point)، راست به runtime این فرصت را می‌دهد که تسک را متوقف کند و به تسک دیگری سوئیچ کند اگر آینده‌ای که منتظر آن هستید آماده نباشد. عکس آن نیز صادق است: راست <em>فقط</em> بلوک‌های async را در نقاط انتظار متوقف می‌کند و کنترل را به runtime بازمی‌گرداند. همه چیز بین نقاط انتظار همگام (synchronous) است.</p>
<p>این به این معنی است که اگر در یک بلوک async بدون نقطه انتظار کار زیادی انجام دهید، آن آینده مانع از پیشرفت سایر آینده‌ها خواهد شد. ممکن است گاهی اوقات به این موضوع به‌عنوان یک آینده که <em>آینده‌های دیگر را گرسنه</em> می‌کند اشاره شود. در برخی موارد، این ممکن است مشکل بزرگی نباشد. با این حال، اگر در حال انجام برخی تنظیمات گران‌قیمت یا کار طولانی‌مدت هستید، یا اگر آینده‌ای دارید که به‌طور نامحدود یک کار خاص انجام می‌دهد، باید در مورد زمان و مکان بازگرداندن کنترل به runtime فکر کنید.</p>
<p>به همان اندازه، اگر عملیات‌های مسدودکننده طولانی‌مدت دارید، async می‌تواند ابزاری مفید برای ارائه راه‌هایی باشد که بخش‌های مختلف برنامه بتوانند با یکدیگر تعامل داشته باشند.</p>
<p>اما در این موارد <em>چگونه</em> کنترل را به runtime بازمی‌گردانید؟</p>
<h3 id="yielding"><a class="header" href="#yielding">Yielding</a></h3>
<p>بیایید یک عملیات طولانی‌مدت را شبیه‌سازی کنیم. فهرست 17-22 یک تابع <code>slow</code> معرفی می‌کند. از <code>std::thread::sleep</code> به جای <code>trpl::sleep</code> استفاده می‌کند تا فراخوانی <code>slow</code> نخ فعلی را به مدت مشخصی از میلی‌ثانیه مسدود کند. می‌توانیم از <code>slow</code> به‌عنوان جایگزین عملیات‌های واقعی دنیای واقعی استفاده کنیم که هم طولانی‌مدت و هم مسدودکننده هستند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
<figcaption>Listing 17-22: استفاده از <code>thread::sleep</code> برای شبیه‌سازی عملیات کند</figcaption>
</figure>
<p>در فهرست 17-23، از <code>slow</code> برای شبیه‌سازی انجام این نوع کارهای وابسته به CPU در یک جفت آینده استفاده می‌کنیم. برای شروع، هر آینده فقط پس از انجام یک سری عملیات کند، کنترل را به runtime بازمی‌گرداند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-23: استفاده از <code>thread::sleep</code> برای شبیه‌سازی عملیات کند</figcaption>
</figure>
<p>اگر این کد را اجرا کنید، این خروجی را خواهید دید:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>همانطور که در مثال قبلی، <code>race</code> همچنان به محض اینکه آینده <code>a</code> کامل شود، تمام می‌شود. با این حال، هیچ درهم‌تنیدگی‌ای بین دو آینده وجود ندارد. آینده <code>a</code> تمام کار خود را انجام می‌دهد تا زمانی که فراخوانی <code>trpl::sleep</code> منتظر بماند، سپس آینده <code>b</code> تمام کار خود را انجام می‌دهد تا زمانی که فراخوانی <code>trpl::sleep</code> خودش منتظر بماند، و سپس آینده <code>a</code> کامل می‌شود. برای اجازه دادن به هر دو آینده برای پیشرفت بین کارهای کند خود، نیاز به نقاط انتظار داریم تا بتوانیم کنترل را به runtime بازگردانیم. این بدان معناست که نیاز به چیزی داریم که بتوانیم منتظر آن بمانیم!</p>
<p>ما از قبل می‌توانیم این نوع واگذاری کنترل را در فهرست 17-23 ببینیم: اگر <code>trpl::sleep</code> را در انتهای آینده <code>a</code> حذف کنیم، این آینده بدون اجرای آینده <code>b</code> <em>به‌کلی</em> کامل می‌شود. شاید بتوانیم از تابع <code>sleep</code> به‌عنوان نقطه شروع استفاده کنیم؟</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-24: استفاده از <code>sleep</code> برای اجازه دادن به عملیات‌ها برای پیشرفت متناوب</figcaption>
</figure>
<p>در فهرست 17-24، فراخوانی‌های <code>trpl::sleep</code> با نقاط انتظار بین هر فراخوانی به <code>slow</code> اضافه می‌کنیم. اکنون کار دو آینده درهم‌تنیده شده است:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>آینده <code>a</code> هنوز برای مدتی اجرا می‌شود قبل از اینکه کنترل را به <code>b</code> واگذار کند، زیرا ابتدا <code>slow</code> را فراخوانی می‌کند قبل از اینکه اصلاً <code>trpl::sleep</code> را فراخوانی کند، اما پس از آن آینده‌ها هر بار که یکی از آن‌ها به یک نقطه انتظار برخورد می‌کند، به‌طور متناوب جابه‌جا می‌شوند. در این حالت، ما این کار را پس از هر فراخوانی به <code>slow</code> انجام داده‌ایم، اما می‌توانیم کار را به هر شکلی که برایمان منطقی‌تر است تقسیم کنیم.</p>
<p>با این حال، واقعاً نمی‌خواهیم اینجا <em>sleep</em> کنیم؛ می‌خواهیم به سریع‌ترین شکلی که می‌توانیم پیشرفت کنیم. فقط نیاز داریم کنترل را به runtime بازگردانیم. می‌توانیم این کار را به‌طور مستقیم با استفاده از تابع <code>yield_now</code> انجام دهیم. در فهرست 17-25، تمام این فراخوانی‌های <code>sleep</code> را با <code>yield_now</code> جایگزین می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-25: استفاده از <code>yield_now</code> برای اجازه دادن به عملیات‌ها برای پیشرفت متناوب</figcaption>
</figure>
<p>این روش هم از نظر هدف واضح‌تر است و هم می‌تواند به‌طور قابل‌توجهی سریع‌تر از استفاده از <code>sleep</code> باشد، زیرا تایمرها مانند تایمری که توسط <code>sleep</code> استفاده می‌شود اغلب محدودیت‌هایی در مورد دقت خود دارند. نسخه‌ای از <code>sleep</code> که ما استفاده می‌کنیم، برای مثال، همیشه حداقل به مدت یک میلی‌ثانیه خواب خواهد رفت، حتی اگر یک <code>Duration</code> یک نانوثانیه به آن بدهیم. دوباره، کامپیوترهای مدرن <em>سریع</em> هستند: آن‌ها می‌توانند در یک میلی‌ثانیه کارهای زیادی انجام دهند!</p>
<p>می‌توانید این موضوع را خودتان با تنظیم یک بنچمارک کوچک مشاهده کنید، مانند چیزی که در فهرست 17-26 آورده شده است. (این روش به‌طور خاص برای آزمایش عملکرد دقیق نیست، اما برای نشان دادن تفاوت اینجا کافی است.) اینجا، ما تمام چاپ وضعیت را نادیده می‌گیریم، یک <code>Duration</code> یک نانوثانیه به <code>trpl::sleep</code> ارسال می‌کنیم و اجازه می‌دهیم هر آینده به‌طور مستقل اجرا شود، بدون سوئیچ بین آینده‌ها. سپس برای 1,000 تکرار اجرا می‌کنیم و می‌بینیم آینده‌ای که از <code>trpl::sleep</code> استفاده می‌کند چقدر طول می‌کشد در مقایسه با آینده‌ای که از <code>trpl::yield_now</code> استفاده می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-26: مقایسه عملکرد <code>sleep</code> و <code>yield_now</code></figcaption>
</figure>
<p>نسخه با <code>yield_now</code> <em>خیلی</em> سریع‌تر است!</p>
<p>این بدان معناست که async حتی برای وظایف وابسته به CPU می‌تواند مفید باشد، بسته به اینکه برنامه شما چه کار دیگری انجام می‌دهد، زیرا ابزاری مفید برای ساختاردهی روابط بین بخش‌های مختلف برنامه فراهم می‌کند. این نوعی از <em>چندوظیفه‌گی مشارکتی</em> است، جایی که هر آینده قدرت تصمیم‌گیری درباره زمان واگذاری کنترل از طریق نقاط انتظار را دارد. بنابراین، هر آینده نیز مسئولیت دارد که از مسدود کردن بیش از حد طولانی اجتناب کند. در برخی سیستم‌عامل‌های مبتنی بر راست برای سیستم‌های تعبیه‌شده، این <em>تنها</em> نوع چندوظیفه‌گی است!</p>
<p>در کد دنیای واقعی، معمولاً با هر خط یک نقطه انتظار جایگزین نمی‌کنید. در حالی که واگذاری کنترل به این روش نسبتاً کم‌هزینه است، رایگان نیست! در بسیاری از موارد، تلاش برای تقسیم یک وظیفه وابسته به CPU ممکن است آن را به‌طور قابل‌توجهی کندتر کند، بنابراین گاهی اوقات برای عملکرد <em>کلی</em> بهتر است که به یک عملیات اجازه دهید برای مدت کوتاهی مسدود شود. همیشه باید عملکرد کد خود را اندازه‌گیری کنید تا ببینید تنگناهای واقعی آن کجاست. دینامیک اساسی نکته‌ای است که باید به خاطر بسپارید اگر <em>واقعاً</em> شاهد انجام مقدار زیادی از کار به‌صورت متوالی هستید که انتظار داشتید به‌طور همزمان انجام شود!</p>
<h3 id="ساخت-انتزاعات-async-خودمان"><a class="header" href="#ساخت-انتزاعات-async-خودمان">ساخت انتزاعات Async خودمان</a></h3>
<p>ما همچنین می‌توانیم آینده‌ها را با هم ترکیب کنیم تا الگوهای جدیدی ایجاد کنیم. برای مثال، می‌توانیم با استفاده از بلوک‌های سازنده async که از قبل داریم، یک تابع <code>timeout</code> بسازیم. وقتی کارمان تمام شد، نتیجه یک بلوک سازنده دیگر خواهد بود که می‌توانیم از آن برای ساخت انتزاعات async بیشتری استفاده کنیم.</p>
<p>فهرست 17-27 نشان می‌دهد که چگونه انتظار داریم این <code>timeout</code> با یک آینده کند کار کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-27: تعریف نحوه کار <code>timeout</code> با یک آینده کند</figcaption>
</figure>
<p>بیایید این را پیاده‌سازی کنیم! برای شروع، بیایید به API مورد نیاز برای <code>timeout</code> فکر کنیم:</p>
<ul>
<li>باید خودش یک تابع async باشد تا بتوانیم منتظر آن بمانیم.</li>
<li>پارامتر اول آن باید یک آینده برای اجرا باشد. می‌توانیم آن را عمومی کنیم تا بتواند با هر آینده‌ای کار کند.</li>
<li>پارامتر دوم آن مدت‌زمان حداکثری برای انتظار خواهد بود. اگر از یک <code>Duration</code> استفاده کنیم، این کار ارسال آن به <code>trpl::sleep</code> را آسان می‌کند.</li>
<li>باید یک <code>Result</code> بازگرداند. اگر آینده با موفقیت کامل شود، <code>Result</code> شامل <code>Ok</code> با مقدار تولیدشده توسط آینده خواهد بود. اگر زمان محدودیت زودتر سپری شود، <code>Result</code> شامل <code>Err</code> با مدت‌زمانی که زمان محدودیت برای آن منتظر ماند خواهد بود.</li>
</ul>
<p>فهرست 17-28 این اعلان را نشان می‌دهد.</p>
<!-- This is not tested because it intentionally does not compile. -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
<figcaption>Listing 17-28: تعریف امضای <code>timeout</code></figcaption>
</figure>
<p>این اهداف ما برای نوع‌ها را برآورده می‌کند. حالا بیایید به <em>رفتاری</em> که نیاز داریم فکر کنیم: می‌خواهیم آینده ارسال‌شده به آن را در برابر مدت‌زمان محدودیت مسابقه دهیم. می‌توانیم از <code>trpl::sleep</code> برای ساختن یک آینده تایمر از مدت‌زمان استفاده کنیم و از <code>trpl::race</code> برای اجرای آن تایمر با آینده‌ای که کاربر ارسال می‌کند استفاده کنیم.</p>
<p>همچنین می‌دانیم که <code>race</code> منصفانه نیست و آرگومان‌ها را به ترتیبی که ارسال شده‌اند بررسی می‌کند. بنابراین، ابتدا <code>future_to_try</code> را به <code>race</code> ارسال می‌کنیم تا حتی اگر <code>max_time</code> یک مدت‌زمان بسیار کوتاه باشد، فرصتی برای تکمیل داشته باشد. اگر <code>future_to_try</code> اول کامل شود، <code>race</code> مقدار <code>Left</code> با خروجی از <code>future</code> بازمی‌گرداند. اگر <code>timer</code> اول کامل شود، <code>race</code> مقدار <code>Right</code> با خروجی تایمر از نوع <code>()</code> بازمی‌گرداند.</p>
<p>در فهرست 17-29، نتیجه انتظار برای <code>trpl::race</code> را با <code>match</code> مدیریت می‌کنیم. اگر <code>future_to_try</code> موفق شد و مقدار <code>Left(output)</code> دریافت کردیم، مقدار <code>Ok(output)</code> را بازمی‌گردانیم. اگر تایمر خواب به جای آن سپری شد و مقدار <code>Right(())</code> دریافت کردیم، <code>()</code> را با <code>_</code> نادیده می‌گیریم و مقدار <code>Err(max_time)</code> را بازمی‌گردانیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-29: تعریف <code>timeout</code> با استفاده از <code>race</code> و <code>sleep</code></figcaption>
</figure>
<p>با این کار، یک <code>timeout</code> کاربردی داریم که از دو ابزار کمکی async دیگر ساخته شده است. اگر کد خود را اجرا کنیم، حالت شکست پس از زمان محدودیت را چاپ می‌کند:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>از آنجا که آینده‌ها با آینده‌های دیگر ترکیب می‌شوند، می‌توانید با استفاده از بلوک‌های سازنده async کوچک‌تر ابزارهای بسیار قدرتمندی بسازید. برای مثال، می‌توانید از همین روش برای ترکیب زمان‌های محدودیت با تلاش‌های مجدد استفاده کنید، و سپس از آن‌ها با چیزهایی مانند تماس‌های شبکه‌ای—یکی از مثال‌های ابتدای فصل—استفاده کنید!</p>
<p>در عمل، معمولاً مستقیماً با <code>async</code> و <code>await</code> کار خواهید کرد و به‌طور ثانویه با توابع و ماکروهایی مانند <code>join</code>، <code>join_all</code>، <code>race</code> و غیره. شما فقط گاهی نیاز خواهید داشت از <code>pin</code> استفاده کنید تا آن‌ها را با این API‌ها استفاده کنید.</p>
<p>ما اکنون چندین روش برای کار با آینده‌های متعدد به‌طور همزمان دیده‌ایم. در مرحله بعدی، به این خواهیم پرداخت که چگونه می‌توانیم با آینده‌های متعدد در یک توالی زمانی کار کنیم، با <em>جریان‌ها (streams)</em>. با این حال، در اینجا چند نکته دیگر برای بررسی وجود دارد:</p>
<ul>
<li>
<p>ما از یک <code>Vec</code> با <code>join_all</code> استفاده کردیم تا منتظر تکمیل همه آینده‌ها در یک گروه باشیم. چگونه می‌توانید از یک <code>Vec</code> برای پردازش یک گروه از آینده‌ها به‌صورت متوالی استفاده کنید؟ مزایا و معایب انجام این کار چیست؟</p>
</li>
<li>
<p>نگاهی به نوع <code>futures::stream::FuturesUnordered</code> از crate <code>futures</code> بیندازید. چگونه استفاده از آن با استفاده از یک <code>Vec</code> متفاوت خواهد بود؟ (نگران این نباشید که این نوع از بخش <code>stream</code> crate است؛ این نوع با هر مجموعه‌ای از آینده‌ها به‌خوبی کار می‌کند.)</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
