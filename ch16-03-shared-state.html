<!DOCTYPE HTML>
<html lang="fa" class="light" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>همزمانی با وضعیت مشترک - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، جعبه‌ها (crates)، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و جعبه‌ها (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گر (Pointer)های هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر (Pointer) هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html" class="active"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از تایپ‌های مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> تایپ‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور single-threaded</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="همزمانی-با-حالت-مشترک-shared-state-concurrency"><a class="header" href="#همزمانی-با-حالت-مشترک-shared-state-concurrency">همزمانی با حالت مشترک (Shared-State Concurrency)</a></h2>
<p>ارسال پیام یک روش مناسب برای مدیریت همزمانی است، اما تنها روش نیست. روش دیگر این
است که چندین نخ به یک داده مشترک دسترسی داشته باشند. دوباره این بخش از شعار
مستندات زبان Go را در نظر بگیرید: «با به اشتراک‌گذاری حافظه ارتباط برقرار نکنید.»</p>
<p>ارتباط با به اشتراک‌گذاری حافظه چگونه خواهد بود؟ علاوه بر این، چرا علاقه‌مندان به
ارسال پیام هشدار می‌دهند که از اشتراک حافظه استفاده نکنید؟</p>
<p>به نوعی، کانال‌ها (channels) در هر زبان برنامه‌نویسی شبیه مالکیت یکتا هستند، زیرا
هنگامی که یک مقدار را از طریق یک کانال منتقل می‌کنید، دیگر نباید از آن مقدار استفاده
کنید. همزمانی با حافظه مشترک مانند مالکیت چندگانه است: چندین نخ می‌توانند به
یک موقعیت حافظه‌ای یکسان به‌طور هم‌زمان دسترسی داشته باشند. همانطور که در فصل
15 دیدید، جایی که اسمارت پوینترها مالکیت چندگانه را ممکن می‌کردند، مالکیت
چندگانه می‌تواند پیچیدگی اضافه کند زیرا این مالکیت‌های مختلف نیاز به مدیریت
دارند. سیستم نوعی و قوانین مالکیت راست به طور قابل‌توجهی به صحیح مدیریت کردن
این موارد کمک می‌کند. برای یک مثال، بیایید به mutex‌ها نگاهی بیندازیم، یکی از
ابتدایی‌ترین سازوکارهای همزمانی برای حافظه مشترک.</p>
<h3 id="استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان"><a class="header" href="#استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان">استفاده از Mutex‌ها برای اجازه دسترسی به داده‌ها توسط یک نخ در هر زمان</a></h3>
<p><em>Mutex</em> مخفف <em>mutual exclusion</em> (حذف متقابل) است، به این معنا که یک mutex فقط
به یک نخ اجازه می‌دهد در هر لحظه به برخی داده‌ها دسترسی داشته باشد. برای دسترسی
به داده‌های یک mutex، یک نخ باید ابتدا سیگنال دهد که می‌خواهد دسترسی داشته باشد
با درخواست قفل کردن (acquire the lock) mutex. قفل یک ساختار داده است که بخشی
از mutex است و پیگیری می‌کند که چه کسی در حال حاضر به‌طور انحصاری به داده‌ها
دسترسی دارد. بنابراین، mutex به‌عنوان نگهبانی از داده‌هایی که نگه می‌دارد توصیف
می‌شود که از طریق سیستم قفل کار می‌کند.</p>
<p>Mutex‌ها به دلیل این که باید دو قانون را به خاطر بسپارید، به سخت بودن شهرت دارند:</p>
<ul>
<li>شما باید قبل از استفاده از داده‌ها، سعی کنید قفل را بگیرید.</li>
<li>هنگامی که استفاده شما از داده‌هایی که mutex نگهبانی می‌کند تمام شد، باید
داده‌ها را باز کنید تا نخ‌های دیگر بتوانند قفل را بگیرند.</li>
</ul>
<p>برای یک تمثیل دنیای واقعی برای mutex، یک بحث پانل در یک کنفرانس را تصور کنید
که فقط یک میکروفون وجود دارد. قبل از اینکه یک عضو پانل بتواند صحبت کند، باید
درخواست دهد یا سیگنال دهد که می‌خواهد از میکروفون استفاده کند. وقتی میکروفون را
می‌گیرد، می‌تواند هر چقدر که بخواهد صحبت کند و سپس میکروفون را به عضو بعدی
که درخواست صحبت کرده است بدهد. اگر یک عضو پانل فراموش کند که میکروفون را پس
دهد، هیچ کس دیگری نمی‌تواند صحبت کند. اگر مدیریت میکروفون مشترک اشتباه انجام
شود، پانل مطابق برنامه پیش نخواهد رفت!</p>
<p>مدیریت mutex‌ها می‌تواند بسیار دشوار باشد، به همین دلیل است که بسیاری از افراد
به کانال‌ها علاقه‌مند هستند. اما به لطف سیستم نوعی و قوانین مالکیت راست، شما
نمی‌توانید در قفل کردن و باز کردن قفل اشتباه کنید.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>به‌عنوان مثالی از نحوه استفاده از mutex، بیایید با استفاده از یک mutex در یک
زمینه تک‌ریسمانی شروع کنیم، همانطور که در فهرست 16-12 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<figcaption>Listing 16-12: بررسی API <code>Mutex&lt;T&gt;</code> در یک زمینه تک‌ریسمانی برای سادگی</figcaption>
</figure>
<p>همانند بسیاری از انواع دیگر، ما یک <code>Mutex&lt;T&gt;</code> را با استفاده از تابع مرتبط <code>new</code> ایجاد
می‌کنیم. برای دسترسی به داده‌های درون mutex، از متد <code>lock</code> برای گرفتن قفل استفاده
می‌کنیم. این فراخوانی، نخ فعلی را مسدود می‌کند تا زمانی که نوبت ما برای گرفتن قفل
برسد.</p>
<p>فراخوانی <code>lock</code> در صورتی که نخ دیگری که قفل را نگه داشته است دچار وحشت (panic)
شود، شکست خواهد خورد. در این صورت، هیچ کس دیگر نمی‌تواند قفل را بگیرد، بنابراین ما
تصمیم گرفتیم <code>unwrap</code> کنیم و در این وضعیت، این نخ نیز وحشت کند.</p>
<p>پس از گرفتن قفل، می‌توانیم مقدار بازگشتی را که در این مثال <code>num</code> نامیده شده است،
مانند یک ارجاع متغیر به داده‌های درون mutex در نظر بگیریم. سیستم نوعی تضمین می‌کند
که قبل از استفاده از مقدار در <code>m</code>، قفل را گرفته‌ایم. نوع <code>m</code> برابر با <code>Mutex&lt;i32&gt;</code>
است، نه <code>i32</code>، بنابراین <em>باید</em> <code>lock</code> را فراخوانی کنیم تا بتوانیم مقدار <code>i32</code> را
استفاده کنیم. نمی‌توانیم فراموش کنیم؛ سیستم نوعی به ما اجازه دسترسی به <code>i32</code>
داخلی را نمی‌دهد.</p>
<p>همانطور که ممکن است حدس بزنید، <code>Mutex&lt;T&gt;</code> یک اسمارت پوینتر است. به طور دقیق‌تر،
فراخوانی <code>lock</code> یک اسمارت پوینتر به نام <code>MutexGuard</code> را بازمی‌گرداند، که درون یک
<code>LockResult</code> قرار دارد و ما آن را با فراخوانی <code>unwrap</code> مدیریت کردیم. اسمارت
پوینتر <code>MutexGuard</code> ویژگی <code>Deref</code> را پیاده‌سازی می‌کند تا به داده‌های داخلی ما
اشاره کند؛ این اسمارت پوینتر همچنین یک پیاده‌سازی <code>Drop</code> دارد که قفل را به طور
خودکار وقتی که یک <code>MutexGuard</code> از دامنه خارج می‌شود آزاد می‌کند، که این اتفاق
در انتهای دامنه داخلی می‌افتد. در نتیجه، خطر فراموش کردن آزاد کردن قفل و مسدود
کردن mutex از استفاده توسط نخ‌های دیگر وجود ندارد، زیرا آزاد کردن قفل به طور
خودکار انجام می‌شود.</p>
<p>پس از آزاد کردن قفل، می‌توانیم مقدار mutex را چاپ کنیم و ببینیم که توانستیم مقدار
<code>i32</code> داخلی را به 6 تغییر دهیم.</p>
<h4 id="به-اشتراکگذاری-یک-mutext-بین-چندین-نخ"><a class="header" href="#به-اشتراکگذاری-یک-mutext-بین-چندین-نخ">به اشتراک‌گذاری یک <code>Mutex&lt;T&gt;</code> بین چندین نخ</a></h4>
<p>حالا، بیایید سعی کنیم یک مقدار را بین چندین نخ با استفاده از <code>Mutex&lt;T&gt;</code> به اشتراک
بگذاریم. ما 10 نخ ایجاد می‌کنیم و به هرکدام از آن‌ها مقدار شمارنده را یک واحد افزایش
می‌دهیم، بنابراین شمارنده از 0 به 10 می‌رسد. مثال بعدی در فهرست 16-13 یک خطای
کامپایل خواهد داشت، و از این خطا برای یادگیری بیشتر درباره استفاده از <code>Mutex&lt;T&gt;</code>
و نحوه کمک راست به ما برای استفاده صحیح از آن استفاده خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption>Listing 16-13: ده نخ که هر کدام مقدار شمارنده محافظت‌شده توسط یک <code>Mutex&lt;T&gt;</code> را افزایش می‌دهند</figcaption>
</figure>
<p>ما یک متغیر <code>counter</code> ایجاد می‌کنیم تا یک مقدار <code>i32</code> را در یک <code>Mutex&lt;T&gt;</code> نگه دارد،
همانطور که در فهرست 16-12 انجام دادیم. سپس، 10 نخ ایجاد می‌کنیم با استفاده از
یک محدوده از اعداد. ما از <code>thread::spawn</code> استفاده می‌کنیم و به همه نخ‌ها یک closure
یکسان می‌دهیم: closure‌ای که شمارنده را به داخل نخ منتقل می‌کند، قفلی روی <code>Mutex&lt;T&gt;</code>
با فراخوانی متد <code>lock</code> می‌گیرد، و سپس 1 به مقدار درون mutex اضافه می‌کند. وقتی
یک نخ اجرای closure خود را تمام می‌کند، <code>num</code> از دامنه خارج می‌شود و قفل آزاد
می‌شود تا نخ دیگری بتواند آن را بگیرد.</p>
<p>در نخ اصلی، تمام handleهای join را جمع‌آوری می‌کنیم. سپس، همانطور که در فهرست
16-2 انجام دادیم، روی هر handle فراخوانی <code>join</code> می‌کنیم تا مطمئن شویم تمام نخ‌ها
پایان یافته‌اند. در این مرحله، نخ اصلی قفل را می‌گیرد و نتیجه این برنامه را چاپ می‌کند.</p>
<p>ما اشاره کردیم که این مثال کامپایل نخواهد شد. حالا بیایید ببینیم چرا!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>پیام خطا بیان می‌کند که مقدار <code>counter</code> در تکرار قبلی حلقه منتقل شده است. راست به ما می‌گوید که نمی‌توانیم مالکیت <code>counter</code> را به چندین نخ منتقل کنیم. بیایید خطای کامپایل را با استفاده از یک روش مالکیت چندگانه که در فصل 15 بحث شد، برطرف کنیم.</p>
<h4 id="مالکیت-چندگانه-با-چندین-نخ"><a class="header" href="#مالکیت-چندگانه-با-چندین-نخ">مالکیت چندگانه با چندین نخ</a></h4>
<p>در فصل 15، ما با استفاده از اسمارت پوینتر <code>Rc&lt;T&gt;</code> برای ایجاد یک مقدار شمارش‌شده با ارجاع (reference counted value)، یک مقدار را به چندین مالک دادیم. بیایید همین کار را اینجا انجام دهیم و ببینیم چه اتفاقی می‌افتد. ما <code>Mutex&lt;T&gt;</code> را درون <code>Rc&lt;T&gt;</code> قرار می‌دهیم و قبل از انتقال مالکیت به نخ، <code>Rc&lt;T&gt;</code> را کلون می‌کنیم. این موضوع در فهرست 16-14 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption>Listing 16-14: تلاش برای استفاده از <code>Rc&lt;T&gt;</code> برای اجازه مالکیت چندین نخ به <code>Mutex&lt;T&gt;</code></figcaption>
</figure>
<p>دوباره کد را کامپایل می‌کنیم و… این بار خطاهای متفاوتی دریافت می‌کنیم! کامپایلر چیزهای زیادی به ما آموزش می‌دهد.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- required by a bound in this function
...
675 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>واو، این پیام خطا بسیار طولانی است! این بخش مهمی است که باید روی آن تمرکز کنید:
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` نمی‌تواند به‌صورت ایمن بین نخ‌ها ارسال شود</code>. کامپایلر همچنین دلیل آن را به ما می‌گوید: <code>ویژگی `Send` برای `Rc&lt;Mutex&lt;i32&gt;&gt;` پیاده‌سازی نشده است</code>. ما در بخش بعدی درباره <code>Send</code> صحبت خواهیم کرد: یکی از ویژگی‌هایی که تضمین می‌کند نوع‌هایی که با نخ‌ها استفاده می‌کنیم برای استفاده در شرایط همزمانی مناسب هستند.</p>
<p>متأسفانه، <code>Rc&lt;T&gt;</code> برای اشتراک‌گذاری بین نخ‌ها ایمن نیست. وقتی <code>Rc&lt;T&gt;</code> شمارش ارجاع را مدیریت می‌کند، برای هر فراخوانی به <code>clone</code> به شمارش اضافه می‌کند و زمانی که هر کلون حذف می‌شود، از شمارش کم می‌کند. اما از هیچ سازوکار همزمانی برای اطمینان از این که تغییرات در شمارش نمی‌توانند توسط یک نخ دیگر قطع شوند، استفاده نمی‌کند. این می‌تواند منجر به شمارش‌های اشتباه شود—اشکال‌های ظریفی که می‌توانند منجر به نشت حافظه یا حذف یک مقدار قبل از اتمام کار ما با آن شوند. چیزی که ما نیاز داریم یک نوع دقیقاً مانند <code>Rc&lt;T&gt;</code> است اما با این تفاوت که تغییرات در شمارش ارجاع را به شکلی ایمن برای نخ انجام دهد.</p>
<h4 id="شمارش-ارجاع-اتمی-با-arct"><a class="header" href="#شمارش-ارجاع-اتمی-با-arct">شمارش ارجاع اتمی با <code>Arc&lt;T&gt;</code></a></h4>
<p>خوشبختانه، <code>Arc&lt;T&gt;</code> یک نوع مانند <code>Rc&lt;T&gt;</code> است که برای استفاده در شرایط همزمانی ایمن است. حرف <em>a</em> به معنای <em>atomic</em> است، به این معنا که این یک نوع <em>شمارش‌شده با ارجاع اتمی</em> است. نوع‌های اتمی یک نوع اضافی از سازوکارهای همزمانی هستند که اینجا به‌طور جزئی بحث نمی‌شوند: برای جزئیات بیشتر، مستندات کتابخانه استاندارد را برای <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> مشاهده کنید. در این مرحله، فقط باید بدانید که نوع‌های اتمی مانند نوع‌های اولیه (primitive types) کار می‌کنند اما برای اشتراک‌گذاری بین نخ‌ها ایمن هستند.</p>
<p>ممکن است این سؤال برای شما پیش بیاید که چرا همه نوع‌های اولیه اتمی نیستند و چرا نوع‌های کتابخانه استاندارد به‌طور پیش‌فرض با استفاده از <code>Arc&lt;T&gt;</code> پیاده‌سازی نمی‌شوند. دلیل آن این است که ایمنی نخ با یک جریمه عملکردی همراه است که فقط زمانی می‌خواهید پرداخت کنید که واقعاً به آن نیاز دارید. اگر شما فقط عملیات‌هایی را روی مقادیر در یک نخ واحد انجام می‌دهید، کد شما می‌تواند سریع‌تر اجرا شود اگر مجبور به اعمال تضمین‌هایی که نوع‌های اتمی ارائه می‌دهند نباشد.</p>
<p>بیایید به مثال خود برگردیم: <code>Arc&lt;T&gt;</code> و <code>Rc&lt;T&gt;</code> دارای API یکسانی هستند، بنابراین برنامه
خود را با تغییر خط <code>use</code>، فراخوانی <code>new</code> و فراخوانی <code>clone</code> اصلاح می‌کنیم. کد در
فهرست 16-15 سرانجام کامپایل و اجرا خواهد شد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<figcaption>Listing 16-15: استفاده از یک <code>Arc&lt;T&gt;</code> برای پیچیدن <code>Mutex&lt;T&gt;</code> تا امکان اشتراک مالکیت بین چندین نخ فراهم شود</figcaption>
</figure>
<p>این کد خروجی زیر را چاپ خواهد کرد:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>ما موفق شدیم! از 0 تا 10 شمارش کردیم، که ممکن است خیلی چشمگیر به نظر نرسد، اما
چیزهای زیادی درباره <code>Mutex&lt;T&gt;</code> و ایمنی نخ آموختیم. همچنین می‌توانید ساختار این
برنامه را برای انجام عملیات پیچیده‌تر از فقط افزایش یک شمارنده استفاده کنید. با
استفاده از این استراتژی، می‌توانید یک محاسبه را به بخش‌های مستقل تقسیم کنید، این
بخش‌ها را بین نخ‌ها توزیع کنید و سپس از یک <code>Mutex&lt;T&gt;</code> برای به‌روزرسانی نتیجه نهایی
با هر بخش استفاده کنید.</p>
<p>توجه داشته باشید که اگر در حال انجام عملیات عددی ساده هستید، نوع‌هایی ساده‌تر از
<code>Mutex&lt;T&gt;</code> توسط <a href="https://doc.rust-lang.org/std/sync/atomic/index.html">ماژول <code>std::sync::atomic</code> از کتابخانه استاندارد</a><!-- ignore -->
ارائه شده‌اند. این نوع‌ها دسترسی ایمن، همزمان و اتمی به نوع‌های اولیه فراهم می‌کنند.
ما برای این مثال از <code>Mutex&lt;T&gt;</code> با یک نوع اولیه استفاده کردیم تا بتوانیم روی نحوه
کار <code>Mutex&lt;T&gt;</code> تمرکز کنیم.</p>
<h3 id="شباهتهای-بین-refcelltrct-و-mutextarct"><a class="header" href="#شباهتهای-بین-refcelltrct-و-mutextarct">شباهت‌های بین <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> و <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>ممکن است متوجه شده باشید که <code>counter</code> غیرقابل‌تغییر است، اما ما توانستیم یک
ارجاع متغیر به مقدار داخل آن دریافت کنیم؛ این بدان معناست که <code>Mutex&lt;T&gt;</code> نیز
تغییرپذیری داخلی (interior mutability) ارائه می‌دهد، همانطور که خانواده <code>Cell</code>
این کار را انجام می‌دهند. به همان شیوه‌ای که در فصل 15 از <code>RefCell&lt;T&gt;</code> استفاده
کردیم تا به ما اجازه دهد محتواهای داخل یک <code>Rc&lt;T&gt;</code> را تغییر دهیم، ما از <code>Mutex&lt;T&gt;</code>
برای تغییر محتواهای داخل یک <code>Arc&lt;T&gt;</code> استفاده می‌کنیم.</p>
<p>یک جزئیات دیگر که باید به آن توجه کنید این است که راست نمی‌تواند شما را از
تمام انواع اشکالات منطقی هنگام استفاده از <code>Mutex&lt;T&gt;</code> محافظت کند. به یاد آورید که
در فصل 15 استفاده از <code>Rc&lt;T&gt;</code> با خطر ایجاد چرخه‌های ارجاعی همراه بود، جایی که
دو مقدار <code>Rc&lt;T&gt;</code> به یکدیگر ارجاع می‌دادند و باعث نشت حافظه می‌شدند. به طور
مشابه، <code>Mutex&lt;T&gt;</code> با خطر ایجاد <em>بن‌بست‌ها (deadlocks)</em> همراه است. این موارد زمانی
رخ می‌دهند که یک عملیات نیاز به قفل کردن دو منبع داشته باشد و دو نخ هر کدام یکی
از قفل‌ها را گرفته باشند، و باعث شوند که هر دو برای همیشه منتظر یکدیگر بمانند.
اگر به بن‌بست‌ها علاقه دارید، سعی کنید یک برنامه راست ایجاد کنید که دچار بن‌بست
شود؛ سپس استراتژی‌های کاهش بن‌بست برای mutex‌ها در هر زبانی را تحقیق کنید و
سعی کنید آن‌ها را در راست پیاده‌سازی کنید. مستندات API کتابخانه استاندارد برای
<code>Mutex&lt;T&gt;</code> و <code>MutexGuard</code> اطلاعات مفیدی ارائه می‌دهد.</p>
<p>ما این فصل را با صحبت درباره ویژگی‌های <code>Send</code> و <code>Sync</code> و نحوه استفاده از آن‌ها
با نوع‌های سفارشی به پایان خواهیم رساند.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
