<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>همزمانی با وضعیت مشترک - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="همزمانی-با-حالت-مشترک-shared-state-concurrency"><a class="header" href="#همزمانی-با-حالت-مشترک-shared-state-concurrency">همزمانی با حالت مشترک (Shared-State Concurrency)</a></h2>
<p>ارسال پیام (Message passing) روش مناسبی برای مدیریت هم‌زمانی (concurrency) است، اما تنها روش موجود نیست. روش دیگری نیز وجود دارد که در آن چندین ترد (thread) به داده‌ی مشترک یکسانی دسترسی دارند. دوباره این بخش از شعار مستندات زبان Go را در نظر بگیرید: «با به‌اشتراک‌گذاری حافظه ارتباط برقرار نکنید.»</p>
<p>ارتباط با به اشتراک‌گذاری حافظه چگونه خواهد بود؟ علاوه بر این، چرا علاقه‌مندان به
ارسال پیام هشدار می‌دهند که از اشتراک حافظه استفاده نکنید؟</p>
<p>به‌نوعی، کانال‌ها (channels) در هر زبان برنامه‌نویسی مشابه مالکیت تکی (single ownership) هستند، چرا که وقتی یک مقدار را از طریق کانال انتقال می‌دهید، دیگر نباید از آن مقدار استفاده کنید. هم‌زمانی با حافظه‌ی مشترک (shared-memory concurrency) شبیه به مالکیت چندگانه است: چندین ترد می‌توانند به‌طور هم‌زمان به یک محل حافظه دسترسی داشته باشند. همان‌طور که در فصل ۱۵ دیدید، جایی که smart pointerها امکان مالکیت چندگانه را فراهم کردند، مالکیت چندگانه می‌تواند پیچیدگی‌هایی را به همراه داشته باشد، چرا که این مالکان مختلف نیاز به مدیریت دارند. سیستم نوع‌دهی و قواعد مالکیت در Rust کمک شایانی به مدیریت درست این وضعیت می‌کنند. به عنوان یک مثال، بیایید به mutexها نگاه کنیم، که یکی از ابتدایی‌ترین سازوکارهای هم‌زمانی برای حافظه‌ی مشترک هستند.</p>
<h3 id="استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان"><a class="header" href="#استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان">استفاده از Mutex‌ها برای اجازه دسترسی به داده‌ها توسط یک نخ در هر زمان</a></h3>
<p>واژه‌ی <em>Mutex</em> مخفف <em>mutual exclusion</em> به‌معنای «ممانعت  متقابل» است؛ به این معنا که یک mutex فقط به یک ترد اجازه می‌دهد تا در هر لحظه به داده‌ای دسترسی داشته باشد. برای دسترسی به داده درون یک mutex، یک ترد ابتدا باید اعلام کند که قصد دسترسی دارد، با درخواست قفل (lock) آن mutex. <em>Lock</em> یک ساختار داده‌ای است که بخشی از mutex به‌شمار می‌رود و مسئول پیگیری این است که در حال حاضر چه کسی به‌صورت انحصاری به داده دسترسی دارد. بنابراین، mutex به‌عنوان ابزاری توصیف می‌شود که از داده‌ای که در خود نگه می‌دارد از طریق سیستم قفل‌گذاری <em>محافظت</em> می‌کند.</p>
<p>Mutex‌ها به دلیل این که باید دو قانون را به خاطر بسپارید، به سخت بودن شهرت دارند:</p>
<ol>
<li>پیش از استفاده از داده، باید تلاش کنید تا قفل (lock) آن را به‌دست آورید.</li>
<li>زمانی که کارتان با داده‌ای که mutex از آن محافظت می‌کند تمام شد، باید قفل را آزاد (unlock) کنید تا سایر تردها بتوانند قفل را به‌دست آورند.</li>
</ol>
<p>برای یک تمثیل دنیای واقعی برای mutex، یک بحث پانل در یک کنفرانس را تصور کنید
که فقط یک میکروفون وجود دارد. قبل از اینکه یک عضو پانل بتواند صحبت کند، باید
درخواست دهد یا سیگنال دهد که می‌خواهد از میکروفون استفاده کند. وقتی میکروفون را
می‌گیرد، می‌تواند هر چقدر که بخواهد صحبت کند و سپس میکروفون را به عضو بعدی
که درخواست صحبت کرده است بدهد. اگر یک عضو پانل فراموش کند که میکروفون را پس
دهد، هیچ کس دیگری نمی‌تواند صحبت کند. اگر مدیریت میکروفون مشترک اشتباه انجام
شود، پانل مطابق برنامه پیش نخواهد رفت!</p>
<p>مدیریت mutex‌ها می‌تواند بسیار دشوار باشد، به همین دلیل است که بسیاری از افراد
به کانال‌ها علاقه‌مند هستند. اما به لطف سیستم نوعی و قوانین مالکیت راست، شما
نمی‌توانید در قفل کردن و باز کردن قفل اشتباه کنید.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>به‌عنوان مثالی از نحوه استفاده از mutex، بیایید با استفاده از یک mutex در یک
زمینه تک‌ریسمانی شروع کنیم، همانطور که در فهرست 16-12 نشان داده شده است:</p>
<figure class="listing" id="listing-16-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<figcaption><a href="#listing-16-12">Listing 16-12</a>: بررسی API <code>Mutex&lt;T&gt;</code> در یک زمینه تک‌ریسمانی برای سادگی</figcaption>
</figure>
<p>همان‌طور که با بسیاری از نوع‌ها مشاهده می‌شود، یک <code>Mutex&lt;T&gt;</code> را با استفاده از تابع وابسته <code>new</code> ایجاد می‌کنیم. برای دسترسی به داده داخل Mutex، از متد <code>lock</code> استفاده می‌کنیم تا قفل را به دست آوریم. این فراخوانی Thread فعلی را متوقف می‌کند، بنابراین نمی‌تواند کاری انجام دهد تا زمانی که نوبت ما برای گرفتن قفل برسد.</p>
<p>فراخوانی <code>lock</code> در صورتی که یک Thread دیگر که قفل را نگه داشته دچار وحشت (<em>panic</em>) شود، شکست می‌خورد. در چنین حالتی، هیچ‌کس دیگر نمی‌تواند قفل را به دست آورد، بنابراین انتخاب کرده‌ایم که از <code>unwrap</code> استفاده کنیم و اگر در چنین وضعیتی قرار گرفتیم، این Thread نیز دچار وحشت شود.</p>
<p>بعد از گرفتن قفل، می‌توانیم مقدار بازگردانده‌شده را، که در اینجا به نام <code>num</code> است، به عنوان یک مرجع قابل تغییر به داده داخل در نظر بگیریم. سیستم نوع تضمین می‌کند که قبل از استفاده از مقدار داخل <code>m</code> قفل را به دست آوریم. نوع <code>m</code> برابر با <code>Mutex&lt;i32&gt;</code> است، نه <code>i32</code>، بنابراین <em>باید</em> برای استفاده از مقدار <code>i32</code>، متد <code>lock</code> را فراخوانی کنیم. نمی‌توانیم فراموش کنیم؛ سیستم نوع اجازه دسترسی به مقدار داخلی <code>i32</code> را به ما نمی‌دهد.</p>
<p>همان‌طور که احتمالاً حدس می‌زنید، <code>Mutex&lt;T&gt;</code> یک اشاره‌گر هوشمند است. دقیق‌تر، فراخوانی <code>lock</code> یک اشاره‌گر هوشمند به نام <code>MutexGuard</code> را بازمی‌گرداند، که در یک <code>LockResult</code> بسته‌بندی شده است و آن را با فراخوانی <code>unwrap</code> مدیریت کردیم. اشاره‌گر هوشمند <code>MutexGuard</code> ویژگی <code>Deref</code> را پیاده‌سازی می‌کند تا به داده داخلی ما اشاره کند. همچنین، این اشاره‌گر هوشمند یک پیاده‌سازی از <code>Drop</code> دارد که به‌طور خودکار قفل را زمانی که یک <code>MutexGuard</code> از محدوده خارج می‌شود، آزاد می‌کند، که این اتفاق در انتهای محدوده داخلی رخ می‌دهد. در نتیجه، خطر فراموش کردن آزاد کردن قفل و جلوگیری از استفاده دیگر Threadها از Mutex وجود ندارد، زیرا آزادسازی قفل به صورت خودکار انجام می‌شود.</p>
<p>پس از آزاد کردن قفل، می‌توانیم مقدار Mutex را چاپ کنیم و ببینیم که توانستیم مقدار داخلی <code>i32</code> را به ۶ تغییر دهیم.</p>
<h4 id="اشتراکگذاری-یک-mutext-بین-چندین-thread"><a class="header" href="#اشتراکگذاری-یک-mutext-بین-چندین-thread">اشتراک‌گذاری یک <code>Mutex&lt;T&gt;</code> بین چندین Thread</a></h4>
<p>حالا، بیایید تلاش کنیم یک مقدار را بین چندین Thread با استفاده از <code>Mutex&lt;T&gt;</code> به اشتراک بگذاریم. ما ۱۰ Thread ایجاد خواهیم کرد و هرکدام مقدار شمارنده را ۱ واحد افزایش می‌دهند، بنابراین شمارنده از ۰ به ۱۰ می‌رسد. مثال بعدی در لیست ۱۶-۱۳ دارای خطای کامپایل خواهد بود، و از آن خطا برای یادگیری بیشتر در مورد استفاده از <code>Mutex&lt;T&gt;</code> و اینکه چگونه Rust به ما کمک می‌کند از آن به درستی استفاده کنیم، استفاده خواهیم کرد.</p>
<figure class="listing" id="listing-16-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="#listing-16-13">Listing 16-13</a>: ده نخ که هر کدام مقدار شمارنده محافظت‌شده توسط یک <code>Mutex&lt;T&gt;</code> را افزایش می‌دهند</figcaption>
</figure>
<p>ما یک متغیر <code>counter</code> ایجاد می‌کنیم تا یک مقدار <code>i32</code> را در یک <code>Mutex&lt;T&gt;</code> نگه دارد، همان‌طور که در لیست ۱۶-۱۲ انجام دادیم. سپس، با تکرار روی یک بازه عددی، ۱۰ Thread ایجاد می‌کنیم. از <code>thread::spawn</code> استفاده می‌کنیم و به تمام Threadها یک Closure یکسان می‌دهیم: یک Closure که متغیر <code>counter</code> را به Thread منتقل می‌کند، قفل <code>Mutex&lt;T&gt;</code> را با فراخوانی متد <code>lock</code> به دست می‌آورد، و سپس ۱ واحد به مقدار داخل Mutex اضافه می‌کند. وقتی یک Thread اجرای Closure خود را تمام می‌کند، <code>num</code> از محدوده خارج شده و قفل را آزاد می‌کند تا Thread دیگری بتواند آن را به دست آورد.</p>
<p>در Thread اصلی، تمام handleهای join را جمع‌آوری می‌کنیم. سپس، همان‌طور که در لیست ۱۶-۲ انجام دادیم، متد <code>join</code> را روی هر handle فراخوانی می‌کنیم تا مطمئن شویم تمام Threadها تمام شده‌اند. در آن نقطه، Thread اصلی قفل را به دست می‌آورد و نتیجه این برنامه را چاپ می‌کند.</p>
<p>ما اشاره کردیم که این مثال کامپایل نخواهد شد. حالا بیایید ببینیم چرا!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>پیام خطا نشان می‌دهد که مقدار <code>counter</code> در تکرار قبلی حلقه منتقل شده است. Rust به ما می‌گوید که نمی‌توانیم مالکیت <code>counter</code> را به چندین Thread منتقل کنیم. بیایید این خطای کامپایلر را با استفاده از روش مالکیت چندگانه که در فصل ۱۵ بحث کردیم، برطرف کنیم.</p>
<h4 id="مالکیت-چندگانه-با-چندین-thread"><a class="header" href="#مالکیت-چندگانه-با-چندین-thread">مالکیت چندگانه با چندین Thread</a></h4>
<p>در فصل ۱۵، ما با استفاده از اشاره‌گر هوشمند <code>Rc&lt;T&gt;</code> برای ایجاد یک مقدار شمارش‌شده توسط مرجع (<em>reference-counted value</em>) به یک مقدار چندین مالک دادیم. بیایید همین کار را اینجا انجام دهیم و ببینیم چه اتفاقی می‌افتد. ما <code>Mutex&lt;T&gt;</code> را در <code>Rc&lt;T&gt;</code> بسته‌بندی می‌کنیم (همان‌طور که در لیست ۱۶-۱۴ نشان داده شده است) و قبل از انتقال مالکیت به Thread، <code>Rc&lt;T&gt;</code> را کلون می‌کنیم.</p>
<figure class="listing" id="listing-16-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="#listing-16-14">Listing 16-14</a>: تلاش برای استفاده از <code>Rc&lt;T&gt;</code> برای اجازه مالکیت چندگانه <code>Mutex&lt;T&gt;</code> توسط چندین Thread</figcaption>
</figure>
<p>دوباره کامپایل می‌کنیم و… خطاهای متفاوتی دریافت می‌کنیم! کامپایلر چیزهای زیادی به ما یاد می‌دهد.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:728:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>وای، این پیام خطا واقعاً پرحرف است! اما بخش مهمی که باید روی آن تمرکز کنیم این است:
<code>Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>
کامپایلر همچنین دلیل آن را نیز به ما می‌گوید:
```the trait <code>Send</code> is not implemented for <code>Rc&lt;Mutex&lt;i32&gt;&gt;```` در بخش بعدی درباره‌ی </code>Send<code>صحبت خواهیم کرد: این یکی از</code>trait`هایی است که اطمینان حاصل می‌کند نوع‌هایی که با تردها استفاده می‌شوند، برای استفاده در موقعیت‌های هم‌زمان طراحی شده‌اند.</p>
<p>متأسفانه، استفاده از <code>Rc&lt;T&gt;</code> برای اشتراک‌گذاری داده‌ها بین تردها ایمن نیست.
زمانی که <code>Rc&lt;T&gt;</code> شمارنده‌ی رفرنس را مدیریت می‌کند، با هر بار فراخوانی <code>clone</code> به شمارنده اضافه می‌شود و با از بین رفتن هر کلون، از شمارنده کم می‌شود.
اما این عملیات از هیچ سازوکار هم‌زمانی‌ای استفاده نمی‌کند تا مطمئن شود که تغییرات روی شمارنده در میان اجرای ترد دیگری قطع نشوند.
این موضوع می‌تواند منجر به شمارنده‌های اشتباه شود—باگ‌هایی ظریف که در ادامه ممکن است منجر به نشت حافظه یا از بین رفتن مقداری شوند در حالی که هنوز به آن نیاز داریم.
چیزی که ما نیاز داریم، نوعی است که دقیقاً مانند <code>Rc&lt;T&gt;</code> عمل کند، اما تغییرات شمارنده‌ی رفرنس را به‌شکلی امن برای ترد انجام دهد.</p>
<h4 id="شمارش-ارجاع-اتمی-با-arct"><a class="header" href="#شمارش-ارجاع-اتمی-با-arct">شمارش ارجاع اتمی با <code>Arc&lt;T&gt;</code></a></h4>
<p>خوشبختانه، <code>Arc&lt;T&gt;</code> یک نوع مشابه <code>Rc&lt;T&gt;</code> است که برای استفاده در شرایط همزمان ایمن است. حرف <em>a</em> در <code>Arc</code> مخفف <em>atomic</em> است، به این معنا که یک نوع <em>شمارش مرجع اتمی</em> است. اتمیک‌ها نوع دیگری از عناصر ابتدایی همزمانی هستند که در اینجا به‌طور مفصل به آن‌ها نمی‌پردازیم؛ برای جزئیات بیشتر به مستندات کتابخانه استاندارد در مورد <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> مراجعه کنید. در این مرحله، فقط باید بدانید که اتمیک‌ها مانند نوع‌های ابتدایی کار می‌کنند اما برای اشتراک‌گذاری بین Threadها ایمن هستند.</p>
<p>شاید از خود بپرسید چرا تمام نوع‌های ابتدایی اتمی نیستند و چرا نوع‌های کتابخانه استاندارد به‌طور پیش‌فرض از <code>Arc&lt;T&gt;</code> استفاده نمی‌کنند. دلیل این است که ایمنی Thread با یک هزینه عملکردی همراه است که فقط زمانی که واقعاً نیاز باشد، می‌خواهید آن را پرداخت کنید. اگر فقط روی مقادیر در یک Thread واحد عملیات انجام می‌دهید، کد شما می‌تواند سریع‌تر اجرا شود اگر مجبور به اعمال تضمین‌های اتمیک نباشد.</p>
<p>بیایید به مثال خود برگردیم: <code>Arc&lt;T&gt;</code> و <code>Rc&lt;T&gt;</code> API یکسانی دارند، بنابراین برنامه خود را با تغییر خط <code>use</code>، فراخوانی <code>new</code>، و فراخوانی <code>clone</code> اصلاح می‌کنیم. کد موجود در لیست ۱۶-۱۵ در نهایت کامپایل و اجرا می‌شود:</p>
<figure class="listing" id="listing-16-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<figcaption><a href="#listing-16-15">Listing 16-15</a>: استفاده از <code>Arc&lt;T&gt;</code> برای بسته‌بندی <code>Mutex&lt;T&gt;</code> جهت اشتراک مالکیت بین چندین Thread</figcaption>
</figure>
<p>این کد خروجی زیر را چاپ خواهد کرد:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>ما موفق شدیم! شمارنده را از ۰ به ۱۰ افزایش دادیم که ممکن است خیلی چشمگیر به نظر نرسد، اما چیزهای زیادی درباره <code>Mutex&lt;T&gt;</code> و ایمنی Thread یاد گرفتیم. همچنین می‌توانید از ساختار این برنامه برای انجام عملیات پیچیده‌تری به‌جز افزایش یک شمارنده استفاده کنید. با استفاده از این استراتژی، می‌توانید یک محاسبه را به بخش‌های مستقل تقسیم کنید، این بخش‌ها را بین Threadها تقسیم کنید، و سپس از یک <code>Mutex&lt;T&gt;</code> استفاده کنید تا هر Thread نتیجه نهایی را با بخش مربوط به خودش به‌روزرسانی کند.</p>
<p>توجه داشته باشید که اگر در حال انجام عملیات عددی ساده هستید، نوع‌های ساده‌تری نسبت به <code>Mutex&lt;T&gt;</code> در ماژول <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code> از کتابخانه استاندارد</a><!-- ignore --> ارائه شده‌اند. این نوع‌ها دسترسی اتمی، ایمن و همزمان به نوع‌های ابتدایی فراهم می‌کنند. ما برای این مثال از <code>Mutex&lt;T&gt;</code> با یک نوع ابتدایی استفاده کردیم تا بتوانیم بر نحوه کار <code>Mutex&lt;T&gt;</code> تمرکز کنیم.</p>
<h3 id="شباهتهای-بین-refcelltrct-و-mutextarct"><a class="header" href="#شباهتهای-بین-refcelltrct-و-mutextarct">شباهت‌های بین <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> و <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>ممکن است متوجه شده باشید که <code>counter</code> تغییرناپذیر است، اما توانستیم یک مرجع قابل تغییر به مقدار داخل آن بگیریم؛ این بدان معناست که <code>Mutex&lt;T&gt;</code> قابلیت تغییر داخلی (<em>interior mutability</em>) را فراهم می‌کند، همان‌طور که خانواده <code>Cell</code> این کار را می‌کنند. به همان شکلی که در فصل ۱۵ از <code>RefCell&lt;T&gt;</code> برای اجازه تغییر محتوا درون یک <code>Rc&lt;T&gt;</code> استفاده کردیم، از <code>Mutex&lt;T&gt;</code> برای تغییر محتوا درون یک <code>Arc&lt;T&gt;</code> استفاده می‌کنیم.</p>
<p>نکته دیگری که باید توجه کنید این است که Rust نمی‌تواند شما را از تمام انواع خطاهای منطقی هنگام استفاده از <code>Mutex&lt;T&gt;</code> محافظت کند. به یاد بیاورید که در فصل ۱۵ استفاده از <code>Rc&lt;T&gt;</code> با خطر ایجاد چرخه‌های مرجع همراه بود، جایی که دو مقدار <code>Rc&lt;T&gt;</code> به یکدیگر ارجاع می‌دادند و باعث نشت حافظه می‌شدند. به‌طور مشابه، <code>Mutex&lt;T&gt;</code> با خطر ایجاد <em>بن‌بست</em> (<em>deadlock</em>) همراه است. این وضعیت زمانی رخ می‌دهد که یک عملیات نیاز به قفل کردن دو منبع دارد و دو Thread هر کدام یکی از قفل‌ها را به دست آورده‌اند و باعث می‌شوند که برای همیشه منتظر یکدیگر بمانند. اگر به بن‌بست علاقه دارید، سعی کنید یک برنامه Rust ایجاد کنید که دچار بن‌بست شود؛ سپس استراتژی‌های کاهش بن‌بست برای Mutexها در هر زبانی را تحقیق کنید و آن‌ها را در Rust پیاده‌سازی کنید. مستندات API کتابخانه استاندارد برای <code>Mutex&lt;T&gt;</code> و <code>MutexGuard</code> اطلاعات مفیدی ارائه می‌دهد.</p>
<p>ما این فصل را با صحبت درباره ویژگی‌های <code>Send</code> و <code>Sync</code> و نحوه استفاده از آن‌ها با نوع‌های سفارشی تکمیل خواهیم کرد.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
