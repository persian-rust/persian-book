<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="استفاده-از-boxt-برای-اشاره-به-دادهها-در-heap"><a class="header" href="#استفاده-از-boxt-برای-اشاره-به-دادهها-در-heap">استفاده از <code>Box&lt;T&gt;</code> برای اشاره به داده‌ها در Heap</a></h2>
<p>ساده‌ترین اشاره‌گر (Pointer) هوشمند یک <em>جعبه</em> است که نوع آن به صورت <code>Box&lt;T&gt;</code> نوشته می‌شود. جعبه‌ها به شما امکان می‌دهند
داده‌ها را در heap ذخیره کنید به جای stack. چیزی که در stack باقی می‌ماند، اشاره‌گر (Pointer)ی به داده‌های heap است. برای
مرور تفاوت بین stack و heap به فصل ۴ مراجعه کنید.</p>
<p>جعبه‌ها هیچ سربار عملکردی ندارند، به‌جز ذخیره داده‌های خود در heap به جای stack. اما آن‌ها قابلیت‌های اضافی زیادی
ندارند. شما اغلب آن‌ها را در این موقعیت‌ها استفاده خواهید کرد:</p>
<ul>
<li>هنگامی که نوعی دارید که اندازه آن در زمان کامپایل مشخص نیست و می‌خواهید از مقداری از آن نوع در محیطی که نیاز
به اندازه دقیق دارد استفاده کنید.</li>
<li>هنگامی که مقدار زیادی داده دارید و می‌خواهید مالکیت را انتقال دهید، اما اطمینان حاصل کنید که داده‌ها هنگام انجام
این کار کپی نمی‌شوند.</li>
<li>هنگامی که می‌خواهید مالک یک مقدار باشید و فقط اهمیت می‌دهید که آن نوع، یک صفت خاص را پیاده‌سازی کرده باشد
نه اینکه از یک نوع خاص باشد.</li>
</ul>
<p>اولین حالت را در بخش <a href="#enabling-recursive-types-with-boxes">“فعال‌سازی انواع بازگشتی با استفاده از جعبه‌ها”</a><!-- 
ignore --> بررسی خواهیم کرد. در حالت دوم، انتقال مالکیت مقدار زیادی داده می‌تواند زمان زیادی بگیرد زیرا داده‌ها
در stack کپی می‌شوند. برای بهبود عملکرد در این حالت، می‌توانیم مقدار زیادی داده را در heap و در یک جعبه ذخیره
کنیم. سپس، تنها مقدار کمی از داده‌های اشاره‌گر (Pointer) در stack کپی می‌شود، در حالی که داده‌هایی که به آن‌ها اشاره می‌کند
در یک مکان در heap باقی می‌مانند. حالت سوم به نام <em>شیء صفت</em> شناخته می‌شود و فصل ۱۸ بخشی کامل به نام <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“استفاده
از اشیای صفت که به شما اجازه می‌دهند مقادیر از انواع مختلف داشته باشید”</a><!-- ignore --> به این
موضوع اختصاص داده است. بنابراین چیزی که اینجا یاد می‌گیرید، دوباره در فصل ۱۸ استفاده خواهید کرد!</p>
<h3 id="استفاده-از-boxt-برای-ذخیره-دادهها-در-heap"><a class="header" href="#استفاده-از-boxt-برای-ذخیره-دادهها-در-heap">استفاده از <code>Box&lt;T&gt;</code> برای ذخیره داده‌ها در Heap</a></h3>
<p>قبل از اینکه مورد استفاده ذخیره در heap برای <code>Box&lt;T&gt;</code> را بحث کنیم، نحو و نحوه تعامل با مقادیر ذخیره‌شده در
یک <code>Box&lt;T&gt;</code> را پوشش خواهیم داد.</p>
<p>لیستینگ ۱۵-۱ نشان می‌دهد چگونه می‌توان از یک جعبه برای ذخیره مقدار <code>i32</code> در heap استفاده کرد:</p>
<figure class="listing" id="listing-15-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<figcaption><a href="#listing-15-1">Listing 15-1</a>: ذخیره مقدار <code>i32</code> در heap با استفاده از یک جعبه</figcaption>
</figure>
<p>ما متغیر <code>b</code> را تعریف می‌کنیم تا مقدار یک <code>Box</code> که به مقدار <code>5</code> اشاره می‌کند را داشته باشد، که در heap تخصیص
داده شده است. این برنامه <code>b = 5</code> را چاپ می‌کند؛ در این حالت، می‌توانیم به داده‌های موجود در جعبه دسترسی داشته
باشیم، مشابه حالتی که این داده‌ها در stack بودند. درست مثل هر مقدار مالک، وقتی یک جعبه از دامنه خارج می‌شود، همان
طور که <code>b</code> در پایان <code>main</code> این کار را می‌کند، آزاد می‌شود. آزادسازی هم برای جعبه (ذخیره‌شده در stack) و هم داده‌هایی
که به آن اشاره می‌کند (ذخیره‌شده در heap) اتفاق می‌افتد.</p>
<p>قرار دادن یک مقدار واحد در heap خیلی مفید نیست، بنابراین جعبه‌ها را به‌تنهایی به این شکل خیلی استفاده نخواهید
کرد. داشتن مقادیری مانند یک <code>i32</code> در stack، جایی که به‌طور پیش‌فرض ذخیره می‌شوند، در اکثر موارد مناسب‌تر است. بیایید
به حالتی نگاه کنیم که جعبه‌ها به ما امکان می‌دهند انواعی را تعریف کنیم که بدون آن‌ها نمی‌توانستیم.</p>
<h3 id="فعالسازی-انواع-بازگشتی-با-استفاده-از-جعبهها"><a class="header" href="#فعالسازی-انواع-بازگشتی-با-استفاده-از-جعبهها">فعال‌سازی انواع بازگشتی با استفاده از جعبه‌ها</a></h3>
<p>یک مقدار از نوع <em>بازگشتی</em> می‌تواند مقدار دیگری از همان نوع را به‌عنوان بخشی از خود داشته باشد. انواع بازگشتی
یک مسئله ایجاد می‌کنند زیرا در زمان کامپایل، Rust باید بداند یک نوع چقدر فضا اشغال می‌کند. با این حال، تودرتویی
مقادیر انواع بازگشتی می‌تواند به‌طور نظری بی‌نهایت ادامه یابد، بنابراین Rust نمی‌تواند بداند که مقدار چقدر فضا
نیاز دارد. چون جعبه‌ها یک اندازه مشخص دارند، می‌توانیم انواع بازگشتی را با قرار دادن یک جعبه در تعریف نوع بازگشتی
فعال کنیم.</p>
<p>به‌عنوان مثالی از یک نوع بازگشتی، بیایید به <em>لیست cons</em> نگاه کنیم. این یک نوع داده است که معمولاً در زبان‌های
برنامه‌نویسی تابعی یافت می‌شود. نوع لیست cons که تعریف خواهیم کرد ساده است به جز بازگشت؛ بنابراین، مفاهیم موجود
در مثالی که با آن کار خواهیم کرد، هر زمان که وارد موقعیت‌های پیچیده‌تری با انواع بازگشتی شوید مفید خواهند بود.</p>
<h4 id="اطلاعات-بیشتر-درباره-لیست-cons"><a class="header" href="#اطلاعات-بیشتر-درباره-لیست-cons">اطلاعات بیشتر درباره لیست Cons</a></h4>
<p>یک <em>لیست cons</em> یک ساختار داده‌ای است که از زبان برنامه‌نویسی Lisp و گویش‌های آن می‌آید و از جفت‌های تودرتو تشکیل
شده است و نسخه Lisp از یک لیست پیوندی است. نام آن از تابع <code>cons</code> (مخفف “تابع ساخت” یا Construct Function) در Lisp
گرفته شده است که یک جفت جدید را از دو آرگومان خود می‌سازد. با فراخوانی <code>cons</code> روی یک جفت که شامل یک مقدار و یک جفت
دیگر است، می‌توانیم لیست‌های cons ساخته‌شده از جفت‌های بازگشتی را ایجاد کنیم.</p>
<p>برای مثال، در اینجا یک نمایش شبه‌کد از یک لیست cons که شامل لیست ۱، ۲، ۳ است آورده شده است که هر جفت در داخل پرانتز
قرار دارد:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>هر آیتم در یک لیست cons شامل دو عنصر است: مقدار آیتم فعلی و آیتم بعدی. آخرین آیتم در لیست تنها شامل مقداری به نام
<code>Nil</code> است و آیتم بعدی ندارد. یک لیست cons با فراخوانی بازگشتی تابع <code>cons</code> تولید می‌شود. نام متعارف برای نشان دادن
حالت پایه بازگشت، <code>Nil</code> است. توجه داشته باشید که این با مفهوم “null” یا “nil” در فصل ۶ که یک مقدار نامعتبر یا غایب
است، متفاوت است.</p>
<p>لیست cons یک ساختار داده‌ای نیست که به‌طور معمول در Rust استفاده شود. در اکثر مواقع وقتی یک لیست از آیتم‌ها در
Rust دارید، استفاده از <code>Vec&lt;T&gt;</code> انتخاب بهتری است. سایر انواع بازگشتی پیچیده‌تر <em>در</em> موقعیت‌های مختلف مفید هستند،
اما با شروع از لیست cons در این فصل، می‌توانیم بررسی کنیم که چگونه جعبه‌ها به ما اجازه می‌دهند یک نوع داده بازگشتی
را بدون حواس‌پرتی زیاد تعریف کنیم.</p>
<p>لیستینگ ۱۵-۲ حاوی یک تعریف enum برای یک لیست cons است. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود زیرا نوع
<code>List</code> اندازه شناخته‌شده‌ای ندارد، که آن را توضیح خواهیم داد.</p>
<figure class="listing" id="listing-15-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-15-2">Listing 15-2</a>: اولین تلاش برای تعریف یک enum برای نمایش یک ساختار داده‌ای لیست cons از مقادیر <code>i32</code></figcaption>
</figure>
<blockquote>
<p>توجه: ما در حال پیاده‌سازی یک لیست cons هستیم که تنها مقادیر <code>i32</code> را نگه می‌دارد، برای اهداف این مثال. می‌توانستیم
آن را با استفاده از جنریک‌ها، همان‌طور که در فصل ۱۰ بحث کردیم، پیاده‌سازی کنیم تا یک نوع لیست cons تعریف کنیم
که بتواند مقادیر هر نوعی را ذخیره کند.</p>
</blockquote>
<p>استفاده از نوع <code>List</code> برای ذخیره لیست <code>1, 2, 3</code> شبیه به کدی خواهد بود که در لیستینگ ۱۵-۳ آورده شده است:</p>
<figure class="listing" id="listing-15-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<figcaption><a href="#listing-15-3">Listing 15-3</a>: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></figcaption>
</figure>
<p>اولین مقدار <code>Cons</code> مقدار <code>1</code> و یک مقدار دیگر از نوع <code>List</code> را نگه می‌دارد. این مقدار <code>List</code> یک مقدار دیگر از نوع
<code>Cons</code> است که مقدار <code>2</code> و یک مقدار دیگر از نوع <code>List</code> را نگه می‌دارد. این مقدار <code>List</code> یک مقدار دیگر از نوع <code>Cons</code>
را نگه می‌دارد که مقدار <code>3</code> و یک مقدار دیگر از نوع <code>List</code> را دارد که در نهایت <code>Nil</code>، متغیر غیر بازگشتی که پایان
لیست را نشان می‌دهد، است.</p>
<p>اگر سعی کنیم کد در لیستینگ ۱۵-۳ را کامپایل کنیم، خطایی را دریافت می‌کنیم که در لیستینگ ۱۵-۴ نشان داده شده است:</p>
<figure class="listing" id="listing-15-4">
<span class="file-name">Filename: output.txt</span>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-15-4">Listing 15-4</a>: خطایی که هنگام تلاش برای تعریف یک enum بازگشتی دریافت می‌کنیم</figcaption>
</figure>
<p>خطا نشان می‌دهد که این نوع “اندازه بی‌نهایت” دارد. دلیل این است که ما <code>List</code> را با یک متغیر تعریف کرده‌ایم که
بازگشتی است: به‌طور مستقیم یک مقدار دیگر از نوع خود را نگه می‌دارد. در نتیجه، Rust نمی‌تواند بفهمد چقدر فضا نیاز
دارد تا یک مقدار از نوع <code>List</code> را ذخیره کند. بیایید بررسی کنیم چرا این خطا را دریافت می‌کنیم. ابتدا، نگاهی به این
می‌اندازیم که Rust چگونه تصمیم می‌گیرد چه مقدار فضا برای ذخیره یک مقدار از نوع غیر بازگشتی نیاز دارد.</p>
<h4 id="محاسبه-اندازه-یک-نوع-غیر-بازگشتی"><a class="header" href="#محاسبه-اندازه-یک-نوع-غیر-بازگشتی">محاسبه اندازه یک نوع غیر بازگشتی</a></h4>
<p>ساختار <code>Message</code> را که در لیستینگ ۶-۲ تعریف کرده‌ایم، به‌خاطر بیاورید وقتی که در فصل ۶ در مورد تعریف‌های enum
بحث کردیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>برای تعیین اینکه چقدر فضا برای یک مقدار از نوع <code>Message</code> اختصاص داده شود، Rust هر یک از متغیرها را بررسی می‌کند
تا ببیند کدام متغیر بیشترین فضا را نیاز دارد. Rust می‌بیند که <code>Message::Quit</code> نیازی به فضا ندارد، <code>Message::Move</code>
نیاز به فضای کافی برای ذخیره دو مقدار <code>i32</code> دارد، و همین‌طور ادامه می‌دهد. چون تنها یک متغیر استفاده خواهد شد،
بیشترین فضای مورد نیاز برای یک مقدار <code>Message</code> فضایی است که بزرگ‌ترین متغیر آن اشغال می‌کند.</p>
<p>این را با حالتی مقایسه کنید که Rust سعی می‌کند تعیین کند چه مقدار فضا برای یک نوع بازگشتی مانند enum <code>List</code> در
لیستینگ ۱۵-۲ نیاز است. کامپایلر با نگاه کردن به متغیر <code>Cons</code> شروع می‌کند که یک مقدار از نوع <code>i32</code> و یک مقدار از نوع
<code>List</code> را نگه می‌دارد. بنابراین، <code>Cons</code> به فضایی معادل اندازه یک <code>i32</code> به‌علاوه اندازه یک <code>List</code> نیاز دارد. برای
فهمیدن اینکه نوع <code>List</code> به چه مقدار حافظه نیاز دارد، کامپایلر متغیرها را بررسی می‌کند و از متغیر <code>Cons</code> شروع می‌کند.
متغیر <code>Cons</code> یک مقدار از نوع <code>i32</code> و یک مقدار از نوع <code>List</code> را نگه می‌دارد، و این فرآیند به‌طور بی‌نهایت ادامه
می‌یابد، همان‌طور که در شکل ۱۵-۱ نشان داده شده است.</p>
<img alt="یک لیست Cons بی‌نهایت: یک مستطیل با برچسب 'Cons' که به دو مستطیل کوچکتر تقسیم شده است. مستطیل اول دارای برچسب 'i32' و مستطیل دوم دارای برچسب 'Cons' است و نسخه‌ای کوچکتر از مستطیل بیرونی 'Cons' را در خود دارد. این مستطیل‌های 'Cons' همچنان نسخه‌های کوچکتری از خود را درون خود نگه می‌دارند تا زمانی که کوچک‌ترین مستطیل قابل‌نمایش یک نماد بی‌نهایت را در خود دارد، که نشان می‌دهد این تکرار تا بی‌نهایت ادامه می‌یابد." src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۱۵-۱: یک <code>List</code> بی‌نهایت شامل متغیرهای <code>Cons</code> بی‌نهایت</span></p>
<h4 id="استفاده-از-boxt-برای-بهدست-آوردن-یک-نوع-بازگشتی-با-اندازه-شناختهشده"><a class="header" href="#استفاده-از-boxt-برای-بهدست-آوردن-یک-نوع-بازگشتی-با-اندازه-شناختهشده">استفاده از <code>Box&lt;T&gt;</code> برای به‌دست آوردن یک نوع بازگشتی با اندازه شناخته‌شده</a></h4>
<p>چون Rust نمی‌تواند بفهمد چه مقدار فضا باید برای انواع تعریف‌شده به‌صورت بازگشتی تخصیص دهد، کامپایلر با این پیشنهاد
کمکی خطا می‌دهد:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>در این پیشنهاد، “غیرمستقیم‌سازی” به این معنا است که به‌جای ذخیره مستقیم یک مقدار، باید ساختار داده را تغییر دهیم تا
مقدار را به‌صورت غیرمستقیم با ذخیره یک اشاره‌گر (Pointer) به مقدار ذخیره کند.</p>
<p>چون <code>Box&lt;T&gt;</code> یک اشاره‌گر (Pointer) است، Rust همیشه می‌داند که یک <code>Box&lt;T&gt;</code> به چه مقدار فضا نیاز دارد: اندازه یک اشاره‌گر (Pointer)
بر اساس مقدار داده‌ای که به آن اشاره می‌کند تغییر نمی‌کند. این بدان معنا است که می‌توانیم یک <code>Box&lt;T&gt;</code> را در
متغیر <code>Cons</code> قرار دهیم به‌جای یک مقدار دیگر از نوع <code>List</code>. <code>Box&lt;T&gt;</code> به مقدار بعدی <code>List</code> اشاره می‌کند که روی heap
خواهد بود به‌جای داخل متغیر <code>Cons</code>. به‌صورت مفهومی، ما همچنان یک لیست داریم که از لیست‌های دیگری تشکیل شده است، اما
این پیاده‌سازی اکنون بیشتر شبیه قرار دادن آیتم‌ها در کنار یکدیگر است تا داخل یکدیگر.</p>
<p>ما می‌توانیم تعریف enum <code>List</code> در لیستینگ ۱۵-۲ و استفاده از <code>List</code> در لیستینگ ۱۵-۳ را به کد موجود در لیستینگ ۱۵-۵
تغییر دهیم، که کامپایل خواهد شد:</p>
<figure class="listing" id="listing-15-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<figcaption><a href="#listing-15-5">Listing 15-5</a>: تعریف <code>List</code> که از <code>Box&lt;T&gt;</code> استفاده می‌کند تا اندازه مشخصی داشته باشد</figcaption>
</figure>
<p>متغیر <code>Cons</code> به اندازه‌ای برابر با یک <code>i32</code> به‌علاوه فضای لازم برای نگه‌داری داده‌های اشاره‌گر <code>Box</code> نیاز دارد. متغیر <code>Nil</code> هیچ مقداری را ذخیره نمی‌کند، بنابراین به فضای کمتری روی پشته نسبت به <code>Cons</code> نیاز دارد. اکنون می‌دانیم که هر مقدار از نوع <code>List</code> فضایی برابر با اندازه‌ی یک <code>i32</code> به‌علاوه اندازه‌ی داده‌ی اشاره‌گر <code>Box</code> اشغال می‌کند. با استفاده از یک <code>Box</code>، زنجیره بازگشتی بی‌نهایت را شکسته‌ایم، بنابراین کامپایلر می‌تواند اندازه مورد نیاز برای ذخیره یک مقدار <code>List</code> را محاسبه کند. شکل 15-2 نشان می‌دهد که متغیر <code>Cons</code> اکنون چگونه به نظر می‌رسد.</p>
<img alt="یک مستطیل با برچسب 'Cons' که به دو مستطیل کوچکتر تقسیم شده است. مستطیل اول دارای برچسب 'i32' و مستطیل دوم دارای برچسب 'Box' است که یک مستطیل داخلی با برچسب 'usize' درون آن قرار دارد، که اندازه محدود اشاره‌گر درون Box را نشان می‌دهد." src="img/trpl15-02.svg" class="center" />
<p><span class="caption">شکل ۱۵-۲: یک <code>List</code> که بی‌نهایت نیست زیرا <code>Cons</code> یک <code>Box</code> نگه می‌دارد</span></p>
<p>جعبه‌ها تنها غیرمستقیم‌سازی و تخصیص heap را فراهم می‌کنند؛ آن‌ها هیچ قابلیت خاص دیگری ندارند، مانند آنچه با دیگر انواع
اشاره‌گر (Pointer) هوشمند خواهیم دید. آن‌ها همچنین سربار عملکردی که این قابلیت‌های خاص ایجاد می‌کنند را ندارند، بنابراین می‌توانند
در مواردی مانند لیست cons مفید باشند که غیرمستقیم‌سازی تنها ویژگی مورد نیاز است. ما موارد استفاده بیشتری از جعبه‌ها را
نیز در فصل ۱۸ بررسی خواهیم کرد.</p>
<p>نوع <code>Box&lt;T&gt;</code> یک اشاره‌گر (Pointer) هوشمند است زیرا ویژگی <code>Deref</code> را پیاده‌سازی می‌کند، که به مقادیر <code>Box&lt;T&gt;</code> اجازه می‌دهد
مانند ارجاعات رفتار کنند. وقتی یک مقدار <code>Box&lt;T&gt;</code> از دامنه خارج می‌شود، داده‌های heap که جعبه به آن اشاره می‌کند
نیز به دلیل پیاده‌سازی ویژگی <code>Drop</code> پاک‌سازی می‌شود. این دو ویژگی برای عملکرد انواع دیگر اشاره‌گر (Pointer)های هوشمند که
در بقیه این فصل مورد بحث قرار می‌دهیم، اهمیت بیشتری خواهند داشت. بیایید این دو ویژگی را با جزئیات بیشتری بررسی کنیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-00-smart-pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-02-deref.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-00-smart-pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-02-deref.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
