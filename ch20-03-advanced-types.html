<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>تایپ‌های پیشرفته - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="انواع-typeهای-پیشرفته"><a class="header" href="#انواع-typeهای-پیشرفته">انواع (Typeهای) پیشرفته</a></h2>
<p>سیستم نوع‌بندی Rust شامل ویژگی‌هایی است که تاکنون فقط به آن‌ها اشاره کرده‌ایم و هنوز به‌طور کامل مورد بحث قرار نگرفته‌اند. ابتدا به بررسی الگوی newtype می‌پردازیم تا بفهمیم چرا این الگو به‌عنوان انواع مفید است. سپس به aliasهای نوع می‌پردازیم، که ویژگی مشابهی با newtype دارند اما با تفاوت‌هایی در معناشناسی. همچنین، نوع <code>!</code> و انواع پویا (dynamically sized types) را نیز بررسی خواهیم کرد.</p>
<h3 id="استفاده-از-الگوی-newtype-برای-ایمنی-نوع-و-انتزاع"><a class="header" href="#استفاده-از-الگوی-newtype-برای-ایمنی-نوع-و-انتزاع">استفاده از الگوی Newtype برای ایمنی نوع و انتزاع</a></h3>
<p>این بخش فرض می‌کند که پیش‌تر بخش <a href="ch20-02-advanced-traits.html#%D8%A7%D8%B3%D8%AA%D9%81%D8%A7%D8%AF%D9%87-%D8%A7%D8%B2-%D8%A7%D9%84%DA%AF%D9%88%DB%8C-newtype-%D8%A8%D8%B1%D8%A7%DB%8C-%D9%BE%DB%8C%D8%A7%D8%AF%D9%87%D8%B3%D8%A7%D8%B2%DB%8C-traits-%D8%AE%D8%A7%D8%B1%D8%AC%DB%8C-%D8%B1%D9%88%DB%8C-%D8%A7%D9%86%D9%88%D8%A7%D8%B9-%D8%AE%D8%A7%D8%B1%D8%AC%DB%8C">«استفاده از الگوی Newtype برای پیاده‌سازی Traitهای خارجی»</a><!-- ignore --> را خوانده‌اید. الگوی newtype برای کارهایی فراتر از آن‌چه تاکنون بحث کردیم نیز مفید است، از جمله اعمال محدودیت‌های ایستا (statically) برای جلوگیری از اشتباه گرفتن مقادیر و مشخص‌کردن واحد یک مقدار. مثالی از استفاده‌ی newtype برای مشخص‌کردن واحدها را در لیستینگ 20-16 مشاهده کردید: به خاطر بیاورید که ساختارهای <code>Millimeters</code> و <code>Meters</code> مقادیر <code>u32</code> را درون یک newtype می‌پیچیدند. اگر تابعی با پارامتری از نوع <code>Millimeters</code> بنویسیم، برنامه‌ای که به‌اشتباه سعی کند آن تابع را با مقداری از نوع <code>Meters</code> یا یک <code>u32</code> معمولی فراخوانی کند، کامپایل نخواهد شد.</p>
<p>ما همچنین می‌توانیم از الگوی newtype برای انتزاع جزئیات پیاده‌سازی یک نوع استفاده کنیم: نوع جدید می‌تواند یک API عمومی ارائه دهد که با API نوع داخلی خصوصی متفاوت است.</p>
<p>الگوی newtype همچنین می‌تواند پیاده‌سازی داخلی را پنهان کند. برای مثال، می‌توانیم یک نوع <code>People</code> ارائه دهیم که یک <code>HashMap&lt;i32, String&gt;</code> را در خود بپیچد؛ این ساختار شناسه‌ی هر فرد را با نام او نگه می‌دارد. کدی که از <code>People</code> استفاده می‌کند، تنها با API عمومی‌ای که ما ارائه می‌دهیم تعامل خواهد داشت، مانند متدی برای افزودن یک رشته‌ی نام به مجموعه‌ی <code>People</code>؛ این کد نیازی ندارد بداند که ما به‌صورت داخلی برای نام‌ها یک شناسه‌ی <code>i32</code> اختصاص می‌دهیم. الگوی newtype روشی سبک‌وزن برای رسیدن به کپسوله‌سازی و پنهان‌سازی جزئیات پیاده‌سازی است؛ موضوعی که در فصل ۱۸، در بخش <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">«کپسوله‌سازی برای پنهان‌سازی جزئیات پیاده‌سازی»</a><!-- ignore --> بررسی کردیم.</p>
<h3 id="ایجاد-مترادفهای-نوع-با-استفاده-از-type-aliases"><a class="header" href="#ایجاد-مترادفهای-نوع-با-استفاده-از-type-aliases">ایجاد مترادف‌های نوع با استفاده از Type Aliases</a></h3>
<p>Rust قابلیت تعریف <em>alias نوع</em> را برای ارائه یک نام دیگر برای یک نوع موجود فراهم می‌کند. برای این کار از کلمه‌کلیدی <code>type</code> استفاده می‌کنیم. به‌عنوان مثال، می‌توانیم alias‌ای به نام <code>Kilometers</code> برای نوع <code>i32</code> ایجاد کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>اکنون نام مستعار <code>Kilometers</code> یک <em>مترادف</em> برای نوع <code>i32</code> است؛ برخلاف انواع <code>Millimeters</code> و <code>Meters</code> که در لیستینگ 20-16 ایجاد کردیم، <code>Kilometers</code> یک نوع جداگانه و جدید نیست. مقادیری که نوع آن‌ها <code>Kilometers</code> باشد، همانند مقادیر نوع <code>i32</code> در نظر گرفته می‌شوند:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>از آن‌جا که <code>Kilometers</code> و <code>i32</code> از نظر نوع یکسان هستند، می‌توانیم مقادیری از هر دو نوع را با هم جمع کنیم و همچنین می‌توانیم مقادیر <code>Kilometers</code> را به توابعی بدهیم که پارامترهایی از نوع <code>i32</code> دارند.
با این حال، با استفاده از این روش، مزایای بررسی نوع را که از الگوی newtype (الگوی نوع جدید) به‌دست می‌آید، نخواهیم داشت.
به‌عبارت دیگر، اگر در جایی <code>Kilometers</code> و <code>i32</code> را با هم اشتباه بگیریم، کامپایلر به ما خطا نخواهد داد.</p>
<p>استفاده اصلی از مترادف‌های نوع برای کاهش تکرار است. به‌عنوان مثال، ممکن است یک نوع طولانی مانند این داشته باشیم:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>نوشتن این نوع طولانی در امضاهای توابع و به‌عنوان توضیحات نوع در سراسر کد می‌تواند خسته‌کننده و مستعد خطا باشد. تصور کنید پروژه‌ای پر از کدی مانند آنچه در فهرست 20-25 نشان داده شده است.</p>
<p>&lt;فهرست شماره=“20-25” عنوان=“استفاده از یک نوع طولانی در مکان‌های متعدد”&gt;</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p>&lt;/فهرست&gt;</p>
<p>یک <strong>نوع مستعار</strong> (type alias) این کد را با کاهش تکرار خواناتر و مدیریت‌پذیرتر می‌کند. در فهرست 20-26، ما یک مستعار به نام <code>Thunk</code> برای نوع طولانی معرفی کرده‌ایم و می‌توانیم همه استفاده‌ها از این نوع را با مستعار کوتاه‌تر <code>Thunk</code> جایگزین کنیم.</p>
<figure class="listing" id="listing-20-26">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p>&lt;/فهرست&gt;</p>
<p>این کد بسیار خواناتر و نوشتن آن آسان‌تر است! انتخاب یک نام معنادار برای نوع مستعار می‌تواند به انتقال مقصود شما کمک کند. (برای مثال، <em>thunk</em> کلمه‌ای است که به کدی اشاره دارد که قرار است در آینده اجرا شود، بنابراین برای اشاره به یک closure که ذخیره می‌شود، مناسب است).</p>
<p>نوع‌های مستعار همچنین معمولاً با نوع <code>Result&lt;T, E&gt;</code> برای کاهش تکرار استفاده می‌شوند. به‌عنوان نمونه، ماژول <code>std::io</code> در کتابخانه استاندارد را در نظر بگیرید. عملیات I/O اغلب یک <code>Result&lt;T, E&gt;</code> برمی‌گرداند تا مواقعی که عملیات با شکست مواجه می‌شود مدیریت شود. این کتابخانه یک ساختار <code>std::io::Error</code> دارد که تمامی خطاهای ممکن در I/O را نمایش می‌دهد. بسیاری از توابع در <code>std::io</code> <code>Result&lt;T, E&gt;</code> را برمی‌گردانند که در آن <code>E</code> برابر با <code>std::io::Error</code> است، مانند این توابع در trait <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>عبارت <code>Result&lt;..., Error&gt;</code> به دفعات تکرار شده است. به همین دلیل، در ماژول <code>std::io</code> یک نوع مستعار (type alias) به این شکل تعریف شده است:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>از آنجا که این تعریف در ماژول <code>std::io</code> قرار دارد، می‌توانیم از نوع مستعار <code>std::io::Result&lt;T&gt;</code> استفاده کنیم؛ به این معنی که <code>Result&lt;T, E&gt;</code> با مقدار <code>E</code> برابر با <code>std::io::Error</code> است. امضای توابع موجود در trait <code>Write</code> به این شکل خواهد بود:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>این نوع مستعار از دو جنبه کمک‌کننده است: نوشتن کد را ساده‌تر می‌کند <em>و</em> یک رابط کاربری یکپارچه در تمام بخش‌های <code>std::io</code> فراهم می‌آورد. از آنجا که این یک مستعار است، همچنان یک <code>Result&lt;T, E&gt;</code> معمولی است؛ به این معنی که می‌توانیم از تمام متدهایی که روی <code>Result&lt;T, E&gt;</code> کار می‌کنند استفاده کنیم، همچنین از نحو خاص مانند عملگر <code>?</code>.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type That Never Returns</a></h3>
<p>Rust دارای یک نوع ویژه به نام <code>!</code> است که در نظریه نوع‌ها به عنوان <em>نوع خالی</em> (empty type) شناخته می‌شود، زیرا هیچ مقداری ندارد. ما ترجیح می‌دهیم آن را <em>نوعی که هرگز بازنمی‌گردد</em> (never type) بنامیم، زیرا به‌جای نوع بازگشتی قرار می‌گیرد زمانی که یک تابع هرگز بازنمی‌گردد. به مثال زیر توجه کنید:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>این کد به این صورت خوانده می‌شود: «تابع <code>bar</code> هرگز باز نمی‌گردد.»
تابع‌هایی که هرگز باز نمی‌گردند، <em>تابع‌های واگرا (diverging functions)</em> نام دارند.
ما نمی‌توانیم مقداری از نوع <code>!</code> بسازیم، بنابراین <code>bar</code> نمی‌تواند هیچ‌گاه مقداری بازگرداند.</p>
<p>اما چه فایده‌ای دارد نوعی که نمی‌توانید هیچ مقداری از آن بسازید؟
کدی را به یاد آورید که در لیست ۲-۵، بخشی از بازی حدس عدد بود؛ ما بخشی از آن را این‌جا در لیست 20-27 بازتولید کرده‌ایم.</p>
<figure class="listing" id="listing-20-27">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-27">Listing 20-27</a>: یک <code>match</code> با بازوی پایانی که به <code>continue</code> ختم می‌شود</figcaption>
</figure>
<p>در آن زمان، از برخی جزئیات در این کد عبور کردیم.
در بخش <a href="ch06-02-match.html#the-match-control-flow-construct">«ساختار کنترلی <code>match</code>»</a><!-- ignore --> در فصل ۶،
بحث کردیم که تمام بازوهای <code>match</code> باید یک نوع بازگشتی یکسان داشته باشند.
برای مثال، کد زیر کار نمی‌کند:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>نوع <code>guess</code> در این کد باید هم عدد صحیح (<em>integer</em>) و هم رشته (<em>string</em>) باشد، و Rust نیاز دارد که <code>guess</code> تنها یک نوع داده داشته باشد. بنابراین، دستور <code>continue</code> چه مقداری را برمی‌گرداند؟ چگونه توانستیم از یک بازو مقدار <code>u32</code> بازگردانیم و در بازوی دیگر <code>continue</code> را قرار دهیم که در لیست ۲۰-۲۷ آورده شده است؟</p>
<p>همان‌طور که احتمالاً حدس زده‌اید، دستور <code>continue</code> دارای نوع <code>!</code> است. یعنی، وقتی Rust نوع <code>guess</code> را محاسبه می‌کند، به هر دو بازوی <code>match</code> نگاه می‌کند: بازوی اول مقداری از نوع <code>u32</code> دارد و بازوی دوم مقداری از نوع <code>!</code>. از آنجا که <code>!</code> نمی‌تواند هیچ مقداری داشته باشد، Rust نتیجه‌گیری می‌کند که نوع <code>guess</code> برابر با <code>u32</code> است.</p>
<p>روش رسمی برای توصیف این رفتار این است که عبارت‌های نوع <code>!</code> می‌توانند به هر نوع دیگری تبدیل شوند (<em>coerce</em>). ما می‌توانیم بازوی <code>match</code> را با دستور <code>continue</code> پایان دهیم زیرا <code>continue</code> مقداری باز نمی‌گرداند؛ بلکه کنترل را به بالای حلقه بازمی‌گرداند، بنابراین در حالت <code>Err</code>، هیچ مقداری به <code>guess</code> اختصاص داده نمی‌شود.</p>
<p>نوع <code>!</code> در ماکرو <code>panic!</code> نیز مفید است. به یاد بیاورید تابع <code>unwrap</code> که روی مقادیر <code>Option&lt;T&gt;</code> فراخوانی می‌کنیم تا مقداری را تولید کند یا با استفاده از این تعریف متوقف شود:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>در این کد، همان چیزی که در <code>match</code> لیست ۲۰-۲۷ رخ داد اتفاق می‌افتد: Rust می‌بیند که <code>val</code> از نوع <code>T</code> است و <code>panic!</code> از نوع <code>!</code> است، بنابراین نتیجه کلی عبارت <code>match</code> برابر با <code>T</code> است. این کد کار می‌کند زیرا <code>panic!</code> هیچ مقداری تولید نمی‌کند؛ بلکه برنامه را متوقف می‌کند. در حالت <code>None</code>، ما مقداری از <code>unwrap</code> بازنمی‌گردانیم، بنابراین این کد معتبر است.</p>
<p>یک عبارت نهایی که نوع <code>!</code> دارد، حلقه <code>loop</code> است:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>اینجا، حلقه هیچ‌گاه متوقف نمی‌شود، بنابراین نوع <code>!</code> مقدار عبارت خواهد بود. با این حال، اگر <code>break</code> درون حلقه باشد، این موضوع درست نخواهد بود، زیرا حلقه وقتی به <code>break</code> می‌رسد، متوقف می‌شود.</p>
<p>فایل تکمیل شد.</p>
<h3 id="typeها-با-اندازه-پویا-dynamic-و-ویژگی-sized"><a class="header" href="#typeها-با-اندازه-پویا-dynamic-و-ویژگی-sized">typeها با اندازه پویا (dynamic) و ویژگی <code>Sized</code></a></h3>
<p>بیایید وارد جزئیات نوعی با اندازه‌ی پویا (Dynamically Sized Type یا DST) به نام <code>str</code> شویم
که در طول این کتاب بارها از آن استفاده کرده‌ایم.
بله درست است، منظورمان <code>&amp;str</code> نیست، بلکه خود <code>str</code> به‌تنهایی یک DST است.
در بسیاری از موارد، مانند زمانی که متنی توسط کاربر وارد می‌شود،
ما نمی‌دانیم طول رشته چقدر است تا زمانی که برنامه اجرا شود.
این بدان معناست که نمی‌توانیم یک متغیر از نوع <code>str</code> ایجاد کنیم
و نه می‌توانیم آرگومانی از نوع <code>str</code> دریافت کنیم.
به مثال زیر توجه کنید که کار نمی‌کند:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust نیاز دارد که بداند چقدر حافظه برای هر مقدار از یک نوع خاص تخصیص دهد، و تمام مقادیر یک نوع باید از همان مقدار حافظه استفاده کنند. اگر Rust اجازه می‌داد این کد را بنویسیم، این دو مقدار <code>str</code> باید از یک مقدار فضا استفاده می‌کردند. اما آن‌ها طول‌های متفاوتی دارند: <code>s1</code> به ۱۲ بایت فضای ذخیره‌سازی نیاز دارد و <code>s2</code> به ۱۵ بایت. به همین دلیل است که ایجاد یک متغیر که یک نوع با اندازه دایتانیک داشته باشد ممکن نیست.</p>
<p>پس چه کار باید بکنیم؟ در این حالت، شما از قبل پاسخ را می‌دانید:
باید نوع‌های <code>s1</code> و <code>s2</code> را به جای <code>str</code>، به <code>&amp;str</code> تغییر دهیم.
به یاد دارید از بخش <a href="ch04-03-slices.html#string-slices">“برش‌های رشته‌ای”</a><!-- ignore --> در فصل ۴
که ساختار داده‌ی slice فقط موقعیت شروع و طول برش را ذخیره می‌کند.
بنابراین، اگرچه یک <code>&amp;T</code> یک مقدار منفرد است که آدرس حافظه‌ای که <code>T</code> در آن قرار دارد را ذخیره می‌کند،
یک <code>&amp;str</code> <em>دو</em> مقدار دارد: آدرس <code>str</code> و طول آن.</p>
<p>از این رو، می‌توانیم اندازه‌ی مقدار <code>&amp;str</code> را در زمان کامپایل بدانیم:
این اندازه دو برابر طول یک <code>usize</code> است.
یعنی، همیشه اندازه‌ی <code>&amp;str</code> را می‌دانیم، فارغ از اینکه طول رشته‌ای که به آن اشاره می‌کند چقدر باشد.
به طور کلی، این همان روشی است که نوع‌های با اندازه‌ی پویا در Rust استفاده می‌شوند:
آن‌ها یک قطعه اضافی از فراداده (metadata) دارند که اندازه‌ی اطلاعات پویا را ذخیره می‌کند.
قانون طلایی نوع‌های با اندازه‌ی پویا این است که
همیشه باید مقادیر این نوع‌ها را پشت یک نوع اشاره‌گر (pointer) قرار دهیم.</p>
<p>ما می‌توانیم <code>str</code> را با انواع مختلفی از اشاره‌گرها ترکیب کنیم:
برای مثال، <code>Box&lt;str&gt;</code> یا <code>Rc&lt;str&gt;</code>.
در واقع، قبلاً نیز این را دیده‌اید اما با نوعی دیگر از نوع‌های با اندازه‌ی پویا: traits.
هر trait یک نوع با اندازه‌ی پویا است که می‌توانیم با استفاده از نام trait به آن ارجاع دهیم.
در بخش <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“استفاده از trait objectها برای انتزاع‌سازی روی رفتار مشترک”</a><!-- ignore -->
در فصل ۱۸، گفتیم که برای استفاده از traits به عنوان trait object،
باید آن‌ها را پشت یک اشاره‌گر قرار دهیم، مانند <code>&amp;dyn Trait</code> یا <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> نیز کار می‌کند).</p>
<p>برای کار با تایپ‌های دایتانیک، Rust ویژگی <code>Sized</code> را فراهم می‌کند تا تعیین کند که آیا اندازه یک نوع در زمان کامپایل مشخص است یا خیر. این ویژگی به طور خودکار برای هر چیزی که اندازه آن در زمان کامپایل مشخص باشد پیاده‌سازی می‌شود. علاوه بر این، Rust به طور ضمنی یک محدودیت روی <code>Sized</code> را به هر تابع جنریک اضافه می‌کند. یعنی یک تعریف تابع جنریک به این صورت:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>در واقع، به گونه‌ای رفتار می‌شود که گویی این را نوشته‌ایم:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>به طور پیش‌فرض، توابع جنریک فقط روی نوع‌هایی کار خواهند کرد که اندازه آن‌ها در زمان کامپایل مشخص باشد. با این حال، می‌توانید از سینتکس خاص زیر برای کاهش این محدودیت استفاده کنید:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>یک محدودیت ویژگی روی <code>?Sized</code> به این معنی است که “<code>T</code> ممکن است <code>Sized</code> باشد یا نباشد” و این یادداشت، پیش‌فرضی که نوع‌های جنریک باید اندازه مشخصی در زمان کامپایل داشته باشند را لغو می‌کند. سینتکس <code>?Trait</code> با این معنا تنها برای <code>Sized</code> در دسترس است، نه برای هیچ ویژگی دیگری.</p>
<p>همچنین توجه داشته باشید که نوع پارامتر <code>t</code> را از <code>T</code> به <code>&amp;T</code> تغییر دادیم. از آنجایی که نوع ممکن است <code>Sized</code> نباشد، باید از آن پشت یک نوع اشاره‌گر (Pointer) استفاده کنیم. در این مورد، یک ارجاع انتخاب کرده‌ایم.</p>
<p>در ادامه، درباره توابع و closureها صحبت خواهیم کرد!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
