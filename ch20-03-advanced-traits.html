<!DOCTYPE HTML>
<html lang="fa" class="light" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>صفت‌های پیشرفته - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، جعبه‌ها (crates)، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و جعبه‌ها (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گر (Pointer)های هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر (Pointer) هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از تایپ‌های مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html" class="active"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> تایپ‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور single-threaded</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h2>
<p>ما در بخش <a href="ch10-02-traits.html#traits-defining-shared-behavior">“Traits: Defining Shared Behavior”</a><!-- ignore --> از فصل 10 به بررسی traits پرداختیم، اما جزئیات پیشرفته‌تر آن را مورد بحث قرار ندادیم. اکنون که اطلاعات بیشتری در مورد راست دارید، می‌توانیم به عمق موضوع بپردازیم.</p>
<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>نوع‌های مرتبط</em> (Associated types) یک نوع جایگزین را با یک trait متصل می‌کنند، به‌گونه‌ای که تعریف‌های متد trait می‌توانند از این نوع‌های جایگزین در امضاهای خود استفاده کنند. پیاده‌ساز یک trait نوع خاصی را برای جایگزینی نوع جایگزین برای پیاده‌سازی خاص مشخص می‌کند. به این ترتیب، می‌توانیم یک trait تعریف کنیم که از برخی نوع‌ها استفاده می‌کند بدون اینکه نیاز داشته باشیم دقیقاً بدانیم این نوع‌ها چه هستند تا زمانی که trait پیاده‌سازی شود.</p>
<p>بیشتر ویژگی‌های پیشرفته‌ای که در این فصل توضیح داده شده است، به‌ندرت مورد نیاز هستند. نوع‌های مرتبط در حد وسط قرار دارند: آن‌ها کمتر از ویژگی‌های توضیح داده‌شده در بقیه کتاب استفاده می‌شوند، اما بیشتر از بسیاری از ویژگی‌های دیگر مورد بحث در این فصل به کار می‌روند.</p>
<p>یکی از مثال‌های یک trait با یک نوع مرتبط، trait <code>Iterator</code> است که کتابخانه استاندارد فراهم می‌کند. نوع مرتبط با نام <code>Item</code> مشخص شده و به‌جای نوع مقادیری که نوع پیاده‌سازی‌کننده <code>Iterator</code> از روی آن‌ها تکرار می‌کند قرار می‌گیرد. تعریف trait <code>Iterator</code> همان‌طور که در فهرست 20-13 نشان داده شده است:</p>
<figure class="listing">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<figcaption>Listing 20-13: تعریف trait <code>Iterator</code> که دارای یک نوع مرتبط به نام <code>Item</code> است</figcaption>
</figure>
<p>نوع <code>Item</code> یک جایگزین است و تعریف متد <code>next</code> نشان می‌دهد که مقادیری از نوع <code>Option&lt;Self::Item&gt;</code> را بازمی‌گرداند. پیاده‌سازان trait <code>Iterator</code> نوع خاصی را برای <code>Item</code> مشخص می‌کنند و متد <code>next</code> یک <code>Option</code> حاوی مقدار از آن نوع خاص بازمی‌گرداند.</p>
<p>نوع‌های مرتبط ممکن است مفهومی مشابه با genericها به نظر برسند، به این معنا که genericها به ما اجازه می‌دهند یک تابع بدون مشخص کردن نوع‌هایی که می‌تواند با آن‌ها کار کند، تعریف کنیم. برای بررسی تفاوت بین این دو مفهوم، به یک پیاده‌سازی trait <code>Iterator</code> روی یک نوع به نام <code>Counter</code> نگاه خواهیم کرد که نوع <code>Item</code> را به‌عنوان <code>u32</code> مشخص می‌کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>این سینتکس با سینتکس genericها قابل مقایسه به نظر می‌رسد. پس چرا به جای این کار، trait <code>Iterator</code> را با استفاده از genericها تعریف نکنیم، همان‌طور که در فهرست 20-14 نشان داده شده است؟</p>
<figure class="listing">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<figcaption>Listing 20-14: یک تعریف فرضی از trait <code>Iterator</code> با استفاده از genericها</figcaption>
</figure>
<p>تفاوت این است که هنگام استفاده از genericها، همان‌طور که در فهرست 20-14 نشان داده شده است، ما باید نوع‌ها را در هر پیاده‌سازی حاشیه‌نویسی کنیم. زیرا می‌توانیم همچنین <code>Iterator&lt;String&gt; for Counter</code> یا هر نوع دیگری را پیاده‌سازی کنیم، به‌طوری که بتوانیم پیاده‌سازی‌های متعددی از <code>Iterator</code> برای <code>Counter</code> داشته باشیم. به عبارت دیگر، زمانی که یک trait یک پارامتر generic دارد، می‌تواند برای یک نوع چندین بار پیاده‌سازی شود و نوع‌های خاص پارامترهای generic را هر بار تغییر دهد. زمانی که ما از متد <code>next</code> بر روی <code>Counter</code> استفاده می‌کنیم، باید حاشیه‌نویسی نوع ارائه دهیم تا مشخص کنیم کدام پیاده‌سازی <code>Iterator</code> را می‌خواهیم استفاده کنیم.</p>
<p>با استفاده از نوع‌های مرتبط، نیازی به حاشیه‌نویسی نوع‌ها نداریم زیرا نمی‌توانیم یک trait را بر روی یک نوع چندین بار پیاده‌سازی کنیم. در فهرست 20-13 با تعریفی که از نوع‌های مرتبط استفاده می‌کند، ما فقط می‌توانیم نوع <code>Item</code> را یک بار انتخاب کنیم، زیرا تنها یک <code>impl Iterator for Counter</code> می‌تواند وجود داشته باشد. ما نیازی نداریم که مشخص کنیم می‌خواهیم یک iterator از مقادیر <code>u32</code> داشته باشیم در هر جایی که <code>next</code> را بر روی <code>Counter</code> فراخوانی می‌کنیم.</p>
<p>نوع‌های مرتبط همچنین بخشی از قرارداد trait می‌شوند: پیاده‌سازان trait باید یک نوع ارائه دهند تا جایگزین نوع جایگزین مرتبط شود. نوع‌های مرتبط اغلب نامی دارند که توصیف می‌کند چگونه نوع استفاده خواهد شد و مستندسازی نوع مرتبط در مستندات API یک عمل خوب است.</p>
<h3 id="default-generic-type-parameters-and-operator-overloading"><a class="header" href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>وقتی که از پارامترهای generic type استفاده می‌کنیم، می‌توانیم یک نوع خاص پیش‌فرض برای پارامتر generic تعیین کنیم. این نیاز به مشخص کردن یک نوع خاص توسط پیاده‌سازان trait را در صورتی که نوع پیش‌فرض کار کند، از بین می‌برد. شما می‌توانید هنگام اعلام یک نوع generic، یک نوع پیش‌فرض با سینتکس <code>&lt;PlaceholderType=ConcreteType&gt;</code> مشخص کنید.</p>
<p>یک مثال عالی از وضعیتی که این تکنیک مفید است، <em>بارگذاری مجدد عملگرها</em> است، جایی که شما رفتار یک عملگر (مانند <code>+</code>) را در شرایط خاص شخصی‌سازی می‌کنید.</p>
<p>راست به شما اجازه نمی‌دهد عملگرهای خود را ایجاد کنید یا عملگرهای دلخواه را بارگذاری مجدد کنید. اما می‌توانید عملیات‌ها و traits مربوط به آن‌ها را که در <code>std::ops</code> فهرست شده‌اند با پیاده‌سازی traits مرتبط با عملگر، بارگذاری مجدد کنید. برای مثال، در فهرست 20-15 ما عملگر <code>+</code> را برای اضافه کردن دو نمونه <code>Point</code> به یکدیگر بارگذاری مجدد می‌کنیم. ما این کار را با پیاده‌سازی trait <code>Add</code> بر روی struct <code>Point</code> انجام می‌دهیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<figcaption>Listing 20-15: پیاده‌سازی trait <code>Add</code> برای بارگذاری مجدد عملگر <code>+</code> برای نمونه‌های <code>Point</code></figcaption>
</figure>
<p>متد <code>add</code> مقادیر <code>x</code> دو نمونه <code>Point</code> و مقادیر <code>y</code> دو نمونه <code>Point</code> را اضافه می‌کند تا یک نمونه جدید از <code>Point</code> ایجاد کند. trait <code>Add</code> دارای یک نوع مرتبط با نام <code>Output</code> است که نوع بازگشتی از متد <code>add</code> را تعیین می‌کند.</p>
<p>نوع generic پیش‌فرض در این کد در داخل trait <code>Add</code> است. در اینجا تعریف آن آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>این کد باید به طور کلی آشنا به نظر برسد: یک trait با یک متد و یک نوع مرتبط. بخش جدید <code>Rhs=Self</code> است: این سینتکس به <em>default type parameters</em> یا “پارامترهای نوع پیش‌فرض” معروف است. پارامتر generic نوع <code>Rhs</code> (مخفف “right hand side” یا “سمت راست”) نوع پارامتر <code>rhs</code> را در متد <code>add</code> تعریف می‌کند. اگر هنگام پیاده‌سازی trait <code>Add</code> یک نوع خاص برای <code>Rhs</code> مشخص نکنیم، نوع <code>Rhs</code> به طور پیش‌فرض به <code>Self</code> تنظیم می‌شود، که نوعی خواهد بود که ما <code>Add</code> را بر روی آن پیاده‌سازی می‌کنیم.</p>
<p>هنگامی که <code>Add</code> را برای <code>Point</code> پیاده‌سازی کردیم، از پیش‌فرض برای <code>Rhs</code> استفاده کردیم زیرا می‌خواستیم دو نمونه <code>Point</code> را به هم اضافه کنیم. حال، بیایید به مثالی از پیاده‌سازی trait <code>Add</code> نگاه کنیم که در آن می‌خواهیم نوع <code>Rhs</code> را شخصی‌سازی کنیم و از پیش‌فرض استفاده نکنیم.</p>
<p>ما دو struct به نام‌های <code>Millimeters</code> و <code>Meters</code> داریم که مقادیر را در واحدهای مختلف نگه می‌دارند. این نوع نازک‌سازی یک نوع موجود در یک struct دیگر به‌عنوان الگوی <em>newtype pattern</em> شناخته می‌شود که ما آن را در بخش <a href="ch20-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Using the Newtype Pattern to Implement External Traits on External Types”</a><!-- ignore --> به‌طور مفصل توضیح می‌دهیم. ما می‌خواهیم مقادیر میلی‌متر را به مقادیر متر اضافه کنیم و پیاده‌سازی <code>Add</code> تبدیل را به‌درستی انجام دهد. می‌توانیم <code>Add</code> را برای <code>Millimeters</code> با <code>Meters</code> به‌عنوان <code>Rhs</code> همان‌طور که در فهرست 20-16 نشان داده شده است، پیاده‌سازی کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<figcaption>Listing 20-16: پیاده‌سازی trait <code>Add</code> برای <code>Millimeters</code> جهت افزودن <code>Millimeters</code> به <code>Meters</code></figcaption>
</figure>
<p>برای افزودن <code>Millimeters</code> و <code>Meters</code>، ما <code>impl Add&lt;Meters&gt;</code> را مشخص می‌کنیم تا مقدار پارامتر نوع <code>Rhs</code> را به جای استفاده از پیش‌فرض <code>Self</code> تنظیم کنیم.</p>
<p>شما از پارامترهای نوع پیش‌فرض در دو حالت اصلی استفاده خواهید کرد:</p>
<ul>
<li>برای گسترش یک نوع بدون شکستن کد موجود</li>
<li>برای اجازه دادن به شخصی‌سازی در موارد خاص که اکثر کاربران به آن نیازی ندارند</li>
</ul>
<p>trait <code>Add</code> در کتابخانه استاندارد یک مثال از هدف دوم است: معمولاً شما دو نوع مشابه را اضافه خواهید کرد، اما trait <code>Add</code> قابلیت شخصی‌سازی فراتر از آن را فراهم می‌کند. استفاده از پارامتر نوع پیش‌فرض در تعریف trait <code>Add</code> به این معناست که شما بیشتر اوقات نیازی به مشخص کردن پارامتر اضافی ندارید. به عبارت دیگر، مقدار کمی از کد اضافی حذف می‌شود و استفاده از trait آسان‌تر می‌شود.</p>
<p>هدف اول مشابه هدف دوم است، اما به‌صورت معکوس: اگر بخواهید یک پارامتر نوع را به یک trait موجود اضافه کنید، می‌توانید برای گسترش قابلیت‌های trait بدون شکستن کد پیاده‌سازی موجود، یک مقدار پیش‌فرض برای آن تنظیم کنید.</p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>در راست هیچ محدودیتی برای داشتن یک متد با همان نام در یک trait و در نوعی دیگر وجود ندارد و همچنین راست مانع نمی‌شود که هر دو trait را بر روی یک نوع پیاده‌سازی کنید. همچنین می‌توانید متدی را مستقیماً بر روی نوعی پیاده‌سازی کنید که همان نام متدهای مربوط به traits را دارد.</p>
<p>هنگام فراخوانی متدهایی با همان نام، باید به راست بگویید که کدام یک را می‌خواهید استفاده کنید. کد زیر در فهرست 20-17 را در نظر بگیرید که در آن دو trait به نام‌های <code>Pilot</code> و <code>Wizard</code> تعریف شده‌اند که هر دو دارای متدی به نام <code>fly</code> هستند. سپس هر دو trait بر روی نوع <code>Human</code> پیاده‌سازی می‌شوند که قبلاً متدی به نام <code>fly</code> نیز بر روی آن پیاده‌سازی شده است. هر متد <code>fly</code> کاری متفاوت انجام می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-17: دو trait تعریف شده‌اند که یک متد مشترک دارند و بر روی نوع <code>Human</code> پیاده‌سازی شده‌اند، و یک متد <code>fly</code> به‌طور مستقیم بر روی <code>Human</code> پیاده‌سازی شده است</figcaption>
</figure>
<p>وقتی متد <code>fly</code> را بر روی یک نمونه از <code>Human</code> فراخوانی می‌کنیم، کامپایلر به طور پیش‌فرض متدی را که مستقیماً بر روی نوع پیاده‌سازی شده است، فراخوانی می‌کند، همان‌طور که در فهرست 20-18 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<figcaption>Listing 20-18: فراخوانی <code>fly</code> بر روی یک نمونه از <code>Human</code></figcaption>
</figure>
<p>اجرای این کد متن <code>*waving arms furiously*</code> را چاپ می‌کند و نشان می‌دهد که راست متد <code>fly</code> پیاده‌سازی‌شده بر روی <code>Human</code> را مستقیماً فراخوانی کرده است.</p>
<p>برای فراخوانی متدهای <code>fly</code> از <code>Pilot</code> یا <code>Wizard</code>، باید از سینتکس صریح‌تری برای مشخص کردن متدی که منظور ماست، استفاده کنیم. فهرست 20-19 این سینتکس را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<figcaption>Listing 20-19: مشخص کردن متد <code>fly</code> مربوط به کدام trait را می‌خواهیم فراخوانی کنیم</figcaption>
</figure>
<p>مشخص کردن نام trait قبل از نام متد، به راست مشخص می‌کند که کدام پیاده‌سازی متد <code>fly</code> را می‌خواهیم فراخوانی کنیم. همچنین می‌توانیم <code>Human::fly(&amp;person)</code> بنویسیم که معادل با <code>person.fly()</code> است که در فهرست 20-19 استفاده کرده‌ایم، اما اگر نیازی به رفع ابهام نباشد، این روش کمی طولانی‌تر است.</p>
<p>اجرای این کد خروجی زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>از آنجا که متد <code>fly</code> یک پارامتر <code>self</code> می‌گیرد، اگر دو <em>نوع</em> داشته باشیم که یک <em>trait</em> را پیاده‌سازی کنند، راست می‌تواند بر اساس نوع <code>self</code> مشخص کند که کدام پیاده‌سازی trait را باید استفاده کند.</p>
<p>با این حال، توابع مرتبطی که متد نیستند، پارامتر <code>self</code> ندارند. وقتی چندین نوع یا trait توابع غیر متد با یک نام مشترک تعریف می‌کنند، راست همیشه نمی‌داند که منظور شما کدام نوع است، مگر اینکه از <em>fully qualified syntax</em> استفاده کنید. به عنوان مثال، در فهرست 20-20 ما یک trait برای یک پناهگاه حیوانات ایجاد می‌کنیم که می‌خواهد تمام سگ‌های کوچک را به نام <em>Spot</em> نام‌گذاری کند. ما یک trait به نام <code>Animal</code> با یک تابع غیر متد مرتبط به نام <code>baby_name</code> تعریف می‌کنیم. trait <code>Animal</code> برای ساختار <code>Dog</code> پیاده‌سازی می‌شود، و همچنین یک تابع غیر متد مرتبط به نام <code>baby_name</code> مستقیماً بر روی <code>Dog</code> فراهم می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
<figcaption>Listing 20-20: یک trait با یک تابع مرتبط و یک نوع با یک تابع مرتبط با همان نام که همچنین trait را پیاده‌سازی می‌کند</figcaption>
</figure>
<p>ما کدی برای نام‌گذاری تمام سگ‌های کوچک به نام Spot در تابع مرتبط <code>baby_name</code> که بر روی <code>Dog</code> تعریف شده است، پیاده‌سازی می‌کنیم. نوع <code>Dog</code> همچنین trait <code>Animal</code> را پیاده‌سازی می‌کند، که ویژگی‌هایی که تمام حیوانات دارند را توصیف می‌کند. سگ‌های کوچک به نام puppy شناخته می‌شوند و این در پیاده‌سازی trait <code>Animal</code> بر روی <code>Dog</code> در تابع <code>baby_name</code> مرتبط با trait <code>Animal</code> بیان شده است.</p>
<p>در تابع <code>main</code>، ما تابع <code>Dog::baby_name</code> را فراخوانی می‌کنیم، که تابع مرتبط تعریف شده بر روی <code>Dog</code> را مستقیماً فراخوانی می‌کند. این کد خروجی زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>این خروجی آن چیزی نیست که ما می‌خواستیم. ما می‌خواهیم تابع <code>baby_name</code> که بخشی از trait <code>Animal</code> است و بر روی <code>Dog</code> پیاده‌سازی شده است را فراخوانی کنیم تا کد <code>A baby dog is called a puppy</code> را چاپ کند. تکنیکی که در فهرست 20-19 برای مشخص کردن نام trait استفاده کردیم، اینجا کمکی نمی‌کند. اگر <code>main</code> را به کد موجود در فهرست 20-21 تغییر دهیم، خطای کامپایل دریافت خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<figcaption>Listing 20-21: تلاش برای فراخوانی تابع <code>baby_name</code> از trait <code>Animal</code>، اما راست نمی‌داند که از کدام پیاده‌سازی استفاده کند</figcaption>
</figure>
<p>از آنجا که <code>Animal::baby_name</code> پارامتر <code>self</code> ندارد، و ممکن است انواع دیگری وجود داشته باشند که trait <code>Animal</code> را پیاده‌سازی کرده باشند، راست نمی‌تواند تشخیص دهد که کدام پیاده‌سازی از <code>Animal::baby_name</code> مورد نظر ما است. در نتیجه این خطای کامپایلر را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>برای رفع ابهام و مشخص کردن اینکه ما می‌خواهیم از پیاده‌سازی trait <code>Animal</code> برای <code>Dog</code> استفاده کنیم، به جای پیاده‌سازی trait <code>Animal</code> برای نوع دیگری، باید از fully qualified syntax استفاده کنیم. فهرست 20-22 نشان می‌دهد چگونه از fully qualified syntax استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<figcaption>Listing 20-22: استفاده از fully qualified syntax برای مشخص کردن اینکه می‌خواهیم تابع <code>baby_name</code> از trait <code>Animal</code> که بر روی <code>Dog</code> پیاده‌سازی شده است، فراخوانی کنیم</figcaption>
</figure>
<p>ما با استفاده از یک اعلان نوع در داخل angle brackets به راست می‌گوییم که می‌خواهیم متد <code>baby_name</code> از trait <code>Animal</code> که بر روی <code>Dog</code> پیاده‌سازی شده است، فراخوانی شود، با این کار مشخص می‌کنیم که می‌خواهیم نوع <code>Dog</code> را برای این فراخوانی تابع به‌عنوان یک <code>Animal</code> در نظر بگیریم. این کد اکنون خروجی مورد نظر ما را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>به طور کلی، fully qualified syntax به صورت زیر تعریف می‌شود:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>برای توابع مرتبطی که متد نیستند، <code>receiver</code> وجود نخواهد داشت: فقط لیستی از آرگومان‌های دیگر خواهد بود. شما می‌توانید fully qualified syntax را در هر جایی که توابع یا متدها را فراخوانی می‌کنید، استفاده کنید. با این حال، مجاز هستید هر بخشی از این سینتکس را که راست می‌تواند از اطلاعات دیگر برنامه تشخیص دهد، حذف کنید. شما فقط در مواردی که چندین پیاده‌سازی با نام یکسان وجود دارد و راست به کمک نیاز دارد تا مشخص کند کدام پیاده‌سازی را می‌خواهید فراخوانی کنید، نیاز به استفاده از این سینتکس دقیق‌تر دارید.</p>
<h3 id="استفاده-از-supertraits-برای-نیاز-به-قابلیتهای-یک-trait-درون-trait-دیگر"><a class="header" href="#استفاده-از-supertraits-برای-نیاز-به-قابلیتهای-یک-trait-درون-trait-دیگر">استفاده از Supertraits برای نیاز به قابلیت‌های یک trait درون trait دیگر</a></h3>
<p>گاهی اوقات ممکن است یک تعریف trait بنویسید که به یک trait دیگر وابسته باشد: برای اینکه یک نوع بتواند اولین trait را پیاده‌سازی کند، می‌خواهید که آن نوع همچنین دومین trait را نیز پیاده‌سازی کند. این کار را انجام می‌دهید تا تعریف trait شما بتواند از آیتم‌های مرتبط trait دوم استفاده کند. trait‌ای که تعریف trait شما به آن متکی است، <em>supertrait</em> نامیده می‌شود.</p>
<p>برای مثال، فرض کنید می‌خواهید یک trait به نام <code>OutlinePrint</code> بسازید که یک متد <code>outline_print</code> داشته باشد که یک مقدار داده شده را با فرمت مشخصی که در قاب ستاره‌ها قرار گرفته است، چاپ کند. به این صورت که اگر یک ساختار <code>Point</code> داشته باشیم که trait کتابخانه استاندارد <code>Display</code> را پیاده‌سازی کرده و نتیجه آن به شکل <code>(x, y)</code> باشد، وقتی متد <code>outline_print</code> را روی یک نمونه از <code>Point</code> که <code>1</code> برای <code>x</code> و <code>3</code> برای <code>y</code> دارد فراخوانی کنیم، باید خروجی زیر را چاپ کند:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>در پیاده‌سازی متد <code>outline_print</code>، می‌خواهیم از قابلیت‌های trait <code>Display</code> استفاده کنیم. بنابراین، نیاز داریم مشخص کنیم که trait <code>OutlinePrint</code> فقط برای انواعی کار خواهد کرد که همچنین trait <code>Display</code> را پیاده‌سازی کرده باشند و قابلیت‌های مورد نیاز <code>OutlinePrint</code> را ارائه دهند. می‌توانیم این کار را در تعریف trait با مشخص کردن <code>OutlinePrint: Display</code> انجام دهیم. این تکنیک شبیه به اضافه کردن یک محدودیت trait به trait است. فهرست 20-23 یک پیاده‌سازی از trait <code>OutlinePrint</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-23: پیاده‌سازی trait <code>OutlinePrint</code> که نیاز به قابلیت‌های <code>Display</code> دارد</figcaption>
</figure>
<p>از آنجایی که مشخص کرده‌ایم که <code>OutlinePrint</code> به trait <code>Display</code> نیاز دارد، می‌توانیم از تابع <code>to_string</code> استفاده کنیم که به طور خودکار برای هر نوعی که <code>Display</code> را پیاده‌سازی کرده باشد، پیاده‌سازی شده است. اگر سعی کنیم <code>to_string</code> را بدون اضافه کردن دو نقطه و مشخص کردن trait <code>Display</code> بعد از نام trait استفاده کنیم، خطایی دریافت خواهیم کرد که می‌گوید هیچ متدی به نام <code>to_string</code> برای نوع <code>&amp;Self</code> در محدوده فعلی یافت نشد.</p>
<p>حالا ببینیم چه اتفاقی می‌افتد اگر بخواهیم <code>OutlinePrint</code> را برای یک نوعی که <code>Display</code> را پیاده‌سازی نکرده است، مانند ساختار <code>Point</code>، پیاده‌سازی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>خطایی دریافت می‌کنیم که می‌گوید <code>Display</code> مورد نیاز است ولی پیاده‌سازی نشده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>برای رفع این مشکل، باید <code>Display</code> را برای <code>Point</code> پیاده‌سازی کنیم و محدودیت مورد نیاز <code>OutlinePrint</code> را برآورده کنیم، به این صورت:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>سپس با پیاده‌سازی trait <code>OutlinePrint</code> بر روی <code>Point</code>، کد با موفقیت کامپایل خواهد شد و می‌توانیم متد <code>outline_print</code> را روی یک نمونه از <code>Point</code> فراخوانی کنیم تا آن را در یک قاب ستاره‌ای نمایش دهد.</p>
<h3 id="استفاده-از-الگوی-newtype-برای-پیادهسازی-traits-خارجی-روی-انواع-خارجی"><a class="header" href="#استفاده-از-الگوی-newtype-برای-پیادهسازی-traits-خارجی-روی-انواع-خارجی">استفاده از الگوی Newtype برای پیاده‌سازی Traits خارجی روی انواع خارجی</a></h3>
<p>در فصل ۱۰ در بخش <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“پیاده‌سازی یک Trait روی یک
نوع”</a><!-- ignore -->، به قانون orphan اشاره کردیم که بیان می‌کند ما فقط مجاز هستیم یک trait را روی یک نوع پیاده‌سازی کنیم اگر یا trait یا نوع به crate ما تعلق داشته باشد. با این حال، می‌توان با استفاده از <em>الگوی newtype</em>، این محدودیت را دور زد. این الگو شامل ایجاد یک نوع جدید در یک tuple struct است. (ما tuple struct‌ها را در بخش <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“استفاده از Tuple Structs بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف”</a><!-- ignore --> در فصل ۵ پوشش دادیم.) tuple struct یک فیلد خواهد داشت و یک wrapper نازک دور نوعی خواهد بود که می‌خواهیم trait را برای آن پیاده‌سازی کنیم. سپس، نوع wrapper به crate ما تعلق دارد و می‌توانیم trait را روی wrapper پیاده‌سازی کنیم. اصطلاح <em>Newtype</em> از زبان برنامه‌نویسی Haskell منشأ گرفته است. هیچ جریمه عملکردی در زمان اجرا برای استفاده از این الگو وجود ندارد و نوع wrapper در زمان کامپایل حذف می‌شود.</p>
<p>به‌عنوان مثال، فرض کنید می‌خواهیم <code>Display</code> را روی <code>Vec&lt;T&gt;</code> پیاده‌سازی کنیم، که قانون orphan مانع انجام این کار به‌صورت مستقیم می‌شود زیرا trait <code>Display</code> و نوع <code>Vec&lt;T&gt;</code> خارج از crate ما تعریف شده‌اند. می‌توانیم یک ساختار <code>Wrapper</code> بسازیم که شامل یک نمونه از <code>Vec&lt;T&gt;</code> باشد؛ سپس می‌توانیم <code>Display</code> را روی <code>Wrapper</code> پیاده‌سازی کنیم و از مقدار <code>Vec&lt;T&gt;</code> استفاده کنیم، همانطور که در فهرست 20-24 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
<figcaption>Listing 20-24: ایجاد نوع <code>Wrapper</code> دور <code>Vec&lt;String&gt;</code> برای پیاده‌سازی <code>Display</code></figcaption>
</figure>
<p>پیاده‌سازی <code>Display</code> از <code>self.0</code> برای دسترسی به <code>Vec&lt;T&gt;</code> داخلی استفاده می‌کند، زیرا <code>Wrapper</code> یک tuple struct است و <code>Vec&lt;T&gt;</code> آیتمی در index صفر tuple است. سپس می‌توانیم از قابلیت‌های trait <code>Display</code> روی <code>Wrapper</code> استفاده کنیم.</p>
<p>عیب استفاده از این تکنیک این است که <code>Wrapper</code> یک نوع جدید است، بنابراین متدهای نوعی که درون خود نگه می‌دارد را ندارد. باید تمام متدهای <code>Vec&lt;T&gt;</code> را مستقیماً روی <code>Wrapper</code> پیاده‌سازی کنیم به طوری که متدها به <code>self.0</code> ارجاع دهند، که به ما اجازه می‌دهد <code>Wrapper</code> را دقیقاً مانند <code>Vec&lt;T&gt;</code> رفتار دهیم. اگر بخواهیم نوع جدید تمام متدهایی که نوع داخلی دارد را داشته باشد، پیاده‌سازی trait <code>Deref</code> (که در فصل ۱۵ در بخش <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“رفتار با اشاره‌گر (Pointer)های هوشمند به‌عنوان ارجاعات معمولی با استفاده از trait <code>Deref</code>”</a><!-- ignore --> بحث شد) روی <code>Wrapper</code> به‌گونه‌ای که نوع داخلی را بازگرداند، راه‌حلی خواهد بود. اگر نخواهیم نوع <code>Wrapper</code> تمام متدهای نوع داخلی را داشته باشد—برای مثال، برای محدود کردن رفتار نوع <code>Wrapper</code>—باید متدهایی که واقعاً نیاز داریم را به صورت دستی پیاده‌سازی کنیم.</p>
<p>این الگوی newtype حتی زمانی که traits درگیر نیستند نیز مفید است. حالا بیایید تمرکز خود را تغییر دهیم و به برخی از روش‌های پیشرفته برای تعامل با سیستم نوع Rust بپردازیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
