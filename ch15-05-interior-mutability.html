<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html" class="active"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt-و-الگوی-تغییرپذیری-داخلی"><a class="header" href="#refcellt-و-الگوی-تغییرپذیری-داخلی"><code>RefCell&lt;T&gt;</code> و الگوی تغییرپذیری داخلی</a></h2>
<p><em>تغییرپذیری داخلی</em> یک الگوی طراحی در راست است که به شما اجازه می‌دهد داده‌ها را حتی زمانی که
ارجاع‌های غیرقابل‌تغییر به آن داده‌ها وجود دارد، تغییر دهید؛ معمولاً این عمل توسط قوانین وام‌دهی
(‌borrowing rules) ممنوع است. برای تغییر داده‌ها، این الگو از کد <code>unsafe</code> درون یک ساختار داده
برای تغییر قوانین معمول راست که کنترل تغییرپذیری و وام‌دهی را بر عهده دارند، استفاده می‌کند. کد
<code>unsafe</code> به کامپایلر نشان می‌دهد که ما قوانین را به صورت دستی بررسی می‌کنیم و دیگر به کامپایلر
اعتماد نداریم که این کار را برای ما انجام دهد؛ ما در فصل 20 بیشتر درباره کد <code>unsafe</code> صحبت خواهیم کرد.</p>
<p>ما می‌توانیم از انواعی که از الگوی تغییرپذیری داخلی استفاده می‌کنند تنها در صورتی استفاده کنیم که
بتوانیم اطمینان حاصل کنیم که قوانین وام‌دهی در زمان اجرا رعایت خواهند شد، حتی اگر کامپایلر نتواند
این را تضمین کند. کد <code>unsafe</code> مرتبط سپس در یک API ایمن پیچیده شده و نوع بیرونی همچنان
غیرقابل‌تغییر باقی می‌ماند.</p>
<p>بیایید این مفهوم را با بررسی نوع <code>RefCell&lt;T&gt;</code> که از الگوی تغییرپذیری داخلی پیروی می‌کند،
بیشتر بررسی کنیم.</p>
<h3 id="اجرای-قوانین-وامدهی-در-زمان-اجرا-با-refcellt"><a class="header" href="#اجرای-قوانین-وامدهی-در-زمان-اجرا-با-refcellt">اجرای قوانین وام‌دهی در زمان اجرا با <code>RefCell&lt;T&gt;</code></a></h3>
<p>برخلاف <code>Rc&lt;T&gt;</code>، نوع <code>RefCell&lt;T&gt;</code> مالکیت واحد (single ownership) داده‌هایی که نگه می‌دارد
را نشان می‌دهد. پس، چه چیزی <code>RefCell&lt;T&gt;</code> را از یک نوع مثل <code>Box&lt;T&gt;</code> متمایز می‌کند؟ قوانین
وام‌دهی‌ای که در فصل 4 یاد گرفتید را به یاد آورید:</p>
<ul>
<li>در هر زمان معین، شما می‌توانید <em>یا</em> (اما نه هر دو) یک ارجاع متغیر یا تعداد زیادی ارجاع
غیرقابل‌تغییر داشته باشید.</li>
<li>ارجاع‌ها باید همیشه معتبر باشند.</li>
</ul>
<p>با استفاده از ارجاع‌ها و <code>Box&lt;T&gt;</code>، ثابت‌های قوانین وام‌دهی در زمان کامپایل اعمال می‌شوند.
اما با <code>RefCell&lt;T&gt;</code>، این ثابت‌ها در <em>زمان اجرا</em> اعمال می‌شوند. با ارجاع‌ها، اگر این قوانین
را بشکنید، یک خطای کامپایل دریافت خواهید کرد. اما با <code>RefCell&lt;T&gt;</code>، اگر این قوانین را بشکنید،
برنامه شما دچار وحشت (panic) می‌شود و متوقف می‌شود.</p>
<p>مزیت بررسی قوانین وام‌دهی در زمان کامپایل این است که خطاها زودتر در فرایند توسعه شناسایی
می‌شوند، و هیچ تأثیری بر عملکرد زمان اجرا وجود ندارد زیرا تمام تحلیل‌ها پیشاپیش انجام شده‌اند.
به همین دلایل، بررسی قوانین وام‌دهی در زمان کامپایل بهترین انتخاب در اکثر موارد است، که به
همین دلیل این روش پیش‌فرض راست است.</p>
<p>مزیت بررسی قوانین وام‌دهی در زمان اجرا این است که سناریوهایی که ایمن از نظر حافظه هستند
اجازه می‌یابند، در حالی که ممکن است توسط بررسی‌های زمان کامپایل مجاز نباشند. تحلیل
ایستا (static analysis)، مانند کامپایلر راست، به‌طور ذاتی محافظه‌کارانه است. برخی
خصوصیات کد غیرممکن است که با تحلیل کد شناسایی شوند: معروف‌ترین مثال، مشکل توقف
(Halting Problem) است که فراتر از محدوده این کتاب است اما موضوع جالبی برای تحقیق
می‌باشد.</p>
<p>زیرا برخی تحلیل‌ها غیرممکن هستند، اگر کامپایلر راست نتواند مطمئن شود که کد با قوانین
مالکیت سازگار است، ممکن است یک برنامه درست را رد کند؛ به این ترتیب، محافظه‌کارانه عمل
می‌کند. اگر راست یک برنامه نادرست را بپذیرد، کاربران نمی‌توانند به تضمین‌هایی که راست
می‌دهد، اعتماد کنند. اما اگر راست یک برنامه درست را رد کند، برنامه‌نویس ناراحت خواهد شد،
اما هیچ چیز فاجعه‌باری رخ نخواهد داد. نوع <code>RefCell&lt;T&gt;</code> زمانی مفید است که مطمئن باشید
کد شما قوانین وام‌دهی را دنبال می‌کند اما کامپایلر نمی‌تواند این را بفهمد و تضمین کند.</p>
<p>مشابه <code>Rc&lt;T&gt;</code>، <code>RefCell&lt;T&gt;</code> تنها برای استفاده در سناریوهای تک‌ریسمانی (single-threaded)
است و اگر بخواهید آن را در یک بافت چندریسمانی (multithreaded) استفاده کنید، یک خطای زمان
کامپایل به شما خواهد داد. ما در فصل 16 درباره نحوه دریافت عملکرد <code>RefCell&lt;T&gt;</code> در یک برنامه
چندریسمانی صحبت خواهیم کرد.</p>
<p>در اینجا مروری بر دلایلی برای انتخاب <code>Box&lt;T&gt;</code>، <code>Rc&lt;T&gt;</code> یا <code>RefCell&lt;T&gt;</code> آمده است:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> امکان چندین مالک برای یک داده را فراهم می‌کند؛ در حالی که <code>Box&lt;T&gt;</code> و
<code>RefCell&lt;T&gt;</code> تنها یک مالک دارند.</li>
<li><code>Box&lt;T&gt;</code> اجازه می‌دهد که وام‌دهی‌های غیرقابل‌تغییر یا قابل‌تغییر در زمان کامپایل
بررسی شوند؛ <code>Rc&lt;T&gt;</code> تنها وام‌دهی‌های غیرقابل‌تغییر را در زمان کامپایل بررسی
می‌کند؛ <code>RefCell&lt;T&gt;</code> اجازه می‌دهد که وام‌دهی‌های غیرقابل‌تغییر یا قابل‌تغییر در
زمان اجرا بررسی شوند.</li>
<li>از آنجا که <code>RefCell&lt;T&gt;</code> اجازه می‌دهد وام‌دهی‌های قابل‌تغییر در زمان اجرا بررسی شوند،
شما می‌توانید مقدار درون <code>RefCell&lt;T&gt;</code> را حتی زمانی که خود <code>RefCell&lt;T&gt;</code> غیرقابل‌تغییر
است، تغییر دهید.</li>
</ul>
<p>تغییر مقدار درون یک مقدار غیرقابل‌تغییر همان الگوی <em>تغییرپذیری داخلی</em> است. بیایید به
یک موقعیت که در آن تغییرپذیری داخلی مفید است نگاهی بیندازیم و بررسی کنیم چگونه این
امر ممکن است.</p>
<h3 id="تغییرپذیری-داخلی-وامدهی-قابلتغییر-به-یک-مقدار-غیرقابلتغییر"><a class="header" href="#تغییرپذیری-داخلی-وامدهی-قابلتغییر-به-یک-مقدار-غیرقابلتغییر">تغییرپذیری داخلی: وام‌دهی قابل‌تغییر به یک مقدار غیرقابل‌تغییر</a></h3>
<p>یکی از پیامدهای قوانین وام‌دهی این است که وقتی شما یک مقدار غیرقابل‌تغییر دارید،
نمی‌توانید آن را به صورت قابل‌تغییر وام دهید. برای مثال، این کد کامپایل نخواهد شد:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>اگر سعی کنید این کد را کامپایل کنید، خطای زیر را دریافت خواهید کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>با این حال، موقعیت‌هایی وجود دارند که در آن‌ها مفید است یک مقدار بتواند خود را در
متدهایش تغییر دهد اما برای کد دیگر غیرقابل‌تغییر به نظر برسد. کدی که خارج از متدهای
مقدار قرار دارد نمی‌تواند مقدار را تغییر دهد. استفاده از <code>RefCell&lt;T&gt;</code> یکی از
راه‌هایی است که می‌توانید قابلیت تغییرپذیری داخلی را به دست آورید، اما <code>RefCell&lt;T&gt;</code>
به طور کامل قوانین وام‌دهی را دور نمی‌زند: کنترل‌کننده وام‌دهی در کامپایلر این
تغییرپذیری داخلی را مجاز می‌کند و قوانین وام‌دهی در عوض در زمان اجرا بررسی می‌شوند.
اگر این قوانین را نقض کنید، به جای خطای کامپایل، یک <code>panic!</code> دریافت خواهید کرد.</p>
<p>بیایید با یک مثال عملی کار کنیم که در آن از <code>RefCell&lt;T&gt;</code> برای تغییر مقدار غیرقابل‌تغییر
استفاده کنیم و ببینیم چرا این کار مفید است.</p>
<h4 id="یک-کاربرد-برای-تغییرپذیری-داخلی-mock-objects"><a class="header" href="#یک-کاربرد-برای-تغییرپذیری-داخلی-mock-objects">یک کاربرد برای تغییرپذیری داخلی: Mock Objects</a></h4>
<p>گاهی اوقات در طول تست، یک برنامه‌نویس از یک نوع به جای نوع دیگری استفاده می‌کند تا
رفتار خاصی را مشاهده کند و اطمینان حاصل کند که به درستی پیاده‌سازی شده است. این نوع
جایگزین <em>تست دابل</em> نامیده می‌شود. آن را به مانند یک “بدل‌کار” در فیلم‌سازی تصور
کنید، جایی که یک نفر جایگزین بازیگر می‌شود تا یک صحنه خاص و دشوار را اجرا کند.
تست دابل‌ها به جای انواع دیگر در زمان تست استفاده می‌شوند. <em>اشیاء Mock</em> نوع خاصی از
تست دابل‌ها هستند که ثبت می‌کنند در طول یک تست چه اتفاقی می‌افتد تا شما بتوانید
اطمینان حاصل کنید که اقدامات صحیح انجام شده‌اند.</p>
<p>راست اشیاء را به همان شکلی که زبان‌های دیگر دارند، ندارد و قابلیت‌های اشیاء Mock
را نیز در کتابخانه استاندارد، مانند برخی زبان‌های دیگر، ارائه نمی‌دهد. با این حال،
شما می‌توانید یک ساختار (struct) ایجاد کنید که همان مقاصد اشیاء Mock را فراهم کند.</p>
<p>در اینجا سناریویی که قصد تست آن را داریم آورده شده است: ما یک کتابخانه ایجاد
خواهیم کرد که یک مقدار را نسبت به یک مقدار حداکثری ردیابی می‌کند و بر اساس
نزدیکی مقدار فعلی به مقدار حداکثری پیام‌هایی ارسال می‌کند. به عنوان مثال، این
کتابخانه می‌تواند برای پیگیری سهمیه تعداد درخواست‌های API که یک کاربر مجاز است
انجام دهد، استفاده شود.</p>
<p>کتابخانه ما فقط عملکرد ردیابی نزدیکی یک مقدار به حداکثر و تعیین پیام‌ها در زمان‌های
خاص را فراهم خواهد کرد. انتظار می‌رود برنامه‌هایی که از کتابخانه ما استفاده می‌کنند
مکانیسم ارسال پیام‌ها را فراهم کنند: برنامه می‌تواند پیامی را در برنامه قرار دهد، یک
ایمیل ارسال کند، یک پیام متنی ارسال کند، یا چیز دیگری. کتابخانه نیازی به دانستن این
جزئیات ندارد. همه چیزی که نیاز دارد چیزی است که یک ویژگی (trait) به نام
<code>Messenger</code> که ما ارائه خواهیم کرد را پیاده‌سازی کند. کد کتابخانه در فهرست
15-20 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<figcaption>Listing 15-20: یک کتابخانه برای پیگیری نزدیکی یک مقدار به یک مقدار حداکثری و هشدار در زمانی که مقدار در سطوح خاصی است</figcaption>
</figure>
<p>یکی از بخش‌های مهم این کد این است که ویژگی <code>Messenger</code> یک متد به نام <code>send</code>
دارد که یک ارجاع غیرقابل‌تغییر به <code>self</code> و متن پیام را می‌گیرد. این ویژگی رابطی
است که شیء Mock ما باید برای استفاده به همان شیوه که یک شیء واقعی استفاده می‌شود،
پیاده‌سازی کند. بخش مهم دیگر این است که ما می‌خواهیم رفتار متد <code>set_value</code> را
روی <code>LimitTracker</code> تست کنیم. ما می‌توانیم چیزی را که به عنوان پارامتر به <code>value</code>
می‌دهیم تغییر دهیم، اما <code>set_value</code> چیزی برای ما برنمی‌گرداند که بتوانیم روی آن
ادعا کنیم. ما می‌خواهیم بتوانیم بگوییم اگر یک <code>LimitTracker</code> با چیزی که ویژگی
<code>Messenger</code> را پیاده‌سازی کرده و مقدار خاصی برای <code>max</code> ایجاد کنیم، زمانی که
مقادیر مختلفی برای <code>value</code> ارسال می‌کنیم، پیام‌رسان گفته شده است که پیام‌های
مناسب را ارسال کند.</p>
<p>ما به یک شیء Mock نیاز داریم که به جای ارسال یک ایمیل یا پیام متنی وقتی که
<code>send</code> را فراخوانی می‌کنیم، فقط پیام‌هایی را که به آن گفته شده است ارسال کند،
پیگیری کند. ما می‌توانیم یک نمونه جدید از شیء Mock ایجاد کنیم، یک
<code>LimitTracker</code> که از شیء Mock استفاده می‌کند ایجاد کنیم، متد <code>set_value</code> را
روی <code>LimitTracker</code> فراخوانی کنیم، و سپس بررسی کنیم که آیا شیء Mock پیام‌هایی که
انتظار داریم را دارد یا نه. فهرست 15-21 تلاش برای پیاده‌سازی یک شیء Mock برای
انجام همین کار را نشان می‌دهد، اما کنترل‌کننده وام‌دهی (borrow checker) این اجازه
را نمی‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-21: تلاش برای پیاده‌سازی یک <code>MockMessenger</code> که توسط کنترل‌کننده وام‌دهی اجازه داده نمی‌شود</figcaption>
</figure>
<p>این کد تست یک ساختار <code>MockMessenger</code> تعریف می‌کند که یک فیلد <code>sent_messages</code> با یک
<code>Vec</code> از مقادیر <code>String</code> دارد تا پیام‌هایی را که به آن گفته شده است ارسال کند،
پیگیری کند. ما همچنین یک تابع مرتبط <code>new</code> تعریف می‌کنیم تا ایجاد مقادیر
<code>MockMessenger</code> جدید که با یک لیست خالی از پیام‌ها شروع می‌شود، راحت باشد. سپس
ویژگی <code>Messenger</code> را برای <code>MockMessenger</code> پیاده‌سازی می‌کنیم تا بتوانیم یک
<code>MockMessenger</code> را به یک <code>LimitTracker</code> بدهیم. در تعریف متد <code>send</code>، ما پیام
ارسال‌شده به عنوان یک پارامتر را می‌گیریم و آن را در لیست <code>sent_messages</code>
درون <code>MockMessenger</code> ذخیره می‌کنیم.</p>
<p>در تست، ما در حال تست این هستیم که وقتی به <code>LimitTracker</code> گفته می‌شود مقدار
<code>value</code> را به چیزی تنظیم کند که بیش از 75 درصد مقدار <code>max</code> است، چه اتفاقی می‌افتد.
ابتدا یک <code>MockMessenger</code> جدید ایجاد می‌کنیم که با یک لیست خالی از پیام‌ها شروع می‌شود.
سپس یک <code>LimitTracker</code> جدید ایجاد می‌کنیم و یک ارجاع به <code>MockMessenger</code> جدید و یک
مقدار <code>max</code> برابر 100 به آن می‌دهیم. متد <code>set_value</code> را روی <code>LimitTracker</code> با
مقدار 80 که بیش از 75 درصد 100 است، فراخوانی می‌کنیم. سپس ادعا می‌کنیم که لیست
پیام‌هایی که <code>MockMessenger</code> پیگیری می‌کند اکنون باید یک پیام در آن داشته باشد.</p>
<p>با این حال، یک مشکل با این تست وجود دارد، همانطور که در اینجا نشان داده شده است:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>ما نمی‌توانیم <code>MockMessenger</code> را برای پیگیری پیام‌ها تغییر دهیم، زیرا متد <code>send</code> یک
ارجاع غیرقابل‌تغییر به <code>self</code> می‌گیرد. همچنین نمی‌توانیم پیشنهاد متن خطا را برای استفاده
از <code>&amp;mut self</code> در هر دو متد <code>impl</code> و تعریف ویژگی (trait) بپذیریم. ما نمی‌خواهیم فقط به
خاطر تست، ویژگی <code>Messenger</code> را تغییر دهیم. در عوض، باید راهی پیدا کنیم که کد تست
ما با طراحی موجود به درستی کار کند.</p>
<p>این یک موقعیت است که در آن تغییرپذیری داخلی می‌تواند کمک کند! ما فیلد
<code>sent_messages</code> را درون یک <code>RefCell&lt;T&gt;</code> ذخیره می‌کنیم، و سپس متد <code>send</code> قادر خواهد بود
<code>sent_messages</code> را برای ذخیره پیام‌هایی که دیده‌ایم، تغییر دهد. فهرست 15-22 نشان می‌دهد
این کار چگونه انجام می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-22: استفاده از <code>RefCell&lt;T&gt;</code> برای تغییر یک مقدار داخلی در حالی که مقدار بیرونی غیرقابل‌تغییر در نظر گرفته می‌شود</figcaption>
</figure>
<p>فیلد <code>sent_messages</code> اکنون از نوع <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> به جای <code>Vec&lt;String&gt;</code> است.
در تابع <code>new</code>، یک نمونه جدید از <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> را در اطراف وکتور خالی ایجاد
می‌کنیم.</p>
<p>برای پیاده‌سازی متد <code>send</code>، پارامتر اول همچنان یک وام‌دهی غیرقابل‌تغییر به <code>self</code>
است، که با تعریف ویژگی مطابقت دارد. ما متد <code>borrow_mut</code> را روی <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
در <code>self.sent_messages</code> فراخوانی می‌کنیم تا یک ارجاع متغیر به مقدار درون
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>، که همان وکتور است، دریافت کنیم. سپس می‌توانیم روی ارجاع
متغیر به وکتور، متد <code>push</code> را فراخوانی کنیم تا پیام‌های ارسال‌شده در طول تست را پیگیری
کنیم.</p>
<p>آخرین تغییری که باید انجام دهیم در ادعا (assertion) است: برای دیدن تعداد آیتم‌های
درون وکتور داخلی، ما متد <code>borrow</code> را روی <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> فراخوانی می‌کنیم تا
یک ارجاع غیرقابل‌تغییر به وکتور دریافت کنیم.</p>
<p>حالا که دیدید چگونه از <code>RefCell&lt;T&gt;</code> استفاده کنید، بیایید به نحوه کار آن بپردازیم!</p>
<h4 id="پیگیری-وامها-در-زمان-اجرا-با-refcellt"><a class="header" href="#پیگیری-وامها-در-زمان-اجرا-با-refcellt">پیگیری وام‌ها در زمان اجرا با <code>RefCell&lt;T&gt;</code></a></h4>
<p>هنگام ایجاد ارجاع‌های غیرقابل‌تغییر و قابل‌تغییر، ما از سینتکس <code>&amp;</code> و <code>&amp;mut</code> استفاده
می‌کنیم. با <code>RefCell&lt;T&gt;</code>، از متدهای <code>borrow</code> و <code>borrow_mut</code> استفاده می‌کنیم، که
بخشی از API ایمن متعلق به <code>RefCell&lt;T&gt;</code> هستند. متد <code>borrow</code> نوع اسمارت پوینتر
<code>Ref&lt;T&gt;</code> را برمی‌گرداند، و <code>borrow_mut</code> نوع اسمارت پوینتر <code>RefMut&lt;T&gt;</code> را برمی‌گرداند.
هر دو نوع، <code>Deref</code> را پیاده‌سازی می‌کنند، بنابراین می‌توانیم با آن‌ها مثل ارجاع‌های
معمولی رفتار کنیم.</p>
<p><code>RefCell&lt;T&gt;</code> تعداد اسمارت پوینترهای <code>Ref&lt;T&gt;</code> و <code>RefMut&lt;T&gt;</code> که در حال حاضر فعال هستند
را پیگیری می‌کند. هر بار که <code>borrow</code> را فراخوانی می‌کنیم، <code>RefCell&lt;T&gt;</code> شمارش تعداد
وام‌دهی‌های غیرقابل‌تغییر فعال را افزایش می‌دهد. وقتی یک مقدار <code>Ref&lt;T&gt;</code> از دامنه
خارج می‌شود، شمارش وام‌دهی‌های غیرقابل‌تغییر یک عدد کاهش می‌یابد. دقیقاً مثل قوانین
وام‌دهی در زمان کامپایل، <code>RefCell&lt;T&gt;</code> به ما اجازه می‌دهد که در هر لحظه تعداد زیادی
وام‌دهی غیرقابل‌تغییر یا یک وام‌دهی قابل‌تغییر داشته باشیم.</p>
<p>اگر سعی کنیم این قوانین را نقض کنیم، به جای دریافت یک خطای کامپایل مثل ارجاع‌ها،
پیاده‌سازی <code>RefCell&lt;T&gt;</code> در زمان اجرا دچار وحشت (panic) خواهد شد. فهرست 15-23
اصلاحی از پیاده‌سازی متد <code>send</code> در فهرست 15-22 را نشان می‌دهد. ما به عمد سعی داریم
دو وام‌دهی قابل‌تغییر در یک دامنه ایجاد کنیم تا نشان دهیم <code>RefCell&lt;T&gt;</code> از انجام
این کار در زمان اجرا جلوگیری می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 15-23: ایجاد دو ارجاع متغیر در یک دامنه برای دیدن اینکه <code>RefCell&lt;T&gt;</code> وحشت خواهد کرد</figcaption>
</figure>
<p>ما یک متغیر به نام <code>one_borrow</code> برای اسمارت پوینتر <code>RefMut&lt;T&gt;</code> که از <code>borrow_mut</code>
بازگردانده شده است، ایجاد می‌کنیم. سپس یک وام‌دهی متغیر دیگر به همان روش در
متغیر <code>two_borrow</code> ایجاد می‌کنیم. این کار دو ارجاع متغیر در یک دامنه ایجاد می‌کند،
که مجاز نیست. هنگامی که تست‌ها را برای کتابخانه خود اجرا می‌کنیم، کد در فهرست
15-23 بدون هیچ خطایی کامپایل می‌شود، اما تست شکست خواهد خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>توجه داشته باشید که کد با پیام <code>already borrowed: BorrowMutError</code> دچار وحشت
(panic) شد. این نحوه عملکرد <code>RefCell&lt;T&gt;</code> برای مدیریت نقض قوانین وام‌دهی در زمان
اجرا است.</p>
<p>انتخاب اینکه خطاهای وام‌دهی در زمان اجرا و نه در زمان کامپایل بررسی شوند، همانطور
که در اینجا انجام دادیم، به این معنا است که ممکن است اشتباهات در کد شما در مراحل
بعدی فرآیند توسعه کشف شوند: شاید حتی تا زمانی که کد شما به محیط تولید
(production) استقرار یابد. همچنین، کد شما جریمه عملکردی کوچکی را به دلیل پیگیری
وام‌ها در زمان اجرا به جای زمان کامپایل متحمل خواهد شد. با این حال، استفاده از
<code>RefCell&lt;T&gt;</code> امکان نوشتن یک شیء Mock را فراهم می‌کند که می‌تواند خود را تغییر
دهد تا پیام‌هایی که مشاهده کرده است را پیگیری کند، در حالی که شما آن را در یک
زمینه که تنها مقادیر غیرقابل‌تغییر مجاز هستند استفاده می‌کنید. شما می‌توانید
با وجود این مبادلات، از <code>RefCell&lt;T&gt;</code> برای دریافت عملکرد بیشتری نسبت به
ارجاع‌های معمولی استفاده کنید.</p>
<h3 id="داشتن-چندین-مالک-برای-دادههای-قابلتغییر-با-ترکیب-rct-و-refcellt"><a class="header" href="#داشتن-چندین-مالک-برای-دادههای-قابلتغییر-با-ترکیب-rct-و-refcellt">داشتن چندین مالک برای داده‌های قابل‌تغییر با ترکیب <code>Rc&lt;T&gt;</code> و <code>RefCell&lt;T&gt;</code></a></h3>
<p>یک روش رایج برای استفاده از <code>RefCell&lt;T&gt;</code> ترکیب آن با <code>Rc&lt;T&gt;</code> است. به خاطر
بیاورید که <code>Rc&lt;T&gt;</code> به شما اجازه می‌دهد چندین مالک برای برخی داده‌ها داشته
باشید، اما فقط دسترسی غیرقابل‌تغییر به آن داده‌ها را می‌دهد. اگر یک <code>Rc&lt;T&gt;</code>
داشته باشید که یک <code>RefCell&lt;T&gt;</code> را نگه می‌دارد، می‌توانید یک مقداری داشته باشید
که می‌تواند چندین مالک داشته باشد <em>و</em> شما بتوانید آن را تغییر دهید!</p>
<p>برای مثال، مثال لیست cons در فهرست 15-18 را به خاطر بیاورید که در آن از <code>Rc&lt;T&gt;</code>
برای اجازه دادن به چندین لیست برای اشتراک مالکیت یک لیست دیگر استفاده کردیم.
چون <code>Rc&lt;T&gt;</code> تنها مقادیر غیرقابل‌تغییر را نگه می‌دارد، نمی‌توانیم هیچ یک از مقادیر
در لیست را پس از ایجاد تغییر دهیم. بیایید <code>RefCell&lt;T&gt;</code> را اضافه کنیم تا توانایی
تغییر مقادیر در لیست‌ها را کسب کنیم. فهرست 15-24 نشان می‌دهد که با استفاده از
<code>RefCell&lt;T&gt;</code> در تعریف <code>Cons</code>، می‌توانیم مقدار ذخیره‌شده در تمام لیست‌ها را
تغییر دهیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<figcaption>Listing 15-24: استفاده از <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> برای ایجاد یک <code>List</code> که می‌توانیم آن را تغییر دهیم</figcaption>
</figure>
<p>ما مقداری که نمونه‌ای از <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> است ایجاد می‌کنیم و آن را در یک
متغیر به نام <code>value</code> ذخیره می‌کنیم تا بتوانیم بعداً به طور مستقیم به آن دسترسی
داشته باشیم. سپس یک <code>List</code> در <code>a</code> با یک متغیر <code>Cons</code> که <code>value</code> را نگه می‌دارد
ایجاد می‌کنیم. ما نیاز داریم <code>value</code> را کلون کنیم تا هر دو <code>a</code> و <code>value</code> مالک
مقدار داخلی <code>5</code> باشند، به جای انتقال مالکیت از <code>value</code> به <code>a</code> یا اینکه <code>a</code> از
<code>value</code> وام بگیرد.</p>
<p>ما لیست <code>a</code> را در یک <code>Rc&lt;T&gt;</code> می‌پیچیم تا وقتی که لیست‌های <code>b</code> و <code>c</code> را ایجاد
می‌کنیم، هر دو بتوانند به <code>a</code> ارجاع دهند، که این همان چیزی است که در فهرست 15-18
انجام دادیم.</p>
<p>پس از ایجاد لیست‌ها در <code>a</code>، <code>b</code> و <code>c</code>، می‌خواهیم 10 به مقدار درون <code>value</code> اضافه
کنیم. این کار را با فراخوانی <code>borrow_mut</code> روی <code>value</code> انجام می‌دهیم، که از
ویژگی بازارجاع خودکار (automatic dereferencing) که در فصل 5 بحث کردیم (به
بخش <a href="ch05-03-method-syntax.html#wheres-the---operator">«عملگر <code>-&gt;</code> کجاست؟»</a><!-- ignore --> مراجعه کنید)
برای بازارجاع <code>Rc&lt;T&gt;</code> به مقدار داخلی <code>RefCell&lt;T&gt;</code> استفاده می‌کند. متد
<code>borrow_mut</code> یک اسمارت پوینتر <code>RefMut&lt;T&gt;</code> برمی‌گرداند، و ما از عملگر بازارجاع
روی آن استفاده می‌کنیم و مقدار داخلی را تغییر می‌دهیم.</p>
<p>وقتی <code>a</code>، <code>b</code> و <code>c</code> را چاپ می‌کنیم، می‌بینیم که همه آن‌ها مقدار تغییر‌یافته
15 به جای 5 را دارند:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>این تکنیک واقعاً جالب است! با استفاده از <code>RefCell&lt;T&gt;</code>، ما یک مقدار <code>List</code> داریم
که به نظر غیرقابل‌تغییر است. اما می‌توانیم از متدهای موجود در <code>RefCell&lt;T&gt;</code> که
دسترسی به تغییرپذیری داخلی آن را فراهم می‌کنند استفاده کنیم تا داده‌های خود را
هر وقت که نیاز داشتیم تغییر دهیم. بررسی‌های زمان اجرا برای قوانین وام‌دهی ما را
از رقابت‌های داده (data races) محافظت می‌کند، و گاهی اوقات ارزش آن را دارد که
مقداری سرعت را برای این انعطاف‌پذیری در ساختار داده‌هایمان معامله کنیم. توجه داشته
باشید که <code>RefCell&lt;T&gt;</code> برای کد چندریسمانی کار نمی‌کند! نسخه امن برای نخ (thread-safe)
از <code>RefCell&lt;T&gt;</code>، نوع <code>Mutex&lt;T&gt;</code> است که در فصل 16 در مورد آن صحبت خواهیم کرد.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
