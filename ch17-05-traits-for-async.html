<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>بررسی عمیق صفت‌ها برای Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html" class="active"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="digging-into-the-traits-for-async"><a class="header" href="#digging-into-the-traits-for-async">Digging Into the Traits for Async</a></h2>
<p>در طول این فصل، ما از Traits مختلفی مانند <code>Future</code>، <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>, و <code>StreamExt</code> به روش‌های مختلف استفاده کردیم. با این حال، تاکنون از بررسی عمیق جزئیات نحوه کار آن‌ها یا چگونگی ارتباطشان اجتناب کرده‌ایم. بیشتر مواقع هنگام نوشتن کد راست، این کافی است. با این حال، گاهی اوقات با شرایطی مواجه می‌شوید که درک کمی بیشتر از این جزئیات مهم است. در این بخش، به‌اندازه کافی به عمق این Traits خواهیم رفت تا برای آن شرایط کمک کنیم—در حالی که بررسی <em>واقعاً</em> عمیق را برای مستندات دیگر باقی می‌گذاریم!</p>
<h3 id="future"><a class="header" href="#future">Future</a></h3>
<p>در بخش <a href="ch17-01-futures-and-syntax.html">“Futures and the Async Syntax”</a><!-- ignore -->، اشاره کردیم که <code>Future</code> یک Trait است. بیایید با نگاه دقیق‌تر به نحوه کار آن شروع کنیم. در اینجا راست <code>Future</code> را چگونه تعریف می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>این تعریف Trait شامل چندین نوع جدید و همچنین نحوی است که قبلاً ندیده‌ایم، بنابراین بیایید قطعه به قطعه آن را بررسی کنیم.</p>
<p>اول، نوع مرتبط <code>Output</code> در <code>Future</code> مشخص می‌کند که آینده به چه چیزی منجر می‌شود. این شبیه به نوع مرتبط <code>Item</code> برای Trait <code>Iterator</code> است. دوم، <code>Future</code> همچنین متدی به نام <code>poll</code> دارد، که یک ارجاع خاص از نوع <code>Pin</code> برای پارامتر <code>self</code> و یک ارجاع قابل‌تغییر به نوع <code>Context</code> می‌گیرد، و یک <code>Poll&lt;Self::Output&gt;</code> بازمی‌گرداند. در ادامه بخش، بیشتر درباره <code>Pin</code> و <code>Context</code> صحبت خواهیم کرد. فعلاً، بیایید روی چیزی که متد بازمی‌گرداند تمرکز کنیم، یعنی نوع <code>Poll</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>نوع <code>Poll</code> شبیه به یک <code>Option</code> است: یک حالت (variant) دارد که دارای یک مقدار است (<code>Ready(T)</code>)، و یکی که مقدار ندارد (<code>Pending</code>). اما معنای بسیار متفاوتی دارد! حالت <code>Pending</code> نشان می‌دهد که آینده هنوز کارهایی برای انجام دارد، بنابراین فراخوان باید دوباره بعداً بررسی کند. حالت <code>Ready</code> نشان می‌دهد که <code>Future</code> کار خود را تمام کرده و مقدار <code>T</code> در دسترس است.</p>
<blockquote>
<p>نکته: با بیشتر آینده‌ها، فراخوان نباید دوباره <code>poll</code> را پس از بازگشت <code>Ready</code> فراخوانی کند. بسیاری از آینده‌ها در صورت فراخوانی دوباره پس از آماده شدن، panic می‌کنند! آینده‌هایی که ایمن هستند تا دوباره <code>poll</code> شوند، این موضوع را به‌صراحت در مستنداتشان ذکر می‌کنند. این شبیه به نحوه رفتار <code>Iterator::next</code> است!</p>
</blockquote>
<p>در پشت صحنه، وقتی کدی می‌بینید که از <code>await</code> استفاده می‌کند، راست آن را به کدی که <code>poll</code> را فراخوانی می‌کند کامپایل می‌کند. اگر به فهرست 17-4 نگاه کنید، جایی که عنوان صفحه را برای یک URL واحد پس از حل آن چاپ کردیم، راست آن را به چیزی شبیه به این (البته نه دقیقاً) کامپایل می‌کند:</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p>وقتی که <code>Future</code> هنوز در حالت <code>Pending</code> است، باید چه کار کنیم؟ ما به روشی نیاز داریم که دوباره امتحان کنیم… و دوباره، و دوباره، تا زمانی که آینده در نهایت آماده شود. به عبارت دیگر، نیاز به یک حلقه داریم:</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p>اگر راست آن را دقیقاً به این کد کامپایل می‌کرد، هر <code>await</code> مسدودکننده می‌شد—دقیقاً برعکس چیزی که به دنبالش بودیم! در عوض، راست اطمینان حاصل می‌کند که حلقه می‌تواند کنترل را به چیزی که قادر است کار روی این آینده را متوقف کند و روی آینده‌های دیگر کار کند و بعداً دوباره این آینده را بررسی کند، واگذار کند. آن “چیزی” یک runtime async است، و این کار برنامه‌ریزی و هماهنگی یکی از وظایف اصلی یک runtime است.</p>
<p>به یاد بیاورید توضیح ما (در بخش <a href="ch17-02-concurrency-with-async.html">Counting</a>) درباره انتظار برای <code>rx.recv</code>. فراخوانی <code>recv</code> یک <code>Future</code> بازمی‌گرداند، و انتظار آن آن را بررسی می‌کند. در بحث اولیه خود، اشاره کردیم که یک runtime آینده را تا زمانی که آماده شود با <code>Some(message)</code> یا <code>None</code> وقتی که کانال بسته می‌شود متوقف می‌کند. با درک عمیق‌تر ما از <code>Future</code>، و به‌طور خاص <code>Future::poll</code>، می‌توانیم ببینیم که این چگونه کار می‌کند. runtime وقتی که آینده <code>Poll::Pending</code> را بازمی‌گرداند، می‌داند که آینده آماده نیست. برعکس، runtime وقتی که <code>poll</code> مقدار <code>Poll::Ready(Some(message))</code> یا <code>Poll::Ready(None)</code> را بازمی‌گرداند، می‌داند که آینده آماده است و آن را جلو می‌برد.</p>
<p>جزئیات دقیق نحوه انجام این کار توسط یک runtime بیشتر از آن چیزی است که ما حتی در این بخش بررسی عمیق پوشش می‌دهیم. نکته کلیدی اینجا این است که مکانیک اصلی آینده‌ها را ببینیم: یک runtime هر آینده‌ای که مسئول آن است را <em>poll</em> می‌کند و وقتی که هنوز آماده نیست، آن را به حالت خواب برمی‌گرداند.</p>
<h3 id="pinning-و-traitsهای-pin-و-unpin"><a class="header" href="#pinning-و-traitsهای-pin-و-unpin">Pinning و Traits‌های Pin و Unpin</a></h3>
<p>وقتی که ایده pinning را هنگام کار روی فهرست 17-16 معرفی کردیم، با یک پیام خطای بسیار پیچیده مواجه شدیم. اینجا بخش مرتبط آن دوباره آمده است:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>وقتی این پیام خطا را با دقت بخوانیم، نه تنها به ما می‌گوید که نیاز داریم مقادیر را pin کنیم، بلکه به ما می‌گوید چرا pinning مورد نیاز است. تابع <code>trpl::join_all</code> یک struct به نام <code>JoinAll</code> بازمی‌گرداند. این struct به‌صورت جنریک بر روی یک نوع <code>F</code> است که محدود به پیاده‌سازی ویژگی <code>Future</code> است. منتظر ماندن مستقیم برای یک آینده با <code>await</code> به‌صورت ضمنی آینده را pin می‌کند. به همین دلیل، نیازی نیست که در هر جایی که می‌خواهیم برای آینده‌ها منتظر بمانیم، از <code>pin!</code> استفاده کنیم.</p>
<p>با این حال، ما در اینجا مستقیماً منتظر یک آینده نیستیم. در عوض، یک آینده جدید به نام <code>JoinAll</code> ایجاد می‌کنیم، با ارسال یک مجموعه از آینده‌ها به تابع <code>join_all</code>. امضای <code>join_all</code> نیاز دارد که نوع آیتم‌ها در مجموعه، همه ویژگی <code>Future</code> را پیاده‌سازی کنند، و <code>Box&lt;T&gt;</code> تنها در صورتی ویژگی <code>Future</code> را پیاده‌سازی می‌کند که نوع <code>T</code> که آن را می‌پیچد یک آینده‌ای باشد که ویژگی <code>Unpin</code> را پیاده‌سازی می‌کند.</p>
<p>این مقدار زیادی اطلاعات است! اما اگر کمی بیشتر به نحوه کارکرد نوع <code>Future</code> و به‌طور خاص اطراف <em>pinning</em> بپردازیم، می‌توانیم آن را درک کنیم.</p>
<p>بیایید دوباره به تعریف <code>Future</code> نگاه کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // متد مورد نیاز
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>پارامتر <code>cx</code> و نوع آن یعنی <code>Context</code> کلید نحوه‌ای است که یک runtime در واقع می‌داند چه زمانی باید یک آینده معین را بررسی کند، در حالی که همچنان تنبل باقی می‌ماند. جزئیات نحوه کارکرد آن فراتر از محدوده این فصل است: شما معمولاً فقط زمانی نیاز به نگرانی درباره آن دارید که یک پیاده‌سازی سفارشی از <code>Future</code> بنویسید.</p>
<p>در عوض، ما روی نوع <code>self</code> تمرکز خواهیم کرد. این اولین باری است که یک متد را می‌بینیم که <code>self</code> دارای یک حاشیه‌نویسی نوع است. یک حاشیه‌نویسی نوع برای <code>self</code> شبیه به حاشیه‌نویسی نوع برای دیگر پارامترهای تابع است، با دو تفاوت کلیدی. اول، وقتی نوع <code>self</code> را به این روش مشخص می‌کنیم، به راست می‌گوییم که نوع <code>self</code> برای فراخوانی این متد چه باید باشد. دوم، یک حاشیه‌نویسی نوع روی <code>self</code> نمی‌تواند هر نوعی باشد. فقط مجاز است که نوعی باشد که متد روی آن پیاده‌سازی شده است، یک ارجاع یا smart pointer به آن نوع، یا یک <code>Pin</code> که یک ارجاع به آن نوع را می‌پیچد. در فصل 18 بیشتر درباره این نحوی خواهیم دید. فعلاً، کافی است بدانیم که اگر بخواهیم یک آینده را بررسی کنیم (برای بررسی اینکه آیا در حالت <code>Pending</code> است یا <code>Ready(Output)</code>)، به یک ارجاع قابل‌تغییر به نوع نیاز داریم که در یک <code>Pin</code> پیچیده شده است.</p>
<p><code>Pin</code> یک نوع wrapper است. از برخی جهات، شبیه به <code>Box</code>، <code>Rc</code>، و دیگر نوع‌های smart pointer که در فصل 15 دیدیم است، که انواع دیگر را می‌پیچند. با این حال، برخلاف آن‌ها، <code>Pin</code> فقط با <em>انواع اشاره‌گر</em> کار می‌کند، مانند ارجاعات (<code>&amp;</code> و <code>&amp;mut</code>) و smart pointer‌ها (<code>Box</code>، <code>Rc</code> و غیره). دقیق‌تر بگوییم، <code>Pin</code> با نوع‌هایی کار می‌کند که ویژگی‌های <code>Deref</code> یا <code>DerefMut</code> را پیاده‌سازی کرده‌اند، که در فصل 15 پوشش دادیم. می‌توانید این محدودیت را معادل با کارکردن فقط با اشاره‌گرها در نظر بگیرید، زیرا پیاده‌سازی <code>Deref</code> یا <code>DerefMut</code> به این معنی است که نوع شما شبیه به یک نوع اشاره‌گر رفتار می‌کند. همچنین، <code>Pin</code> خودش یک اشاره‌گر نیست و رفتار خاصی مانند شمارش ارجاع در <code>Rc</code> و <code>Arc</code> ندارد. این فقط ابزاری است که کامپایلر می‌تواند برای رعایت تضمین‌های مرتبط با پیچیدن اشاره‌گرها در نوع استفاده کند.</p>
<p>با به یاد آوردن اینکه <code>await</code> بر اساس فراخوانی‌های <code>poll</code> پیاده‌سازی شده است، این شروع به توضیح پیام خطایی که در بالا دیدیم می‌کند—اما آن پیام به جای <code>Pin</code> در مورد <code>Unpin</code> بود. بنابراین <code>Pin</code> و <code>Unpin</code> دقیقاً چه هستند، چگونه به هم مرتبط می‌شوند، و چرا <code>Future</code> نیاز دارد که <code>self</code> در یک نوع <code>Pin</code> باشد تا بتواند <code>poll</code> را فراخوانی کند؟</p>
<p>در <a href="ch17-01-futures-and-syntax.html#our-first-async-program">اولین برنامه Async ما</a>، توضیح دادیم که چگونه یک سری نقاط انتظار (await points) در یک آینده به یک ماشین حالت کامپایل می‌شوند—و اشاره کردیم که چگونه کامپایلر کمک می‌کند تا مطمئن شود که ماشین حالت تمام قوانین عادی راست درباره ایمنی، از جمله وام‌دهی (borrowing) و مالکیت (ownership) را رعایت می‌کند. برای انجام این کار، راست بررسی می‌کند که چه داده‌ای بین هر نقطه انتظار و نقطه انتظار بعدی یا پایان بلوک async نیاز است. سپس یک حالت معادل در ماشین حالتی که ایجاد می‌کند، می‌سازد. هر حالت به داده‌هایی که در آن بخش از کد منبع استفاده خواهند شد دسترسی پیدا می‌کند، خواه با مالکیت گرفتن از آن داده‌ها یا با دریافت یک ارجاع قابل‌تغییر یا غیرقابل‌تغییر به آن.</p>
<p>تا اینجا مشکلی نیست: اگر چیزی درباره مالکیت یا ارجاعات در یک بلوک async معین اشتباه کنیم، وام‌دهنده (borrow checker) به ما خواهد گفت. اما وقتی می‌خواهیم آینده‌ای که با آن بلوک مطابقت دارد را جابه‌جا کنیم—مانند قرار دادن آن در یک <code>Vec</code> برای ارسال به <code>join_all</code>، همانطور که در بخش <a href="ch17-03-more-futures.html#working-with-any-number-of-futures">“کار با هر تعداد آینده”</a><!-- ignore --> انجام دادیم—کارها پیچیده‌تر می‌شوند.</p>
<p>وقتی یک آینده را جابه‌جا می‌کنیم—خواه با قرار دادن آن در یک ساختار داده برای استفاده به‌عنوان یک iterator با <code>join_all</code>، یا بازگرداندن آن‌ها از یک تابع—در واقع ماشین حالتی که راست برای ما ایجاد کرده است را جابه‌جا می‌کنیم. و برخلاف بیشتر نوع‌های دیگر در راست، آینده‌هایی که راست برای بلوک‌های async ایجاد می‌کند می‌توانند در نهایت دارای ارجاع‌هایی به خودشان در فیلدهای هر حالت معین باشند، همانطور که در شکل 17-4 نشان داده شده است (یک تصویر ساده‌شده برای کمک به درک ایده، نه برای وارد شدن به جزئیات پیچیده).</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-04.svg" class="center" />
<figcaption>شکل 17-4: یک نوع داده خودارجاعی.</figcaption>
</figure>
<p>با این حال، به‌طور پیش‌فرض، هر شیئی که ارجاعی به خودش دارد برای جابه‌جا شدن ناامن است، زیرا ارجاعات همیشه به آدرس حافظه واقعی چیزی که به آن ارجاع می‌دهند اشاره می‌کنند. اگر ساختار داده خودش را جابه‌جا کنید، آن ارجاعات داخلی به مکان قدیمی اشاره خواهند کرد. با این حال، آن مکان حافظه اکنون نامعتبر است. برای مثال، مقدار آن با تغییراتی که در ساختار داده انجام می‌دهید به‌روزرسانی نمی‌شود. و مهم‌تر از همه، کامپیوتر اکنون آزاد است که از آن حافظه برای چیزهای دیگر استفاده کند! ممکن است در آینده داده‌های کاملاً نامرتبطی را بخوانید.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-05.svg" class="center" />
<figcaption>شکل 17-5: نتیجه ناامن جابه‌جا کردن یک نوع داده خودارجاعی.</figcaption>
</figure>
<p>در اصل، کامپایلر راست می‌توانست تلاش کند هر ارجاع به یک شیء را هر بار که جابه‌جا می‌شود به‌روزرسانی کند. این کار می‌توانست سربار عملکرد زیادی داشته باشد، به‌ویژه با توجه به اینکه ممکن است یک شبکه کامل از ارجاعات وجود داشته باشد که نیاز به به‌روزرسانی دارند. از طرف دیگر، اگر می‌توانستیم مطمئن شویم که ساختار داده مورد نظر <em>در حافظه جابه‌جا نمی‌شود</em>، نیازی به به‌روزرسانی هیچ ارجاعی نداشتیم. این دقیقاً چیزی است که وام‌دهنده راست نیاز دارد: نمی‌توانید آیتمی را که هر گونه ارجاع فعالی به آن وجود دارد با کد ایمن جابه‌جا کنید.</p>
<p><code>Pin</code> بر اساس این مفهوم ساخته شده است تا تضمینی که نیاز داریم را فراهم کند. وقتی مقداری را <em>pin</em> می‌کنیم با پیچیدن یک اشاره‌گر به آن مقدار در <code>Pin</code>، دیگر نمی‌تواند جابه‌جا شود. بنابراین، اگر <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code> دارید، در واقع مقدار <code>SomeType</code> را pin می‌کنید، <em>نه</em> اشاره‌گر <code>Box</code>. شکل 17-6 این را نشان می‌دهد:</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-06.svg" class="center" />
<figcaption>شکل 17-6: pin کردن یک `Box` که به یک نوع آینده خودارجاعی اشاره می‌کند.</figcaption>
</figure>
<p>در واقع، اشاره‌گر <code>Box</code> هنوز می‌تواند به‌طور آزاد جابه‌جا شود. به یاد داشته باشید: ما به مطمئن شدن از اینکه داده‌ای که در نهایت به آن ارجاع داده می‌شود در جای خود باقی می‌ماند اهمیت می‌دهیم. اگر یک اشاره‌گر جابه‌جا شود اما داده‌ای که به آن اشاره می‌کند در همان مکان باقی بماند، همانطور که در شکل 17-7 نشان داده شده است، هیچ مشکلی پیش نمی‌آید. (چگونگی انجام این کار با یک <code>Pin</code> که یک <code>Box</code> را می‌پیچد فراتر از بحث این بخش خاص است، اما می‌تواند تمرین خوبی باشد! اگر به مستندات نوع‌ها و همچنین ماژول <code>std::pin</code> نگاه کنید، ممکن است بتوانید بفهمید چگونه این کار را انجام دهید.) نکته کلیدی این است که نوع خودارجاعی خود نمی‌تواند جابه‌جا شود، زیرا همچنان pin شده است.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-07.svg" class="center" />
<figcaption>شکل 17-7: جابه‌جایی یک `Box` که به یک نوع آینده خودارجاعی اشاره می‌کند.</figcaption>
</figure>
<p>با این حال، بیشتر نوع‌ها کاملاً ایمن برای جابه‌جایی هستند، حتی اگر پشت یک اشاره‌گر <code>Pin</code> باشند. فقط وقتی آیتم‌ها ارجاعات داخلی دارند باید به pinning فکر کنیم. مقادیر اولیه مانند اعداد و مقادیر بولی هیچ ارجاع داخلی ندارند، بنابراین آن‌ها به‌طور واضح ایمن هستند. بیشتر نوع‌هایی که معمولاً در راست با آن‌ها کار می‌کنید نیز همین‌طور هستند. برای مثال، یک <code>Vec</code> هیچ ارجاع داخلی‌ای ندارد که به این روش به‌روز شود، بنابراین می‌توانید آن را بدون نگرانی جابه‌جا کنید. اگر یک <code>Pin&lt;Vec&lt;String&gt;&gt;</code> داشته باشید، باید همه کارها را از طریق API‌های ایمن اما محدودکننده ارائه‌شده توسط <code>Pin</code> انجام دهید، حتی اگر یک <code>Vec&lt;String&gt;</code> همیشه ایمن برای جابه‌جایی باشد اگر هیچ ارجاع دیگری به آن وجود نداشته باشد. ما به روشی نیاز داریم تا به کامپایلر بگوییم که در مواردی مانند این، جابه‌جایی آیتم‌ها کاملاً خوب است. برای این کار، <code>Unpin</code> وجود دارد.</p>
<p><code>Unpin</code> یک trait نشانگر (marker trait) است، مشابه <code>Send</code> و <code>Sync</code> که در فصل 16 دیدیم. به یاد بیاورید که trait‌های نشانگر هیچ عملکردی از خود ندارند. آن‌ها فقط برای اطلاع دادن به کامپایلر وجود دارند که استفاده از نوعی که یک trait معین را پیاده‌سازی کرده است در یک زمینه خاص ایمن است. <code>Unpin</code> به کامپایلر اطلاع می‌دهد که یک نوع معین <em>نیازی</em> به رعایت تضمین‌های خاصی درباره اینکه آیا مقدار موردنظر می‌تواند جابه‌جا شود یا خیر ندارد.</p>
<p>درست مانند <code>Send</code> و <code>Sync</code>، کامپایلر <code>Unpin</code> را به‌طور خودکار برای همه نوع‌هایی که می‌تواند اثبات کند ایمن هستند پیاده‌سازی می‌کند. حالت خاص، دوباره مشابه <code>Send</code> و <code>Sync</code>، حالتی است که <code>Unpin</code> برای یک نوع پیاده‌سازی <em>نشده</em> است. نشانه‌گذاری برای این حالت به‌صورت <code>impl !Unpin for SomeType</code> است، که در آن <code>SomeType</code> نام نوعی است که برای ایمن بودن هر زمان که یک اشاره‌گر به آن نوع در یک <code>Pin</code> استفاده می‌شود، نیاز به رعایت تضمین‌ها دارد.</p>
<p>به عبارت دیگر، دو نکته درباره رابطه بین <code>Pin</code> و <code>Unpin</code> باید در نظر گرفته شود. اول، <code>Unpin</code> حالت “عادی” است و <code>!Unpin</code> حالت خاص است. دوم، اینکه آیا یک نوع <code>Unpin</code> یا <code>!Unpin</code> را پیاده‌سازی می‌کند فقط زمانی مهم است که از یک اشاره‌گر pinned به آن نوع مانند <code>Pin&lt;&amp;mut SomeType&gt;</code> استفاده می‌کنید.</p>
<p>برای ملموس‌تر کردن این موضوع، به یک <code>String</code> فکر کنید: یک طول و کاراکترهای Unicode که آن را تشکیل می‌دهند دارد. می‌توانیم یک <code>String</code> را در <code>Pin</code> بپیچیم، همان‌طور که در شکل 17-8 نشان داده شده است. با این حال، <code>String</code> به‌طور خودکار <code>Unpin</code> را پیاده‌سازی می‌کند، همان‌طور که بیشتر نوع‌های دیگر در راست.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center" />
<figcaption>شکل 17-8: pin کردن یک String، با یک خط نقطه‌چین نشان‌دهنده اینکه String ویژگی `Unpin` را پیاده‌سازی می‌کند، بنابراین pin نیست.</figcaption>
</figure>
<p>در نتیجه، می‌توانیم کارهایی انجام دهیم که اگر <code>String</code> به جای آن <code>!Unpin</code> را پیاده‌سازی می‌کرد غیرقانونی بودند، مانند جایگزینی یک رشته با رشته دیگر در همان مکان دقیق حافظه، همان‌طور که در شکل 17-9 نشان داده شده است. این قرارداد <code>Pin</code> را نقض نمی‌کند، زیرا <code>String</code> هیچ ارجاع داخلی‌ای ندارد که جابه‌جایی آن را ناامن کند! این دقیقاً دلیل پیاده‌سازی <code>Unpin</code> به جای <code>!Unpin</code> است.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center" />
<figcaption>شکل 17-9: جایگزینی یک String با یک String کاملاً متفاوت در حافظه.</figcaption>
</figure>
<p>اکنون به‌اندازه کافی می‌دانیم تا خطاهایی که برای آن فراخوانی <code>join_all</code> در فهرست 17-17 گزارش شدند را درک کنیم. ما در ابتدا سعی کردیم آینده‌های تولیدشده توسط بلوک‌های async را به یک <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code> منتقل کنیم، اما همان‌طور که دیدیم، این آینده‌ها ممکن است ارجاعات داخلی داشته باشند، بنابراین ویژگی <code>Unpin</code> را پیاده‌سازی نمی‌کنند. آن‌ها نیاز به pin شدن دارند، و سپس می‌توانیم نوع <code>Pin</code> را به <code>Vec</code> ارسال کنیم، با اطمینان از اینکه داده‌های زیربنایی در آینده‌ها <em>جابه‌جا نخواهند شد</em>.</p>
<p><code>Pin</code> و <code>Unpin</code> بیشتر برای ساخت کتابخانه‌های سطح پایین یا وقتی که خودتان یک runtime می‌سازید مهم هستند، نه برای کد روزمره راست. وقتی این Traits را در پیام‌های خطا مشاهده می‌کنید، اکنون ایده بهتری از نحوه رفع کد خواهید داشت!</p>
<blockquote>
<p>نکته: این ترکیب <code>Pin</code> و <code>Unpin</code> اجازه می‌دهد که یک کلاس کامل از نوع‌های پیچیده در راست ایمن باشند که در غیر این صورت به دلیل خودارجاعی بودن دشوار برای پیاده‌سازی هستند. نوع‌هایی که نیاز به <code>Pin</code> دارند <em>بیشتر</em> در راست async امروزی ظاهر می‌شوند، اما ممکن است—بسیار به‌ندرت!—در زمینه‌های دیگر نیز ببینید.</p>
<p>جزئیات نحوه کار <code>Pin</code> و <code>Unpin</code> و قوانینی که باید رعایت کنند، به‌طور گسترده در مستندات API برای <code>std::pin</code> پوشش داده شده‌اند، بنابراین اگر می‌خواهید آن‌ها را عمیق‌تر درک کنید، این مکان خوبی برای شروع است.</p>
<p>اگر می‌خواهید بفهمید که “در پشت صحنه” چگونه کار می‌کنند، کتاب رسمی <a href="https://rust-lang.github.io/async-book/"><em>برنامه‌نویسی ناهمگام در راست</em></a> پاسخگوی شماست:</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">Chapter 2: Under the Hood: Executing Futures and Tasks</a></li>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Chapter 4: Pinning</a></li>
</ul>
</blockquote>
<h3 id="the-stream-trait"><a class="header" href="#the-stream-trait">The Stream Trait</a></h3>
<p>اکنون که درک عمیق‌تری از Traits‌های <code>Future</code>، <code>Pin</code>، و <code>Unpin</code> داریم، می‌توانیم توجه خود را به Trait <code>Stream</code> معطوف کنیم. همانطور که در بخش معرفی streams توضیح داده شد، streams مشابه iteratorهای ناهمگام هستند. برخلاف <code>Iterator</code> و <code>Future</code>، در زمان نگارش این متن، تعریف <code>Stream</code> در کتابخانه استاندارد وجود ندارد، اما یک تعریف بسیار رایج از crate <code>futures</code> وجود دارد که در سراسر اکوسیستم استفاده می‌شود.</p>
<p>بیایید تعاریف Traits‌های <code>Iterator</code> و <code>Future</code> را مرور کنیم تا بتوانیم تصور کنیم یک Trait <code>Stream</code> که این دو را ترکیب می‌کند چگونه ممکن است به نظر برسد. از <code>Iterator</code>، مفهوم یک توالی را داریم: متد <code>next</code> آن یک <code>Option&lt;Self::Item&gt;</code> فراهم می‌کند. از <code>Future</code>، مفهوم آماده شدن در طول زمان را داریم: متد <code>poll</code> آن یک <code>Poll&lt;Self::Output&gt;</code> فراهم می‌کند. برای نمایش یک توالی از آیتم‌هایی که در طول زمان آماده می‌شوند، یک Trait <code>Stream</code> تعریف می‌کنیم که این ویژگی‌ها را ترکیب می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait <code>Stream</code> یک نوع مرتبط به نام <code>Item</code> برای نوع آیتم‌هایی که توسط stream تولید می‌شوند تعریف می‌کند. این مشابه با <code>Iterator</code> است: ممکن است تعداد این آیتم‌ها صفر تا بی‌نهایت باشد، برخلاف <code>Future</code> که همیشه یک <code>Output</code> واحد دارد (حتی اگر نوع واحد <code>()</code> باشد).</p>
<p><code>Stream</code> همچنین یک متد برای دریافت این آیتم‌ها تعریف می‌کند. ما آن را <code>poll_next</code> می‌نامیم تا واضح باشد که این متد به همان روشی که <code>Future::poll</code> بررسی می‌کند، آیتم‌ها را بررسی می‌کند و به همان روشی که <code>Iterator::next</code> یک توالی از آیتم‌ها تولید می‌کند، آیتم‌ها را تولید می‌کند. نوع بازگشتی آن <code>Poll</code> را با <code>Option</code> ترکیب می‌کند. نوع خارجی <code>Poll</code> است، زیرا باید برای آماده بودن بررسی شود، همان‌طور که یک آینده بررسی می‌شود. نوع داخلی <code>Option</code> است، زیرا باید نشان دهد که آیا پیام‌های بیشتری وجود دارد یا نه، همان‌طور که یک iterator انجام می‌دهد.</p>
<p>چیزی بسیار مشابه با این احتمالاً در نهایت به‌عنوان بخشی از کتابخانه استاندارد راست استانداردسازی خواهد شد. در حال حاضر، این Trait بخشی از ابزار اکثر runtime‌ها است، بنابراین می‌توانید روی آن حساب کنید و همه چیزهایی که در ادامه می‌بینید عموماً قابل اعمال هستند!</p>
<p>با این حال، در مثالی که در بخش مربوط به streams دیدیم، ما از <code>poll_next</code> یا <code>Stream</code> استفاده نکردیم، بلکه از <code>next</code> و <code>StreamExt</code> استفاده کردیم. البته می‌توانیم مستقیماً از API <code>poll_next</code> استفاده کنیم و ماشین‌های حالت <code>Stream</code> خود را با دست بنویسیم، همان‌طور که می‌توانیم مستقیماً از طریق متد <code>poll</code> با آینده‌ها کار کنیم. اما استفاده از <code>await</code> بسیار دلپذیرتر است، بنابراین Trait <code>StreamExt</code> متد <code>next</code> را فراهم می‌کند تا بتوانیم دقیقاً این کار را انجام دهیم.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>نکته: تعریف واقعی که قبلاً در این فصل استفاده کردیم کمی متفاوت به نظر می‌رسد، زیرا از نسخه‌هایی از راست پشتیبانی می‌کند که هنوز از استفاده از توابع async در Traits پشتیبانی نمی‌کنند. در نتیجه، این‌گونه به نظر می‌رسد:</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>نوع <code>Next</code> یک <code>struct</code> است که <code>Future</code> را پیاده‌سازی می‌کند و راهی برای نام‌گذاری طول عمر ارجاع به <code>self</code> با <code>Next&lt;'_, Self&gt;</code> فراهم می‌کند، به‌طوری که <code>await</code> بتواند با این متد کار کند!</p>
</blockquote>
<p>Trait <code>StreamExt</code> همچنین محل تمام متدهای جالبی است که می‌توان با streams استفاده کرد. <code>StreamExt</code> به‌طور خودکار برای هر نوعی که <code>Stream</code> را پیاده‌سازی کند، پیاده‌سازی می‌شود، اما این Traits به‌طور جداگانه تعریف شده‌اند تا جامعه بتواند به‌صورت جداگانه روی Trait بنیادی و API‌های راحتی کار کند.</p>
<p>در نسخه <code>StreamExt</code> استفاده‌شده در crate <code>trpl</code>، این Trait نه تنها متد <code>next</code> را تعریف می‌کند، بلکه یک پیاده‌سازی از <code>next</code> ارائه می‌دهد که جزئیات فراخوانی <code>Stream::poll_next</code> را به‌درستی مدیریت می‌کند. این بدان معناست که حتی زمانی که نیاز دارید نوع داده‌های جریان خود را بنویسید، فقط کافی است <code>Stream</code> را پیاده‌سازی کنید، و سپس هرکسی که از نوع داده شما استفاده کند، می‌تواند به‌طور خودکار از <code>StreamExt</code> و متدهای آن با آن استفاده کند.</p>
<p>این تمام چیزی است که درباره جزئیات سطح پایین این Traits پوشش خواهیم داد. برای جمع‌بندی، بیایید در نظر بگیریم که چگونه آینده‌ها (شامل streams)، تسک‌ها، و نخ‌ها همگی با هم سازگار هستند!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-04-streams.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-04-streams.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
