<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، crateها، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و crateها</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گرهای هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گرهای هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html" class="active"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از انواع مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناامن</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> صفت‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> انواع پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closureهای پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور تک‌نخی</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند"><a class="header" href="#چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند">چرخه‌های ارجاعی می‌توانند منجر به نشت حافظه شوند</a></h2>
<p>تضمین‌های ایمنی حافظه راست ایجاد حافظه‌ای که هرگز پاک نمی‌شود (که به عنوان <em>نشت حافظه</em>
شناخته می‌شود) را دشوار می‌کنند، اما غیرممکن نمی‌کنند. جلوگیری کامل از نشت حافظه
یکی از تضمین‌های راست نیست، به این معنی که نشت حافظه در راست ایمن است. ما می‌توانیم
ببینیم که راست اجازه نشت حافظه را می‌دهد با استفاده از <code>Rc&lt;T&gt;</code> و <code>RefCell&lt;T&gt;</code>:
امکان ایجاد ارجاع‌هایی وجود دارد که آیتم‌ها در آن به یکدیگر در یک چرخه ارجاع می‌دهند.
این باعث نشت حافظه می‌شود، زیرا شمارش ارجاع هر آیتم در چرخه هرگز به 0 نمی‌رسد و
مقادیر هرگز حذف نمی‌شوند.</p>
<h3 id="ایجاد-یک-چرخه-ارجاعی"><a class="header" href="#ایجاد-یک-چرخه-ارجاعی">ایجاد یک چرخه ارجاعی</a></h3>
<p>بیایید نگاهی بیندازیم که چگونه یک چرخه ارجاعی ممکن است اتفاق بیفتد و چگونه می‌توان از آن
جلوگیری کرد، با تعریف enum <code>List</code> و یک متد <code>tail</code> در فهرست 15-25 شروع می‌کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<figcaption>Listing 15-25: تعریف یک لیست cons که یک <code>RefCell&lt;T&gt;</code> نگه می‌دارد تا بتوانیم آنچه که یک متغیر <code>Cons</code> به آن اشاره می‌کند را تغییر دهیم</figcaption>
</figure>
<p>ما از یک نسخه دیگر از تعریف <code>List</code> که در فهرست 15-5 آمده بود استفاده می‌کنیم.
عنصر دوم در متغیر <code>Cons</code> اکنون <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> است، به این معنی که به جای
توانایی تغییر مقدار <code>i32</code> که در فهرست 15-24 داشتیم، می‌خواهیم مقدار <code>List</code> را که
یک متغیر <code>Cons</code> به آن اشاره می‌کند، تغییر دهیم. همچنین، یک متد <code>tail</code> اضافه
می‌کنیم تا دسترسی به آیتم دوم را در صورتی که یک متغیر <code>Cons</code> داریم، راحت‌تر کنیم.</p>
<p>در فهرست 15-26، یک تابع <code>main</code> اضافه می‌کنیم که از تعاریف فهرست 15-25 استفاده می‌کند.
این کد لیستی در <code>a</code> و لیستی در <code>b</code> ایجاد می‌کند که به لیست <code>a</code> اشاره می‌کند.
سپس لیست در <code>a</code> را تغییر می‌دهد تا به <code>b</code> اشاره کند و یک چرخه ارجاعی ایجاد کند.
در طول این فرآیند، اظهارات <code>println!</code> وجود دارند که نشان می‌دهند شمارش ارجاع
در نقاط مختلف چه مقدار است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<figcaption>Listing 15-26: ایجاد یک چرخه ارجاعی از دو مقدار <code>List</code> که به یکدیگر اشاره می‌کنند</figcaption>
</figure>
<p>ما یک نمونه <code>Rc&lt;List&gt;</code> ایجاد می‌کنیم که یک مقدار <code>List</code> را در متغیر <code>a</code> نگه می‌دارد
با یک لیست اولیه از <code>5, Nil</code>. سپس یک نمونه <code>Rc&lt;List&gt;</code> دیگر ایجاد می‌کنیم که مقدار
دیگری از <code>List</code> را در متغیر <code>b</code> نگه می‌دارد که مقدار 10 را شامل می‌شود و به لیست
در <code>a</code> اشاره می‌کند.</p>
<p>ما <code>a</code> را تغییر می‌دهیم تا به جای <code>Nil</code> به <code>b</code> اشاره کند، و یک چرخه ایجاد می‌کنیم.
این کار را با استفاده از متد <code>tail</code> انجام می‌دهیم تا یک ارجاع به <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>
در <code>a</code> بگیریم، که آن را در متغیر <code>link</code> قرار می‌دهیم. سپس از متد <code>borrow_mut</code>
روی <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> استفاده می‌کنیم تا مقدار داخلی را از یک <code>Rc&lt;List&gt;</code> که
مقدار <code>Nil</code> را نگه می‌دارد به <code>Rc&lt;List&gt;</code> در <code>b</code> تغییر دهیم.</p>
<p>وقتی این کد را اجرا می‌کنیم و <code>println!</code> آخر را به طور موقت کامنت می‌کنیم، خروجی زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>شمارش ارجاع نمونه‌های <code>Rc&lt;List&gt;</code> در هر دو <code>a</code> و <code>b</code> پس از تغییر لیست در <code>a</code> برای اشاره به <code>b</code> برابر با 2 است. در پایان تابع <code>main</code>، راست متغیر <code>b</code> را حذف می‌کند، که شمارش ارجاع نمونه <code>Rc&lt;List&gt;</code> در <code>b</code> را از 2 به 1 کاهش می‌دهد. حافظه‌ای که <code>Rc&lt;List&gt;</code> در heap اشغال کرده است در این نقطه حذف نخواهد شد، زیرا شمارش ارجاع آن برابر با 1 است و نه 0. سپس راست متغیر <code>a</code> را حذف می‌کند، که شمارش ارجاع نمونه <code>Rc&lt;List&gt;</code> در <code>a</code> را نیز از 2 به 1 کاهش می‌دهد. حافظه این نمونه نیز نمی‌تواند حذف شود، زیرا نمونه دیگر <code>Rc&lt;List&gt;</code> همچنان به آن ارجاع می‌دهد. حافظه تخصیص‌یافته به این لیست برای همیشه غیرقابل جمع‌آوری باقی خواهد ماند. برای تجسم این چرخه ارجاع، نموداری در شکل 15-4 ایجاد کرده‌ایم.</p>
<img alt="چرخه ارجاعی لیست‌ها" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">شکل 15-4: یک چرخه ارجاعی از لیست‌های <code>a</code> و <code>b</code> که به یکدیگر اشاره می‌کنند</span></p>
<p>اگر آخرین دستور <code>println!</code> را از حالت کامنت خارج کنید و برنامه را اجرا کنید، راست سعی خواهد کرد این چرخه را با <code>a</code> که به <code>b</code> و سپس به <code>a</code> اشاره می‌کند و به همین ترتیب ادامه می‌دهد، چاپ کند تا زمانی که استک سرریز شود.</p>
<p>در مقایسه با یک برنامه واقعی، عواقب ایجاد چرخه ارجاعی در این مثال چندان وخیم نیست: درست بعد از اینکه چرخه ارجاعی ایجاد می‌شود، برنامه پایان می‌یابد. با این حال، اگر یک برنامه پیچیده‌تر مقدار زیادی حافظه در یک چرخه تخصیص دهد و برای مدت طولانی آن را نگه دارد، برنامه بیشتر از حافظه‌ای که نیاز دارد استفاده خواهد کرد و ممکن است سیستم را از حافظه موجود تخلیه کند.</p>
<p>ایجاد چرخه‌های ارجاعی کار آسانی نیست، اما غیرممکن هم نیست. اگر مقادیر <code>RefCell&lt;T&gt;</code> داشته باشید که مقادیر <code>Rc&lt;T&gt;</code> یا ترکیبات مشابهی از انواع با تغییرپذیری داخلی و شمارش ارجاع را در خود جای دهند، باید مطمئن شوید که چرخه‌ای ایجاد نمی‌کنید؛ نمی‌توانید به راست اعتماد کنید که آن‌ها را شناسایی کند. ایجاد چرخه ارجاعی یک اشکال منطقی در برنامه شما خواهد بود که باید با استفاده از تست‌های خودکار، بررسی کد، و دیگر شیوه‌های توسعه نرم‌افزار، آن را به حداقل برسانید.</p>
<p>یک راه‌حل دیگر برای جلوگیری از چرخه‌های ارجاعی، بازسازی ساختار داده‌هایتان است به‌طوری که برخی ارجاعات بیانگر مالکیت باشند و برخی نباشند. به این ترتیب، می‌توانید چرخه‌هایی داشته باشید که شامل برخی روابط مالکیت و برخی روابط غیرمالکیت هستند، و تنها روابط مالکیت تعیین می‌کنند که آیا یک مقدار می‌تواند حذف شود یا خیر. در فهرست 15-25، ما همیشه می‌خواهیم که متغیرهای <code>Cons</code> مالک لیست‌هایشان باشند، بنابراین بازسازی ساختار داده امکان‌پذیر نیست. بیایید به یک مثال با استفاده از گراف‌ها که شامل گره‌های والد و فرزند هستند نگاه کنیم تا ببینیم چه زمانی روابط غیرمالکیت یک راه مناسب برای جلوگیری از چرخه‌های ارجاعی هستند.</p>
<h3 id="جلوگیری-از-چرخههای-ارجاعی-تبدیل-یک-rct-به-یک-weakt"><a class="header" href="#جلوگیری-از-چرخههای-ارجاعی-تبدیل-یک-rct-به-یک-weakt">جلوگیری از چرخه‌های ارجاعی: تبدیل یک <code>Rc&lt;T&gt;</code> به یک <code>Weak&lt;T&gt;</code></a></h3>
<p>تا اینجا، نشان داده‌ایم که فراخوانی <code>Rc::clone</code> شمارش <code>strong_count</code> یک نمونه <code>Rc&lt;T&gt;</code> را افزایش می‌دهد، و یک نمونه <code>Rc&lt;T&gt;</code> تنها زمانی پاک‌سازی می‌شود که شمارش <code>strong_count</code> آن 0 باشد. همچنین می‌توانید با فراخوانی <code>Rc::downgrade</code> و ارسال یک ارجاع به <code>Rc&lt;T&gt;</code>، یک <em>ارجاع ضعیف</em> به مقدار درون یک نمونه <code>Rc&lt;T&gt;</code> ایجاد کنید. ارجاعات قوی به شما اجازه می‌دهند مالکیت یک نمونه <code>Rc&lt;T&gt;</code> را به اشتراک بگذارید. ارجاعات ضعیف یک رابطه مالکیت را بیان نمی‌کنند، و شمارش آن‌ها تأثیری در زمان پاک‌سازی یک نمونه <code>Rc&lt;T&gt;</code> ندارد. آن‌ها باعث ایجاد چرخه ارجاعی نمی‌شوند، زیرا هر چرخه‌ای که شامل برخی ارجاعات ضعیف باشد، وقتی شمارش ارجاع قوی مقادیر درگیر 0 شود، شکسته می‌شود.</p>
<p>وقتی <code>Rc::downgrade</code> را فراخوانی می‌کنید، یک اسمارت پوینتر از نوع <code>Weak&lt;T&gt;</code> دریافت می‌کنید. به جای افزایش شمارش <code>strong_count</code> در نمونه <code>Rc&lt;T&gt;</code> به مقدار 1، فراخوانی <code>Rc::downgrade</code> شمارش <code>weak_count</code> را به مقدار 1 افزایش می‌دهد. نوع <code>Rc&lt;T&gt;</code> از <code>weak_count</code> برای پیگیری تعداد ارجاعات <code>Weak&lt;T&gt;</code> موجود استفاده می‌کند، مشابه <code>strong_count</code>. تفاوت این است که شمارش <code>weak_count</code> نیازی به 0 بودن برای پاک‌سازی نمونه <code>Rc&lt;T&gt;</code> ندارد.</p>
<p>از آنجا که مقداری که <code>Weak&lt;T&gt;</code> به آن ارجاع می‌دهد ممکن است حذف شده باشد، برای انجام هر
کاری با مقداری که یک <code>Weak&lt;T&gt;</code> به آن اشاره می‌کند، باید مطمئن شوید که مقدار هنوز
وجود دارد. این کار را با فراخوانی متد <code>upgrade</code> روی یک نمونه <code>Weak&lt;T&gt;</code> انجام دهید،
که یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> را برمی‌گرداند. اگر مقدار <code>Rc&lt;T&gt;</code> هنوز حذف نشده باشد، نتیجه
<code>Some</code> خواهد بود و اگر مقدار <code>Rc&lt;T&gt;</code> حذف شده باشد، نتیجه <code>None</code> خواهد بود. از آنجا
که <code>upgrade</code> یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> را برمی‌گرداند، راست تضمین می‌کند که حالت
<code>Some</code> و حالت <code>None</code> مدیریت می‌شوند و هیچ اشاره‌گر نامعتبری وجود نخواهد داشت.</p>
<p>برای مثال، به جای استفاده از یک لیست که آیتم‌های آن فقط درباره آیتم بعدی اطلاع دارند،
ما یک درخت ایجاد خواهیم کرد که آیتم‌های آن درباره آیتم‌های فرزند <em>و</em> والد خود اطلاع دارند.</p>
<h4 id="ایجاد-یک-ساختار-داده-درخت-یک-node-با-گرههای-فرزند"><a class="header" href="#ایجاد-یک-ساختار-داده-درخت-یک-node-با-گرههای-فرزند">ایجاد یک ساختار داده درخت: یک <code>Node</code> با گره‌های فرزند</a></h4>
<p>برای شروع، ما یک درخت با گره‌هایی ایجاد خواهیم کرد که درباره گره‌های فرزند خود اطلاع
دارند. ما یک ساختار به نام <code>Node</code> ایجاد خواهیم کرد که مقدار <code>i32</code> خود را نگه می‌دارد
و همچنین به گره‌های فرزند خود ارجاع می‌دهد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>ما می‌خواهیم که یک <code>Node</code> مالک فرزندان خود باشد و همچنین می‌خواهیم که این مالکیت با
متغیرها به اشتراک گذاشته شود تا بتوانیم مستقیماً به هر <code>Node</code> در درخت دسترسی داشته
باشیم. برای انجام این کار، آیتم‌های <code>Vec&lt;T&gt;</code> را به عنوان مقادیری از نوع <code>Rc&lt;Node&gt;</code>
تعریف می‌کنیم. همچنین می‌خواهیم تغییر دهیم که کدام گره‌ها فرزندان یک گره دیگر باشند،
بنابراین در <code>children</code> یک <code>RefCell&lt;T&gt;</code> در اطراف <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> قرار می‌دهیم.</p>
<p>سپس، تعریف ساختار خود را استفاده می‌کنیم و یک نمونه <code>Node</code> به نام <code>leaf</code> با مقدار 3 و
بدون فرزند، و یک نمونه دیگر به نام <code>branch</code> با مقدار 5 و <code>leaf</code> به عنوان یکی از فرزندان
آن ایجاد می‌کنیم، همانطور که در فهرست 15-27 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<figcaption>Listing 15-27: ایجاد یک گره <code>leaf</code> بدون فرزند و یک گره <code>branch</code> با <code>leaf</code> به عنوان یکی از فرزندان آن</figcaption>
</figure>
<p>ما <code>Rc&lt;Node&gt;</code> را در <code>leaf</code> کلون می‌کنیم و آن را در <code>branch</code> ذخیره می‌کنیم، به این
معنی که <code>Node</code> در <code>leaf</code> اکنون دو مالک دارد: <code>leaf</code> و <code>branch</code>. ما می‌توانیم از
<code>branch</code> به <code>leaf</code> از طریق <code>branch.children</code> برسیم، اما هیچ راهی برای رفتن از
<code>leaf</code> به <code>branch</code> وجود ندارد. دلیل این است که <code>leaf</code> هیچ ارجاعی به <code>branch</code>
ندارد و نمی‌داند که آن‌ها مرتبط هستند. ما می‌خواهیم که <code>leaf</code> بداند که <code>branch</code>
والد آن است. این کار را در مرحله بعد انجام خواهیم داد.</p>
<h4 id="افزودن-یک-ارجاع-از-فرزند-به-والد"><a class="header" href="#افزودن-یک-ارجاع-از-فرزند-به-والد">افزودن یک ارجاع از فرزند به والد</a></h4>
<p>برای آگاه کردن گره فرزند از والدش، باید یک فیلد <code>parent</code> به تعریف ساختار <code>Node</code> خود اضافه کنیم. مشکل در تصمیم‌گیری در مورد نوع <code>parent</code> است. می‌دانیم که نمی‌تواند شامل یک <code>Rc&lt;T&gt;</code> باشد، زیرا این امر باعث ایجاد چرخه ارجاعی می‌شود که در آن <code>leaf.parent</code> به <code>branch</code> اشاره می‌کند و <code>branch.children</code> به <code>leaf</code>، که باعث می‌شود مقادیر <code>strong_count</code> آن‌ها هرگز به 0 نرسد.</p>
<p>با در نظر گرفتن روابط از دیدگاهی دیگر، یک گره والد باید مالک فرزندان خود باشد: اگر یک گره والد حذف شود، گره‌های فرزند آن نیز باید حذف شوند. اما، یک فرزند نباید مالک والدش باشد: اگر یک گره فرزند حذف شود، والد باید همچنان وجود داشته باشد. این مورد برای استفاده از ارجاعات ضعیف (weak references) مناسب است!</p>
<p>بنابراین، به جای <code>Rc&lt;T&gt;</code>، نوع <code>parent</code> را از نوع <code>Weak&lt;T&gt;</code> انتخاب می‌کنیم، به طور خاص یک <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. اکنون تعریف ساختار <code>Node</code> ما به این شکل است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>یک گره قادر خواهد بود به گره والد خود ارجاع دهد اما مالک والد نخواهد بود. در فهرست 15-28، ما تابع <code>main</code> را به‌روزرسانی می‌کنیم تا از این تعریف جدید استفاده کنیم، به‌طوری که گره <code>leaf</code> راهی برای ارجاع به والد خود، <code>branch</code>، داشته باشد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<figcaption>Listing 15-28: یک گره <code>leaf</code> با یک ارجاع ضعیف به گره والد خود <code>branch</code></figcaption>
</figure>
<p>ایجاد گره <code>leaf</code> مشابه فهرست 15-27 است با این تفاوت که فیلد <code>parent</code>: <code>leaf</code> ابتدا بدون والد شروع می‌شود، بنابراین یک نمونه جدید و خالی از ارجاع <code>Weak&lt;Node&gt;</code> ایجاد می‌کنیم.</p>
<p>در این مرحله، وقتی سعی می‌کنیم با استفاده از متد <code>upgrade</code> به والد گره <code>leaf</code> دسترسی پیدا کنیم، یک مقدار <code>None</code> دریافت می‌کنیم. این مورد را در خروجی اولین دستور <code>println!</code> مشاهده می‌کنیم:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>وقتی گره <code>branch</code> را ایجاد می‌کنیم، آن نیز یک ارجاع جدید <code>Weak&lt;Node&gt;</code> در فیلد <code>parent</code> خواهد داشت، زیرا <code>branch</code> گره والد ندارد. همچنان گره <code>leaf</code> به‌عنوان یکی از فرزندان <code>branch</code> است. وقتی نمونه <code>Node</code> در <code>branch</code> را داریم، می‌توانیم <code>leaf</code> را تغییر دهیم تا به والد خود یک ارجاع <code>Weak&lt;Node&gt;</code> بدهد. از متد <code>borrow_mut</code> روی <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> در فیلد <code>parent</code> از <code>leaf</code> استفاده می‌کنیم و سپس از تابع <code>Rc::downgrade</code> برای ایجاد یک ارجاع <code>Weak&lt;Node&gt;</code> به <code>branch</code> از <code>Rc&lt;Node&gt;</code> در <code>branch</code> استفاده می‌کنیم.</p>
<p>وقتی والد گره <code>leaf</code> را دوباره چاپ می‌کنیم، این بار یک متغیر <code>Some</code> که <code>branch</code> را
نگه می‌دارد دریافت می‌کنیم: اکنون <code>leaf</code> می‌تواند به والد خود دسترسی پیدا کند!
هنگامی که <code>leaf</code> را چاپ می‌کنیم، همچنین از چرخه‌ای که نهایتاً به سرریز شدن استک
مانند فهرست 15-26 منجر می‌شد اجتناب می‌کنیم؛ ارجاعات <code>Weak&lt;Node&gt;</code> به‌صورت <code>(Weak)</code>
چاپ می‌شوند:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>نبود خروجی بی‌نهایت نشان می‌دهد که این کد چرخه ارجاعی ایجاد نکرده است. همچنین می‌توانیم
این را با مشاهده مقادیری که از فراخوانی <code>Rc::strong_count</code> و <code>Rc::weak_count</code>
دریافت می‌کنیم، تأیید کنیم.</p>
<h4 id="تجسم-تغییرات-در-strong_count-و-weak_count"><a class="header" href="#تجسم-تغییرات-در-strong_count-و-weak_count">تجسم تغییرات در <code>strong_count</code> و <code>weak_count</code></a></h4>
<p>بیایید نگاهی بیندازیم که چگونه مقادیر <code>strong_count</code> و <code>weak_count</code> نمونه‌های
<code>Rc&lt;Node&gt;</code> با ایجاد یک دامنه داخلی جدید و انتقال ایجاد <code>branch</code> به آن دامنه تغییر
می‌کنند. با این کار، می‌توانیم ببینیم چه اتفاقی می‌افتد وقتی <code>branch</code> ایجاد و سپس
هنگام خارج شدن از دامنه حذف می‌شود. تغییرات در فهرست 15-29 نشان داده شده‌اند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<figcaption>Listing 15-29: ایجاد <code>branch</code> در یک دامنه داخلی و بررسی شمارش ارجاعات قوی و ضعیف</figcaption>
</figure>
<p>پس از ایجاد <code>leaf</code>، <code>Rc&lt;Node&gt;</code> آن دارای شمارش قوی 1 و شمارش ضعیف 0 است. در دامنه
داخلی، ما <code>branch</code> را ایجاد می‌کنیم و آن را با <code>leaf</code> مرتبط می‌کنیم، در این نقطه
وقتی شمارش‌ها را چاپ می‌کنیم، <code>Rc&lt;Node&gt;</code> در <code>branch</code> دارای شمارش قوی 1 و شمارش
ضعیف 1 خواهد بود (برای <code>leaf.parent</code> که به <code>branch</code> با یک <code>Weak&lt;Node&gt;</code> اشاره
می‌کند). وقتی شمارش‌ها را در <code>leaf</code> چاپ می‌کنیم، می‌بینیم که شمارش قوی آن 2 خواهد
بود، زیرا <code>branch</code> اکنون یک کلون از <code>Rc&lt;Node&gt;</code> در <code>leaf</code> که در <code>branch.children</code>
ذخیره شده است، دارد، اما همچنان شمارش ضعیف 0 خواهد بود.</p>
<p>وقتی دامنه داخلی به پایان می‌رسد، <code>branch</code> از دامنه خارج می‌شود و شمارش قوی
<code>Rc&lt;Node&gt;</code> به 0 کاهش می‌یابد، بنابراین <code>Node</code> آن حذف می‌شود. شمارش ضعیف 1 از
<code>leaf.parent</code> تأثیری بر اینکه آیا <code>Node</code> حذف می‌شود ندارد، بنابراین هیچ نشت
حافظه‌ای نخواهیم داشت!</p>
<p>اگر سعی کنیم پس از پایان دامنه به والد <code>leaf</code> دسترسی پیدا کنیم، دوباره مقدار
<code>None</code> دریافت خواهیم کرد. در پایان برنامه، <code>Rc&lt;Node&gt;</code> در <code>leaf</code> دارای شمارش قوی 1
و شمارش ضعیف 0 است، زیرا متغیر <code>leaf</code> اکنون تنها ارجاع به <code>Rc&lt;Node&gt;</code> است.</p>
<p>تمام منطق مدیریت شمارش‌ها و حذف مقدار درون <code>Rc&lt;T&gt;</code> و <code>Weak&lt;T&gt;</code> و پیاده‌سازی‌های
ویژگی <code>Drop</code> آن‌ها تعبیه شده است. با مشخص کردن اینکه رابطه از یک فرزند به والد
آن باید یک ارجاع <code>Weak&lt;T&gt;</code> باشد در تعریف <code>Node</code>، می‌توانید گره‌های والد را
به گره‌های فرزند و بالعکس ارجاع دهید بدون ایجاد یک چرخه ارجاعی و نشت حافظه.</p>
<h2 id="خلاصه"><a class="header" href="#خلاصه">خلاصه</a></h2>
<p>این فصل نحوه استفاده از اسمارت پوینترها برای ارائه تضمین‌ها و مبادلات متفاوت
از آنچه که راست به طور پیش‌فرض با ارجاع‌های معمولی ارائه می‌دهد را پوشش داد.
نوع <code>Box&lt;T&gt;</code> دارای اندازه مشخصی است و به داده‌های تخصیص‌یافته در heap اشاره می‌کند.
نوع <code>Rc&lt;T&gt;</code> تعداد ارجاع‌ها به داده‌ها در heap را پیگیری می‌کند تا داده‌ها بتوانند
چندین مالک داشته باشند. نوع <code>RefCell&lt;T&gt;</code> با تغییرپذیری داخلی خود به ما نوعی
می‌دهد که می‌توانیم زمانی که به یک نوع غیرقابل‌تغییر نیاز داریم اما باید مقدار
درونی آن نوع را تغییر دهیم، استفاده کنیم؛ همچنین قوانین وام‌دهی را در زمان اجرا
به جای زمان کامپایل اعمال می‌کند.</p>
<p>همچنین، ویژگی‌های <code>Deref</code> و <code>Drop</code> که بسیاری از قابلیت‌های اسمارت پوینترها را
ممکن می‌سازند، مورد بحث قرار گرفتند. ما چرخه‌های ارجاعی که می‌توانند باعث
نشت حافظه شوند و نحوه جلوگیری از آن‌ها با استفاده از <code>Weak&lt;T&gt;</code> را بررسی کردیم.</p>
<p>اگر این فصل علاقه شما را برانگیخته و می‌خواهید اسمارت پوینترهای خود را پیاده‌سازی
کنید، به <a href="../nomicon/index.html">“The Rustonomicon”</a> برای اطلاعات مفید بیشتر مراجعه کنید.</p>
<p>در فصل بعدی، درباره همزمانی (concurrency) در راست صحبت خواهیم کرد. حتی با
چند اسمارت پوینتر جدید نیز آشنا خواهید شد.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/custom.js"></script>


    </div>
    </body>
</html>
