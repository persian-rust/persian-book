<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند"><a class="header" href="#چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند">چرخه‌های ارجاعی می‌توانند منجر به نشت حافظه شوند</a></h2>
<p>تضمین‌های ایمنی حافظه راست ایجاد حافظه‌ای که هرگز پاک نمی‌شود (که به عنوان <em>نشت حافظه</em>
شناخته می‌شود) را دشوار می‌کنند، اما غیرممکن نمی‌کنند. جلوگیری کامل از نشت حافظه
یکی از تضمین‌های راست نیست، به این معنی که نشت حافظه در راست ایمن است. ما می‌توانیم
ببینیم که راست اجازه نشت حافظه را می‌دهد با استفاده از <code>Rc&lt;T&gt;</code> و <code>RefCell&lt;T&gt;</code>:
امکان ایجاد ارجاع‌هایی وجود دارد که آیتم‌ها در آن به یکدیگر در یک چرخه ارجاع می‌دهند.
این باعث نشت حافظه می‌شود، زیرا شمارش ارجاع هر آیتم در چرخه هرگز به 0 نمی‌رسد و
مقادیر هرگز حذف نمی‌شوند.</p>
<h3 id="ایجاد-یک-چرخه-ارجاعی"><a class="header" href="#ایجاد-یک-چرخه-ارجاعی">ایجاد یک چرخه ارجاعی</a></h3>
<p>بیایید بررسی کنیم که چگونه ممکن است یک چرخه‌ی رفرنس (reference cycle) به‌وجود بیاید و چگونه می‌توان از آن جلوگیری کرد. این بررسی را با تعریف <code>enum</code>ی به نام <code>List</code> و متدی به نام <code>tail</code> در لیستینگ 15-25 آغاز می‌کنیم.</p>
<figure class="listing" id="listing-15-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<figcaption><a href="#listing-15-25">Listing 15-25</a>: تعریف یک لیست cons که یک <code>RefCell&lt;T&gt;</code> نگه می‌دارد تا بتوانیم آنچه که یک متغیر <code>Cons</code> به آن اشاره می‌کند را تغییر دهیم</figcaption>
</figure>
<p>ما از یک نسخه دیگر از تعریف <code>List</code> که در فهرست 15-5 آمده بود استفاده می‌کنیم.
عنصر دوم در متغیر <code>Cons</code> اکنون <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> است، به این معنی که به جای
توانایی تغییر مقدار <code>i32</code> که در فهرست 15-24 داشتیم، می‌خواهیم مقدار <code>List</code> را که
یک متغیر <code>Cons</code> به آن اشاره می‌کند، تغییر دهیم. همچنین، یک متد <code>tail</code> اضافه
می‌کنیم تا دسترسی به آیتم دوم را در صورتی که یک متغیر <code>Cons</code> داریم، راحت‌تر کنیم.</p>
<p>در فهرست 15-26، یک تابع <code>main</code> اضافه می‌کنیم که از تعاریف فهرست 15-25 استفاده می‌کند.
این کد لیستی در <code>a</code> و لیستی در <code>b</code> ایجاد می‌کند که به لیست <code>a</code> اشاره می‌کند.
سپس لیست در <code>a</code> را تغییر می‌دهد تا به <code>b</code> اشاره کند و یک چرخه ارجاعی ایجاد کند.
در طول این فرآیند، اظهارات <code>println!</code> وجود دارند که نشان می‌دهند شمارش ارجاع
در نقاط مختلف چه مقدار است.</p>
<figure class="listing" id="listing-15-26">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack.
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<figcaption><a href="#listing-15-26">Listing 15-26</a>: ایجاد یک چرخه ارجاعی از دو مقدار <code>List</code> که به یکدیگر اشاره می‌کنند</figcaption>
</figure>
<p>ما یک نمونه‌ی <code>Rc&lt;List&gt;</code> ایجاد می‌کنیم که یک مقدار از نوع <code>List</code> را در متغیر <code>a</code> نگه می‌دارد و لیست اولیه‌ای به شکل <code>5, Nil</code> دارد. سپس یک نمونه‌ی دیگر از <code>Rc&lt;List&gt;</code> در متغیر <code>b</code> می‌سازیم که مقداری برابر با <code>10</code> دارد و به لیست موجود در <code>a</code> اشاره می‌کند.</p>
<p>ما <code>a</code> را تغییر می‌دهیم تا به جای <code>Nil</code> به <code>b</code> اشاره کند، و یک چرخه ایجاد می‌کنیم.
این کار را با استفاده از متد <code>tail</code> انجام می‌دهیم تا یک ارجاع به <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>
در <code>a</code> بگیریم، که آن را در متغیر <code>link</code> قرار می‌دهیم. سپس از متد <code>borrow_mut</code>
روی <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> استفاده می‌کنیم تا مقدار داخلی را از یک <code>Rc&lt;List&gt;</code> که
مقدار <code>Nil</code> را نگه می‌دارد به <code>Rc&lt;List&gt;</code> در <code>b</code> تغییر دهیم.</p>
<p>وقتی این کد را اجرا می‌کنیم و <code>println!</code> آخر را به طور موقت کامنت می‌کنیم، خروجی زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>تعداد رفرنس‌های نمونه‌های <code>Rc&lt;List&gt;</code> در هر دو متغیر <code>a</code> و <code>b</code> پس از آن‌که لیست در <code>a</code> را طوری تغییر می‌دهیم که به <code>b</code> اشاره کند، برابر با ۲ خواهد شد. در پایان تابع <code>main</code>، Rust متغیر <code>b</code> را حذف می‌کند، که شمارنده‌ی رفرنس نمونه‌ی <code>Rc&lt;List&gt;</code> مربوط به <code>b</code> را از ۲ به ۱ کاهش می‌دهد. حافظه‌ای که <code>Rc&lt;List&gt;</code> در heap نگه می‌دارد در این لحظه آزاد نخواهد شد، چون شمارنده‌ی رفرنس آن هنوز ۱ است، نه صفر. سپس Rust متغیر <code>a</code> را حذف می‌کند، که شمارنده‌ی رفرنس نمونه‌ی <code>Rc&lt;List&gt;</code> مربوط به <code>a</code> را نیز از ۲ به ۱ کاهش می‌دهد. حافظه‌ی این نمونه نیز نمی‌تواند آزاد شود، زیرا نمونه‌ی دیگر از <code>Rc&lt;List&gt;</code> هنوز به آن اشاره دارد. در نتیجه، حافظه‌ای که به این لیست اختصاص داده شده است، برای همیشه آزاد نخواهد شد.</p>
<p>برای تصویرسازی این چرخه‌ی رفرنس، دیاگرام زیر را در شکل 15-4 ایجاد کرده‌ایم:</p>
<img alt="مستطیلی با برچسب 'a' که به مستطیلی شامل عدد صحیح 5 اشاره می‌کند. مستطیلی با برچسب 'b' که به مستطیلی شامل عدد صحیح 10 اشاره می‌کند. مستطیل حاوی عدد 5 به مستطیل حاوی عدد 10 اشاره دارد، و مستطیل حاوی عدد 10 دوباره به مستطیل حاوی عدد 5 اشاره دارد، و این یک چرخه ایجاد می‌کند" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">شکل 15-4: یک چرخه ارجاعی از لیست‌های <code>a</code> و <code>b</code> که به یکدیگر اشاره می‌کنند</span></p>
<p>اگر آخرین <code>println!</code> را از حالت کامنت خارج کرده و برنامه را اجرا کنید، Rust تلاش خواهد کرد این چرخه را چاپ کند؛ چرخه‌ای که در آن <code>a</code> به <code>b</code> اشاره می‌کند، <code>b</code> به <code>a</code> و دوباره <code>a</code> به <code>b</code> و همین‌طور ادامه پیدا می‌کند تا جایی که پشته (stack) پر شده و <em>stack overflow</em> رخ می‌دهد.</p>
<p>در مقایسه با یک برنامه واقعی، عواقب ایجاد چرخه ارجاعی در این مثال چندان وخیم نیست: درست بعد از اینکه چرخه ارجاعی ایجاد می‌شود، برنامه پایان می‌یابد. با این حال، اگر یک برنامه پیچیده‌تر مقدار زیادی حافظه در یک چرخه تخصیص دهد و برای مدت طولانی آن را نگه دارد، برنامه بیشتر از حافظه‌ای که نیاز دارد استفاده خواهد کرد و ممکن است سیستم را از حافظه موجود تخلیه کند.</p>
<p>ایجاد چرخه‌های ارجاعی کار آسانی نیست، اما غیرممکن هم نیست. اگر مقادیر <code>RefCell&lt;T&gt;</code> داشته باشید که مقادیر <code>Rc&lt;T&gt;</code> یا ترکیبات مشابهی از انواع با تغییرپذیری داخلی و شمارش ارجاع را در خود جای دهند، باید مطمئن شوید که چرخه‌ای ایجاد نمی‌کنید؛ نمی‌توانید به راست اعتماد کنید که آن‌ها را شناسایی کند. ایجاد چرخه ارجاعی یک اشکال منطقی در برنامه شما خواهد بود که باید با استفاده از تست‌های خودکار، بررسی کد، و دیگر شیوه‌های توسعه نرم‌افزار، آن را به حداقل برسانید.</p>
<p>یک راه‌حل دیگر برای جلوگیری از چرخه‌های ارجاعی، بازسازی ساختار داده‌هایتان است به‌طوری که برخی ارجاعات بیانگر مالکیت باشند و برخی نباشند. به این ترتیب، می‌توانید چرخه‌هایی داشته باشید که شامل برخی روابط مالکیت و برخی روابط غیرمالکیت هستند، و تنها روابط مالکیت تعیین می‌کنند که آیا یک مقدار می‌تواند حذف شود یا خیر. در فهرست 15-25، ما همیشه می‌خواهیم که متغیرهای <code>Cons</code> مالک لیست‌هایشان باشند، بنابراین بازسازی ساختار داده امکان‌پذیر نیست. بیایید به یک مثال با استفاده از گراف‌ها که شامل گره‌های والد و فرزند هستند نگاه کنیم تا ببینیم چه زمانی روابط غیرمالکیت یک راه مناسب برای جلوگیری از چرخه‌های ارجاعی هستند.</p>
<!-- Old link, do not remove -->
<p><a id="preventing-reference-cycles-turning-an-rct-into-a-weakt"></a></p>
<h3 id="جلوگیری-از-چرخههای-رفرنس-با-استفاده-از-weakt"><a class="header" href="#جلوگیری-از-چرخههای-رفرنس-با-استفاده-از-weakt">جلوگیری از چرخه‌های رفرنس با استفاده از <code>Weak&lt;T&gt;</code></a></h3>
<p>تا این‌جا نشان دادیم که فراخوانی <code>Rc::clone</code> شمارنده‌ی <code>strong_count</code> یک نمونه‌ی <code>Rc&lt;T&gt;</code> را افزایش می‌دهد، و یک نمونه‌ی <code>Rc&lt;T&gt;</code> تنها زمانی پاک‌سازی می‌شود که مقدار <code>strong_count</code> آن برابر با صفر باشد. همچنین می‌توانید با فراخوانی <code>Rc::downgrade</code> و ارسال یک رفرنس به <code>Rc&lt;T&gt;</code>، یک <em>رفرنس ضعیف</em> (weak reference) به مقدار درون یک نمونه‌ی <code>Rc&lt;T&gt;</code> ایجاد کنید.</p>
<p><em>رفرنس‌های قوی</em> (strong references) روشی برای به‌اشتراک‌گذاری مالکیت یک نمونه‌ی <code>Rc&lt;T&gt;</code> هستند. در مقابل، <em>رفرنس‌های ضعیف</em> رابطه‌ی مالکیتی ایجاد نمی‌کنند، و شمارش آن‌ها (weak count) هیچ تأثیری در زمان پاک‌سازی یک نمونه‌ی <code>Rc&lt;T&gt;</code> ندارد. آن‌ها باعث ایجاد چرخه‌ی رفرنس نمی‌شوند، زیرا هر چرخه‌ای که شامل برخی <code>weak reference</code> باشد، زمانی شکسته می‌شود که شمارنده‌ی قوی (<code>strong_count</code>) مقادیر درگیر در آن چرخه به صفر برسد.</p>
<p>وقتی <code>Rc::downgrade</code> را فراخوانی می‌کنید، یک اسمارت پوینتر از نوع <code>Weak&lt;T&gt;</code> دریافت می‌کنید. به جای افزایش شمارش <code>strong_count</code> در نمونه <code>Rc&lt;T&gt;</code> به مقدار 1، فراخوانی <code>Rc::downgrade</code> شمارش <code>weak_count</code> را به مقدار 1 افزایش می‌دهد. نوع <code>Rc&lt;T&gt;</code> از <code>weak_count</code> برای پیگیری تعداد ارجاعات <code>Weak&lt;T&gt;</code> موجود استفاده می‌کند، مشابه <code>strong_count</code>. تفاوت این است که شمارش <code>weak_count</code> نیازی به 0 بودن برای پاک‌سازی نمونه <code>Rc&lt;T&gt;</code> ندارد.</p>
<p>از آن‌جا که مقداری که یک <code>Weak&lt;T&gt;</code> به آن اشاره می‌کند ممکن است پیش از این پاک شده باشد، برای انجام هر کاری با آن مقدار ابتدا باید مطمئن شوید که هنوز وجود دارد. برای این کار، متد <code>upgrade</code> را روی یک نمونه‌ی <code>Weak&lt;T&gt;</code> فراخوانی می‌کنید؛ این متد یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> بازمی‌گرداند. اگر مقدار <code>Rc&lt;T&gt;</code> هنوز پاک نشده باشد، نتیجه‌ی <code>Some</code> دریافت خواهید کرد؛ و اگر مقدار <code>Rc&lt;T&gt;</code> قبلاً پاک شده باشد، نتیجه‌ی <code>None</code> خواهد بود.
از آن‌جا که <code>upgrade</code> یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> برمی‌گرداند، Rust شما را ملزم می‌کند که هر دو حالت <code>Some</code> و <code>None</code> را مدیریت کنید، و در نتیجه از بروز اشاره‌گر نامعتبر جلوگیری می‌شود.</p>
<p>برای مثال، به جای استفاده از یک لیست که آیتم‌های آن فقط درباره آیتم بعدی اطلاع دارند،
ما یک درخت ایجاد خواهیم کرد که آیتم‌های آن درباره آیتم‌های فرزند <em>و</em> والد خود اطلاع دارند.</p>
<h4 id="ایجاد-یک-ساختار-دادهی-درختی-یک-node-با-گرههای-فرزند-child-nodes"><a class="header" href="#ایجاد-یک-ساختار-دادهی-درختی-یک-node-با-گرههای-فرزند-child-nodes">ایجاد یک ساختار داده‌ی درختی: یک <code>Node</code> با گره‌های فرزند (Child Nodes)</a></h4>
<p>برای شروع، ما یک درخت با گره‌هایی ایجاد خواهیم کرد که درباره گره‌های فرزند خود اطلاع
دارند. ما یک ساختار به نام <code>Node</code> ایجاد خواهیم کرد که مقدار <code>i32</code> خود را نگه می‌دارد
و همچنین به گره‌های فرزند خود ارجاع می‌دهد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>ما می‌خواهیم که یک <code>Node</code> مالک فرزندان خود باشد و همچنین می‌خواهیم که این مالکیت با
متغیرها به اشتراک گذاشته شود تا بتوانیم مستقیماً به هر <code>Node</code> در درخت دسترسی داشته
باشیم. برای انجام این کار، آیتم‌های <code>Vec&lt;T&gt;</code> را به عنوان مقادیری از نوع <code>Rc&lt;Node&gt;</code>
تعریف می‌کنیم. همچنین می‌خواهیم تغییر دهیم که کدام گره‌ها فرزندان یک گره دیگر باشند،
بنابراین در <code>children</code> یک <code>RefCell&lt;T&gt;</code> در اطراف <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> قرار می‌دهیم.</p>
<p>در ادامه، از تعریف <code>struct</code> خود استفاده می‌کنیم و یک نمونه از <code>Node</code> با نام <code>leaf</code> ایجاد می‌کنیم که مقدار آن <code>3</code> است و هیچ فرزندی ندارد، و یک نمونه‌ی دیگر با نام <code>branch</code> می‌سازیم که مقدار آن <code>5</code> است و <code>leaf</code> را به‌عنوان یکی از فرزندان خود دارد؛ همان‌طور که در لیستینگ 15-27 نشان داده شده است.</p>
<figure class="listing" id="listing-15-27">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<figcaption><a href="#listing-15-27">Listing 15-27</a>: ایجاد یک گره <code>leaf</code> بدون فرزند و یک گره <code>branch</code> با <code>leaf</code> به عنوان یکی از فرزندان آن</figcaption>
</figure>
<p>ما <code>Rc&lt;Node&gt;</code> را در <code>leaf</code> کلون می‌کنیم و آن را در <code>branch</code> ذخیره می‌کنیم، به این
معنی که <code>Node</code> در <code>leaf</code> اکنون دو مالک دارد: <code>leaf</code> و <code>branch</code>. ما می‌توانیم از
<code>branch</code> به <code>leaf</code> از طریق <code>branch.children</code> برسیم، اما هیچ راهی برای رفتن از
<code>leaf</code> به <code>branch</code> وجود ندارد. دلیل این است که <code>leaf</code> هیچ ارجاعی به <code>branch</code>
ندارد و نمی‌داند که آن‌ها مرتبط هستند. ما می‌خواهیم که <code>leaf</code> بداند که <code>branch</code>
والد آن است. این کار را در مرحله بعد انجام خواهیم داد.</p>
<h4 id="افزودن-یک-ارجاع-از-فرزند-به-والد"><a class="header" href="#افزودن-یک-ارجاع-از-فرزند-به-والد">افزودن یک ارجاع از فرزند به والد</a></h4>
<p>برای آگاه کردن گره فرزند از والدش، باید یک فیلد <code>parent</code> به تعریف ساختار <code>Node</code> خود اضافه کنیم. مشکل در تصمیم‌گیری در مورد نوع <code>parent</code> است. می‌دانیم که نمی‌تواند شامل یک <code>Rc&lt;T&gt;</code> باشد، زیرا این امر باعث ایجاد چرخه ارجاعی می‌شود که در آن <code>leaf.parent</code> به <code>branch</code> اشاره می‌کند و <code>branch.children</code> به <code>leaf</code>، که باعث می‌شود مقادیر <code>strong_count</code> آن‌ها هرگز به 0 نرسد.</p>
<p>با در نظر گرفتن روابط از دیدگاهی دیگر، یک گره والد باید مالک فرزندان خود باشد: اگر یک گره والد حذف شود، گره‌های فرزند آن نیز باید حذف شوند. اما، یک فرزند نباید مالک والدش باشد: اگر یک گره فرزند حذف شود، والد باید همچنان وجود داشته باشد. این مورد برای استفاده از ارجاعات ضعیف (weak references) مناسب است!</p>
<p>بنابراین، به جای <code>Rc&lt;T&gt;</code>، نوع <code>parent</code> را از نوع <code>Weak&lt;T&gt;</code> انتخاب می‌کنیم، به طور خاص یک <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. اکنون تعریف ساختار <code>Node</code> ما به این شکل است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>یک گره باید بتواند به گره والد خود اشاره کند، اما مالک آن نباشد.
در لیستینگ 15-28، تابع <code>main</code> را به‌روزرسانی می‌کنیم تا از این تعریف جدید استفاده کند و گره <code>leaf</code> بتواند به گره والد خود، یعنی <code>branch</code>، اشاره کند.</p>
<figure class="listing" id="listing-15-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<figcaption><a href="#listing-15-28">Listing 15-28</a>: یک گره <code>leaf</code> با یک رفرنس ضعیف به گره والدش، <code>branch</code></figcaption>
</figure>
<p>ایجاد گره <code>leaf</code> مشابه فهرست 15-27 است با این تفاوت که فیلد <code>parent</code>: <code>leaf</code> ابتدا بدون والد شروع می‌شود، بنابراین یک نمونه جدید و خالی از ارجاع <code>Weak&lt;Node&gt;</code> ایجاد می‌کنیم.</p>
<p>در این مرحله، وقتی سعی می‌کنیم با استفاده از متد <code>upgrade</code> به والد گره <code>leaf</code> دسترسی پیدا کنیم، یک مقدار <code>None</code> دریافت می‌کنیم. این مورد را در خروجی اولین دستور <code>println!</code> مشاهده می‌کنیم:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>زمانی که گره <code>branch</code> را ایجاد می‌کنیم، این گره در فیلد <code>parent</code> خود دارای یک رفرنس جدید از نوع <code>Weak&lt;Node&gt;</code> خواهد بود، زیرا <code>branch</code> هیچ گره والد ندارد. همچنان <code>leaf</code> یکی از فرزندان <code>branch</code> است. پس از آن‌که نمونه‌ی <code>Node</code> را در <code>branch</code> ساختیم، می‌توانیم گره <code>leaf</code> را طوری تغییر دهیم که یک رفرنس <code>Weak&lt;Node&gt;</code> به والد خود داشته باشد.
برای این کار، از متد <code>borrow_mut</code> روی <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> موجود در فیلد <code>parent</code> در <code>leaf</code> استفاده می‌کنیم، و سپس با استفاده از تابع <code>Rc::downgrade</code> یک رفرنس <code>Weak&lt;Node&gt;</code> به <code>branch</code> می‌سازیم که از <code>Rc&lt;Node&gt;</code> موجود در <code>branch</code> ساخته شده است.</p>
<p>وقتی والد گره <code>leaf</code> را دوباره چاپ می‌کنیم، این بار یک متغیر <code>Some</code> که <code>branch</code> را
نگه می‌دارد دریافت می‌کنیم: اکنون <code>leaf</code> می‌تواند به والد خود دسترسی پیدا کند!
هنگامی که <code>leaf</code> را چاپ می‌کنیم، همچنین از چرخه‌ای که نهایتاً به سرریز شدن استک
مانند فهرست 15-26 منجر می‌شد اجتناب می‌کنیم؛ ارجاعات <code>Weak&lt;Node&gt;</code> به‌صورت <code>(Weak)</code>
چاپ می‌شوند:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>نبود خروجی بی‌نهایت نشان می‌دهد که این کد چرخه ارجاعی ایجاد نکرده است. همچنین می‌توانیم
این را با مشاهده مقادیری که از فراخوانی <code>Rc::strong_count</code> و <code>Rc::weak_count</code>
دریافت می‌کنیم، تأیید کنیم.</p>
<h4 id="تجسم-تغییرات-در-strong_count-و-weak_count"><a class="header" href="#تجسم-تغییرات-در-strong_count-و-weak_count">تجسم تغییرات در <code>strong_count</code> و <code>weak_count</code></a></h4>
<p>بیایید بررسی کنیم که چگونه مقادیر <code>strong_count</code> و <code>weak_count</code> در نمونه‌های <code>Rc&lt;Node&gt;</code> تغییر می‌کنند؛ برای این کار، یک بلاک داخلی جدید ایجاد می‌کنیم و ساخت گره <code>branch</code> را به درون این بلاک منتقل می‌کنیم. با این کار می‌توانیم مشاهده کنیم که چه اتفاقی می‌افتد زمانی که <code>branch</code> ایجاد می‌شود و سپس پس از خارج شدن از حوزه‌ی دید (scope) حذف می‌گردد. این تغییرات در لیستینگ 15-29 نشان داده شده‌اند.</p>
<figure class="listing" id="listing-15-29">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<figcaption><a href="#listing-15-29">Listing 15-29</a>: ایجاد <code>branch</code> در یک دامنه داخلی و بررسی شمارش ارجاعات قوی و ضعیف</figcaption>
</figure>
<p>پس از ایجاد <code>leaf</code>، مقدار <code>strong_count</code> برای <code>Rc&lt;Node&gt;</code> آن برابر با ۱ و مقدار <code>weak_count</code> برابر با ۰ است. در بلاک داخلی، گره‌ی <code>branch</code> را ایجاد می‌کنیم و آن را به <code>leaf</code> مرتبط می‌سازیم؛ در این مرحله وقتی شمارنده‌ها را چاپ کنیم، <code>Rc&lt;Node&gt;</code> مربوط به <code>branch</code> دارای <code>strong_count</code> برابر با ۱ و <code>weak_count</code> برابر با ۱ خواهد بود (به‌خاطر اینکه <code>leaf.parent</code> به <code>branch</code> با یک <code>Weak&lt;Node&gt;</code> اشاره می‌کند). همچنین وقتی شمارنده‌ها را در <code>leaf</code> چاپ کنیم، مشاهده خواهیم کرد که <code>strong_count</code> آن برابر با ۲ است، زیرا <code>branch</code> اکنون یک کلون از <code>Rc&lt;Node&gt;</code> مربوط به <code>leaf</code> را در <code>branch.children</code> نگه می‌دارد، اما مقدار <code>weak_count</code> آن همچنان ۰ باقی می‌ماند.</p>
<p>وقتی دامنه داخلی به پایان می‌رسد، <code>branch</code> از دامنه خارج می‌شود و شمارش قوی
<code>Rc&lt;Node&gt;</code> به 0 کاهش می‌یابد، بنابراین <code>Node</code> آن حذف می‌شود. شمارش ضعیف 1 از
<code>leaf.parent</code> تأثیری بر اینکه آیا <code>Node</code> حذف می‌شود ندارد، بنابراین هیچ نشت
حافظه‌ای نخواهیم داشت!</p>
<p>اگر بعد از پایان بلاک (scope) تلاش کنیم به والد <code>leaf</code> دسترسی پیدا کنیم، دوباره مقدار <code>None</code> دریافت خواهیم کرد. در انتهای برنامه، مقدار <code>strong_count</code> برای <code>Rc&lt;Node&gt;</code> در <code>leaf</code> برابر با ۱ و مقدار <code>weak_count</code> برابر با ۰ خواهد بود، زیرا متغیر <code>leaf</code> اکنون تنها رفرنس به آن <code>Rc&lt;Node&gt;</code> است.</p>
<p>تمام منطق مدیریت شمارش‌ها و حذف مقدار درون <code>Rc&lt;T&gt;</code> و <code>Weak&lt;T&gt;</code> و پیاده‌سازی‌های
ویژگی <code>Drop</code> آن‌ها تعبیه شده است. با مشخص کردن اینکه رابطه از یک فرزند به والد
آن باید یک ارجاع <code>Weak&lt;T&gt;</code> باشد در تعریف <code>Node</code>، می‌توانید گره‌های والد را
به گره‌های فرزند و بالعکس ارجاع دهید بدون ایجاد یک چرخه ارجاعی و نشت حافظه.</p>
<h2 id="خلاصه"><a class="header" href="#خلاصه">خلاصه</a></h2>
<p>این فصل نحوه استفاده از اسمارت پوینترها برای ارائه تضمین‌ها و مبادلات متفاوت
از آنچه که راست به طور پیش‌فرض با ارجاع‌های معمولی ارائه می‌دهد را پوشش داد.
نوع <code>Box&lt;T&gt;</code> دارای اندازه مشخصی است و به داده‌های تخصیص‌یافته در heap اشاره می‌کند.
نوع <code>Rc&lt;T&gt;</code> تعداد ارجاع‌ها به داده‌ها در heap را پیگیری می‌کند تا داده‌ها بتوانند
چندین مالک داشته باشند. نوع <code>RefCell&lt;T&gt;</code> با تغییرپذیری داخلی خود به ما نوعی
می‌دهد که می‌توانیم زمانی که به یک نوع غیرقابل‌تغییر نیاز داریم اما باید مقدار
درونی آن نوع را تغییر دهیم، استفاده کنیم؛ همچنین قوانین وام‌دهی را در زمان اجرا
به جای زمان کامپایل اعمال می‌کند.</p>
<p>همچنین، ویژگی‌های <code>Deref</code> و <code>Drop</code> که بسیاری از قابلیت‌های اسمارت پوینترها را
ممکن می‌سازند، مورد بحث قرار گرفتند. ما چرخه‌های ارجاعی که می‌توانند باعث
نشت حافظه شوند و نحوه جلوگیری از آن‌ها با استفاده از <code>Weak&lt;T&gt;</code> را بررسی کردیم.</p>
<p>اگر این فصل علاقه شما را برانگیخته و می‌خواهید اسمارت پوینترهای خود را پیاده‌سازی
کنید، به <a href="../nomicon/index.html">“The Rustonomicon”</a> برای اطلاعات مفید بیشتر مراجعه کنید.</p>
<p>در فصل بعدی، درباره همزمانی (concurrency) در راست صحبت خواهیم کرد. حتی با
چند اسمارت پوینتر جدید نیز آشنا خواهید شد.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
