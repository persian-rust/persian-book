<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>منتشر کردن یک crate در Crates.io - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="انتشار-یک-crate-در-cratesio"><a class="header" href="#انتشار-یک-crate-در-cratesio">انتشار یک Crate در Crates.io</a></h2>
<p>ما از پکیج‌های موجود در <a href="https://crates.io/">crates.io</a><!-- ignore --> به عنوان وابستگی‌های پروژه خود استفاده کرده‌ایم، اما شما همچنین می‌توانید کد خود را با دیگران به اشتراک بگذارید با انتشار پکیج‌های خودتان. رجیستری Crates.io کد منبع پکیج‌های شما را توزیع می‌کند، بنابراین به طور عمده میزبان کدهای منبع باز است.</p>
<p>Rust و Cargo ویژگی‌هایی دارند که باعث می‌شود پکیج منتشرشده شما برای دیگران راحت‌تر پیدا شده و استفاده شود. ما ابتدا درباره برخی از این ویژگی‌ها صحبت می‌کنیم و سپس توضیح می‌دهیم چگونه یک پکیج منتشر کنیم.</p>
<h3 id="ایجاد-نظرات-مستندات-مفید"><a class="header" href="#ایجاد-نظرات-مستندات-مفید">ایجاد نظرات مستندات مفید</a></h3>
<p>مستندسازی دقیق پکیج‌های شما به دیگر کاربران کمک می‌کند بدانند چگونه و چه زمانی از آن‌ها استفاده کنند، بنابراین ارزش دارد که وقت خود را برای نوشتن مستندات صرف کنید. در فصل 3، نحوه اضافه کردن نظرات به کد Rust با استفاده از دو اسلش <code>//</code> را بررسی کردیم. Rust همچنین نوع خاصی از نظرات برای مستندات دارد که به نام <em>نظرات مستندات</em> شناخته می‌شود و مستندات HTML تولید می‌کند. این مستندات HTML محتوای نظرات مستندات را برای آیتم‌های عمومی API نمایش می‌دهد که برای برنامه‌نویسانی که به دنبال دانستن چگونگی <em>استفاده از</em> crate شما هستند، طراحی شده است و نه چگونگی <em>پیاده‌سازی</em> crate شما.</p>
<p>نظرات مستندات به جای دو اسلش از سه اسلش <code>///</code> استفاده می‌کنند و از نشانه‌گذاری Markdown برای قالب‌بندی متن پشتیبانی می‌کنند. نظرات مستندات را درست قبل از آیتمی که قرار است مستندسازی شود قرار دهید. لیستینگ 14-1 نظرات مستندات برای یک تابع <code>add_one</code> در یک crate به نام <code>my_crate</code> را نشان می‌دهد.</p>
<figure class="listing" id="listing-14-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<figcaption><a href="#listing-14-1">Listing 14-1</a>: یک نظر مستند برای یک تابع</figcaption>
</figure>
<p>اینجا، ما توضیحی درباره عملکرد تابع <code>add_one</code> می‌دهیم، بخشی با عنوان <code>Examples</code> شروع می‌کنیم، و سپس کدی که نشان می‌دهد چگونه از تابع <code>add_one</code> استفاده کنیم ارائه می‌دهیم. می‌توانیم مستندات HTML را از این نظر مستند با اجرای دستور <code>cargo doc</code> تولید کنیم. این دستور ابزار <code>rustdoc</code> که با Rust توزیع شده را اجرا می‌کند و مستندات HTML تولیدشده را در دایرکتوری <em>target/doc</em> قرار می‌دهد.</p>
<h1 id="head"><a class="header" href="#head">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>برای راحتی، اجرای دستور <code>cargo doc --open</code> مستندات HTML را برای crate فعلی شما (و همچنین مستندات همه وابستگی‌های crate شما) می‌سازد و نتیجه را در مرورگر وب باز می‌کند. به تابع <code>add_one</code> بروید و خواهید دید که چگونه متن موجود در نظرات مستندات نمایش داده می‌شود، همانطور که در شکل 14-1 نشان داده شده است:</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<img alt="مستندات HTML تولیدشده برای تابع `add_one` از `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">شکل 14-1: مستندات HTML برای تابع <code>add_one</code></span></p>
<h4 id="بخشهای-متداول-مورد-استفاده"><a class="header" href="#بخشهای-متداول-مورد-استفاده">بخش‌های متداول مورد استفاده</a></h4>
<p>ما در لیستینگ 14-1 از عنوان Markdown <code># Examples</code> برای ایجاد یک بخش در HTML با عنوان “Examples” استفاده کردیم. در اینجا برخی دیگر از بخش‌هایی که نویسندگان crate معمولاً در مستندات خود استفاده می‌کنند آورده شده است:</p>
<ul>
<li><strong>Panics</strong>: سناریوهایی که در آن ممکن است تابع مستند شده باعث ایجاد panic شود. فراخوانان تابع که نمی‌خواهند برنامه‌هایشان panic کنند باید مطمئن شوند که تابع را در این شرایط فراخوانی نمی‌کنند.</li>
<li><strong>Errors</strong>: اگر تابع یک مقدار <code>Result</code> بازگرداند، توضیح انواع خطاهایی که ممکن است رخ دهد و شرایطی که ممکن است این خطاها را ایجاد کند، برای فراخوانان مفید است تا بتوانند کدهایی برای مدیریت انواع مختلف خطاها بنویسند.</li>
<li><strong>Safety</strong>: اگر تابع <code>unsafe</code> برای فراخوانی باشد (ما عدم ایمنی را در فصل 20 بررسی خواهیم کرد)، باید بخشی توضیح دهد که چرا تابع ناامن است و اصولی را که تابع از فراخوانان انتظار دارد رعایت کنند پوشش دهد.</li>
</ul>
<p>بیشتر نظرات مستندات به همه این بخش‌ها نیاز ندارند، اما این یک چک‌لیست خوب برای یادآوری جنبه‌هایی از کد شما است که کاربران علاقه‌مند به دانستن آن هستند.</p>
<h4 id="نظرات-مستندات-به-عنوان-تست"><a class="header" href="#نظرات-مستندات-به-عنوان-تست">نظرات مستندات به عنوان تست</a></h4>
<h1 id="head-1"><a class="header" href="#head-1">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>اضافه کردن بلوک‌های کد مثال به نظرات مستندات شما می‌تواند به نمایش نحوه استفاده از کتابخانه شما کمک کند، و انجام این کار یک مزیت اضافی دارد: اجرای دستور <code>cargo test</code>، مثال‌های کد در مستندات شما را به عنوان تست اجرا خواهد کرد! هیچ چیزی بهتر از مستندات با مثال نیست. اما هیچ چیزی بدتر از مثال‌هایی نیست که کار نمی‌کنند زیرا کد از زمان نوشته شدن مستندات تغییر کرده است. اگر <code>cargo test</code> را با مستندات تابع <code>add_one</code> از لیستینگ 14-1 اجرا کنیم، بخشی در نتایج تست مانند زیر خواهیم دید:</p>
<p>Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running <code>cargo test</code> will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code>
function from Listing 14-1, we will see a section in the test results that looks
like this:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<h1 id="head-2"><a class="header" href="#head-2">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>اکنون، اگر تابع یا مثال را تغییر دهیم به طوری که <code>assert_eq!</code> در مثال باعث panic شود و دوباره <code>cargo test</code> را اجرا کنیم، خواهیم دید که تست‌های مستندات تشخیص می‌دهند که مثال و کد با یکدیگر همگام نیستند!</p>
<p>Now, if we change either the function or the example so the <code>assert_eq!</code> in the
example panics, and run <code>cargo test</code> again, we’ll see that the doc tests catch
that the example and the code are out of sync with each other!</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="مستندسازی-آیتمهای-شامل-شده"><a class="header" href="#مستندسازی-آیتمهای-شامل-شده">مستندسازی آیتم‌های شامل شده</a></h4>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
سبک نظر مستند <code>//!</code> مستندات را به آیتمی که نظرات را شامل می‌شود اضافه می‌کند، به جای آیتم‌هایی که بعد از نظرات قرار دارند. ما معمولاً از این نظرات مستند در فایل اصلی crate (<em>src/lib.rs</em> بر اساس قرارداد) یا در داخل یک ماژول برای مستندسازی کل crate یا ماژول استفاده می‌کنیم.</p>
<h1 id="برای-مثال-برای-اضافه-کردن-مستنداتی-که-هدف-crate-my_crate-را-که-شامل-تابع-add_one-است-توضیح-میدهد-نظرات-مستندی-که-با--شروع-میشوند-را-به-ابتدای-فایل-srclibrs-اضافه-میکنیم-همانطور-که-در-لیستینگ-14-2-نشان-داده-شده-است"><a class="header" href="#برای-مثال-برای-اضافه-کردن-مستنداتی-که-هدف-crate-my_crate-را-که-شامل-تابع-add_one-است-توضیح-میدهد-نظرات-مستندی-که-با--شروع-میشوند-را-به-ابتدای-فایل-srclibrs-اضافه-میکنیم-همانطور-که-در-لیستینگ-14-2-نشان-داده-شده-است">برای مثال، برای اضافه کردن مستنداتی که هدف crate <code>my_crate</code> را که شامل تابع <code>add_one</code> است توضیح می‌دهد، نظرات مستندی که با <code>//!</code> شروع می‌شوند را به ابتدای فایل <em>src/lib.rs</em> اضافه می‌کنیم، همان‌طور که در لیستینگ 14-2 نشان داده شده است:</a></h1>
<p>The style of doc comment <code>//!</code> adds documentation to the item that <em>contains</em>
the comments rather than to the items <em>following</em> the comments. We typically use
these doc comments inside the crate root file (<em>src/lib.rs</em> by convention) or
inside a module to document the crate or the module as a whole.</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code>
crate that contains the <code>add_one</code> function, we add documentation comments that
start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing
14-2.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="listing" id="listing-14-2">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-14-2">Listing 14-2</a>: مستندات برای کل crate <code>my_crate</code></figcaption>
</figure>
<p>توجه داشته باشید که هیچ کدی بعد از آخرین خطی که با <code>//!</code> شروع می‌شود وجود ندارد. چون ما نظرات را با <code>//!</code> شروع کرده‌ایم به جای <code>///</code>، ما در حال مستندسازی آیتمی هستیم که این نظر را شامل می‌شود به جای آیتمی که بعد از این نظر قرار دارد. در این مورد، آن آیتم فایل <em>src/lib.rs</em> است که ریشه crate است. این نظرات کل crate را توضیح می‌دهند.</p>
<h1 id="head-3"><a class="header" href="#head-3">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>وقتی <code>cargo doc --open</code> را اجرا می‌کنیم، این نظرات در صفحه اول مستندات crate <code>my_crate</code> بالای لیست آیتم‌های عمومی در crate نمایش داده می‌شوند، همان‌طور که در شکل 14-2 نشان داده شده است:</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-2.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">شکل 14-2: مستندات تولید شده برای <code>my_crate</code>، شامل توضیحات در مورد کل crate</span></p>
<p>نظرات مستندات داخل آیتم‌ها به ویژه برای توصیف crates و ماژول‌ها مفید هستند. از آن‌ها برای توضیح هدف کلی container استفاده کنید تا به کاربران خود در درک سازمان‌دهی crate کمک کنید.</p>
<h3 id="صادرات-یک-api-عمومی-کارآمد-با-استفاده-از-pub-use"><a class="header" href="#صادرات-یک-api-عمومی-کارآمد-با-استفاده-از-pub-use">صادرات یک API عمومی کارآمد با استفاده از <code>pub use</code></a></h3>
<p>ساختار API عمومی شما یک موضوع مهم هنگام انتشار یک crate است. افرادی که از crate شما استفاده می‌کنند، کمتر از شما با ساختار آن آشنا هستند و ممکن است در یافتن قسمت‌هایی که می‌خواهند استفاده کنند، اگر crate شما دارای یک سلسله‌مراتب ماژول بزرگ باشد، دچار مشکل شوند.</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
در فصل 7، نحوه عمومی کردن آیتم‌ها با استفاده از کلمه کلیدی <code>pub</code> و آوردن آیتم‌ها به یک scope با استفاده از کلمه کلیدی <code>use</code> را پوشش دادیم. با این حال، ساختاری که هنگام توسعه یک crate برای شما منطقی به نظر می‌رسد ممکن است برای کاربران شما چندان مناسب نباشد. ممکن است بخواهید ساختارهای خود را در یک سلسله‌مراتب با چندین سطح سازماندهی کنید، اما سپس افرادی که می‌خواهند از یک نوع تعریف‌شده عمیق در سلسله‌مراتب استفاده کنند ممکن است در پیدا کردن آن نوع دچار مشکل شوند. همچنین ممکن است مجبور شوند به جای <code>use my_crate::UsefulType;</code>، چیزی مانند <code>use my_crate::some_module::another_module::UsefulType;</code> بنویسند که ناخوشایند است.</p>
<p>خبر خوب این است که اگر ساختار <em>برای دیگران راحت نیست</em>، نیازی نیست سازمان‌دهی داخلی خود را دوباره بچینید: به جای آن می‌توانید آیتم‌ها را با استفاده از <code>pub use</code> مجدداً صادر کنید تا یک ساختار عمومی متفاوت از ساختار خصوصی خود ایجاد کنید. صادرات مجدد یک آیتم عمومی در یک مکان را می‌گیرد و آن را در یک مکان دیگر عمومی می‌کند، گویی که در مکان دیگر تعریف شده است.</p>
<h1 id="برای-مثال-فرض-کنید-ما-یک-کتابخانه-به-نام-art-برای-مدلسازی-مفاهیم-هنری-ایجاد-کردهایم-در-این-کتابخانه-دو-ماژول-وجود-دارند-یک-ماژول-kinds-که-شامل-دو-enum-به-نامهای-primarycolor-و-secondarycolor-است-و-یک-ماژول-utils-که-شامل-یک-تابع-به-نام-mix-است-همانطور-که-در-لیستینگ-14-3-نشان-داده-شده-است"><a class="header" href="#برای-مثال-فرض-کنید-ما-یک-کتابخانه-به-نام-art-برای-مدلسازی-مفاهیم-هنری-ایجاد-کردهایم-در-این-کتابخانه-دو-ماژول-وجود-دارند-یک-ماژول-kinds-که-شامل-دو-enum-به-نامهای-primarycolor-و-secondarycolor-است-و-یک-ماژول-utils-که-شامل-یک-تابع-به-نام-mix-است-همانطور-که-در-لیستینگ-14-3-نشان-داده-شده-است">برای مثال، فرض کنید ما یک کتابخانه به نام <code>art</code> برای مدل‌سازی مفاهیم هنری ایجاد کرده‌ایم. در این کتابخانه دو ماژول وجود دارند: یک ماژول <code>kinds</code> که شامل دو enum به نام‌های <code>PrimaryColor</code> و <code>SecondaryColor</code> است و یک ماژول <code>utils</code> که شامل یک تابع به نام <code>mix</code> است، همان‌طور که در لیستینگ 14-3 نشان داده شده است:</a></h1>
<p>In Chapter 7, we covered how to make items public using the <code>pub</code> keyword, and
how to bring items into a scope with the <code>use</code> keyword. However, the structure
that makes sense to you while you’re developing a crate might not be very
convenient for your users. You might want to organize your structs in a
hierarchy containing multiple levels, but then people who want to use a type
you’ve defined deep in the hierarchy might have trouble finding out that type
exists. They might also be annoyed at having to enter <code>use my_crate::some_module::another_module::UsefulType;</code> rather than <code>use my_crate::UsefulType;</code>.</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
from your private structure by using <code>pub use</code>. <em>Re-exporting</em> takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library are two modules: a <code>kinds</code> module containing two enums
named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a
function named <code>mix</code>, as shown in Listing 14-3.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="listing" id="listing-14-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<figcaption><a href="#listing-14-3">Listing 14-3</a>: یک کتابخانه <code>art</code> با آیتم‌هایی که در ماژول‌های <code>kinds</code> و <code>utils</code> سازماندهی شده‌اند</figcaption>
</figure>
<h1 id="head-4"><a class="header" href="#head-4">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>شکل 14-3 نشان می‌دهد که صفحه اول مستندات این crate که توسط <code>cargo doc</code> تولید شده است چگونه به نظر می‌رسد:</p>
<p>Figure 14-3 shows what the front page of the documentation for this crate
generated by <code>cargo doc</code> would look like.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<img alt="مستندات تولید شده برای crate `art` که ماژول‌های `kinds` و `utils` را لیست می‌کند" src="img/trpl14-03.png" class="center" />
<p><span class="caption">شکل 14-3: صفحه اول مستندات crate <code>art</code> که ماژول‌های <code>kinds</code> و <code>utils</code> را لیست می‌کند</span></p>
<p>توجه کنید که انواع <code>PrimaryColor</code> و <code>SecondaryColor</code> در صفحه اول لیست نشده‌اند، و تابع <code>mix</code> نیز لیست نشده است. برای دیدن آن‌ها باید روی <code>kinds</code> و <code>utils</code> کلیک کنیم.</p>
<h1 id="head-5"><a class="header" href="#head-5">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>یک crate دیگر که به این کتابخانه وابسته است نیاز دارد که بیانیه‌های <code>use</code> مشخص کنند که آیتم‌ها را از <code>art</code> به scope می‌آورند، و ساختار ماژول تعریف‌شده کنونی را بیان کنند. لیستینگ 14-4 یک مثال از crate‌ای که آیتم‌های <code>PrimaryColor</code> و <code>mix</code> را از crate <code>art</code> استفاده می‌کند نشان می‌دهد:</p>
<p>Another crate that depends on this library would need <code>use</code> statements that
bring the items from <code>art</code> into scope, specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
<code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="listing" id="listing-14-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<figcaption><a href="#listing-14-4">Listing 14-4</a>: A crate using the <code>art</code> crate’s items with its internal structure exported</figcaption>
</figure>
<p>نویسنده کدی که در لیستینگ 14-4 نشان داده شده و از crate <code>art</code> استفاده می‌کند، مجبور بوده متوجه شود که <code>PrimaryColor</code> در ماژول <code>kinds</code> و <code>mix</code> در ماژول <code>utils</code> قرار دارد. ساختار ماژول crate <code>art</code> بیشتر برای توسعه‌دهندگانی که روی این crate کار می‌کنند مرتبط است تا کسانی که از آن استفاده می‌کنند. ساختار داخلی اطلاعات مفیدی برای کسی که می‌خواهد نحوه استفاده از crate <code>art</code> را بفهمد ارائه نمی‌دهد، بلکه بیشتر باعث سردرگمی می‌شود، زیرا توسعه‌دهندگانی که از آن استفاده می‌کنند باید بفهمند کجا را باید جستجو کنند و نام‌های ماژول را در بیانیه‌های <code>use</code> مشخص کنند.</p>
<h1 id="head-6"><a class="header" href="#head-6">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>برای حذف سازمان‌دهی داخلی از API عمومی، می‌توانیم کد crate <code>art</code> را در لیستینگ 14-3 تغییر دهیم تا بیانیه‌های <code>pub use</code> را برای صادرات مجدد آیتم‌ها در سطح بالا اضافه کنیم، همان‌طور که در لیستینگ 14-5 نشان داده شده است:</p>
<p>To remove the internal organization from the public API, we can modify the
<code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-5.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="listing" id="listing-14-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<figcaption><a href="#listing-14-5">Listing 14-5</a>: افزودن بیانیه‌های <code>pub use</code> برای صادرات مجدد آیتم‌ها</figcaption>
</figure>
<p>مستندات API که <code>cargo doc</code> برای این crate تولید می‌کند اکنون صادرات‌های مجدد را در صفحه اول لیست کرده و به آن‌ها لینک می‌دهد، همان‌طور که در شکل 14-4 نشان داده شده است. این کار پیدا کردن انواع <code>PrimaryColor</code> و <code>SecondaryColor</code> و تابع <code>mix</code> را آسان‌تر می‌کند.</p>
<img alt="مستندات تولیدشده برای crate `art` با صادرات‌های مجدد در صفحه اول" src="img/trpl14-04.png" class="center" />
<p><span class="caption">شکل 14-4: صفحه اول مستندات برای crate <code>art</code> که صادرات‌های مجدد را لیست می‌کند</span></p>
<h1 id="head-7"><a class="header" href="#head-7">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>کاربران crate <code>art</code> همچنان می‌توانند ساختار داخلی را از لیستینگ 14-3 ببینند و استفاده کنند، همان‌طور که در لیستینگ 14-4 نشان داده شده است، یا می‌توانند از ساختار راحت‌تر در لیستینگ 14-5 استفاده کنند، همان‌طور که در لیستینگ 14-6 نشان داده شده است:</p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="listing" id="listing-14-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<figcaption><a href="#listing-14-6">Listing 14-6</a>: یک برنامه که از آیتم‌های صادرات‌شده مجدد crate <code>art</code> استفاده می‌کند</figcaption>
</figure>
<p>در مواردی که ماژول‌های تو در تو زیادی وجود دارند، صادرات مجدد انواع در سطح بالا با <code>pub use</code> می‌تواند تفاوت بزرگی در تجربه افرادی که از crate استفاده می‌کنند ایجاد کند. یکی دیگر از استفاده‌های رایج <code>pub use</code>، صادرات مجدد تعاریف یک وابستگی در crate فعلی برای تبدیل تعاریف آن به بخشی از API عمومی crate شما است.</p>
<p>ایجاد یک ساختار API عمومی مفید بیشتر شبیه یک هنر است تا یک علم، و می‌توانید با آزمون و خطا API‌ای پیدا کنید که بهترین کارکرد را برای کاربران شما داشته باشد. انتخاب <code>pub use</code> به شما انعطاف می‌دهد که چگونه crate خود را به صورت داخلی ساختار دهید و آن ساختار داخلی را از چیزی که به کاربران خود ارائه می‌دهید جدا کنید. به برخی از کدهای crate‌هایی که نصب کرده‌اید نگاهی بیندازید تا ببینید آیا ساختار داخلی آن‌ها با API عمومی آن‌ها تفاوت دارد یا خیر.</p>
<h3 id="تنظیم-یک-حساب-در-cratesio"><a class="header" href="#تنظیم-یک-حساب-در-cratesio">تنظیم یک حساب در Crates.io</a></h3>
<p>قبل از اینکه بتوانید هر crate‌ای را منتشر کنید، نیاز دارید که یک حساب در <a href="https://crates.io/">crates.io</a><!-- ignore --> ایجاد کنید و یک توکن API دریافت کنید. برای این کار، به صفحه اصلی در <a href="https://crates.io/">crates.io</a><!-- ignore --> بروید و از طریق حساب GitHub وارد شوید. (در حال حاضر حساب GitHub یک نیاز است، اما ممکن است سایت در آینده از روش‌های دیگری برای ایجاد حساب پشتیبانی کند.) پس از ورود به سیستم، به تنظیمات حساب خود در <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> بروید و کلید API خود را دریافت کنید. سپس دستور <code>cargo login</code> را اجرا کرده و کلید API خود را وارد کنید، مانند این:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<h1 id="head-8"><a class="header" href="#head-8">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>این دستور Cargo را از توکن API شما مطلع کرده و آن را به صورت محلی در فایل <em>~/.cargo/credentials</em> ذخیره می‌کند. توجه داشته باشید که این توکن یک <em>راز</em> است: آن را با هیچ‌کس دیگری به اشتراک نگذارید. اگر به هر دلیلی این توکن را با کسی به اشتراک گذاشتید، باید آن را لغو کنید و یک توکن جدید در <a href="https://crates.io/">crates.io</a><!-- ignore --> ایجاد کنید.</p>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials.toml</em>. Note that this token is a <em>secret</em>: do not share
it with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on <a href="https://crates.io/">crates.io</a><!-- ignore
-->.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="افزودن-متادیتا-به-یک-crate-جدید"><a class="header" href="#افزودن-متادیتا-به-یک-crate-جدید">افزودن متادیتا به یک Crate جدید</a></h3>
<p>فرض کنید یک crate دارید که می‌خواهید منتشر کنید. قبل از انتشار، نیاز دارید که برخی متادیتا را در بخش <code>[package]</code> فایل <em>Cargo.toml</em> crate خود اضافه کنید.</p>
<p>crate شما باید یک نام منحصر به فرد داشته باشد. در حالی که به صورت محلی روی یک crate کار می‌کنید، می‌توانید هر نامی که دوست دارید برای crate خود انتخاب کنید. با این حال، نام‌های crate در <a href="https://crates.io/">crates.io</a><!-- ignore --> به صورت اولین درخواست‌کننده تخصیص داده می‌شوند. هنگامی که یک نام برای یک crate گرفته شود، هیچ کس دیگری نمی‌تواند یک crate با آن نام منتشر کند. قبل از تلاش برای انتشار یک crate، جستجو کنید که نامی که می‌خواهید استفاده کنید در دسترس است یا خیر. اگر نام استفاده شده باشد، باید یک نام دیگر پیدا کنید و فیلد <code>name</code> را در فایل <em>Cargo.toml</em> در زیر بخش <code>[package]</code> ویرایش کنید تا از نام جدید برای انتشار استفاده کنید، مانند زیر:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<h1 id="head-9"><a class="header" href="#head-9">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>حتی اگر یک نام منحصر به فرد انتخاب کرده باشید، زمانی که <code>cargo publish</code> را برای انتشار crate در این مرحله اجرا کنید، یک هشدار و سپس یک خطا دریافت خواهید کرد:</p>
<p>Even if you’ve chosen a unique name, when you run <code>cargo publish</code> to publish
the crate at this point, you’ll get a warning and then an error:</p>
<!-- manual-regeneration
Create a new package with an unregistered name, making no further modifications
  to the generated package, so it is missing the description and license fields.
cargo publish
copy just the relevant lines below
-->
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
</code></pre>
<h1 id="head-10"><a class="header" href="#head-10">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>این خطا به دلیل این است که شما برخی اطلاعات حیاتی را از دست داده‌اید: یک توضیح و یک مجوز مورد نیاز است تا افراد بدانند crate شما چه کاری انجام می‌دهد و تحت چه شرایطی می‌توانند از آن استفاده کنند. در فایل <em>Cargo.toml</em>، یک توضیح اضافه کنید که فقط یک یا دو جمله باشد، زیرا این توضیح همراه crate شما در نتایج جستجو ظاهر خواهد شد. برای فیلد <code>license</code>، باید یک <em>مقدار شناسگر مجوز</em> ارائه دهید. <a href="http://spdx.org/licenses/">پروژه Software Package Data Exchange (SPDX)</a> لیستی از شناسگرهایی که می‌توانید برای این مقدار استفاده کنید را ارائه می‌دهد. برای مثال، برای مشخص کردن اینکه crate خود را با استفاده از مجوز MIT منتشر کرده‌اید، شناسگر <code>MIT</code> را اضافه کنید:</p>
<p>This results in an error because you’re missing some crucial information: a
description and license are required so people will know what your crate does
and under what terms they can use it. In <em>Cargo.toml</em>, add a description that’s
just a sentence or two, because it will appear with your crate in search
results. For the <code>license</code> field, you need to give a <em>license identifier value</em>.
The <a href="https://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a> lists the
identifiers you can use for this value. For example, to specify that you’ve
licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>اگر می‌خواهید از مجوزی استفاده کنید که در لیست SPDX موجود نیست، باید متن آن مجوز را در یک فایل قرار دهید، فایل را در پروژه خود اضافه کنید و سپس از کلید <code>license-file</code> برای مشخص کردن نام آن فایل به جای استفاده از کلید <code>license</code> استفاده کنید.</p>
<p>راهنمایی درباره اینکه کدام مجوز برای پروژه شما مناسب است، فراتر از محدوده این کتاب است. بسیاری از افراد در جامعه Rust پروژه‌های خود را به همان روشی که Rust مجوز داده است، با استفاده از یک مجوز دوگانه <code>MIT OR Apache-2.0</code> مجوز می‌دهند. این روش نشان می‌دهد که شما می‌توانید چندین شناسه مجوز را با جدا کردن آن‌ها با <code>OR</code> مشخص کنید تا چندین مجوز برای پروژه خود داشته باشید.</p>
<p>با یک نام منحصر به فرد، نسخه، توضیحات، و یک مجوز اضافه شده، فایل <em>Cargo.toml</em> برای یک پروژه آماده انتشار ممکن است به این صورت باشد:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<h1 id="head-11"><a class="header" href="#head-11">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p><a href="https://doc.rust-lang.org/cargo/">مستندات Cargo</a> سایر متادیتاهایی که می‌توانید مشخص کنید تا دیگران بتوانند crate شما را راحت‌تر پیدا کرده و استفاده کنند توضیح می‌دهد.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure that others can discover and use your crate
more easily.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="انتشار-در-cratesio"><a class="header" href="#انتشار-در-cratesio">انتشار در Crates.io</a></h3>
<p>اکنون که یک حساب ایجاد کرده‌اید، توکن API خود را ذخیره کرده‌اید، نامی برای crate خود انتخاب کرده‌اید، و متادیتای مورد نیاز را مشخص کرده‌اید، آماده انتشار هستید! انتشار یک crate نسخه‌ای خاص از آن را در <a href="https://crates.io/">crates.io</a><!-- ignore --> آپلود می‌کند تا دیگران بتوانند از آن استفاده کنند.</p>
<h1 id="head-12"><a class="header" href="#head-12">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>دقت کنید، زیرا انتشار <em>دائمی</em> است. نسخه هرگز نمی‌تواند بازنویسی شود، و کد نمی‌تواند حذف شود. یکی از اهداف اصلی <a href="https://crates.io/">crates.io</a><!-- ignore --> این است که به عنوان یک آرشیو دائمی از کد عمل کند، به طوری که ساخت‌های همه پروژه‌هایی که به crates از <a href="https://crates.io/">crates.io</a><!-- ignore --> وابسته هستند، همچنان کار کنند. اجازه حذف نسخه‌ها تحقق این هدف را غیرممکن می‌کند. با این حال، هیچ محدودیتی برای تعداد نسخه‌های crate که می‌توانید منتشر کنید وجود ندارد.</p>
<p>Be careful, because a publish is <em>permanent</em>. The version can never be
overwritten, and the code cannot be deleted except in certain circumstances.
One major goal of Crates.io is to act as a permanent archive of code so that
builds of all projects that depend on crates from
<a href="https://crates.io/">crates.io</a><!-- ignore --> will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>دستور <code>cargo publish</code> را دوباره اجرا کنید. اکنون باید موفق شود:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
    Packaged 6 files, 1.2KiB (895.0B compressed)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
    Uploaded guessing_game v0.1.0 to registry `crates-io`
note: waiting for `guessing_game v0.1.0` to be available at registry
`crates-io`.
You may press ctrl-c to skip waiting; the crate should be available shortly.
   Published guessing_game v0.1.0 at registry `crates-io`
</code></pre>
<p>تبریک می‌گویم! شما اکنون کد خود را با جامعه Rust به اشتراک گذاشته‌اید و هر کسی می‌تواند به راحتی crate شما را به عنوان یک وابستگی به پروژه خود اضافه کند.</p>
<h3 id="انتشار-نسخه-جدیدی-از-یک-crate-موجود"><a class="header" href="#انتشار-نسخه-جدیدی-از-یک-crate-موجود">انتشار نسخه جدیدی از یک Crate موجود</a></h3>
<h1 id="head-13"><a class="header" href="#head-13">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></h1>
<p>وقتی تغییراتی در crate خود ایجاد کرده‌اید و آماده انتشار یک نسخه جدید هستید، مقدار <code>version</code> مشخص‌شده در فایل <em>Cargo.toml</em> خود را تغییر داده و دوباره منتشر کنید. از <a href="https://semver.org/">قوانین نسخه‌بندی معنایی (Semantic Versioning)</a> استفاده کنید تا تصمیم بگیرید که بر اساس نوع تغییراتی که ایجاد کرده‌اید، چه شماره نسخه‌ای مناسب است. سپس دستور <code>cargo publish</code> را اجرا کنید تا نسخه جدید آپلود شود.</p>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the <a href="https://semver.org/">Semantic Versioning rules</a> to decide what an
appropriate next version number is, based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<!-- لینک قدیمی، حذف نکنید -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="از-رده-خارج-کردن-نسخهها-از-cratesio-با-استفاده-از-cargo-yank"><a class="header" href="#از-رده-خارج-کردن-نسخهها-از-cratesio-با-استفاده-از-cargo-yank">از رده خارج کردن نسخه‌ها از Crates.io با استفاده از <code>cargo yank</code></a></h3>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
اگرچه نمی‌توانید نسخه‌های قبلی یک crate را حذف کنید، می‌توانید از اضافه شدن آن‌ها به عنوان وابستگی جدید در پروژه‌های آینده جلوگیری کنید. این ویژگی زمانی مفید است که یک نسخه از crate به هر دلیلی خراب باشد. در چنین مواردی، Cargo از <em>یَنک کردن</em> (yanking) یک نسخه از crate پشتیبانی می‌کند.</p>
<h1 id="یَنک-کردن-یک-نسخه-باعث-میشود-که-پروژههای-جدید-نتوانند-به-آن-نسخه-وابسته-شوند-در-حالی-که-تمام-پروژههای-موجود-که-به-آن-نسخه-وابسته-هستند-به-کار-خود-ادامه-میدهند-به-طور-خلاصه-یَنک-به-این-معناست-که-تمام-پروژههایی-که-دارای-فایل-cargolock-هستند-شکسته-نخواهند-شد-و-هر-فایل-cargolock-جدیدی-که-تولید-شود-از-نسخه-یَنکشده-استفاده-نخواهد-کرد"><a class="header" href="#یَنک-کردن-یک-نسخه-باعث-میشود-که-پروژههای-جدید-نتوانند-به-آن-نسخه-وابسته-شوند-در-حالی-که-تمام-پروژههای-موجود-که-به-آن-نسخه-وابسته-هستند-به-کار-خود-ادامه-میدهند-به-طور-خلاصه-یَنک-به-این-معناست-که-تمام-پروژههایی-که-دارای-فایل-cargolock-هستند-شکسته-نخواهند-شد-و-هر-فایل-cargolock-جدیدی-که-تولید-شود-از-نسخه-یَنکشده-استفاده-نخواهد-کرد">یَنک کردن یک نسخه باعث می‌شود که پروژه‌های جدید نتوانند به آن نسخه وابسته شوند، در حالی که تمام پروژه‌های موجود که به آن نسخه وابسته هستند به کار خود ادامه می‌دهند. به طور خلاصه، یَنک به این معناست که تمام پروژه‌هایی که دارای فایل <em>Cargo.lock</em> هستند شکسته نخواهند شد و هر فایل <em>Cargo.lock</em> جدیدی که تولید شود از نسخه یَنک‌شده استفاده نخواهد کرد.</a></h1>
<p>Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports yanking a crate version.</p>
<p><em>Yanking</em> a version prevents new projects from depending on that version while
allowing all existing projects that depend on it to continue. Essentially, a
yank means that all projects with a <em>Cargo.lock</em> will not break, and any future
<em>Cargo.lock</em> files generated will not use the yanked version.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>upstream/main</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>برای یَنک کردن یک نسخه از یک crate، در دایرکتوری crate‌ای که قبلاً منتشر کرده‌اید، دستور <code>cargo yank</code> را اجرا کرده و نسخه‌ای که می‌خواهید یَنک کنید را مشخص کنید. به عنوان مثال، اگر ما یک crate به نام <code>guessing_game</code> نسخه 1.0.1 منتشر کرده باشیم و بخواهیم آن را یَنک کنیم، در دایرکتوری پروژه <code>guessing_game</code> این دستور را اجرا می‌کنیم:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>با افزودن گزینه <code>--undo</code> به دستور، می‌توانید یَنک را لغو کرده و به پروژه‌ها اجازه دهید دوباره به آن نسخه وابسته شوند:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>یَنک <em>هیچ کدی را حذف نمی‌کند</em>. به عنوان مثال، نمی‌تواند اطلاعات حساسی که به طور تصادفی آپلود شده‌اند را حذف کند. اگر چنین اتفاقی افتاد، باید فوراً آن اطلاعات حساس را بازنشانی کنید.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch14-01-release-profiles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch14-01-release-profiles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
