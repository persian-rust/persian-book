<!DOCTYPE HTML>
<html lang="fa" class="light" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">زبان برنامه‌نویسی راست</a></li><li class="chapter-item expanded affix "><a href="foreword.html">پیش‌گفتار</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">مقدمه</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> نصب</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> سلام، دنیا!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> سلام، Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> برنامه‌نویسی یک بازی حدس زدن</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> مفاهیم رایج برنامه‌نویسی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> متغیرها و تغییرپذیری</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> انواع داده</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> توابع</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> کامنت‌ها</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> کنترل جریان</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> درک مالکیت</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> مالکیت چیست؟</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ارجاعات و قرض گرفتن</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> نوع Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> استفاده از Structها برای سازماندهی داده‌های مرتبط</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> تعریف و نمونه‌سازی Structها</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> یک برنامه نمونه با استفاده از Structها</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> متد</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> شمارنده‌ها و تطابق الگو</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> تعریف یک Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ساختار جریان کنترل match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> جریان کنترل مختصر با if let و let else</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> مدیریت پروژه‌های در حال رشد با پکیج‌ها، جعبه‌ها (crates)، و ماژول‌ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> پکیج‌ها و جعبه‌ها (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> تعریف ماژول‌ها برای کنترل دامنه و حریم خصوصی</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> مسیرها برای ارجاع به یک آیتم در درخت ماژول</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> وارد کردن مسیرها با کلمه کلیدی use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> جداسازی ماژول‌ها به فایل‌های مختلف</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> مجموعه‌های رایج</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ذخیره لیست مقادیر با بردارها</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ذخیره کلیدها با مقادیر مرتبط در نقشه‌های هش</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> مدیریت خطاها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> خطاهای غیرقابل بازیابی با panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> خطاهای قابل بازیابی با Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> آیا از panic! استفاده کنیم یا نه؟</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> انواع جنریک، صفت‌ها، و طول عمرها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> انواع داده جنریک</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> صفت‌ها: تعریف رفتارهای مشترک</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> اعتبارسنجی ارجاعات با طول عمرها</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> نوشتن تست‌های خودکار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> چگونه تست بنویسیم</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> کنترل نحوه اجرای تست‌ها</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> سازماندهی تست‌ها</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> یک پروژه I/O: ساخت یک برنامه خط فرمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> پذیرش آرگومان‌های خط فرمان</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> خواندن یک فایل</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> بازسازی برای بهبود ماژولاریت و مدیریت خطا</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> کار با متغیرهای محیطی</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> نوشتن پیام‌های خطا به خروجی خطا به جای خروجی استاندارد</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> ویژگی‌های زبان‌های تابعی: Iteratorها و Closureها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closureها: توابع ناشناخته که محیط خود را می‌گیرند</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> پردازش یک سری آیتم با Iteratorها</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> بهبود پروژه I/O ما</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> مقایسه عملکرد: حلقه‌ها در مقابل Iteratorها</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> بیشتر درباره Cargo و Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> سفارشی‌سازی بیلدها با پروفایل‌های انتشار</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> منتشر کردن یک crate در Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> محیط‌های کاری Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> نصب باینری‌ها از Crates.io با cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> گسترش Cargo با دستورات سفارشی</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> اشاره‌گر (Pointer)های هوشمند</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> استفاده از Box&lt;T&gt; برای اشاره به داده‌ها در Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با صفت Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> اجرای کد هنگام پاک‌سازی با صفت Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;، اشاره‌گر (Pointer) هوشمند با شمارش ارجاعات</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; و الگوی تغییرپذیری داخلی</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> چرخه‌های ارجاع می‌توانند باعث نشت حافظه شوند</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> همزمانی بدون ترس</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> استفاده از نخ‌ها برای اجرای همزمان کد</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> همزمانی با وضعیت مشترک</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> همزمانی قابل گسترش با صفت‌های Sync و Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async و Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures و نحو Async</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html"><strong aria-hidden="true">17.2.</strong> همزمانی با Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> کار با تعداد دلخواهی از Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-streams.html"><strong aria-hidden="true">17.4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-05-traits-for-async.html"><strong aria-hidden="true">17.5.</strong> بررسی عمیق صفت‌ها برای Async</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures، Tasks، و Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> ویژگی‌های برنامه‌نویسی شی‌گرا در Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> ویژگی‌های زبان‌های شی‌گرا</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> استفاده از صفت‌های شی‌گرا برای مقادیر از تایپ‌های مختلف</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> پیاده‌سازی یک الگوی طراحی شی‌گرا</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> الگوها و تطبیق</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> تمام مکان‌هایی که می‌توان از الگوها استفاده کرد</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> قابلیت رد: آیا ممکن است یک الگو با مقدار مطابقت نداشته باشد؟</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> نحو الگوها</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> ویژگی‌های پیشرفته</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Rust ناایمن</a></li><li class="chapter-item expanded "><a href="ch20-02-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> Traits پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-types.html"><strong aria-hidden="true">20.3.</strong> تایپ‌های پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> توابع و Closures پیشرفته</a></li><li class="chapter-item expanded "><a href="ch20-05-macros.html"><strong aria-hidden="true">20.5.</strong> ماکروها</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> پروژه نهایی: ساخت یک وب‌سرور چندنخی</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> ساخت یک وب‌سرور single-threaded</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> تبدیل وب‌سرور تک‌نخی به وب‌سرور چندنخی</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> خاموشی ملایم و پاک‌سازی</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> ضمیمه</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> الف - کلمات کلیدی</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> ب - عملگرها و نمادها</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> ج - صفت‌های قابل اشتقاق</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> د - ابزارهای توسعه مفید</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> ه - نسخه‌ها</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> و - ترجمه‌های کتاب</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> ی - چگونه Rust ساخته می‌شود و "Nightly Rust"</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="زبان-برنامهنویسی-راست"><a class="header" href="#زبان-برنامهنویسی-راست">زبان برنامه‌نویسی راست</a></h1>
<p><em>نوشته استیو کلابنیک، کارول نیکولز، و کریس کریچو، با مشارکت اعضای جامعه راست</em></p>
<p>این نسخه از متن فرض می‌کند که شما از راست نسخه 1.82.0 (منتشر شده در تاریخ 17-10-2024) یا نسخه‌های جدیدتر استفاده می‌کنید. برای نصب یا به‌روزرسانی راست به <a href="ch01-01-installation.html">بخش “نصب” از فصل 1</a><!-- ignore --> مراجعه کنید.</p>
<p>فرمت HTML به‌صورت آنلاین در دسترس است در
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
و به‌صورت آفلاین با نصب‌های راست که با <code>rustup</code> انجام شده‌اند؛ دستور <code>rustup doc --book</code> را اجرا کنید تا باز شود.</p>
<p>چندین [ترجمه] جامعه نیز در دسترس است.</p>
<p>این متن در <a href="https://nostarch.com/rust-programming-language-2nd-edition">فرمت کاغذی و الکترونیکی از انتشارات No Starch Press</a> نیز موجود است.</p>
<blockquote>
<p><strong>🚨 می‌خواهید تجربه یادگیری تعاملی‌تری داشته باشید؟ نسخه دیگری از کتاب راست را امتحان کنید که شامل: آزمون‌ها، برجسته‌سازی‌ها، تجسم‌ها، و موارد دیگر است</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="پیشگفتار"><a class="header" href="#پیشگفتار">پیش‌گفتار</a></h1>
<p>همیشه این‌قدر واضح نبود، اما زبان برنامه‌نویسی راست اساساً درباره <em>توانمندسازی</em> است: فرقی نمی‌کند چه نوع کدی اکنون می‌نویسید، راست به شما این قدرت را می‌دهد که فراتر بروید، با اعتمادبه‌نفس در طیف وسیع‌تری از حوزه‌ها برنامه‌نویسی کنید.</p>
<p>به‌عنوان مثال، کارهای “در سطح سیستم” که با جزئیات سطح پایین مدیریت حافظه، نمایش داده‌ها و همروندی سر و کار دارند. به طور سنتی، این حوزه از برنامه‌نویسی پیچیده و فقط برای عده معدودی قابل دسترسی است که سال‌های لازم را برای اجتناب از مشکلات معروف آن صرف کرده‌اند. حتی کسانی که در این زمینه فعالیت می‌کنند نیز با احتیاط عمل می‌کنند تا کد آن‌ها در معرض بهره‌برداری، خرابی یا خرابی داده‌ها قرار نگیرد.</p>
<p>راست این موانع را از بین می‌برد و با حذف مشکلات قدیمی و ارائه مجموعه‌ای دوستانه و صیقل‌خورده از ابزارها به شما کمک می‌کند. برنامه‌نویسانی که نیاز دارند به کنترل‌های سطح پایین‌تر “فرو روند”، می‌توانند این کار را با راست انجام دهند، بدون پذیرش خطر معمول خرابی‌ها یا مشکلات امنیتی و بدون نیاز به یادگیری جزئیات ابزارهای پیچیده. بهتر از آن، این زبان طوری طراحی شده است که شما را به‌صورت طبیعی به سمت کدی قابل‌اطمینان و کارآمد از نظر سرعت و استفاده از حافظه هدایت می‌کند.</p>
<p>برنامه‌نویسانی که قبلاً با کد سطح پایین کار می‌کنند، می‌توانند با راست جاه‌طلبی‌های خود را افزایش دهند. به‌عنوان مثال، معرفی همروندی در راست عملی نسبتاً کم‌خطر است: کامپایلر اشتباهات کلاسیک را برای شما می‌گیرد. و شما می‌توانید با اطمینان به این که به‌طور تصادفی خرابی‌ها یا آسیب‌پذیری‌ها را معرفی نمی‌کنید، بهینه‌سازی‌های جسورانه‌تری را در کد خود پیاده کنید.</p>
<p>اما راست محدود به برنامه‌نویسی سیستم‌های سطح پایین نیست. این زبان به قدری بیانگر و راحت است که نوشتن برنامه‌های خط فرمان (CLI)، سرورهای وب و بسیاری از انواع دیگر کدها را دلپذیر می‌کند — نمونه‌های ساده‌ای از هر دو را در بخش‌های بعدی کتاب خواهید یافت. کار با راست به شما این امکان را می‌دهد که مهارت‌هایی بسازید که از یک حوزه به حوزه دیگر قابل‌انتقال باشند؛ می‌توانید راست را با نوشتن یک برنامه وب یاد بگیرید و سپس همان مهارت‌ها را برای هدف قرار دادن رزبری پای خود به کار ببرید.</p>
<p>این کتاب پتانسیل راست برای توانمندسازی کاربرانش را به طور کامل در آغوش می‌گیرد. این متنی دوستانه و قابل‌دسترس است که قصد دارد نه تنها دانش شما در مورد راست، بلکه دامنه و اعتمادبه‌نفس شما را به‌عنوان یک برنامه‌نویس به طور کلی ارتقا دهد. پس وارد شوید، آماده یادگیری باشید — و به جامعه راست خوش آمدید!</p>
<p>— نیکولاس ماتساکیس و آرون تورون</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مقدمه"><a class="header" href="#مقدمه">مقدمه</a></h1>
<blockquote>
<p>توجه: این نسخه از کتاب همان <a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming Language</a> است که به صورت چاپی و الکترونیکی از <a href="https://nostarch.com/">No Starch Press</a> در دسترس است.</p>
</blockquote>
<p>به <em>زبان برنامه‌نویسی راست</em> خوش آمدید، یک کتاب مقدماتی درباره راست. زبان برنامه‌نویسی راست به شما کمک می‌کند نرم‌افزاری سریع‌تر و قابل‌اعتمادتر بنویسید. در طراحی زبان‌های برنامه‌نویسی، راحتی در سطح بالا و کنترل در سطح پایین اغلب در تضاد هستند؛ راست این تناقض را به چالش می‌کشد. با ایجاد تعادل بین توانایی‌های فنی قدرتمند و تجربه عالی برنامه‌نویسی، راست به شما این امکان را می‌دهد که جزئیات سطح پایین (مانند استفاده از حافظه) را بدون دردسرهای سنتی مرتبط با چنین کنترلی مدیریت کنید.</p>
<h2 id="راست-برای-چه-کسانی-است"><a class="header" href="#راست-برای-چه-کسانی-است">راست برای چه کسانی است</a></h2>
<p>راست برای افراد مختلف با دلایل متنوع ایده‌آل است. بیایید به برخی از مهم‌ترین گروه‌ها نگاهی بیندازیم.</p>
<h3 id="تیمهای-برنامهنویسی"><a class="header" href="#تیمهای-برنامهنویسی">تیم‌های برنامه‌نویسی</a></h3>
<p>راست ابزاری اثبات شده برای همکاری میان تیم‌های بزرگ برنامه‌نویسان با سطوح مختلف دانش برنامه‌نویسی سیستم است. کد سطح پایین مستعد اشکالات ظریف متعددی است که در بیشتر زبان‌های دیگر تنها از طریق تست گسترده و بازبینی دقیق کد توسط برنامه‌نویسان با تجربه قابل شناسایی هستند. در راست، کامپایلر نقش نگهبان را ایفا می‌کند و از کامپایل کردن کدهایی با این اشکالات گریزان، از جمله اشکالات همروندی، جلوگیری می‌کند. با کار کردن در کنار کامپایلر، تیم می‌تواند زمان خود را بر روی منطق برنامه به جای رفع اشکالات صرف کند.</p>
<p>راست همچنین ابزارهای مدرن برنامه‌نویسی را به دنیای برنامه‌نویسی سیستم‌ها می‌آورد:</p>
<ul>
<li>Cargo، مدیر وابستگی و ابزار ساخت، اضافه کردن، کامپایل کردن، و مدیریت وابستگی‌ها را در سراسر اکوسیستم راست ساده و یکپارچه می‌کند.</li>
<li>ابزار قالب‌بندی Rustfmt، یک سبک کدنویسی ثابت را در بین برنامه‌نویسان تضمین می‌کند.</li>
<li>rust-analyzer یکپارچگی محیط توسعه یکپارچه (IDE) را برای تکمیل کد و پیام‌های خطای درون‌خطی فراهم می‌کند.</li>
</ul>
<p>با استفاده از این ابزارها و دیگر ابزارهای اکوسیستم راست، برنامه‌نویسان می‌توانند در هنگام نوشتن کد سطح سیستم‌ها بهره‌ور باشند.</p>
<h3 id="دانشجویان"><a class="header" href="#دانشجویان">دانشجویان</a></h3>
<p>راست برای دانشجویان و کسانی است که به یادگیری مفاهیم سیستم‌ها علاقه‌مند هستند. بسیاری از افراد با استفاده از راست موضوعاتی مانند توسعه سیستم‌عامل را آموخته‌اند. جامعه راست بسیار پذیرنده است و با خوشحالی به سوالات دانشجویان پاسخ می‌دهد. از طریق تلاش‌هایی مانند این کتاب، تیم‌های راست می‌خواهند مفاهیم سیستم‌ها را برای افراد بیشتری، به ویژه کسانی که تازه وارد برنامه‌نویسی هستند، قابل دسترس‌تر کنند.</p>
<h3 id="شرکتها"><a class="header" href="#شرکتها">شرکت‌ها</a></h3>
<p>صدها شرکت، بزرگ و کوچک، از راست در تولید برای وظایف متنوعی استفاده می‌کنند، از جمله ابزارهای خط فرمان، خدمات وب، ابزارهای DevOps، دستگاه‌های تعبیه‌شده، تحلیل و رمزگذاری صدا و تصویر، ارزهای دیجیتال، زیست‌اطلاعات، موتورهای جستجو، برنامه‌های اینترنت اشیاء، یادگیری ماشین و حتی بخش‌های اصلی مرورگر وب فایرفاکس.</p>
<h3 id="توسعهدهندگان-متنباز"><a class="header" href="#توسعهدهندگان-متنباز">توسعه‌دهندگان متن‌باز</a></h3>
<p>راست برای کسانی است که می‌خواهند زبان برنامه‌نویسی راست، جامعه، ابزارهای توسعه‌دهنده و کتابخانه‌ها را بسازند. ما دوست داریم شما در توسعه زبان راست مشارکت کنید.</p>
<h3 id="افرادی-که-سرعت-و-پایداری-را-ارزشمند-میدانند"><a class="header" href="#افرادی-که-سرعت-و-پایداری-را-ارزشمند-میدانند">افرادی که سرعت و پایداری را ارزشمند می‌دانند</a></h3>
<p>راست برای افرادی است که به سرعت و پایداری در یک زبان برنامه‌نویسی علاقه دارند. منظور از سرعت، هم سرعت اجرای کدهای راست و هم سرعتی است که راست به شما اجازه می‌دهد برنامه‌ها را بنویسید. بررسی‌های کامپایلر راست پایداری را از طریق افزودن ویژگی‌ها و بازسازی تضمین می‌کند. این در تضاد با کدهای قدیمی شکننده در زبان‌هایی است که فاقد این بررسی‌ها هستند و توسعه‌دهندگان اغلب از تغییر آن‌ها می‌ترسند. با تلاش برای ارائه انتزاعات بدون هزینه، ویژگی‌های سطح بالا که به کدهای سطح پایین با سرعتی معادل کدهای نوشته شده دستی کامپایل می‌شوند، راست می‌کوشد کد ایمن را به کد سریع تبدیل کند.</p>
<p>زبان راست امیدوار است از بسیاری از کاربران دیگر نیز پشتیبانی کند؛ افرادی که در اینجا ذکر شدند تنها برخی از بزرگ‌ترین ذینفعان هستند. در کل، بزرگ‌ترین جاه‌طلبی راست این است که با ارائه ایمنی <em>و</em> بهره‌وری، سرعت <em>و</em> راحتی، مصالحه‌هایی که برنامه‌نویسان دهه‌ها پذیرفته‌اند را حذف کند. راست را امتحان کنید و ببینید آیا انتخاب‌های آن برای شما مناسب است یا خیر.</p>
<h2 id="این-کتاب-برای-چه-کسانی-است"><a class="header" href="#این-کتاب-برای-چه-کسانی-است">این کتاب برای چه کسانی است</a></h2>
<p>این کتاب فرض می‌کند که شما قبلاً در یک زبان برنامه‌نویسی دیگر کدنویسی کرده‌اید اما هیچ فرضی در مورد اینکه کدام زبان است، ندارد. ما سعی کرده‌ایم مطالب را به گونه‌ای ارائه دهیم که برای افراد با زمینه‌های برنامه‌نویسی متنوع قابل دسترسی باشد. ما زمان زیادی را صرف صحبت درباره اینکه برنامه‌نویسی <em>چیست</em> یا چگونه باید به آن فکر کنید، نمی‌کنیم. اگر کاملاً تازه‌وارد برنامه‌نویسی هستید، بهتر است کتابی را بخوانید که به طور خاص مقدمه‌ای بر برنامه‌نویسی ارائه می‌دهد.</p>
<h2 id="نحوه-استفاده-از-این-کتاب"><a class="header" href="#نحوه-استفاده-از-این-کتاب">نحوه استفاده از این کتاب</a></h2>
<p>به طور کلی، این کتاب فرض می‌کند که شما آن را به ترتیب از ابتدا تا انتها می‌خوانید. فصل‌های بعدی بر مفاهیم فصل‌های قبلی بنا شده‌اند و فصل‌های اولیه ممکن است به جزئیات خاصی وارد نشوند اما در فصول بعدی به آن موضوعات بازمی‌گردند.</p>
<p>در این کتاب، دو نوع فصل وجود دارد: فصل‌های مفهومی و فصل‌های پروژه‌ای. در فصل‌های مفهومی، درباره یک جنبه از راست یاد خواهید گرفت. در فصل‌های پروژه‌ای، برنامه‌های کوچکی را با هم می‌سازیم و آنچه را که تاکنون آموخته‌اید به کار می‌گیریم. فصل‌های ۲، ۱۲ و ۲۱ فصل‌های پروژه‌ای هستند؛ بقیه فصل‌ها مفهومی هستند.</p>
<p>فصل ۱ نحوه نصب راست، نوشتن یک برنامه “سلام دنیا!” و استفاده از Cargo، مدیر بسته و ابزار ساخت راست را توضیح می‌دهد. فصل ۲ مقدمه‌ای عملی برای نوشتن برنامه‌ای در راست است و شما را به ساخت یک بازی حدس عدد می‌برد. در اینجا مفاهیم را به طور کلی پوشش می‌دهیم و جزئیات بیشتری را در فصول بعدی ارائه خواهیم کرد. اگر می‌خواهید بلافاصله کار عملی انجام دهید، فصل ۲ مناسب شماست. فصل ۳ ویژگی‌های راست را که مشابه ویژگی‌های سایر زبان‌های برنامه‌نویسی است پوشش می‌دهد و در فصل ۴ درباره سیستم مالکیت راست یاد خواهید گرفت. اگر شما یک یادگیرنده دقیق هستید که ترجیح می‌دهید قبل از ادامه، همه جزئیات را بیاموزید، ممکن است بخواهید فصل ۲ را رد کنید و مستقیماً به فصل ۳ بروید و پس از یادگیری جزئیات به فصل ۲ بازگردید تا روی پروژه‌ای کار کنید.</p>
<p>فصل ۵ به ساختارها (structs) و متدها می‌پردازد و فصل ۶ شامل enumerations (enums)، عبارات <code>match</code> و سازه کنترلی <code>if let</code> است. از ساختارها و enum‌ها برای ایجاد انواع سفارشی در راست استفاده خواهید کرد.</p>
<p>در فصل ۷، درباره سیستم ماژول راست و قوانین حریم خصوصی برای سازمان‌دهی کد و رابط برنامه‌نویسی عمومی (API) آن یاد خواهید گرفت. فصل ۸ به بررسی برخی از ساختارهای داده مجموعه رایج که کتابخانه استاندارد ارائه می‌دهد، مانند vectors، strings و hash maps می‌پردازد. فصل ۹ فلسفه و تکنیک‌های مدیریت خطا در راست را بررسی می‌کند.</p>
<p>فصل ۱۰ به مفاهیم جنریک‌ها، traits و lifetimes می‌پردازد که به شما این قدرت را می‌دهد تا کدی بنویسید که به انواع مختلف اعمال شود. فصل ۱۱ کاملاً درباره تست است که حتی با تضمین‌های ایمنی راست، برای اطمینان از درستی منطق برنامه شما ضروری است. در فصل ۱۲، پیاده‌سازی بخشی از ابزار خط فرمان <code>grep</code> که متن را در فایل‌ها جستجو می‌کند، خواهیم ساخت. برای این کار، از بسیاری از مفاهیمی که در فصل‌های قبلی مورد بحث قرار گرفتند استفاده خواهیم کرد.</p>
<p>فصل ۱۳ به بررسی closures و iterators می‌پردازد: ویژگی‌هایی از راست که از زبان‌های برنامه‌نویسی تابعی آمده‌اند. در فصل ۱۴، Cargo را به طور عمیق‌تری بررسی خواهیم کرد و درباره بهترین روش‌ها برای اشتراک‌گذاری کتابخانه‌های خود با دیگران صحبت خواهیم کرد. فصل ۱۵ اشاره‌گر (Pointer)های هوشمند (smart pointers) ارائه‌شده توسط کتابخانه استاندارد و traitsی که قابلیت‌های آن‌ها را امکان‌پذیر می‌سازد بررسی می‌کند.</p>
<p>در فصل ۱۶، مدل‌های مختلف برنامه‌نویسی هم‌زمان را بررسی می‌کنیم و درباره اینکه چگونه راست به شما کمک می‌کند بدون ترس با چندین رشته (string) کار کنید صحبت خواهیم کرد. در فصل ۱۷، این موضوع را با بررسی syntax async و await و مدل هم‌زمانی سبک‌وزنی که پشتیبانی می‌کنند، گسترش خواهیم داد.</p>
<p>فصل ۱۸ نگاهی به چگونگی مقایسه اصطلاحات راست با اصول برنامه‌نویسی شیءگرا می‌اندازد که ممکن است با آن‌ها آشنا باشید.</p>
<p>فصل ۱۹ مرجعی درباره الگوها و الگویابی (pattern matching) است که راه‌های قدرتمندی برای بیان ایده‌ها در سراسر برنامه‌های راست ارائه می‌دهد. فصل ۲۰ شامل مجموعه‌ای از موضوعات پیشرفته جالب، از جمله راست ناامن، ماکروها، و مباحث بیشتر درباره lifetimes، traits، انواع، توابع و closures است.</p>
<p>در فصل ۲۱، پروژه‌ای را تکمیل می‌کنیم که در آن یک سرور وب چندرشته‌ای سطح پایین پیاده‌سازی خواهیم کرد!</p>
<p>در نهایت، پیوست‌هایی شامل اطلاعات مفید درباره زبان به شکلی مرجع‌گونه ارائه می‌شوند. ضمیمه الف کلمات کلیدی راست، ضمیمه ب عملگرها و نمادهای راست، ضمیمه ج traits قابل اشتقاق ارائه‌شده توسط کتابخانه استاندارد، ضمیمه د برخی از ابزارهای توسعه مفید، و ضمیمه ه نسخه‌های راست را توضیح می‌دهد. در ضمیمه و می‌توانید ترجمه‌های کتاب را پیدا کنید و در ضمیمه ی درباره چگونگی ساخت راست و راست nightly اطلاعات کسب کنید.</p>
<p>هیچ روش نادرستی برای خواندن این کتاب وجود ندارد: اگر می‌خواهید به جلو بروید، این کار را انجام دهید! ممکن است مجبور شوید به فصل‌های قبلی بازگردید اگر با سردرگمی روبه‌رو شدید. اما هرچه برای شما مناسب است انجام دهید.</p>
<p><span id="ferris"></span></p>
<p>بخش مهمی از فرآیند یادگیری راست، یادگیری نحوه خواندن پیام‌های خطای کامپایلر است: این پیام‌ها شما را به سمت کدی که کار می‌کند هدایت می‌کنند. به همین دلیل، مثال‌های زیادی را ارائه می‌دهیم که کامپایل نمی‌شوند، همراه با پیام خطایی که کامپایلر در هر وضعیت نمایش می‌دهد. بدانید که اگر یک مثال تصادفی را وارد کنید و اجرا کنید، ممکن است کامپایل نشود! مطمئن شوید که متن اطراف را بخوانید تا ببینید آیا مثالی که می‌خواهید اجرا کنید قرار است خطا بدهد یا خیر. Ferris همچنین به شما کمک می‌کند کدی که قرار نیست کار کند را تشخیص دهید:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>معنی</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>این کد کامپایل نمی‌شود!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>این کد وحشت می‌کند!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>این کد رفتار مورد انتظار را تولید نمی‌کند.</td></tr>
</tbody></table>
</div>
<p>در بیشتر موارد، شما را به نسخه صحیح هر کدی که کامپایل نمی‌شود هدایت خواهیم کرد.</p>
<h2 id="کد-منبع"><a class="header" href="#کد-منبع">کد منبع</a></h2>
<p>فایل‌های منبعی که این کتاب از آن‌ها تولید می‌شود را می‌توانید در <a href="https://github.com/persian-rust/book/tree/main/src">GitHub</a> پیدا کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="شروع-به-کار"><a class="header" href="#شروع-به-کار">شروع به کار</a></h1>
<p>بیایید سفر خود به دنیای راست را آغاز کنیم! چیزهای زیادی برای یادگیری وجود دارد، اما هر سفری از جایی شروع می‌شود. در این فصل، درباره موارد زیر صحبت خواهیم کرد:</p>
<ul>
<li>نصب راست بر روی لینوکس، macOS، و ویندوز</li>
<li>نوشتن برنامه‌ای که <code>سلام دنیا!</code> را چاپ می‌کند</li>
<li>استفاده از <code>cargo</code>، مدیر بسته و سیستم ساخت راست</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="نصب"><a class="header" href="#نصب">نصب</a></h2>
<p>اولین قدم نصب راست است. ما راست را از طریق <code>rustup</code> دانلود می‌کنیم، ابزاری خط فرمان برای مدیریت نسخه‌های راست و ابزارهای مربوطه. برای دانلود به اتصال اینترنتی نیاز دارید.</p>
<blockquote>
<p>توجه: اگر به هر دلیلی ترجیح می‌دهید از <code>rustup</code> استفاده نکنید، لطفاً صفحه <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">روش‌های نصب دیگر راست</a> را برای گزینه‌های بیشتر مشاهده کنید.</p>
</blockquote>
<p>مراحل زیر نسخه پایدار جدیدترین کامپایلر راست را نصب می‌کنند. تضمین‌های پایداری راست اطمینان می‌دهند که تمام مثال‌های کتاب که کامپایل می‌شوند، با نسخه‌های جدیدتر راست نیز کامپایل خواهند شد. خروجی ممکن است کمی متفاوت باشد، زیرا راست به طور مرتب پیغام‌های خطا و هشدارها را بهبود می‌بخشد. به عبارت دیگر، هر نسخه پایدار جدیدی که با این مراحل نصب کنید، باید با محتوای این کتاب به درستی کار کند.</p>
<section class="note" aria-role="note">
<h3 id="یادداشت-دستورات-خط-فرمان"><a class="header" href="#یادداشت-دستورات-خط-فرمان">یادداشت دستورات خط فرمان</a></h3>
<p>در این فصل و throughout the book، ما برخی از دستورات استفاده شده در ترمینال را نمایش خواهیم داد. خطوطی که باید در ترمینال وارد کنید، همگی با <code>$</code> شروع می‌شوند. شما نیازی به وارد کردن نماد <code>$</code> ندارید؛ این نماد نشان‌دهنده شروع هر دستور است. خطوطی که با <code>$</code> شروع نمی‌شوند معمولاً خروجی دستور قبلی را نشان می‌دهند. علاوه بر این، مثال‌های خاص PowerShell از <code>&gt;</code> به جای <code>$</code> استفاده می‌کنند.</p>
</section>
<h3 id="نصب-rustup-در-لینوکس-یا-macos"><a class="header" href="#نصب-rustup-در-لینوکس-یا-macos">نصب <code>rustup</code> در لینوکس یا macOS</a></h3>
<p>اگر از لینوکس یا macOS استفاده می‌کنید، یک ترمینال باز کرده و دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>این دستور یک اسکریپت دانلود کرده و نصب ابزار <code>rustup</code> را آغاز می‌کند که نسخه پایدار جدید راست را نصب می‌کند. ممکن است از شما خواسته شود تا رمز عبور خود را وارد کنید. اگر نصب موفقیت‌آمیز بود، خط زیر ظاهر می‌شود:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>همچنین به یک <em>لینکر</em> نیاز خواهید داشت که برنامه‌ای است که راست از آن برای ترکیب خروجی‌های کامپایل شده خود به یک فایل استفاده می‌کند. احتمالاً شما یک لینکر دارید. اگر با ارورهای لینکر روبه‌رو شدید، باید یک کامپایلر C نصب کنید که معمولاً لینکر را نیز شامل می‌شود. یک کامپایلر C همچنین مفید است زیرا برخی از پکیج‌های رایج راست به کد C وابسته‌اند و به یک کامپایلر C نیاز دارند.</p>
<p>برای نصب کامپایلر C در macOS، دستور زیر را اجرا کنید:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>کاربران لینوکس معمولاً باید GCC یا Clang را طبق مستندات توزیع خود نصب کنند. برای مثال، اگر از اوبونتو استفاده می‌کنید، می‌توانید پکیج <code>build-essential</code> را نصب کنید.</p>
<h3 id="نصب-rustup-در-ویندوز"><a class="header" href="#نصب-rustup-در-ویندوز">نصب <code>rustup</code> در ویندوز</a></h3>
<p>در ویندوز، به <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> بروید و دستورالعمل‌های نصب راست را دنبال کنید. در یک مرحله از نصب، از شما خواسته می‌شود تا Visual Studio را نصب کنید. این ابزار یک لینکر و کتابخانه‌های بومی لازم برای کامپایل برنامه‌ها را فراهم می‌کند. اگر به کمک بیشتری نیاز دارید، این صفحه را مشاهده کنید <a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">https://rust-lang.github.io/rustup/installation/windows-msvc.html</a></p>
<p>بقیه کتاب از دستورات استفاده شده در <em>cmd.exe</em> و PowerShell استفاده می‌کند. اگر تفاوت‌های خاصی وجود داشته باشد، توضیح خواهیم داد که کدام را باید استفاده کنید.</p>
<h3 id="عیبیابی"><a class="header" href="#عیبیابی">عیب‌یابی</a></h3>
<p>برای بررسی اینکه راست به درستی نصب شده است یا خیر، یک شل باز کرده و این دستور را وارد کنید:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>باید شماره نسخه، هش کمیّت و تاریخ کمیّت برای جدیدترین نسخه پایدار منتشر شده را به صورت زیر ببینید:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>اگر این اطلاعات را مشاهده کردید، راست به درستی نصب شده است! اگر این اطلاعات را مشاهده نکردید، بررسی کنید که راست در متغیر سیستم <code>%PATH%</code> شما قرار دارد.</p>
<p>در CMD ویندوز، از دستور زیر استفاده کنید:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>در PowerShell، از دستور زیر استفاده کنید:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>در لینوکس و macOS، از دستور زیر استفاده کنید:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>اگر همه چیز درست باشد و راست همچنان کار نکند، منابع زیادی برای کمک وجود دارد. برای تماس با سایر راست‌نویسان (لقب خنده‌داری که خودمان به کار می‌بریم)، به صفحه <a href="https://www.rust-lang.org/community">اجتماع</a> مراجعه کنید.</p>
<h3 id="بروزرسانی-و-حذف-نصب"><a class="header" href="#بروزرسانی-و-حذف-نصب">بروزرسانی و حذف نصب</a></h3>
<p>بعد از نصب راست از طریق <code>rustup</code>، بروزرسانی به نسخه جدید بسیار آسان است. از شل خود دستور زیر را اجرا کنید:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>برای حذف نصب راست و <code>rustup</code>، اسکریپت حذف زیر را از شل خود اجرا کنید:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="مستندات-محلی"><a class="header" href="#مستندات-محلی">مستندات محلی</a></h3>
<p>نصب راست همچنین شامل یک نسخه محلی از مستندات است تا بتوانید آن را به صورت آفلاین مطالعه کنید. برای باز کردن مستندات محلی در مرورگر خود، دستور <code>rustup doc</code> را اجرا کنید.</p>
<p>هر زمان که از یک نوع یا تابع ارائه‌شده توسط کتابخانه استاندارد استفاده می‌کنید و مطمئن نیستید که چه کار می‌کند یا چگونه از آن استفاده کنید، از مستندات رابط برنامه‌نویسی (API) برای یافتن آن استفاده کنید!</p>
<h3 id="ویرایشگرهای-متن-و-محیطهای-توسعه-یکپارچه"><a class="header" href="#ویرایشگرهای-متن-و-محیطهای-توسعه-یکپارچه">ویرایشگرهای متن و محیط‌های توسعه یکپارچه</a></h3>
<p>این کتاب هیچ فرضی درباره ابزارهایی که برای نوشتن کد راست استفاده می‌کنید، ندارد. تقریباً هر ویرایشگر متنی کار را انجام می‌دهد! با این حال، بسیاری از ویرایشگرها و محیط‌های توسعه یکپارچه (IDE) پشتیبانی داخلی برای راست دارند. همیشه می‌توانید فهرست نسبتاً جدیدی از بسیاری از ویرایشگرها و IDEها را در <a href="https://www.rust-lang.org/tools">صفحه ابزارها</a> در وب‌سایت راست پیدا کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="سلام-دنیا"><a class="header" href="#سلام-دنیا">سلام، دنیا!</a></h2>
<p>حالا که Rust را نصب کرده‌اید، وقت آن است که اولین برنامه‌ی Rust خود را بنویسید.
وقتی زبان جدیدی را یاد می‌گیرید، معمولاً یک برنامه کوچک می‌نویسید که متن <code>Hello, world!</code> را به صفحه نمایش چاپ کند، پس ما هم همین کار را خواهیم کرد!</p>
<blockquote>
<p>نکته: این کتاب فرض می‌کند که شما با خط فرمان آشنایی پایه‌ای دارید. Rust هیچ‌گونه الزامی در مورد ویرایش یا ابزارهای شما یا جایی که کد شما قرار دارد ندارد، بنابراین اگر ترجیح می‌دهید از یک محیط توسعه یکپارچه (IDE) به جای خط فرمان استفاده کنید، می‌توانید از IDE مورد علاقه خود استفاده کنید. بسیاری از IDE‌ها اکنون از Rust پشتیبانی می‌کنند؛ برای جزئیات، مستندات IDE خود را بررسی کنید. تیم Rust تمرکز خود را بر enabling پشتیبانی خوب از IDE از طریق <code>rust-analyzer</code> گذاشته است. برای جزئیات بیشتر، به <a href="appendix-04-useful-development-tools.html">ضمیمه د</a><!-- ignore --> مراجعه کنید.</p>
</blockquote>
<h3 id="ایجاد-یک-دایرکتوری-پروژه"><a class="header" href="#ایجاد-یک-دایرکتوری-پروژه">ایجاد یک دایرکتوری پروژه</a></h3>
<p>شما با ایجاد یک دایرکتوری برای ذخیره کدهای Rust خود شروع خواهید کرد. برای Rust مهم نیست که کد شما کجا قرار دارد، اما برای تمرین‌ها و پروژه‌های این کتاب، پیشنهاد می‌کنیم یک دایرکتوری <em>projects</em> در دایرکتوری خانه‌تان بسازید و تمام پروژه‌هایتان را در آن نگهدارید.</p>
<p>یک ترمینال باز کنید و دستورات زیر را وارد کنید تا یک دایرکتوری <em>projects</em> و یک دایرکتوری برای پروژه‌ی “Hello, world!” در داخل دایرکتوری <em>projects</em> ایجاد کنید.</p>
<p>برای لینوکس، macOS، و PowerShell در ویندوز، این دستورات را وارد کنید:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>برای CMD ویندوز، این دستورات را وارد کنید:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="نوشتن-و-اجرای-یک-برنامه-rust"><a class="header" href="#نوشتن-و-اجرای-یک-برنامه-rust">نوشتن و اجرای یک برنامه Rust</a></h3>
<p>حالا یک فایل سورس جدید بسازید و آن را <em>main.rs</em> نام‌گذاری کنید. فایل‌های Rust همیشه با پسوند <em>.rs</em> تمام می‌شوند. اگر از بیش از یک کلمه در نام فایل استفاده می‌کنید، سنت معمول این است که از خط تیره زیر برای جدا کردن آنها استفاده کنید. به عنوان مثال، از <em>hello_world.rs</em> به جای <em>helloworld.rs</em> استفاده کنید.</p>
<p>حالا فایل <em>main.rs</em> که تازه ایجاد کرده‌اید را باز کنید و کد موجود در فهرست 1-1 را وارد کنید.</p>
<figure class="listing">
<span class="file-name">Filename: main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<figcaption>Listing 1-1: یک برنامه که <code>Hello, world!</code> را چاپ می‌کند</figcaption>
</figure>
<p>فایل را ذخیره کنید و به پنجره ترمینال خود در دایرکتوری
<em>~/projects/hello_world</em> برگردید. در لینوکس یا macOS، دستورات زیر را وارد کنید تا فایل را کامپایل کرده و اجرا کنید:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>در ویندوز، به جای <code>./main</code> دستور <code>.\main.exe</code> را وارد کنید:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>صرف‌نظر از سیستم‌عامل شما، رشته <code>Hello, world!</code> باید در ترمینال چاپ شود. اگر این خروجی را مشاهده نکردید، به بخش <a href="ch01-01-installation.html#troubleshooting">“رفع مشکلات”</a><!-- ignore --> در قسمت نصب مراجعه کنید تا روش‌های دریافت کمک را بیابید.</p>
<p>اگر <code>Hello, world!</code> چاپ شد، تبریک می‌گوییم! شما به طور رسمی یک برنامه نویس Rust شده‌اید—خوش آمدید!</p>
<h3 id="آناتومی-یک-برنامه-rust"><a class="header" href="#آناتومی-یک-برنامه-rust">آناتومی یک برنامه Rust</a></h3>
<p>بیایید این برنامه “Hello, world!” را به طور دقیق بررسی کنیم. این اولین بخش معما است:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

}</code></pre></pre>
<p>این خطوط یک تابع به نام <code>main</code> تعریف می‌کنند. تابع <code>main</code> خاص است: همیشه اولین کدی است که در هر برنامه Rust اجرایی اجرا می‌شود. در اینجا، خط اول یک تابع به نام <code>main</code> اعلام می‌کند که هیچ پارامتر ندارد و هیچ چیزی را برنمی‌گرداند. اگر پارامترهایی وجود داشتند، آن‌ها داخل پرانتزهای <code>()</code> قرار می‌گرفتند.</p>
<p>بدن تابع در <code>{}</code> قرار دارد. Rust از آکولادها برای احاطه کردن تمام بدنه‌های توابع استفاده می‌کند. این یک سبک خوب است که آکولاد باز را در همان خط اعلام تابع قرار دهید و یک فضای خالی بین آن‌ها اضافه کنید.</p>
<blockquote>
<p>نکته: اگر می‌خواهید در پروژه‌های Rust خود از یک سبک استاندارد پیروی کنید، می‌توانید از ابزاری به نام <code>rustfmt</code> برای فرمت کردن کد خود در یک سبک خاص استفاده کنید (بیشتر در مورد <code>rustfmt</code> در <a href="appendix-04-useful-development-tools.html">ضمیمه د</a><!-- ignore -->). تیم Rust این ابزار را همراه با توزیع استاندارد Rust شامل کرده است، همانطور که <code>rustc</code> است، بنابراین باید قبلاً روی کامپیوتر شما نصب شده باشد!</p>
</blockquote>
<p>بدن تابع <code>main</code> شامل کد زیر است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello, world!");
<span class="boring">}</span></code></pre></pre>
<p>این خط تمام کار را در این برنامه کوچک انجام می‌دهد: آن متن را به صفحه نمایش چاپ می‌کند. چهار نکته مهم وجود دارد که باید به آن‌ها توجه کنید.</p>
<p>اول، <code>println!</code> یک ماکرو Rust را فراخوانی می‌کند. اگر به جای آن یک تابع فراخوانی می‌شد، باید به صورت <code>println</code> (بدون <code>!</code>) وارد می‌شد. ماکروهای Rust را در فصل 20 به طور مفصل‌تر بررسی خواهیم کرد. در حال حاضر، شما فقط باید بدانید که استفاده از <code>!</code> به این معنی است که شما یک ماکرو را فراخوانی می‌کنید نه یک تابع معمولی و اینکه ماکروها همیشه از همان قوانین توابع پیروی نمی‌کنند.</p>
<p>دوم، شما رشته <code>"Hello, world!"</code> را مشاهده می‌کنید. این رشته را به عنوان آرگومان به <code>println!</code> می‌دهیم و این رشته به صفحه نمایش چاپ می‌شود.</p>
<p>سوم، خط را با یک نقطه‌ویرگول (<code>;</code>) تمام می‌کنیم که نشان می‌دهد این عبارت تمام شده و عبارت بعدی آماده شروع است. بیشتر خطوط کد Rust با نقطه‌ویرگول تمام می‌شوند.</p>
<h3 id="کامپایل-کردن-و-اجرا-کردن-مراحل-جداگانه-هستند"><a class="header" href="#کامپایل-کردن-و-اجرا-کردن-مراحل-جداگانه-هستند">کامپایل کردن و اجرا کردن مراحل جداگانه هستند</a></h3>
<p>شما به تازگی یک برنامه جدید ایجاد شده را اجرا کرده‌اید، بنابراین بیایید هر مرحله از فرآیند را بررسی کنیم.</p>
<p>قبل از اجرای یک برنامه Rust، باید آن را با استفاده از کامپایلر Rust کامپایل کنید. برای این کار باید دستور <code>rustc</code> را وارد کرده و نام فایل سورس خود را به آن بدهید، مانند این:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>اگر پیش‌زمینه‌ای از C یا C++ دارید، متوجه خواهید شد که این مشابه دستور <code>gcc</code> یا <code>clang</code> است. پس از کامپایل موفق، Rust یک فایل اجرایی باینری تولید می‌کند.</p>
<p>در لینوکس، macOS و PowerShell در ویندوز، می‌توانید فایل اجرایی را با وارد کردن دستور <code>ls</code> در شل خود مشاهده کنید:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>در لینوکس و macOS، شما دو فایل خواهید دید. در PowerShell در ویندوز، همان سه فایلی را که با CMD می‌بینید مشاهده خواهید کرد. در CMD در ویندوز، باید دستور زیر را وارد کنید:</p>
<pre><code class="language-cmd">&gt; dir /B %= گزینه /B می‌گوید که فقط نام فایل‌ها نمایش داده شود =%
main.exe
main.pdb
main.rs
</code></pre>
<p>این لیست فایل سورس با پسوند <em>.rs</em>، فایل اجرایی (<em>main.exe</em> در ویندوز، اما <em>main</em> در سایر پلتفرم‌ها)، و در صورت استفاده از ویندوز، یک فایل شامل اطلاعات دیباگ با پسوند <em>.pdb</em> را نشان می‌دهد. از اینجا، شما فایل <em>main</em> یا <em>main.exe</em> را اجرا می‌کنید، مانند این:</p>
<pre><code class="language-console">$ ./main # یا .\main.exe در ویندوز
</code></pre>
<p>اگر فایل <em>main.rs</em> شما برنامه “Hello, world!” باشد، این خط <code>Hello, world!</code> را در ترمینال شما چاپ می‌کند.</p>
<p>اگر با زبان‌های داینامیک مانند Ruby، Python یا JavaScript آشنایی بیشتری دارید، ممکن است عادت نداشته باشید که کامپایل و اجرای یک برنامه را به عنوان مراحل جداگانه انجام دهید. Rust یک زبان <em>کامپایل شده پیش از زمان</em> است، به این معنی که شما می‌توانید یک برنامه را کامپایل کرده و فایل اجرایی را به شخص دیگری بدهید تا آن را اجرا کند، حتی بدون اینکه Rust روی سیستم آن شخص نصب شده باشد. اگر به کسی فایل <em>.rb</em>، <em>.py</em> یا <em>.js</em> بدهید، آن‌ها نیاز به نصب پیاده‌سازی Ruby، Python یا JavaScript (به ترتیب) دارند. اما در این زبان‌ها، شما فقط به یک دستور نیاز دارید تا برنامه خود را کامپایل و اجرا کنید. همه چیز در طراحی زبان‌ها یک تعادل است.</p>
<p>فقط با کامپایل کردن با <code>rustc</code> برای برنامه‌های ساده کافی است، اما با رشد پروژه شما، می‌خواهید تمام گزینه‌ها را مدیریت کرده و اشتراک‌گذاری کد خود را آسان کنید. در ادامه، ما ابزار Cargo را معرفی خواهیم کرد که به شما کمک می‌کند برنامه‌های واقعی Rust بنویسید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="سلام-cargo"><a class="header" href="#سلام-cargo">سلام، Cargo!</a></h2>
<p>Cargo سیستم ساخت و مدیر بسته‌های Rust است. بیشتر Rustacean ها از این ابزار برای مدیریت پروژه‌های Rust خود استفاده می‌کنند زیرا Cargo بسیاری از وظایف را برای شما انجام می‌دهد، مانند ساختن کد شما، دانلود کتابخانه‌هایی که کد شما به آن‌ها وابسته است، و ساختن آن کتابخانه‌ها. (ما به کتابخانه‌هایی که کد شما به آن‌ها نیاز دارد <em>وابستگی‌ها</em> می‌گوییم.)</p>
<p>ساده‌ترین برنامه‌های Rust، مانند برنامه‌ای که تا کنون نوشته‌ایم، هیچ وابستگی‌ای ندارند. اگر پروژه “Hello, world!” را با Cargo می‌ساختیم، فقط از بخشی از Cargo استفاده می‌کرد که مسئول ساختن کد شما است. هنگامی که برنامه‌های پیچیده‌تری در Rust بنویسید، وابستگی‌ها را اضافه خواهید کرد و اگر پروژه‌ای را با استفاده از Cargo شروع کنید، اضافه کردن وابستگی‌ها بسیار راحت‌تر خواهد بود.</p>
<p>به دلیل اینکه اکثریت عظیم پروژه‌های Rust از Cargo استفاده می‌کنند، بقیه این کتاب فرض می‌کند که شما نیز از Cargo استفاده می‌کنید. Cargo با Rust نصب می‌شود اگر از نصب‌کننده‌های رسمی که در بخش
[“نصب”][installation]<!-- ignore --> بحث شده‌اند استفاده کرده باشید. اگر Rust را از طریق روش‌های دیگری نصب کرده‌اید، بررسی کنید که آیا Cargo نصب شده است یا نه با وارد کردن دستور زیر در ترمینال خود:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>اگر شماره نسخه‌ای مشاهده کردید، آن را دارید! اگر خطای <code>command not found</code> را دیدید، به مستندات روش نصب خود مراجعه کنید تا نحوه نصب جداگانه Cargo را پیدا کنید.</p>
<h3 id="ایجاد-یک-پروژه-با-cargo"><a class="header" href="#ایجاد-یک-پروژه-با-cargo">ایجاد یک پروژه با Cargo</a></h3>
<p>بیایید یک پروژه جدید با استفاده از Cargo بسازیم و ببینیم چگونه از پروژه اولیه “Hello, world!” ما متفاوت است. به دایرکتوری <em>projects</em> خود بروید (یا هر جایی که تصمیم گرفته‌اید کد خود را ذخیره کنید). سپس، در هر سیستم‌عاملی، دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>دستور اول یک دایرکتوری جدید به نام <em>hello_cargo</em> ایجاد می‌کند و پروژه‌ای به همین نام ایجاد می‌کند. ما پروژه خود را <em>hello_cargo</em> نام‌گذاری کرده‌ایم و Cargo فایل‌های خود را در دایرکتوری به همین نام ایجاد می‌کند.</p>
<p>به دایرکتوری <em>hello_cargo</em> بروید و فایل‌ها را لیست کنید. خواهید دید که Cargo دو فایل و یک دایرکتوری برای ما ایجاد کرده است: یک فایل <em>Cargo.toml</em> و یک دایرکتوری <em>src</em> که داخل آن یک فایل <em>main.rs</em> است.</p>
<p>همچنین یک مخزن Git جدید به همراه یک فایل <em>.gitignore</em> ایجاد شده است. فایل‌های Git در صورتی که دستور <code>cargo new</code> را در یک مخزن Git موجود اجرا کنید، ایجاد نمی‌شوند؛ می‌توانید این رفتار را با استفاده از <code>cargo new --vcs=git</code> لغو کنید.</p>
<blockquote>
<p>نکته: Git یک سیستم کنترل نسخه رایج است. شما می‌توانید دستور <code>cargo new</code> را تغییر دهید تا از سیستم کنترل نسخه‌ای متفاوت یا هیچ سیستم کنترل نسخه‌ای استفاده کند با استفاده از پرچم <code>--vcs</code>. برای دیدن گزینه‌های موجود، دستور <code>cargo new --help</code> را اجرا کنید.</p>
</blockquote>
<p>فایل <em>Cargo.toml</em> را در ویرایشگر متن دلخواه خود باز کنید. این فایل باید مشابه کدی باشد که در فهرست 1-2 آمده است.</p>
<figure class="listing">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# برای مشاهده کلیدها و تعاریف بیشتر به https://doc.rust-lang.org/cargo/reference/manifest.html مراجعه کنید

[dependencies]
</code></pre>
<figcaption>Listing 1-2: محتویات <em>Cargo.toml</em> که توسط <code>cargo new</code> ایجاد شده است</figcaption>
</figure>
<p>این فایل در فرمت [<em>TOML</em>][toml]<!-- ignore --> (<em>زبان ساده و آشکار تام</em>) است که فرمت پیکربندی Cargo است.</p>
<p>خط اول، <code>[package]</code>، یک عنوان بخش است که نشان می‌دهد بیانیه‌های بعدی در حال پیکربندی یک بسته هستند. همانطور که اطلاعات بیشتری به این فایل اضافه می‌کنیم، بخش‌های دیگری را اضافه خواهیم کرد.</p>
<p>سه خط بعدی اطلاعات پیکربندی‌ای را تنظیم می‌کنند که Cargo برای کامپایل برنامه شما به آن‌ها نیاز دارد: نام، نسخه و نسخه‌ای از Rust که باید استفاده شود. در مورد کلید <code>edition</code> در [ضمیمه ه][appendix-e]<!-- ignore --> صحبت خواهیم کرد.</p>
<p>آخرین خط، <code>[dependencies]</code>، شروع یک بخش است که شما باید وابستگی‌های پروژه خود را در آن ذکر کنید. در Rust، بسته‌های کد به نام <em>کرِیت‌ها</em> شناخته می‌شوند. برای این پروژه نیازی به کرِیت‌های دیگر نداریم، اما در پروژه اول فصل 2 به آن‌ها نیاز خواهیم داشت، بنابراین در آن زمان از این بخش وابستگی‌ها استفاده خواهیم کرد.</p>
<p>حالا فایل <em>src/main.rs</em> را باز کنید و نگاهی بیندازید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo یک برنامه “Hello, world!” برای شما ایجاد کرده است، درست مانند برنامه‌ای که در فهرست 1-1 نوشتیم! تا کنون، تفاوت‌های بین پروژه ما و پروژه‌ای که Cargo ایجاد کرده این است که Cargo کد را در دایرکتوری <em>src</em> قرار داده و ما یک فایل پیکربندی <em>Cargo.toml</em> در دایرکتوری بالای پروژه داریم.</p>
<p>Cargo انتظار دارد که فایل‌های منبع شما داخل دایرکتوری <em>src</em> قرار داشته باشند. دایرکتوری بالای پروژه فقط برای فایل‌های README، اطلاعات مجوز، فایل‌های پیکربندی و هر چیز دیگری که مربوط به کد شما نباشد، استفاده می‌شود. استفاده از Cargo به شما کمک می‌کند پروژه‌هایتان را سازماندهی کنید. برای هر چیز جایی وجود دارد و همه چیز در جای خود قرار دارد.</p>
<p>اگر پروژه‌ای شروع کرده‌اید که از Cargo استفاده نمی‌کند، همانطور که در پروژه “Hello, world!” انجام دادیم، می‌توانید آن را به پروژه‌ای که از Cargo استفاده می‌کند تبدیل کنید. کد پروژه را به دایرکتوری <em>src</em> منتقل کرده و یک فایل <em>Cargo.toml</em> مناسب ایجاد کنید. یکی از راه‌های آسان برای به‌دست آوردن آن فایل <em>Cargo.toml</em> این است که دستور <code>cargo init</code> را اجرا کنید که به‌طور خودکار آن را برای شما ایجاد می‌کند.</p>
<h3 id="ساخت-و-اجرای-پروژه-با-cargo"><a class="header" href="#ساخت-و-اجرای-پروژه-با-cargo">ساخت و اجرای پروژه با Cargo</a></h3>
<p>حالا بیایید ببینیم که چه تفاوتی در زمانی که برنامه “Hello, world!” را با Cargo می‌سازیم و اجرا می‌کنیم وجود دارد! از دایرکتوری <em>hello_cargo</em> خود، پروژه را با وارد کردن دستور زیر بسازید:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>این دستور یک فایل اجرایی در <em>target/debug/hello_cargo</em> (یا <em>target\debug\hello_cargo.exe</em> در ویندوز) ایجاد می‌کند به جای این که آن را در دایرکتوری فعلی شما قرار دهد. زیرا ساخت پیش‌فرض یک ساخت دیباگ است، Cargo فایل باینری را در دایرکتوری به نام <em>debug</em> قرار می‌دهد. شما می‌توانید فایل اجرایی را با این دستور اجرا کنید:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # یا .\target\debug\hello_cargo.exe در ویندوز
Hello, world!
</code></pre>
<p>اگر همه چیز درست پیش رفته باشد، <code>Hello, world!</code> باید در ترمینال چاپ شود. اجرای <code>cargo build</code> برای اولین بار همچنین باعث می‌شود که Cargo یک فایل جدید در بالای دایرکتوری ایجاد کند: <em>Cargo.lock</em>. این فایل نسخه‌های دقیق وابستگی‌های پروژه شما را پیگیری می‌کند. چون این پروژه وابستگی ندارد، این فایل کمی خالی است. شما هیچ‌گاه نیازی به تغییر دستی این فایل نخواهید داشت؛ Cargo محتویات آن را برای شما مدیریت می‌کند.</p>
<p>ما همین حالا پروژه را با دستور <code>cargo build</code> ساختیم و با <code>./target/debug/hello_cargo</code> اجرا کردیم، اما همچنین می‌توانیم از <code>cargo run</code> برای کامپایل کردن کد و سپس اجرای باینری حاصل در یک دستور استفاده کنیم:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>استفاده از <code>cargo run</code> راحت‌تر از این است که بخواهید دستور <code>cargo build</code> را اجرا کرده و سپس مسیر کامل به باینری را استفاده کنید، بنابراین بیشتر توسعه‌دهندگان از <code>cargo run</code> استفاده می‌کنند.</p>
<p>توجه کنید که این بار، خروجی‌ای که نشان دهد Cargo در حال کامپایل کردن <code>hello_cargo</code> است، مشاهده نکردیم. Cargo متوجه شد که فایل‌ها تغییر نکرده‌اند، بنابراین بازسازی نکرد و فقط باینری را اجرا کرد. اگر کد منبع خود را تغییر داده بودید، Cargo ابتدا پروژه را بازسازی می‌کرد و سپس آن را اجرا می‌کرد، و شما این خروجی را می‌دیدید:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo همچنین یک دستور به نام <code>cargo check</code> را فراهم می‌کند. این دستور کد شما را به سرعت بررسی می‌کند تا مطمئن شود که کامپایل می‌شود اما هیچ اجرایی تولید نمی‌کند:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>چرا شما به یک فایل اجرایی نیاز ندارید؟ اغلب، <code>cargo check</code> بسیار سریع‌تر از <code>cargo build</code> است زیرا مرحله تولید یک فایل اجرایی را رد می‌کند. اگر شما به طور مداوم در حال بررسی کد خود هستید، استفاده از <code>cargo check</code> سرعت فرایند اطلاع دادن به شما از این که پروژه هنوز کامپایل می‌شود را افزایش می‌دهد! به همین دلیل، بسیاری از Rustaceans به طور دوره‌ای <code>cargo check</code> را در حین نوشتن کد خود اجرا می‌کنند تا مطمئن شوند که پروژه‌شان کامپایل می‌شود. سپس زمانی که آماده استفاده از باینری شدند، از دستور <code>cargo build</code> استفاده می‌کنند.</p>
<p>بیایید خلاصه‌ای از آنچه که تا به حال در مورد Cargo آموخته‌ایم مرور کنیم:</p>
<ul>
<li>ما می‌توانیم یک پروژه با استفاده از <code>cargo new</code> بسازیم.</li>
<li>ما می‌توانیم یک پروژه را با استفاده از <code>cargo build</code> بسازیم.</li>
<li>ما می‌توانیم یک پروژه را با یک مرحله از ساخت و اجرا با استفاده از <code>cargo run</code> بسازیم و اجرا کنیم.</li>
<li>ما می‌توانیم یک پروژه را بدون تولید باینری برای بررسی خطاها با استفاده از <code>cargo check</code> بسازیم.</li>
<li>به جای ذخیره نتیجه ساخت در همان دایرکتوری که کد ما قرار دارد، Cargo آن را در دایرکتوری <em>target/debug</em> ذخیره می‌کند.</li>
</ul>
<p>یک مزیت اضافی استفاده از Cargo این است که دستورات آن در همه سیستم‌عامل‌ها یکسان است. بنابراین، از این پس، دیگر دستورالعمل‌های خاصی برای لینوکس و macOS در مقابل ویندوز ارائه نخواهیم کرد.</p>
<h3 id="ساخت-برای-انتشار"><a class="header" href="#ساخت-برای-انتشار">ساخت برای انتشار</a></h3>
<p>وقتی پروژه شما آماده انتشار است، می‌توانید از دستور <code>cargo build --release</code> برای کامپایل کردن آن با بهینه‌سازی‌ها استفاده کنید. این دستور یک فایل اجرایی در دایرکتوری <em>target/release</em> به جای <em>target/debug</em> ایجاد می‌کند. بهینه‌سازی‌ها باعث می‌شوند که کد Rust شما سریع‌تر اجرا شود، اما فعال کردن آن‌ها زمان کامپایل برنامه را طولانی‌تر می‌کند. به همین دلیل، دو پروفایل مختلف وجود دارد: یکی برای توسعه که شما می‌خواهید سریعاً و به دفعات پروژه را بازسازی کنید، و دیگری برای ساختن برنامه نهایی که به کاربر تحویل خواهید داد، که به دفعات بازسازی نمی‌شود و باید سریع‌ترین اجرا را داشته باشد. اگر در حال اندازه‌گیری زمان اجرای کد خود هستید، حتماً از دستور <code>cargo build --release</code> استفاده کنید و با فایل اجرایی در <em>target/release</em> اندازه‌گیری کنید.</p>
<h3 id="cargo-به-عنوان-یک-کنوانسیون"><a class="header" href="#cargo-به-عنوان-یک-کنوانسیون">Cargo به عنوان یک کنوانسیون</a></h3>
<p>در پروژه‌های ساده، Cargo نسبت به استفاده از <code>rustc</code> مزیت زیادی ندارد، اما با پیچیده‌تر شدن برنامه‌ها، ارزش خود را نشان می‌دهد. زمانی که برنامه‌ها به چندین فایل نیاز پیدا می‌کنند یا وابستگی دارند، استفاده از Cargo برای هماهنگ کردن فرایند ساخت بسیار راحت‌تر می‌شود.</p>
<p>حتی اگر پروژه <code>hello_cargo</code> ساده باشد، اکنون از بسیاری از ابزارهای واقعی استفاده می‌کند که در طول مسیر Rust خود به آن‌ها نیاز خواهید داشت. در واقع، برای کار بر روی هر پروژه موجود، می‌توانید از دستورات زیر برای بررسی کد با استفاده از Git، تغییر به دایرکتوری آن پروژه و ساخت آن استفاده کنید:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>برای اطلاعات بیشتر در مورد Cargo، می‌توانید به <a href="https://doc.rust-lang.org/cargo/">مستندات آن</a> مراجعه کنید.</p>
<h2 id="خلاصه"><a class="header" href="#خلاصه">خلاصه</a></h2>
<p>شما در حال حاضر شروع بسیار خوبی برای سفر خود در Rust دارید! در این فصل، شما یاد گرفته‌اید که چگونه:</p>
<ul>
<li>آخرین نسخه پایدار Rust را با استفاده از <code>rustup</code> نصب کنید.</li>
<li>به نسخه جدیدتر Rust بروزرسانی کنید.</li>
<li>مستندات محلی نصب‌شده را باز کنید.</li>
<li>یک برنامه “Hello, world!” را با استفاده از <code>rustc</code> مستقیماً بنویسید و اجرا کنید.</li>
<li>یک پروژه جدید را با استفاده از کنوانسیون‌های Cargo بسازید و اجرا کنید.</li>
</ul>
<p>این زمان بسیار خوبی است که برنامه‌ای بزرگتر بسازید تا با خواندن و نوشتن کد Rust بیشتر آشنا شوید. بنابراین، در فصل 2، یک برنامه بازی حدس زدن خواهیم ساخت. اگر ترجیح می‌دهید ابتدا یاد بگیرید که مفاهیم برنامه‌نویسی رایج در Rust چگونه کار می‌کنند، فصل 3 را مطالعه کنید و سپس به فصل 2 بازگردید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="برنامهنویسی-یک-بازی-حدس-زدن"><a class="header" href="#برنامهنویسی-یک-بازی-حدس-زدن">برنامه‌نویسی یک بازی حدس زدن</a></h1>
<p>بیایید با کار روی یک پروژه عملی با هم به دنیای Rust وارد شویم! این فصل با نشان دادن نحوه استفاده از مفاهیم رایج Rust در یک برنامه واقعی، شما را با آن‌ها آشنا می‌کند. درباره <code>let</code>، <code>match</code>، متدها، توابع مرتبط (associated functions)، جعبه‌ها (crates)ی خارجی و موارد دیگر خواهید آموخت! در فصل‌های بعدی، این ایده‌ها را به طور مفصل بررسی خواهیم کرد. در این فصل، فقط اصول اولیه را تمرین می‌کنید.</p>
<p>ما یک مسئله کلاسیک برنامه‌نویسی برای مبتدیان را پیاده‌سازی خواهیم کرد: یک بازی حدس زدن. این بازی به این صورت عمل می‌کند: برنامه یک عدد صحیح تصادفی بین 1 تا 100 تولید می‌کند. سپس از بازیکن می‌خواهد که یک حدس وارد کند. پس از وارد کردن حدس، برنامه مشخص می‌کند که آیا حدس خیلی پایین است یا خیلی بالا. اگر حدس درست باشد، برنامه یک پیام تبریک چاپ می‌کند و از بازی خارج می‌شود.</p>
<h2 id="راهاندازی-یک-پروژه-جدید"><a class="header" href="#راهاندازی-یک-پروژه-جدید">راه‌اندازی یک پروژه جدید</a></h2>
<p>برای راه‌اندازی یک پروژه جدید، به دایرکتوری <em>projects</em> که در فصل 1 ایجاد کردید بروید و یک پروژه جدید با استفاده از Cargo ایجاد کنید، به این صورت:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>دستور اول، <code>cargo new</code>، نام پروژه (<code>guessing_game</code>) را به عنوان آرگومان اول می‌گیرد. دستور دوم به دایرکتوری پروژه جدید منتقل می‌شود.</p>
<p>فایل <em>Cargo.toml</em> تولیدشده را مشاهده کنید:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p>همان‌طور که در فصل 1 دیدید، <code>cargo new</code> یک برنامه “Hello, world!” برای شما تولید می‌کند. فایل <em>src/main.rs</em> را بررسی کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>حالا این برنامه “Hello, world!” را کامپایل کرده و در همان مرحله با استفاده از دستور <code>cargo run</code> اجرا کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>دستور <code>run</code> زمانی که نیاز دارید به سرعت روی یک پروژه تکرار کنید مفید است، همان‌طور که در این بازی انجام خواهیم داد، و به سرعت هر مرحله را قبل از ادامه به مرحله بعدی آزمایش می‌کنیم.</p>
<p>فایل <em>src/main.rs</em> را دوباره باز کنید. شما تمام کد را در این فایل خواهید نوشت.</p>
<h2 id="پردازش-یک-حدس"><a class="header" href="#پردازش-یک-حدس">پردازش یک حدس</a></h2>
<p>اولین بخش از برنامه بازی حدس زدن از کاربر درخواست ورودی می‌کند، آن ورودی را پردازش می‌کند و بررسی می‌کند که ورودی در قالب مورد انتظار باشد. برای شروع، به بازیکن اجازه می‌دهیم یک حدس وارد کند. کد موجود در لیستینگ 2-1 را در فایل <em>src/main.rs</em> وارد کنید.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}</code></pre>
<figcaption>Listing 2-1: کدی که یک حدس از کاربر دریافت کرده و آن را چاپ می‌کند</figcaption>
</figure>
<p>این کد اطلاعات زیادی دارد، پس بیایید خط به خط آن را بررسی کنیم. برای گرفتن ورودی کاربر و سپس چاپ نتیجه به‌عنوان خروجی، نیاز داریم که کتابخانه ورودی/خروجی <code>io</code> را به دامنه بیاوریم. کتابخانه <code>io</code> از کتابخانه استاندارد که با نام <code>std</code> شناخته می‌شود، می‌آید:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>به‌طور پیش‌فرض، Rust مجموعه‌ای از آیتم‌ها را که در کتابخانه استاندارد تعریف شده‌اند به دامنه هر برنامه وارد می‌کند. این مجموعه <em>prelude</em> نامیده می‌شود و می‌توانید همه چیز در آن را <a href="https://doc.rust-lang.org/std/prelude/index.html">در مستندات کتابخانه استاندارد</a> ببینید.</p>
<p>اگر نوعی که می‌خواهید استفاده کنید در prelude نباشد، باید آن نوع را به‌طور صریح با یک دستور <code>use</code> به دامنه بیاورید. استفاده از کتابخانه <code>std::io</code> به شما ویژگی‌های مفیدی مانند امکان پذیرش ورودی کاربر می‌دهد.</p>
<p>همان‌طور که در فصل 1 دیدید، تابع <code>main</code> نقطه ورود به برنامه است:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>نحو <code>fn</code> یک تابع جدید را اعلام می‌کند؛ پرانتزها <code>()</code> نشان می‌دهند که هیچ پارامتری وجود ندارد و کروشه باز <code>{</code> بدنه تابع را شروع می‌کند.</p>
<p>همچنین در فصل 1 آموختید که <code>println!</code> یک ماکرو است که یک رشته را به صفحه چاپ می‌کند:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>این کد یک پیغام اعلام می‌کند که بازی چیست و از کاربر درخواست ورودی می‌کند.</p>
<h3 id="ذخیره-مقادیر-با-متغیرها"><a class="header" href="#ذخیره-مقادیر-با-متغیرها">ذخیره مقادیر با متغیرها</a></h3>
<p>سپس، یک <em>متغیر</em> ایجاد می‌کنیم تا ورودی کاربر را ذخیره کند، مانند این:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>حالا برنامه جالب‌تر می‌شود! در این خط کوچک چیزهای زیادی در حال اتفاق است. ما از دستور <code>let</code> برای ایجاد متغیر استفاده می‌کنیم. در اینجا یک مثال دیگر آورده شده است:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>این خط یک متغیر جدید به نام <code>apples</code> ایجاد می‌کند و آن را به مقدار 5 متصل می‌کند. در Rust، متغیرها به‌طور پیش‌فرض غیرقابل‌تغییر هستند، به این معنا که پس از اختصاص مقدار به متغیر، مقدار تغییر نخواهد کرد. این مفهوم را به‌طور مفصل در بخش <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“متغیرها و تغییرپذیری”</a><!-- ignore --> در فصل 3 بررسی خواهیم کرد. برای متغیری که تغییرپذیر باشد، <code>mut</code> را قبل از نام متغیر اضافه می‌کنیم:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<blockquote>
<p>نکته: نحو <code>//</code> یک نظر (comment) را آغاز می‌کند که تا انتهای خط ادامه دارد. Rust همه چیز در نظرات را نادیده می‌گیرد. نظرات را در <a href="ch03-04-comments.html">فصل 3</a><!-- ignore --> با جزئیات بیشتری بررسی خواهیم کرد.</p>
</blockquote>
<p>بازگشت به برنامه بازی حدس زدن: اکنون می‌دانید که <code>let mut guess</code> یک متغیر تغییرپذیر به نام <code>guess</code> معرفی می‌کند. علامت مساوی (<code>=</code>) به Rust می‌گوید که می‌خواهیم چیزی را به این متغیر متصل کنیم. در سمت راست علامت مساوی، مقداری قرار دارد که <code>guess</code> به آن متصل می‌شود، که نتیجه فراخوانی <code>String::new</code> است، یک تابع که یک نمونه جدید از نوع <code>String</code> بازمی‌گرداند. <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> یک نوع رشته‌ای ارائه‌شده توسط کتابخانه استاندارد است که بخشی از متن قابل رشد و با رمزگذاری UTF-8 است.</p>
<p>نحو <code>::</code> در خط <code>::new</code> نشان می‌دهد که <code>new</code> یک تابع مرتبط با نوع <code>String</code> است. یک <em>تابع مرتبط</em> تابعی است که روی یک نوع پیاده‌سازی شده است، در اینجا <code>String</code>. این تابع <code>new</code> یک رشته جدید و خالی ایجاد می‌کند. شما در بسیاری از انواع یک تابع <code>new</code> پیدا خواهید کرد، زیرا این نام معمولاً برای تابعی که یک مقدار جدید از یک نوع خاص ایجاد می‌کند استفاده می‌شود.</p>
<p>در مجموع، خط <code>let mut guess = String::new();</code> یک متغیر تغییرپذیر ایجاد کرده است که در حال حاضر به یک نمونه جدید و خالی از <code>String</code> متصل شده است. خوب!</p>
<h3 id="دریافت-ورودی-کاربر"><a class="header" href="#دریافت-ورودی-کاربر">دریافت ورودی کاربر</a></h3>
<p>به یاد آورید که با <code>use std::io;</code> در اولین خط برنامه، قابلیت ورودی/خروجی را از کتابخانه استاندارد اضافه کردیم. اکنون تابع <code>stdin</code> را از ماژول <code>io</code> فراخوانی می‌کنیم که به ما امکان مدیریت ورودی کاربر را می‌دهد:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>اگر کتابخانه <code>io</code> را با <code>use std::io;</code> در ابتدای برنامه وارد نکرده بودیم، همچنان می‌توانستیم تابع را با نوشتن <code>std::io::stdin</code> فراخوانی کنیم. تابع <code>stdin</code> یک نمونه از نوع <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> بازمی‌گرداند که یک نوع برای مدیریت ورودی استاندارد ترمینال شما است.</p>
<p>در خط بعدی، متد <code>.read_line(&amp;mut guess)</code> را روی handle ورودی استاندارد فراخوانی می‌کنیم تا ورودی کاربر را دریافت کنیم. همچنین <code>&amp;mut guess</code> را به‌عنوان آرگومان به <code>read_line</code> ارسال می‌کنیم تا به آن بگوییم ورودی کاربر را در چه رشته‌ای ذخیره کند. وظیفه کامل <code>read_line</code> این است که هر چیزی را که کاربر در ورودی استاندارد تایپ می‌کند به رشته‌ای اضافه کند (بدون بازنویسی محتوای آن)، بنابراین این رشته را به‌عنوان آرگومان ارسال می‌کنیم. آرگومان رشته باید تغییرپذیر باشد تا متد بتواند محتوای رشته را تغییر دهد.</p>
<p>علامت <code>&amp;</code> نشان می‌دهد که این آرگومان یک <em>ارجاع</em> است، که به شما راهی می‌دهد تا به چندین بخش از کد اجازه دهید به یک قطعه داده دسترسی داشته باشند بدون اینکه نیاز به کپی کردن آن داده در حافظه چندین بار داشته باشید. ارجاعات یک ویژگی پیچیده هستند و یکی از مزایای اصلی Rust این است که استفاده از ارجاعات ایمن و آسان است. نیازی نیست جزئیات زیادی درباره آن بدانید تا این برنامه را کامل کنید. فعلاً، تنها چیزی که باید بدانید این است که، مانند متغیرها، ارجاعات به‌طور پیش‌فرض غیرقابل تغییر هستند. بنابراین، باید <code>&amp;mut guess</code> بنویسید به‌جای <code>&amp;guess</code> تا آن را تغییرپذیر کنید. (فصل 4 ارجاعات را به‌طور کامل توضیح خواهد داد.)</p>
<h3 id="مدیریت-خطای-احتمالی-با-result"><a class="header" href="#مدیریت-خطای-احتمالی-با-result">مدیریت خطای احتمالی با <code>Result</code></a></h3>
<p>ما همچنان روی همین خط کد کار می‌کنیم. اکنون در حال بحث درباره خط سوم هستیم، اما توجه داشته باشید که این هنوز بخشی از یک خط منطقی از کد است. قسمت بعدی این متد است:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>ما می‌توانستیم این کد را به این صورت بنویسیم:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>با این حال، یک خط طولانی خواندن آن را دشوار می‌کند، بنابراین بهتر است آن را تقسیم کنیم. اغلب توصیه می‌شود یک خط جدید و فضای سفید معرفی کنید تا خطوط طولانی را هنگام فراخوانی متدی با نحو <code>.method_name()</code> تقسیم کنید. حالا بیایید ببینیم این خط چه می‌کند.</p>
<p>همان‌طور که قبلاً ذکر شد، <code>read_line</code> هر چیزی که کاربر وارد می‌کند را در رشته‌ای که به آن ارسال می‌کنیم قرار می‌دهد، اما همچنین یک مقدار <code>Result</code> بازمی‌گرداند. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> یک <a href="ch06-00-enums.html"><em>enumeration</em></a><!-- ignore --> است که اغلب به عنوان <em>enum</em> نامیده می‌شود و نوعی است که می‌تواند در یکی از چندین حالت ممکن باشد. ما هر حالت ممکن را یک <em>متغیر</em> (variant) می‌نامیم.</p>
<p><a href="ch06-00-enums.html">فصل 6</a><!-- ignore --> به جزئیات بیشتری در مورد enumها خواهد پرداخت. هدف از انواع <code>Result</code> رمزگذاری اطلاعات مدیریت خطا است.</p>
<p>متغیرهای <code>Result</code> شامل <code>Ok</code> و <code>Err</code> هستند. متغیر <code>Ok</code> نشان می‌دهد که عملیات موفقیت‌آمیز بوده و مقداری که با موفقیت تولید شده است را در خود دارد. متغیر <code>Err</code> به معنای این است که عملیات شکست خورده و اطلاعاتی درباره چگونگی یا دلیل شکست عملیات در خود دارد.</p>
<p>مقادیر نوع <code>Result</code>، مانند مقادیر هر نوع دیگری، متدهایی تعریف‌شده بر روی خود دارند. یک نمونه از <code>Result</code> یک <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">متد <code>expect</code></a><!-- ignore --> دارد که می‌توانید آن را فراخوانی کنید. اگر این نمونه از <code>Result</code> یک مقدار <code>Err</code> باشد، <code>expect</code> باعث می‌شود برنامه متوقف شده و پیغام خطایی که به‌عنوان آرگومان به <code>expect</code> پاس داده‌اید را نمایش دهد. اگر متد <code>read_line</code> یک <code>Err</code> بازگرداند، احتمالاً به دلیل خطایی از سیستم‌عامل زیربنایی است. اگر این نمونه از <code>Result</code> یک مقدار <code>Ok</code> باشد، <code>expect</code> مقدار بازگشتی که <code>Ok</code> در خود دارد را می‌گیرد و فقط آن مقدار را بازمی‌گرداند تا بتوانید از آن استفاده کنید. در این مورد، آن مقدار تعداد بایت‌های ورودی کاربر است.</p>
<p>اگر <code>expect</code> را فراخوانی نکنید، برنامه کامپایل می‌شود، اما هشداری دریافت خواهید کرد:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust هشدار می‌دهد که از مقدار <code>Result</code> بازگشتی از <code>read_line</code> استفاده نکرده‌اید، که نشان می‌دهد برنامه یک خطای ممکن را مدیریت نکرده است.</p>
<p>روش درست برای جلوگیری از هشدار این است که واقعاً کد مدیریت خطا بنویسید، اما در مورد ما فقط می‌خواهیم وقتی مشکلی پیش آمد این برنامه متوقف شود، بنابراین می‌توانیم از <code>expect</code> استفاده کنیم. درباره بازیابی از خطاها در <a href="ch09-02-recoverable-errors-with-result.html">فصل 9</a><!-- ignore --> خواهید آموخت.</p>
<h3 id="چاپ-مقادیر-با-جاینگهدارهای-println"><a class="header" href="#چاپ-مقادیر-با-جاینگهدارهای-println">چاپ مقادیر با جای‌نگهدارهای <code>println!</code></a></h3>
<p>علاوه بر کروشه بسته، فقط یک خط دیگر برای بحث در کدی که تاکنون نوشته‌ایم باقی مانده است:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {}", guess);
<span class="boring">}</span></code></pre>
<p>این خط رشته‌ای را که اکنون ورودی کاربر را در خود دارد چاپ می‌کند. مجموعه <code>{}</code> از کروشه‌های باز و بسته یک جای‌نگهدار است: به <code>{}</code> به‌عنوان پنجه‌های کوچک خرچنگی فکر کنید که یک مقدار را در جای خود نگه می‌دارند. هنگام چاپ مقدار یک متغیر، نام متغیر می‌تواند داخل کروشه‌ها قرار گیرد. هنگام چاپ نتیجه ارزیابی یک عبارت، کروشه‌های باز و بسته خالی را در رشته فرمت قرار دهید، سپس رشته فرمت را با لیستی از عبارات جداشده با کاما دنبال کنید تا در هر جای‌نگهدار خالی به همان ترتیب چاپ شوند. چاپ یک متغیر و نتیجه یک عبارت در یک فراخوانی <code>println!</code> به این صورت خواهد بود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>این کد <code>x = 5 and y + 2 = 12</code> را چاپ می‌کند.</p>
<h3 id="آزمایش-بخش-اول"><a class="header" href="#آزمایش-بخش-اول">آزمایش بخش اول</a></h3>
<p>بیایید بخش اول بازی حدس زدن را آزمایش کنیم. با استفاده از دستور <code>cargo run</code> آن را اجرا کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>در این مرحله، بخش اول بازی تمام شده است: ما ورودی را از صفحه‌کلید می‌گیریم و سپس آن را چاپ می‌کنیم.</p>
<h2 id="تولید-یک-عدد-مخفی"><a class="header" href="#تولید-یک-عدد-مخفی">تولید یک عدد مخفی</a></h2>
<p>در مرحله بعد، باید یک عدد مخفی تولید کنیم که کاربر سعی خواهد کرد آن را حدس بزند. عدد مخفی باید هر بار متفاوت باشد تا بازی بارها قابل بازی و لذت‌بخش باشد. از یک عدد تصادفی بین 1 تا 100 استفاده می‌کنیم تا بازی خیلی سخت نباشد. Rust هنوز قابلیت تولید اعداد تصادفی را در کتابخانه استاندارد خود ندارد. با این حال، تیم Rust یک <a href="https://crates.io/crates/rand">crate <code>rand</code></a> با این قابلیت ارائه می‌دهد.</p>
<h3 id="استفاده-از-یک-crate-برای-دسترسی-به-قابلیتهای-بیشتر"><a class="header" href="#استفاده-از-یک-crate-برای-دسترسی-به-قابلیتهای-بیشتر">استفاده از یک crate برای دسترسی به قابلیت‌های بیشتر</a></h3>
<p>به یاد داشته باشید که یک crate مجموعه‌ای از فایل‌های کد منبع Rust است. پروژه‌ای که ما در حال ساخت آن هستیم یک <em>crate دودویی</em> است که یک فایل اجرایی است. crate <code>rand</code> یک <em>crate کتابخانه‌ای</em> است که حاوی کدی است که قرار است در برنامه‌های دیگر استفاده شود و به تنهایی قابل اجرا نیست.</p>
<p>هماهنگی Cargo با جعبه‌ها (crates)ی خارجی یکی از نقاط قوت آن است. قبل از اینکه بتوانیم کدی بنویسیم که از <code>rand</code> استفاده کند، باید فایل <em>Cargo.toml</em> را تغییر دهیم تا crate <code>rand</code> را به عنوان وابستگی اضافه کنیم. اکنون آن فایل را باز کنید و خط زیر را به انتهای آن، زیر بخش <code>[dependencies]</code> که Cargo برای شما ایجاد کرده است، اضافه کنید. مطمئن شوید که <code>rand</code> را دقیقاً همان‌طور که در اینجا آمده است با این شماره نسخه مشخص کنید، وگرنه مثال‌های کد در این آموزش ممکن است کار نکنند:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>در فایل <em>Cargo.toml</em>، هر چیزی که بعد از یک سرآیند بیاید بخشی از آن بخش است و تا زمانی که بخش دیگری شروع نشود ادامه می‌یابد. در <code>[dependencies]</code> به Cargo می‌گویید پروژه شما به کدام جعبه‌ها (crates)ی خارجی وابسته است و کدام نسخه از آن جعبه‌ها (crates) را نیاز دارید. در این مورد، ما crate <code>rand</code> را با مشخص‌کننده نسخه <code>0.8.5</code> مشخص می‌کنیم. Cargo <a href="http://semver.org">نسخه‌بندی معنایی</a><!-- ignore --> (گاهی اوقات <em>SemVer</em> نامیده می‌شود) را درک می‌کند، که یک استاندارد برای نوشتن شماره نسخه‌ها است. مشخص‌کننده <code>0.8.5</code> در واقع مخفف <code>^0.8.5</code> است که به این معناست که هر نسخه‌ای که حداقل 0.8.5 باشد ولی کمتر از 0.9.0 باشد.</p>
<p>Cargo این نسخه‌ها را دارای API عمومی سازگار با نسخه 0.8.5 در نظر می‌گیرد و این مشخصه تضمین می‌کند که آخرین نسخه patch را دریافت خواهید کرد که همچنان با کد موجود در این فصل کامپایل می‌شود. هیچ تضمینی وجود ندارد که نسخه 0.9.0 یا بالاتر همان API را داشته باشد که مثال‌های زیر استفاده می‌کنند.</p>
<p>اکنون، بدون تغییر هیچ کدی، بیایید پروژه را بسازیم، همان‌طور که در لیستینگ 2-2 نشان داده شده است.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<figure class="listing">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
<figcaption>Listing 2-2: خروجی اجرای <code>cargo build</code> پس از افزودن crate rand به عنوان وابستگی</figcaption>
</figure>
<p>ممکن است نسخه‌های متفاوتی را ببینید (اما همه آن‌ها با کد سازگار خواهند بود، به لطف SemVer!) و خطوط متفاوتی (بسته به سیستم‌عامل) داشته باشید، و این خطوط ممکن است به ترتیب متفاوتی ظاهر شوند.</p>
<p>وقتی یک وابستگی خارجی اضافه می‌کنیم، Cargo جدیدترین نسخه‌های هر چیزی که آن وابستگی نیاز دارد را از <em>رجیستری</em> دریافت می‌کند، که یک کپی از داده‌های <a href="https://crates.io/">Crates.io</a> است. Crates.io جایی است که افراد در اکوسیستم Rust پروژه‌های منبع‌باز Rust خود را برای استفاده دیگران ارسال می‌کنند.</p>
<p>پس از به‌روزرسانی رجیستری، Cargo بخش <code>[dependencies]</code> را بررسی می‌کند و هر crateی را که در لیست نیست و هنوز دانلود نشده است دانلود می‌کند. در این مورد، اگرچه ما فقط <code>rand</code> را به‌عنوان یک وابستگی لیست کرده‌ایم، Cargo سایر جعبه‌ها (crates)یی را که <code>rand</code> برای کارکردن به آن‌ها وابسته است نیز دریافت کرده است. پس از دانلود جعبه‌ها (crates)، Rust آن‌ها را کامپایل می‌کند و سپس پروژه را با وابستگی‌های موجود کامپایل می‌کند.</p>
<p>اگر بلافاصله دوباره دستور <code>cargo build</code> را اجرا کنید بدون اینکه هیچ تغییری ایجاد کرده باشید، خروجی‌ای به‌جز خط <code>Finished</code> دریافت نخواهید کرد. Cargo می‌داند که قبلاً وابستگی‌ها را دانلود و کامپایل کرده است، و شما هیچ تغییری در فایل <em>Cargo.toml</em> خود نداده‌اید. Cargo همچنین می‌داند که شما هیچ تغییری در کد خود نداده‌اید، بنابراین آن را هم دوباره کامپایل نمی‌کند. وقتی کاری برای انجام دادن وجود ندارد، فقط خارج می‌شود.</p>
<p>اگر فایل <em>src/main.rs</em> را باز کنید، یک تغییر جزئی در آن ایجاد کنید، و سپس آن را ذخیره کرده و دوباره بسازید، فقط دو خط خروجی خواهید دید:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>این خطوط نشان می‌دهند که Cargo فقط با تغییر کوچک شما در فایل <em>src/main.rs</em> بیلد را به‌روزرسانی کرده است. وابستگی‌های شما تغییری نکرده‌اند، بنابراین Cargo می‌داند که می‌تواند از آنچه قبلاً دانلود و کامپایل کرده است استفاده مجدد کند.</p>
<h4 id="اطمینان-از-بیلدهای-قابل-بازتولید-با-فایل-cargolock"><a class="header" href="#اطمینان-از-بیلدهای-قابل-بازتولید-با-فایل-cargolock">اطمینان از بیلدهای قابل بازتولید با فایل <em>Cargo.lock</em></a></h4>
<p>Cargo مکانیزمی دارد که اطمینان می‌دهد شما یا هر کس دیگری بتوانید هر بار که کد خود را بیلد می‌کنید، همان نتیجه را دریافت کنید: Cargo تنها از نسخه‌هایی از وابستگی‌ها که مشخص کرده‌اید استفاده می‌کند، مگر اینکه خلاف آن را اعلام کنید. برای مثال، فرض کنید هفته آینده نسخه 0.8.6 از crate <code>rand</code> منتشر می‌شود و آن نسخه شامل یک رفع باگ مهم است، اما همچنین شامل یک برگشت (regression) است که کد شما را خراب می‌کند. برای مدیریت این موضوع، Rust فایل <em>Cargo.lock</em> را در اولین باری که <code>cargo build</code> را اجرا می‌کنید ایجاد می‌کند، بنابراین اکنون این فایل در دایرکتوری <em>guessing_game</em> وجود دارد.</p>
<p>وقتی برای اولین بار پروژه‌ای را بیلد می‌کنید، Cargo همه نسخه‌های وابستگی‌هایی که با معیارها تطابق دارند را پیدا می‌کند و سپس آن‌ها را به فایل <em>Cargo.lock</em> می‌نویسد. وقتی در آینده پروژه خود را بیلد می‌کنید، Cargo می‌بیند که فایل <em>Cargo.lock</em> وجود دارد و از نسخه‌های مشخص‌شده در آن استفاده می‌کند، به جای اینکه تمام کار پیدا کردن نسخه‌ها را دوباره انجام دهد. این کار به شما اجازه می‌دهد که به‌طور خودکار یک بیلد قابل بازتولید داشته باشید. به عبارت دیگر، پروژه شما در نسخه 0.8.5 باقی خواهد ماند تا زمانی که به صورت صریح آن را به‌روزرسانی کنید، به لطف فایل <em>Cargo.lock</em>. چون فایل <em>Cargo.lock</em> برای بیلدهای قابل بازتولید مهم است، معمولاً همراه با بقیه کد پروژه در سیستم کنترل نسخه (source control) ذخیره می‌شود.</p>
<h4 id="بهروزرسانی-یک-crate-برای-دریافت-نسخه-جدید"><a class="header" href="#بهروزرسانی-یک-crate-برای-دریافت-نسخه-جدید">به‌روزرسانی یک crate برای دریافت نسخه جدید</a></h4>
<p>وقتی <em>می‌خواهید</em> یک crate را به‌روزرسانی کنید، Cargo دستور <code>update</code> را فراهم می‌کند که فایل <em>Cargo.lock</em> را نادیده می‌گیرد و تمام نسخه‌های جدیدی که با مشخصات شما در فایل <em>Cargo.toml</em> سازگار هستند را پیدا می‌کند. سپس Cargo آن نسخه‌ها را به فایل <em>Cargo.lock</em> می‌نویسد. در این مورد، Cargo تنها به دنبال نسخه‌هایی می‌گردد که بالاتر از 0.8.5 و کمتر از 0.9.0 باشند. اگر crate <code>rand</code> دو نسخه جدید 0.8.6 و 0.9.0 را منتشر کرده باشد، با اجرای <code>cargo update</code> چنین چیزی را خواهید دید:</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo نسخه 0.9.0 را نادیده می‌گیرد. در این مرحله، شما همچنین تغییری در فایل <em>Cargo.lock</em> مشاهده می‌کنید که نشان می‌دهد نسخه crate <code>rand</code> که اکنون استفاده می‌کنید 0.8.6 است. برای استفاده از نسخه 0.9.0 <code>rand</code> یا هر نسخه‌ای در سری 0.9.<em>x</em>، باید فایل <em>Cargo.toml</em> را به این شکل تغییر دهید:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>دفعه بعد که <code>cargo build</code> را اجرا کنید، Cargo رجیستری جعبه‌ها (crates)ی موجود را به‌روزرسانی می‌کند و نیازمندی‌های شما برای <code>rand</code> را بر اساس نسخه جدیدی که مشخص کرده‌اید ارزیابی می‌کند.</p>
<p>چیزهای بیشتری درباره <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> و <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">اکوسیستم آن</a><!-- ignore --> وجود دارد که در فصل 14 بحث خواهیم کرد، اما فعلاً این تمام چیزی است که باید بدانید. Cargo استفاده از کتابخانه‌ها را بسیار آسان می‌کند، بنابراین Rustaceans می‌توانند پروژه‌های کوچک‌تری بنویسند که از تعدادی بسته تشکیل شده‌اند.</p>
<h3 id="تولید-یک-عدد-تصادفی"><a class="header" href="#تولید-یک-عدد-تصادفی">تولید یک عدد تصادفی</a></h3>
<p>بیایید استفاده از <code>rand</code> را برای تولید یک عدد برای حدس زدن شروع کنیم. مرحله بعد به‌روزرسانی فایل <em>src/main.rs</em> است، همان‌طور که در لیستینگ 2-3 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption>Listing 2-3: اضافه کردن کدی برای تولید یک عدد تصادفی</figcaption>
</figure>
<p>ابتدا خط <code>use rand::Rng;</code> را اضافه می‌کنیم. صفت (trait) <code>Rng</code> متدهایی را تعریف می‌کند که تولیدکنندگان اعداد تصادفی پیاده‌سازی می‌کنند، و این صفت باید در دامنه باشد تا بتوانیم از آن متدها استفاده کنیم. فصل 10 به‌طور مفصل به بررسی صفت‌ها خواهد پرداخت.</p>
<p>سپس دو خط در وسط اضافه می‌کنیم. در خط اول، تابع <code>rand::thread_rng</code> را فراخوانی می‌کنیم که تولیدکننده اعداد تصادفی خاصی را که می‌خواهیم استفاده کنیم به ما می‌دهد: تولیدکننده‌ای که محلی برای نخ فعلی اجرا است و توسط سیستم‌عامل seed می‌شود. سپس متد <code>gen_range</code> را روی تولیدکننده اعداد تصادفی فراخوانی می‌کنیم. این متد توسط صفت <code>Rng</code> که با دستور <code>use rand::Rng;</code> وارد دامنه کردیم، تعریف شده است. متد <code>gen_range</code> یک عبارت بازه‌ای را به‌عنوان آرگومان می‌گیرد و یک عدد تصادفی در آن بازه تولید می‌کند. نوع عبارت بازه‌ای که در اینجا استفاده می‌کنیم به صورت <code>start..=end</code> است و شامل حد پایین و بالا می‌شود، بنابراین باید <code>1..=100</code> را مشخص کنیم تا عددی بین 1 تا 100 درخواست کنیم.</p>
<blockquote>
<p>نکته: شما نمی‌توانید به‌طور پیش‌فرض بدانید که کدام صفت‌ها را باید استفاده کنید و کدام متدها و توابع را از یک crate فراخوانی کنید، بنابراین هر crate دارای مستنداتی با دستورالعمل‌هایی برای استفاده از آن است. ویژگی جالب دیگر Cargo این است که اجرای دستور <code>cargo doc --open</code> مستندات ارائه‌شده توسط تمام وابستگی‌های شما را به‌صورت محلی می‌سازد و در مرورگر شما باز می‌کند. اگر به دیگر قابلیت‌های crate <code>rand</code> علاقه‌مند هستید، برای مثال دستور <code>cargo doc --open</code> را اجرا کنید و روی <code>rand</code> در نوار کناری سمت چپ کلیک کنید.</p>
</blockquote>
<p>خط جدید دوم عدد مخفی را چاپ می‌کند. این خط در حین توسعه برنامه برای آزمایش آن مفید است، اما در نسخه نهایی آن را حذف خواهیم کرد. اگر برنامه به محض شروع پاسخ را چاپ کند، خیلی بازی هیجان‌انگیزی نخواهد بود!</p>
<p>برنامه را چند بار اجرا کنید:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>شما باید اعداد تصادفی متفاوتی دریافت کنید و تمام آن‌ها باید بین 1 تا 100 باشند. عالی!</p>
<h2 id="مقایسه-حدس-با-عدد-مخفی"><a class="header" href="#مقایسه-حدس-با-عدد-مخفی">مقایسه حدس با عدد مخفی</a></h2>
<p>حالا که ورودی کاربر و یک عدد تصادفی داریم، می‌توانیم آن‌ها را مقایسه کنیم. این مرحله در لیستینگ 2-4 نشان داده شده است. توجه داشته باشید که این کد هنوز کامپایل نخواهد شد، همان‌طور که توضیح خواهیم داد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<figcaption>Listing 2-4: مدیریت مقادیر بازگشتی ممکن از مقایسه دو عدد</figcaption>
</figure>
<p>ابتدا یک دستور <code>use</code> دیگر اضافه می‌کنیم تا نوعی به نام <code>std::cmp::Ordering</code> را از کتابخانه استاندارد وارد دامنه کنیم. نوع <code>Ordering</code> یک enum دیگر است و دارای متغیرهای <code>Less</code>، <code>Greater</code> و <code>Equal</code> است. این‌ها سه نتیجه ممکن هنگام مقایسه دو مقدار هستند.</p>
<p>سپس پنج خط جدید در انتهای کد اضافه می‌کنیم که از نوع <code>Ordering</code> استفاده می‌کنند. متد <code>cmp</code> دو مقدار را مقایسه می‌کند و می‌تواند روی هر چیزی که قابل مقایسه باشد فراخوانی شود. این متد یک ارجاع به مقداری که می‌خواهید مقایسه کنید می‌گیرد: در اینجا مقایسه بین <code>guess</code> و <code>secret_number</code> است. سپس یکی از متغیرهای enum <code>Ordering</code> که با دستور <code>use</code> به دامنه آوردیم را بازمی‌گرداند. از یک عبارت <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> برای تصمیم‌گیری در مورد اقدام بعدی بر اساس اینکه کدام متغیر <code>Ordering</code> از فراخوانی <code>cmp</code> با مقادیر <code>guess</code> و <code>secret_number</code> بازگشته است استفاده می‌کنیم.</p>
<p>یک عبارت <code>match</code> از <em>شاخه‌ها (arms)</em> تشکیل شده است. یک شاخه شامل یک <em>الگو</em> برای مطابقت است و کدی که باید اجرا شود اگر مقدار داده‌شده به <code>match</code> با الگوی آن شاخه تطابق داشته باشد. Rust مقدار داده‌شده به <code>match</code> را گرفته و به ترتیب هر الگوی شاخه را بررسی می‌کند. الگوها و سازه <code>match</code> از ویژگی‌های قدرتمند Rust هستند: آن‌ها به شما اجازه می‌دهند موقعیت‌های مختلفی که کد شما ممکن است با آن‌ها روبرو شود را بیان کنید و اطمینان حاصل کنید که همه آن‌ها را مدیریت می‌کنید. این ویژگی‌ها به‌طور مفصل در فصل 6 و فصل 19 پوشش داده خواهند شد.</p>
<p>بیایید با یک مثال از عبارت <code>match</code> که در اینجا استفاده کرده‌ایم، آن را بررسی کنیم. فرض کنید کاربر 50 را حدس زده و عدد مخفی که این بار به‌طور تصادفی تولید شده 38 است.</p>
<p>وقتی کد 50 را با 38 مقایسه می‌کند، متد <code>cmp</code> مقدار <code>Ordering::Greater</code> را بازمی‌گرداند زیرا 50 بزرگ‌تر از 38 است. عبارت <code>match</code> مقدار <code>Ordering::Greater</code> را گرفته و شروع به بررسی هر الگوی شاخه می‌کند. به الگوی شاخه اول، <code>Ordering::Less</code> نگاه می‌کند و می‌بیند که مقدار <code>Ordering::Greater</code> با <code>Ordering::Less</code> تطابق ندارد، بنابراین کد موجود در آن شاخه را نادیده می‌گیرد و به شاخه بعدی می‌رود. الگوی شاخه بعدی <code>Ordering::Greater</code> است که با <code>Ordering::Greater</code> تطابق دارد! کد مرتبط با آن شاخه اجرا شده و عبارت <code>Too big!</code> را روی صفحه چاپ می‌کند. عبارت <code>match</code> پس از اولین تطابق موفقیت‌آمیز پایان می‌یابد، بنابراین در این سناریو به شاخه آخر نگاه نمی‌کند.</p>
<p>با این حال، کد موجود در لیستینگ 2-4 هنوز کامپایل نخواهد شد. بیایید آن را امتحان کنیم:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>هسته خطا بیان می‌کند که <em>انواع ناسازگار</em> وجود دارند. Rust دارای یک سیستم نوع قوی و ایستا است. با این حال، همچنین دارای استنباط نوع است. وقتی <code>let mut guess = String::new()</code> نوشتیم، Rust توانست استنباط کند که <code>guess</code> باید یک <code>String</code> باشد و نیازی نبود که نوع را به‌صورت صریح بنویسیم. از طرف دیگر، <code>secret_number</code> یک نوع عددی است. چند نوع عددی در Rust می‌توانند مقداری بین 1 و 100 داشته باشند: <code>i32</code>، یک عدد 32 بیتی؛ <code>u32</code>، یک عدد بدون علامت 32 بیتی؛ <code>i64</code>، یک عدد 64 بیتی؛ و دیگران. مگر اینکه خلاف آن مشخص شده باشد، Rust به‌طور پیش‌فرض از <code>i32</code> استفاده می‌کند، که نوع <code>secret_number</code> است مگر اینکه اطلاعات نوع دیگری اضافه کنید که باعث شود Rust نوع عددی دیگری را استنباط کند. دلیل خطا این است که Rust نمی‌تواند یک رشته و یک نوع عددی را مقایسه کند.</p>
<p>در نهایت، می‌خواهیم <code>String</code> که برنامه به‌عنوان ورودی می‌خواند را به یک نوع عددی تبدیل کنیم تا بتوانیم آن را به‌صورت عددی با عدد مخفی مقایسه کنیم. این کار را با اضافه کردن این خط به بدنه تابع <code>main</code> انجام می‌دهیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>خط موردنظر این است:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>ما یک متغیر به نام <code>guess</code> ایجاد می‌کنیم. اما صبر کنید، آیا برنامه قبلاً یک متغیر به نام <code>guess</code> ندارد؟ دارد، اما Rust به‌طور مفیدی به ما اجازه می‌دهد مقدار قبلی <code>guess</code> را با یک مقدار جدید پوشش دهیم. <em>پوشش‌دهی</em> به ما اجازه می‌دهد که از نام متغیر <code>guess</code> دوباره استفاده کنیم، به‌جای اینکه مجبور شویم دو متغیر منحصربه‌فرد مانند <code>guess_str</code> و <code>guess</code> ایجاد کنیم. این موضوع را در <a href="ch03-01-variables-and-mutability.html#shadowing">فصل 3</a><!-- ignore --> با جزئیات بیشتری بررسی خواهیم کرد، اما فعلاً بدانید که این ویژگی اغلب زمانی استفاده می‌شود که بخواهید مقدار را از یک نوع به نوع دیگری تبدیل کنید.</p>
<p>ما این متغیر جدید را به عبارت <code>guess.trim().parse()</code> متصل می‌کنیم. <code>guess</code> در این عبارت به متغیر اصلی <code>guess</code> که ورودی به‌صورت رشته‌ای بود اشاره دارد. متد <code>trim</code> روی یک نمونه <code>String</code> تمام فضای سفید در ابتدا و انتهای رشته را حذف می‌کند، که قبل از تبدیل رشته به <code>u32</code> که فقط می‌تواند داده‌های عددی داشته باشد، باید این کار را انجام دهیم. کاربر باید کلید <kbd>enter</kbd> را فشار دهد تا <code>read_line</code> مقدار ورودی را دریافت کند، که یک کاراکتر newline به رشته اضافه می‌کند. برای مثال، اگر کاربر کلید <kbd>5</kbd> را تایپ کند و <kbd>enter</kbd> را فشار دهد، <code>guess</code> به این شکل خواهد بود: <code>5\n</code>. <code>\n</code> نشان‌دهنده “خط جدید” است. (در ویندوز، فشار دادن <kbd>enter</kbd> منجر به carriage return و newline، یعنی <code>\r\n</code> می‌شود.) متد <code>trim</code> <code>\n</code> یا <code>\r\n</code> را حذف می‌کند و نتیجه فقط <code>5</code> است.</p>
<p>متد <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code> روی رشته‌ها</a><!-- ignore --> یک رشته را به نوع دیگری تبدیل می‌کند. اینجا از آن برای تبدیل یک رشته به عدد استفاده می‌کنیم. باید به Rust نوع عدد دقیق موردنظرمان را با استفاده از <code>let guess: u32</code> بگوییم. علامت <code>:</code> بعد از <code>guess</code> به Rust می‌گوید که نوع متغیر را مشخص خواهیم کرد. Rust چند نوع عدد داخلی دارد؛ <code>u32</code> که اینجا دیده می‌شود، یک عدد صحیح 32 بیتی بدون علامت است. این یک انتخاب پیش‌فرض خوب برای یک عدد مثبت کوچک است. درباره دیگر انواع عددی در <a href="ch03-02-data-types.html#integer-types">فصل 3</a><!-- ignore --> خواهید آموخت.</p>
<p>علاوه بر این، حاشیه‌نویسی <code>u32</code> در این برنامه نمونه و مقایسه با <code>secret_number</code> به این معناست که Rust استنباط خواهد کرد که <code>secret_number</code> نیز باید یک <code>u32</code> باشد. بنابراین اکنون مقایسه بین دو مقدار از یک نوع خواهد بود!</p>
<p>متد <code>parse</code> فقط روی کاراکترهایی کار می‌کند که منطقی بتوان آن‌ها را به اعداد تبدیل کرد و بنابراین به‌راحتی می‌تواند باعث خطا شود. برای مثال، اگر رشته‌ای شامل <code>A👍%</code> باشد، هیچ راهی برای تبدیل آن به عدد وجود ندارد. چون ممکن است این عملیات شکست بخورد، متد <code>parse</code> نوع <code>Result</code> را برمی‌گرداند، دقیقاً مانند متد <code>read_line</code> (که قبلاً در <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“مدیریت خطای احتمالی با <code>Result</code>”</a><!-- ignore --> بحث کردیم). ما این <code>Result</code> را همان‌طور که قبلاً انجام دادیم با استفاده مجدد از متد <code>expect</code> مدیریت خواهیم کرد. اگر <code>parse</code> متغیر <code>Err</code> از نوع <code>Result</code> را برگرداند زیرا نتوانست یک عدد از رشته ایجاد کند، فراخوانی <code>expect</code> بازی را متوقف کرده و پیام مشخص‌شده را چاپ می‌کند. اگر <code>parse</code> بتواند با موفقیت رشته را به عدد تبدیل کند، متغیر <code>Ok</code> از نوع <code>Result</code> را برمی‌گرداند و <code>expect</code> عدد مورد نظر را از مقدار <code>Ok</code> بازمی‌گرداند.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>عالی! حتی با اینکه قبل از حدس کاربر فاصله‌هایی اضافه شده بود، برنامه همچنان تشخیص داد که کاربر عدد 76 را حدس زده است. برنامه را چند بار اجرا کنید تا رفتارهای مختلف را با انواع مختلف ورودی بررسی کنید: عدد را درست حدس بزنید، عددی که خیلی بزرگ است حدس بزنید، و عددی که خیلی کوچک است را حدس بزنید.</p>
<p>اکنون بیشتر بخش‌های بازی کار می‌کند، اما کاربر فقط می‌تواند یک حدس بزند. بیایید این موضوع را با اضافه کردن یک حلقه تغییر دهیم!</p>
<h2 id="اجازه-دادن-به-چندین-حدس-با-استفاده-از-حلقه"><a class="header" href="#اجازه-دادن-به-چندین-حدس-با-استفاده-از-حلقه">اجازه دادن به چندین حدس با استفاده از حلقه</a></h2>
<p>کلمه کلیدی <code>loop</code> یک حلقه بی‌نهایت ایجاد می‌کند. ما یک حلقه اضافه می‌کنیم تا به کاربران فرصت‌های بیشتری برای حدس زدن عدد بدهیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>همان‌طور که می‌بینید، ما همه چیز از درخواست ورودی حدس به بعد را داخل یک حلقه قرار داده‌ایم. مطمئن شوید که خطوط داخل حلقه را چهار فاصله دیگر تورفتگی (indentation) بدهید و برنامه را دوباره اجرا کنید. اکنون برنامه به‌طور بی‌پایان از شما حدس می‌خواهد، که در واقع یک مشکل جدید ایجاد می‌کند. به نظر می‌رسد که کاربر نمی‌تواند از برنامه خارج شود!</p>
<p>کاربر همیشه می‌تواند برنامه را با استفاده از میانبر صفحه‌کلید <kbd>ctrl</kbd>-<kbd>c</kbd> متوقف کند. اما راه دیگری برای فرار از این هیولای سیری‌ناپذیر وجود دارد، همان‌طور که در بحث <code>parse</code> در <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“مقایسه حدس با عدد مخفی”</a><!-- ignore --> ذکر شد: اگر کاربر پاسخی غیرعددی وارد کند، برنامه متوقف می‌شود. می‌توانیم از این موضوع استفاده کنیم تا به کاربر اجازه دهیم خارج شود، همان‌طور که در اینجا نشان داده شده است:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>تایپ کردن <code>quit</code> باعث خروج از بازی می‌شود، اما همان‌طور که متوجه خواهید شد، وارد کردن هر ورودی غیرعددی دیگر نیز همین کار را انجام می‌دهد. این رفتار چندان بهینه نیست؛ ما می‌خواهیم بازی همچنین وقتی عدد درست حدس زده شد متوقف شود.</p>
<h3 id="خروج-پس-از-حدس-درست"><a class="header" href="#خروج-پس-از-حدس-درست">خروج پس از حدس درست</a></h3>
<p>بیایید برنامه را طوری تنظیم کنیم که وقتی کاربر برنده می‌شود، با افزودن یک دستور <code>break</code> از بازی خارج شود:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>اضافه کردن خط <code>break</code> بعد از <code>You win!</code> باعث می‌شود که برنامه وقتی کاربر عدد مخفی را به‌درستی حدس می‌زند، از حلقه خارج شود. خروج از حلقه همچنین به معنای خروج از برنامه است، زیرا حلقه آخرین بخش از <code>main</code> است.</p>
<h3 id="مدیریت-ورودی-نامعتبر"><a class="header" href="#مدیریت-ورودی-نامعتبر">مدیریت ورودی نامعتبر</a></h3>
<p>برای بهبود بیشتر رفتار بازی، به جای اینکه برنامه هنگام ورود ورودی غیرعددی توسط کاربر متوقف شود، بیایید بازی را طوری تنظیم کنیم که ورودی غیرعددی را نادیده بگیرد تا کاربر بتواند به حدس زدن ادامه دهد. این کار را می‌توان با تغییر خطی که در آن <code>guess</code> از یک <code>String</code> به یک <code>u32</code> تبدیل می‌شود انجام داد، همان‌طور که در لیستینگ 2-5 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 2-5: نادیده گرفتن یک حدس غیرعددی و درخواست یک حدس دیگر به جای متوقف کردن برنامه</figcaption>
</figure>
<p>ما از یک فراخوانی <code>expect</code> به یک عبارت <code>match</code> تغییر می‌دهیم تا به جای متوقف کردن برنامه در صورت خطا، خطا را مدیریت کنیم. به یاد داشته باشید که <code>parse</code> یک نوع <code>Result</code> بازمی‌گرداند و <code>Result</code> یک enum است که دارای متغیرهای <code>Ok</code> و <code>Err</code> است. ما در اینجا از یک عبارت <code>match</code> استفاده می‌کنیم، همان‌طور که با نتیجه <code>Ordering</code> از متد <code>cmp</code> انجام دادیم.</p>
<p>اگر <code>parse</code> بتواند رشته را با موفقیت به یک عدد تبدیل کند، یک مقدار <code>Ok</code> بازمی‌گرداند که عدد تولیدشده را در خود دارد. مقدار <code>Ok</code> با الگوی شاخه اول مطابقت خواهد داشت و عبارت <code>match</code> فقط مقدار <code>num</code> که <code>parse</code> تولید کرده و در داخل مقدار <code>Ok</code> قرار داده است را بازمی‌گرداند. آن عدد در همان جایی که می‌خواهیم، در متغیر جدید <code>guess</code> که ایجاد می‌کنیم، قرار می‌گیرد.</p>
<p>اگر <code>parse</code> <em>نتواند</em> رشته را به عدد تبدیل کند، یک مقدار <code>Err</code> بازمی‌گرداند که اطلاعات بیشتری درباره خطا دارد. مقدار <code>Err</code> با الگوی <code>Ok(num)</code> در شاخه اول <code>match</code> مطابقت ندارد، اما با الگوی <code>Err(_)</code> در شاخه دوم مطابقت دارد. کاراکتر زیرخط، <code>_</code>، یک مقدار کلی است؛ در این مثال، ما می‌گوییم که می‌خواهیم تمام مقادیر <code>Err</code> را بدون توجه به اطلاعات داخل آن‌ها مطابقت دهیم. بنابراین برنامه کد شاخه دوم، <code>continue</code> را اجرا می‌کند، که به برنامه می‌گوید به تکرار بعدی <code>loop</code> برود و یک حدس دیگر درخواست کند. بنابراین، برنامه به‌طور مؤثر تمام خطاهایی که <code>parse</code> ممکن است با آن‌ها مواجه شود را نادیده می‌گیرد!</p>
<p>حالا همه چیز در برنامه باید طبق انتظار کار کند. بیایید آن را امتحان کنیم:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>عالی! با یک تغییر کوچک نهایی، بازی حدس زدن را کامل خواهیم کرد. به یاد داشته باشید که برنامه همچنان عدد مخفی را چاپ می‌کند. این کار برای آزمایش خوب بود، اما بازی را خراب می‌کند. بیایید دستور <code>println!</code> که عدد مخفی را خروجی می‌دهد حذف کنیم. لیستینگ 2-6 کد نهایی را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<figcaption>Listing 2-6: کد کامل بازی حدس زدن</figcaption>
</figure>
<p>در این مرحله، شما با موفقیت بازی حدس زدن را ساخته‌اید. تبریک می‌گویم!</p>
<h2 id="خلاصه-1"><a class="header" href="#خلاصه-1">خلاصه</a></h2>
<p>این پروژه یک روش عملی برای معرفی بسیاری از مفاهیم جدید Rust به شما بود: <code>let</code>، <code>match</code>، توابع، استفاده از جعبه‌ها (crates)ی خارجی، و موارد دیگر. در چند فصل بعدی، این مفاهیم را با جزئیات بیشتری یاد خواهید گرفت. فصل 3 مفاهیمی را که بیشتر زبان‌های برنامه‌نویسی دارند، مانند متغیرها، انواع داده و توابع را پوشش می‌دهد و نشان می‌دهد چگونه از آن‌ها در Rust استفاده کنید. فصل 4 مالکیت را بررسی می‌کند، ویژگی‌ای که Rust را از زبان‌های دیگر متمایز می‌کند. فصل 5 ساختارها و نحو متدها را مورد بحث قرار می‌دهد و فصل 6 توضیح می‌دهد که enumها چگونه کار می‌کنند.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مفاهیم-رایج-برنامهنویسی"><a class="header" href="#مفاهیم-رایج-برنامهنویسی">مفاهیم رایج برنامه‌نویسی</a></h1>
<p>این فصل مفاهیمی را پوشش می‌دهد که در تقریباً هر زبان برنامه‌نویسی وجود دارند و نحوه کار آن‌ها در Rust را توضیح می‌دهد. بسیاری از زبان‌های برنامه‌نویسی در هسته خود اشتراکات زیادی دارند. هیچ‌یک از مفاهیم ارائه‌شده در این فصل مختص Rust نیستند، اما ما آن‌ها را در زمینه Rust مورد بحث قرار می‌دهیم و قراردادهای مرتبط با استفاده از این مفاهیم را توضیح می‌دهیم.</p>
<p>به طور خاص، شما با متغیرها، انواع پایه، توابع، نظرات و جریان کنترل آشنا خواهید شد. این مبانی در هر برنامه Rust وجود خواهند داشت و یادگیری آن‌ها در اوایل کار، پایه قوی‌ای برای شروع به شما می‌دهد.</p>
<section class="note" aria-role="note">
<h4 id="کلمات-کلیدی"><a class="header" href="#کلمات-کلیدی">کلمات کلیدی</a></h4>
<p>زبان Rust مجموعه‌ای از <em>کلمات کلیدی</em> دارد که فقط برای استفاده توسط زبان رزرو شده‌اند، همانند سایر زبان‌ها. به خاطر داشته باشید که نمی‌توانید از این کلمات به‌عنوان نام متغیرها یا توابع استفاده کنید. اکثر کلمات کلیدی معانی خاصی دارند و شما از آن‌ها برای انجام وظایف مختلف در برنامه‌های Rust خود استفاده خواهید کرد؛ تعدادی از آن‌ها در حال حاضر هیچ عملکردی ندارند اما برای قابلیت‌هایی که ممکن است در آینده به Rust اضافه شوند رزرو شده‌اند. شما می‌توانید لیست کلمات کلیدی را در <a href="appendix-01-keywords.html">ضمیمه الف</a><!-- ignore --> پیدا کنید.</p>
</section>
<div style="break-before: page; page-break-before: always;"></div><h2 id="متغیرها-و-تغییرپذیری"><a class="header" href="#متغیرها-و-تغییرپذیری">متغیرها و تغییرپذیری</a></h2>
<p>همان‌طور که در بخش [“ذخیره مقادیر با استفاده از متغیرها”][storing-values-with-variables]<!-- ignore --> ذکر شد، به طور پیش‌فرض متغیرها در Rust غیرقابل‌تغییر هستند. این یکی از راه‌هایی است که Rust شما را به نوشتن کدی که از ایمنی و همزمانی آسان ارائه‌شده توسط این زبان بهره می‌برد، تشویق می‌کند. با این حال، شما همچنان گزینه‌ای دارید تا متغیرهای خود را قابل‌تغییر کنید. بیایید بررسی کنیم که چگونه و چرا Rust شما را تشویق به استفاده از غیرقابل‌تغییر بودن می‌کند و چرا ممکن است گاهی بخواهید این حالت را تغییر دهید.</p>
<p>وقتی یک متغیر غیرقابل‌تغییر است، وقتی مقداری به یک نام متصل شد، نمی‌توانید آن مقدار را تغییر دهید. برای نشان دادن این موضوع، یک پروژه جدید به نام <em>variables</em> در دایرکتوری <em>projects</em> خود ایجاد کنید با استفاده از دستور <code>cargo new variables</code>.</p>
<p>سپس، در دایرکتوری جدید <em>variables</em> خود، فایل <em>src/main.rs</em> را باز کنید و کد آن را با کد زیر جایگزین کنید، که هنوز کامپایل نخواهد شد:</p>
<p><span class="filename">تام فایل: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre>
<p>فایل را ذخیره کنید و برنامه را با استفاده از <code>cargo run</code> اجرا کنید. باید یک پیام خطا در مورد غیرقابل‌تغییر بودن دریافت کنید، همان‌طور که در این خروجی نشان داده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>این مثال نشان می‌دهد که چگونه کامپایلر به شما کمک می‌کند تا خطاها را در برنامه‌های خود پیدا کنید. خطاهای کامپایلر ممکن است ناامیدکننده باشند، اما در واقع به این معنا هستند که برنامه شما هنوز به طور ایمن کاری را که می‌خواهید انجام نمی‌دهد؛ این به هیچ وجه به این معنا نیست که شما برنامه‌نویس خوبی نیستید! حتی برنامه‌نویسان باتجربه Rust نیز همچنان خطاهای کامپایلر دریافت می‌کنند.</p>
<p>شما پیام خطای <code>cannot assign twice to immutable variable `x`</code> را دریافت کردید زیرا سعی کردید مقدار دوم را به متغیر غیرقابل‌تغییر <code>x</code> تخصیص دهید.</p>
<p>این بسیار مهم است که ما خطاهای زمان کامپایل را دریافت کنیم وقتی سعی می‌کنیم مقدار یک متغیر غیرقابل‌تغییر را تغییر دهیم زیرا این وضعیت می‌تواند به باگ منجر شود. اگر یک بخش از کد ما با این فرض عمل کند که یک مقدار هرگز تغییر نمی‌کند و بخش دیگری از کد آن مقدار را تغییر دهد، ممکن است بخش اول کد کاری که برای انجام آن طراحی شده بود را به درستی انجام ندهد. علت این نوع باگ می‌تواند بعد از وقوع به سختی قابل‌ردیابی باشد، به‌ویژه وقتی که بخش دوم کد فقط <em>گاهی اوقات</em> مقدار را تغییر می‌دهد. کامپایلر Rust تضمین می‌کند که وقتی بیان می‌کنید یک مقدار تغییر نخواهد کرد، واقعاً تغییر نخواهد کرد، بنابراین نیازی نیست که خودتان این موضوع را پیگیری کنید. به این ترتیب کد شما راحت‌تر قابل‌درک خواهد بود.</p>
<p>اما قابلیت تغییر می‌تواند بسیار مفید باشد و نوشتن کد را راحت‌تر کند. اگرچه متغیرها به طور پیش‌فرض غیرقابل‌تغییر هستند، می‌توانید با اضافه کردن <code>mut</code> قبل از نام متغیر آنها را قابل‌تغییر کنید، همان‌طور که در [فصل ۲][storing-values-with-variables]<!-- ignore --> انجام دادید. اضافه کردن <code>mut</code> همچنین به خوانندگان آینده کد نیت شما را نشان می‌دهد که قسمت‌های دیگر کد مقدار این متغیر را تغییر خواهند داد.</p>
<p>برای مثال، بیایید فایل <em>src/main.rs</em> را به کد زیر تغییر دهیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>وقتی اکنون برنامه را اجرا می‌کنیم، این خروجی را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>ما اجازه داریم مقدار مرتبط با <code>x</code> را از <code>5</code> به <code>6</code> تغییر دهیم وقتی که از <code>mut</code> استفاده شود. در نهایت، تصمیم‌گیری در مورد استفاده یا عدم استفاده از قابلیت تغییر به عهده شما است و به این بستگی دارد که در آن موقعیت خاص چه چیزی واضح‌تر به نظر می‌رسد.</p>
<h3 id="ثابت-ها"><a class="header" href="#ثابت-ها">ثابت ها</a></h3>
<p>مانند متغیرهای غیرقابل‌تغییر، <em>ثابت‌ها</em> مقادیری هستند که به یک نام متصل می‌شوند و اجازه تغییر ندارند، اما چند تفاوت بین ثابت‌ها و متغیرها وجود دارد.</p>
<p>اول، شما نمی‌توانید از <code>mut</code> با ثابت‌ها استفاده کنید. ثابت‌ها نه تنها به طور پیش‌فرض غیرقابل‌تغییر هستند، بلکه همیشه غیرقابل‌تغییر هستند. شما ثابت‌ها را با استفاده از کلیدواژه <code>const</code> به جای کلیدواژه <code>let</code> تعریف می‌کنید و نوع مقدار <em>باید</em> مشخص شود. ما در بخش بعدی [“انواع داده”][data-types]<!-- ignore --> درباره انواع و حاشیه‌نویسی نوع صحبت خواهیم کرد، بنابراین نگران جزئیات آن در حال حاضر نباشید. فقط بدانید که همیشه باید نوع را مشخص کنید.</p>
<p>ثابت‌ها می‌توانند در هر دامنه‌ای، از جمله دامنه‌ی جهانی، تعریف شوند، که این ویژگی آنها را برای مقادیری که بخش‌های مختلف کد باید بدانند مفید می‌سازد.</p>
<p>آخرین تفاوت این است که ثابت‌ها فقط می‌توانند به یک عبارت ثابت تنظیم شوند، نه نتیجه‌ای که فقط می‌تواند در زمان اجرا محاسبه شود.</p>
<p>در اینجا یک مثال از تعریف ثابت آورده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>نام ثابت <code>THREE_HOURS_IN_SECONDS</code> است و مقدار آن برابر با نتیجه ضرب ۶۰ (تعداد ثانیه‌ها در یک دقیقه) در ۶۰ (تعداد دقیقه‌ها در یک ساعت) در ۳ (تعداد ساعت‌هایی که می‌خواهیم در این برنامه شمارش کنیم) تنظیم شده است. قانون نام‌گذاری ثابت‌ها در Rust استفاده از حروف بزرگ با خط زیر (_) بین کلمات است. کامپایلر قادر است مجموعه محدودی از عملیات را در زمان کامپایل ارزیابی کند، که به ما این امکان را می‌دهد تا این مقدار را به صورتی بنویسیم که آسان‌تر قابل‌درک و بررسی باشد، به جای تنظیم این ثابت به مقدار ۱۰،۸۰۰. برای اطلاعات بیشتر در مورد اینکه چه عملیات‌هایی می‌توانند در زمان تعریف ثابت‌ها استفاده شوند، به [بخش ارزیابی ثابت‌ها در مرجع Rust][const-eval] مراجعه کنید.</p>
<p>ثابت‌ها برای تمام مدت اجرای یک برنامه، در دامنه‌ای که در آن تعریف شده‌اند، معتبر هستند. این ویژگی، ثابت‌ها را برای مقادیر موجود در دامنه برنامه شما که ممکن است بخش‌های مختلف برنامه نیاز به دانستن آنها داشته باشند، مانند حداکثر تعداد امتیازاتی که هر بازیکن یک بازی می‌تواند کسب کند یا سرعت نور، مفید می‌سازد.</p>
<p>نام‌گذاری مقادیر ثابت در سراسر برنامه شما به عنوان ثابت‌ها، در انتقال معنی آن مقدار به نگهدارندگان آینده کد شما مفید است. همچنین این کمک می‌کند که فقط یک مکان در کد وجود داشته باشد که اگر مقدار ثابت نیاز به به‌روزرسانی داشت، باید تغییر کند.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>همان‌طور که در آموزش بازی حدس زدن در [فصل ۲][comparing-the-guess-to-the-secret-number]<!-- ignore --> دیدید، شما می‌توانید یک متغیر جدید با همان نام متغیر قبلی تعریف کنید. Rustaceanها می‌گویند که متغیر اول توسط متغیر دوم <em>سایه انداخته شده است</em>، به این معنا که متغیر دوم چیزی است که کامپایلر وقتی از نام متغیر استفاده می‌کنید می‌بیند. در واقع، متغیر دوم متغیر اول را تحت‌الشعاع قرار می‌دهد، استفاده‌های مربوط به نام متغیر را به خود اختصاص می‌دهد تا زمانی که یا خودش تحت‌الشعاع قرار بگیرد یا دامنه تمام شود. ما می‌توانیم یک متغیر را با استفاده از همان نام متغیر و تکرار استفاده از کلیدواژه <code>let</code> به شرح زیر سایه‌اندازی کنیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>این برنامه ابتدا <code>x</code> را به مقدار <code>۵</code> متصل می‌کند. سپس یک متغیر جدید <code>x</code> با تکرار <code>let x =</code> ایجاد می‌کند و مقدار اصلی را می‌گیرد و <code>۱</code> اضافه می‌کند، بنابراین مقدار <code>x</code> به <code>۶</code> تغییر می‌کند. سپس، در یک دامنه داخلی که با آکولادها ایجاد شده است، عبارت سوم <code>let</code> نیز <code>x</code> را سایه‌اندازی می‌کند و یک متغیر جدید ایجاد می‌کند که مقدار قبلی را در <code>۲</code> ضرب می‌کند و به <code>x</code> مقدار <code>۱۲</code> می‌دهد. وقتی آن دامنه تمام می‌شود، سایه‌اندازی داخلی پایان می‌یابد و <code>x</code> به مقدار <code>۶</code> بازمی‌گردد. وقتی این برنامه را اجرا می‌کنیم، خروجی زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>سایه‌اندازی با علامت‌گذاری متغیر به‌عنوان <code>mut</code> متفاوت است، زیرا اگر به طور تصادفی سعی کنید به این متغیر بدون استفاده از کلیدواژه <code>let</code> مقدار جدیدی تخصیص دهید، یک خطای زمان کامپایل دریافت می‌کنید. با استفاده از <code>let</code>، ما می‌توانیم چند تبدیل روی یک مقدار انجام دهیم، اما متغیر بعد از اتمام این تبدیل‌ها غیرقابل تغییر باقی می‌ماند.</p>
<p>تفاوت دیگر بین <code>mut</code> و سایه‌اندازی این است که به دلیل اینکه ما عملاً یک متغیر جدید ایجاد می‌کنیم وقتی دوباره از کلیدواژه <code>let</code> استفاده می‌کنیم، می‌توانیم نوع مقدار را تغییر دهیم اما همان نام را دوباره استفاده کنیم. برای مثال، فرض کنید برنامه ما از یک کاربر می‌خواهد تا نشان دهد که چند فاصله می‌خواهد بین متن‌های خاص داشته باشد با وارد کردن کاراکترهای فاصله، و سپس می‌خواهیم آن ورودی را به‌عنوان یک عدد ذخیره کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>اولین متغیر <code>spaces</code> یک نوع رشته است و دومین متغیر <code>spaces</code> یک نوع عدد است. سایه‌اندازی در نتیجه ما را از نیاز به یافتن نام‌های مختلف، مانند <code>spaces_str</code> و <code>spaces_num</code> نجات می‌دهد. به جای آن، می‌توانیم از نام ساده‌تر <code>spaces</code> استفاده کنیم. با این حال، اگر سعی کنیم برای این کار از <code>mut</code> استفاده کنیم، همان‌طور که در اینجا نشان داده شده است، یک خطای زمان کامپایل دریافت می‌کنیم:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>خطا می‌گوید که مجاز نیستیم نوع متغیر را تغییر دهیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>حال که بررسی کردیم متغیرها چگونه کار می‌کنند، بیایید نگاهی به انواع داده‌های بیشتری بیندازیم که متغیرها می‌توانند داشته باشند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="انواع-دادهها"><a class="header" href="#انواع-دادهها">انواع داده‌ها</a></h2>
<p>هر مقدار در زبان راست نوع خاصی از <em>داده</em> را دارد که به راست می‌گوید چه نوع داده‌ای مشخص شده است تا بداند چگونه با آن داده کار کند. ما به دو زیرمجموعه از انواع داده نگاه خواهیم کرد: انواع ساده و ترکیبی.</p>
<p>به خاطر داشته باشید که راست یک زبان <em>ایستا-تایپ</em> است، به این معنا که باید نوع تمام متغیرها در زمان کامپایل مشخص باشد. کامپایلر معمولاً می‌تواند بر اساس مقدار و نحوه استفاده از آن، نوع مورد نظر ما را حدس بزند. در مواردی که انواع متعددی ممکن است، مانند زمانی که یک <code>String</code> را به نوع عددی تبدیل کردیم در بخش <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“مقایسه حدس با عدد مخفی”</a><!-- ignore --> در فصل 2، باید یک تعریف نوع اضافه کنیم، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p>اگر تعریف نوع <code>: u32</code> را که در کد بالا آمده است اضافه نکنیم، راست خطای زیر را نمایش می‌دهد، که به معنای این است که کامپایلر به اطلاعات بیشتری از ما نیاز دارد تا بداند کدام نوع را می‌خواهیم استفاده کنیم:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>شما تعریف‌های نوع مختلفی برای انواع داده‌های دیگر خواهید دید.</p>
<h3 id="انواع-ساده"><a class="header" href="#انواع-ساده">انواع ساده</a></h3>
<p>یک نوع <em>ساده</em> نمایانگر یک مقدار واحد است. راست چهار نوع ساده اصلی دارد: اعداد صحیح، اعداد اعشاری، بولین‌ها و کاراکترها. ممکن است این‌ها را از زبان‌های برنامه‌نویسی دیگر بشناسید. بیایید ببینیم چگونه در راست کار می‌کنند.</p>
<h4 id="انواع-اعداد-صحیح"><a class="header" href="#انواع-اعداد-صحیح">انواع اعداد صحیح</a></h4>
<p>یک <em>عدد صحیح</em> عددی بدون جزء اعشاری است. ما در فصل 2 از یک نوع عدد صحیح به نام <code>u32</code> استفاده کردیم. این تعریف نوع نشان می‌دهد که مقدار مرتبط باید یک عدد صحیح بدون علامت (انواع اعداد صحیح با علامت با <code>i</code> به جای <code>u</code> شروع می‌شوند) باشد که 32 بیت فضا اشغال می‌کند. جدول 3-1 انواع اعداد صحیح ساخته شده در راست را نشان می‌دهد. ما می‌توانیم از هر یک از این حالت‌ها برای تعریف نوع یک مقدار عدد صحیح استفاده کنیم.</p>
<p><span class="caption">جدول 3-1: انواع اعداد صحیح در راست</span></p>
<div class="table-wrapper"><table><thead><tr><th>طول</th><th>با علامت</th><th>بدون علامت</th></tr></thead><tbody>
<tr><td>8 بیت</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 بیت</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 بیت</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 بیت</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 بیت</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>معماری</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>هر حالت می‌تواند یا با علامت یا بدون علامت باشد و اندازه صریحی دارد. <em>با علامت</em> و <em>بدون علامت</em> به این اشاره دارند که آیا ممکن است عدد منفی باشد یا خیر؛ به عبارت دیگر، آیا عدد نیاز به علامت دارد (با علامت) یا اینکه فقط مثبت خواهد بود و بنابراین می‌توان آن را بدون علامت نشان داد (بدون علامت). این شبیه به نوشتن اعداد روی کاغذ است: وقتی علامت مهم باشد، عدد با علامت مثبت یا منفی نشان داده می‌شود؛ اما وقتی فرض مثبت بودن عدد ایمن باشد، بدون علامت نشان داده می‌شود. اعداد با علامت با استفاده از نمایش <a href="https://en.wikipedia.org/wiki/Two%27s_complement">دو مکمل</a><!-- ignore --> ذخیره می‌شوند.</p>
<p>هر حالت با علامت می‌تواند اعداد را از -(2<sup>n - 1</sup>) تا 2<sup>n - 1</sup> - 1 شامل شود، جایی که <em>n</em> تعداد بیت‌هایی است که آن حالت استفاده می‌کند. بنابراین یک <code>i8</code> می‌تواند اعداد را از -(2<sup>7</sup>) تا 2<sup>7</sup> - 1 ذخیره کند، که برابر است با -128 تا 127. حالت‌های بدون علامت می‌توانند اعداد را از 0 تا 2<sup>n</sup> - 1 ذخیره کنند، بنابراین یک <code>u8</code> می‌تواند اعداد را از 0 تا 2<sup>8</sup> - 1 ذخیره کند، که برابر است با 0 تا 255.</p>
<p>علاوه بر این، نوع‌های <code>isize</code> و <code>usize</code> به معماری رایانه‌ای که برنامه شما روی آن اجرا می‌شود بستگی دارند، که در جدول به عنوان “معماری” مشخص شده است: 64 بیت اگر روی معماری 64 بیتی باشید و 32 بیت اگر روی معماری 32 بیتی باشید.</p>
<p>شما می‌توانید اعداد صحیح را به هر یک از اشکال نشان داده شده در جدول 3-2 بنویسید. توجه داشته باشید که عددهایی که می‌توانند به چندین نوع عددی تبدیل شوند، یک پسوند نوع دارند، مانند <code>57u8</code>، برای تعیین نوع. اعداد همچنین می‌توانند از <code>_</code> به عنوان جداکننده بصری برای خواناتر کردن استفاده کنند، مانند <code>1_000</code>، که همان مقدار <code>1000</code> را دارد.</p>
<p><span class="caption">جدول 3-2: نمایش اعداد صحیح در راست</span></p>
<div class="table-wrapper"><table><thead><tr><th>نوع اعداد</th><th>مثال</th></tr></thead><tbody>
<tr><td>دهدهی</td><td><code>98_222</code></td></tr>
<tr><td>هگزادسیمال</td><td><code>0xff</code></td></tr>
<tr><td>اکتال</td><td><code>0o77</code></td></tr>
<tr><td>باینری</td><td><code>0b1111_0000</code></td></tr>
<tr><td>بایت (فقط <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>حال چگونه می‌دانید که از کدام نوع عدد صحیح استفاده کنید؟ اگر مطمئن نیستید، مقادیر پیش‌فرض راست معمولاً مکان خوبی برای شروع هستند: نوع‌های عدد صحیح پیش‌فرض به <code>i32</code> تبدیل می‌شوند. وضعیت اصلی که در آن ممکن است از <code>isize</code> یا <code>usize</code> استفاده کنید زمانی است که می‌خواهید به یک نوع مجموعه اشاره کنید.</p>
<section class="note" aria-role="note">
<h5 id="سرریز-عدد-صحیح"><a class="header" href="#سرریز-عدد-صحیح">سرریز عدد صحیح</a></h5>
<p>فرض کنید یک متغیر از نوع <code>u8</code> دارید که می‌تواند مقادیر بین 0 و 255 را نگه دارد. اگر تلاش کنید مقدار متغیر را به عددی خارج از این بازه، مانند 256، تغییر دهید، <em>سرریز عدد صحیح</em> رخ خواهد داد که می‌تواند منجر به یکی از دو رفتار شود. وقتی برنامه خود را در حالت دیباگ کامپایل می‌کنید، راست شامل بررسی‌هایی برای سرریز عدد صحیح است که باعث می‌شود برنامه شما در زمان اجرا <em>پانیک</em> کند اگر این رفتار رخ دهد. راست از اصطلاح <em>پانیک کردن</em> زمانی استفاده می‌کند که برنامه با یک خطا خارج شود؛ ما در بخش <a href="ch09-01-unrecoverable-errors-with-panic.html">“خطاهای غیرقابل بازیابی با <code>panic!</code>”</a><!-- ignore --> در فصل 9 به طور عمیق‌تر درباره پانیک‌ها بحث خواهیم کرد.</p>
<p>وقتی برنامه خود را در حالت انتشار با پرچم <code>--release</code> کامپایل می‌کنید، راست این بررسی‌ها را برای سرریز عدد صحیح شامل نمی‌شود. در عوض، اگر سرریز رخ دهد، راست از <em>دو مکمل بسته‌بندی</em> استفاده می‌کند. به طور خلاصه، مقادیر بزرگتر از حداکثر مقداری که نوع می‌تواند نگه دارد به “حداقل مقادیر” بازه نوع بسته‌بندی می‌شوند. در مورد یک <code>u8</code>، مقدار 256 به 0 تبدیل می‌شود، مقدار 257 به 1 و غیره. برنامه پانیک نخواهد کرد، اما متغیر مقدار متفاوتی نسبت به آنچه انتظار می‌رفت خواهد داشت. اعتماد به رفتار بسته‌بندی سرریز عدد صحیح یک خطا محسوب می‌شود.</p>
<p>برای مدیریت صریح امکان سرریز، می‌توانید از این خانواده‌های روش‌ها استفاده کنید که توسط کتابخانه استاندارد برای نوع‌های عددی اولیه ارائه شده‌اند:</p>
<ul>
<li>بسته‌بندی در همه حالت‌ها با روش‌های <code>wrapping_*</code>، مانند <code>wrapping_add</code>.</li>
<li>بازگرداندن مقدار <code>None</code> اگر سرریز رخ دهد با روش‌های <code>checked_*</code>.</li>
<li>بازگرداندن مقدار و یک بولین که نشان‌دهنده سرریز است با روش‌های <code>overflowing_*</code>.</li>
<li>اشباع در مقادیر حداقل یا حداکثر مقدار نوع با روش‌های <code>saturating_*</code>.</li>
</ul>
</section>
<h4 id="انواع-اعداد-اعشاری"><a class="header" href="#انواع-اعداد-اعشاری">انواع اعداد اعشاری</a></h4>
<p>راست همچنین دو نوع اولیه برای <em>اعداد اعشاری</em> دارد، که اعدادی با نقطه اعشار هستند. نوع‌های اعشاری راست <code>f32</code> و <code>f64</code> هستند که به ترتیب 32 بیت و 64 بیت اندازه دارند. نوع پیش‌فرض <code>f64</code> است زیرا روی CPUهای مدرن، سرعت آن تقریباً مشابه <code>f32</code> است اما دقت بیشتری دارد. همه نوع‌های اعشاری علامت‌دار هستند.</p>
<p>در اینجا مثالی که اعداد اعشاری را در عمل نشان می‌دهد آورده شده است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>اعداد اعشاری طبق استاندارد IEEE-754 نمایش داده می‌شوند.</p>
<h4 id="عملیات-عددی"><a class="header" href="#عملیات-عددی">عملیات عددی</a></h4>
<p>راست از عملیات ریاضی پایه‌ای که برای تمام انواع عددی انتظار دارید پشتیبانی می‌کند: جمع، تفریق، ضرب، تقسیم و باقی‌مانده. تقسیم اعداد صحیح به نزدیک‌ترین عدد صحیح به سمت صفر گرد می‌شود. کد زیر نشان می‌دهد چگونه می‌توانید از هر عملیات عددی در یک عبارت <code>let</code> استفاده کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>هر عبارت در این دستورات از یک عملگر ریاضی استفاده می‌کند و به یک مقدار واحد ارزیابی می‌شود، که سپس به یک متغیر متصل می‌شود. <a href="appendix-02-operators.html">ضمیمه ب</a><!-- ignore --> شامل لیستی از تمام عملگرهایی است که راست فراهم می‌کند.</p>
<h4 id="نوع-بولین"><a class="header" href="#نوع-بولین">نوع بولین</a></h4>
<p>مانند اکثر زبان‌های برنامه‌نویسی دیگر، نوع بولین در راست دو مقدار ممکن دارد: <code>true</code> و <code>false</code>. نوع بولین در راست یک بایت اندازه دارد. نوع بولین در راست با استفاده از <code>bool</code> مشخص می‌شود. برای مثال:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>راه اصلی استفاده از مقادیر بولین از طریق عبارات شرطی، مانند عبارت <code>if</code> است. ما در بخش <a href="ch03-05-control-flow.html#control-flow">“جریان کنترل”</a><!-- ignore --> توضیح می‌دهیم که چگونه عبارات <code>if</code> در راست کار می‌کنند.</p>
<h4 id="نوع-کاراکتر"><a class="header" href="#نوع-کاراکتر">نوع کاراکتر</a></h4>
<p>نوع <code>char</code> در راست ابتدایی‌ترین نوع الفبایی زبان است. در اینجا برخی از مثال‌های اعلام مقادیر <code>char</code> آورده شده است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>توجه داشته باشید که مقادیر <code>char</code> با استفاده از علامت نقل قول تکی مشخص می‌شوند، در حالی که مقادیر رشته‌ای از علامت نقل قول دوتایی استفاده می‌کنند. نوع <code>char</code> در راست چهار بایت اندازه دارد و نمایانگر یک مقدار اسکالر یونیکد است، به این معنی که می‌تواند خیلی بیشتر از فقط ASCII را نمایان کند. حروف با لهجه؛ حروف چینی، ژاپنی و کره‌ای؛ ایموجی؛ و فاصله‌های بدون عرض همگی مقادیر <code>char</code> معتبر در راست هستند. مقادیر اسکالر یونیکد در بازه <code>U+0000</code> تا <code>U+D7FF</code> و <code>U+E000</code> تا <code>U+10FFFF</code> قرار دارند. با این حال، “کاراکتر” واقعاً یک مفهوم در یونیکد نیست، بنابراین درک انسانی شما از آنچه یک “کاراکتر” است ممکن است با آنچه یک <code>char</code> در راست است همخوانی نداشته باشد. ما این موضوع را به تفصیل در بخش <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها”</a><!-- ignore --> در فصل 8 بحث خواهیم کرد.</p>
<h3 id="انواع-ترکیبی"><a class="header" href="#انواع-ترکیبی">انواع ترکیبی</a></h3>
<p><em>انواع ترکیبی</em> می‌توانند چندین مقدار را در یک نوع گروه‌بندی کنند. راست دو نوع ترکیبی اولیه دارد: تاپل‌ها و آرایه‌ها.</p>
<h4 id="نوع-تاپل"><a class="header" href="#نوع-تاپل">نوع تاپل</a></h4>
<p><em>تاپل</em> یک روش کلی برای گروه‌بندی چند مقدار با انواع مختلف در یک نوع ترکیبی است. تاپل‌ها طول ثابتی دارند: پس از اعلام، نمی‌توانند بزرگ‌تر یا کوچک‌تر شوند.</p>
<p>ما یک تاپل را با نوشتن یک لیست جدا شده با کاما از مقادیر در داخل پرانتز ایجاد می‌کنیم. هر موقعیت در تاپل یک نوع دارد، و انواع مقادیر مختلف در تاپل نیازی به یکسان بودن ندارند. ما در این مثال حاشیه‌نویسی نوع اختیاری اضافه کرده‌ایم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>متغیر <code>tup</code> به کل تاپل متصل می‌شود زیرا یک تاپل به عنوان یک عنصر ترکیبی واحد در نظر گرفته می‌شود. برای استخراج مقادیر جداگانه از یک تاپل، می‌توانیم از تطابق الگو برای تجزیه مقدار تاپل استفاده کنیم، مانند این:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>این برنامه ابتدا یک تاپل ایجاد کرده و آن را به متغیر <code>tup</code> متصل می‌کند. سپس از یک الگو با <code>let</code> برای گرفتن <code>tup</code> و تبدیل آن به سه متغیر جداگانه، <code>x</code>، <code>y</code>، و <code>z</code> استفاده می‌کند. این فرآیند <em>تجزیه</em> نامیده می‌شود زیرا تاپل واحد را به سه قسمت تقسیم می‌کند. در نهایت، برنامه مقدار <code>y</code> را که <code>6.4</code> است، چاپ می‌کند.</p>
<p>ما همچنین می‌توانیم یک عنصر از تاپل را مستقیماً با استفاده از یک نقطه (<code>.</code>) به دنبال شماره شاخص مقدار مورد نظر دسترسی داشته باشیم. برای مثال:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>این برنامه تاپل <code>x</code> را ایجاد کرده و سپس به هر عنصر تاپل با استفاده از شاخص‌های مربوطه آنها دسترسی پیدا می‌کند. همانند اکثر زبان‌های برنامه‌نویسی، اولین شاخص در یک تاپل <code>0</code> است.</p>
<p>تاپل بدون هیچ مقداری یک نام خاص دارد، <em>واحد</em>. این مقدار و نوع مربوط به آن هر دو با <code>()</code> نوشته می‌شوند و یک مقدار خالی یا یک نوع بازگشت خالی را نشان می‌دهند. عبارات به طور ضمنی مقدار واحد را بازمی‌گردانند اگر هیچ مقدار دیگری بازنگردانند.</p>
<h4 id="نوع-آرایه"><a class="header" href="#نوع-آرایه">نوع آرایه</a></h4>
<p>روش دیگری برای داشتن مجموعه‌ای از چند مقدار، استفاده از <em>آرایه</em> است. برخلاف تاپل، هر عنصر آرایه باید از یک نوع باشد. برخلاف آرایه‌ها در برخی زبان‌های دیگر، آرایه‌ها در راست طول ثابتی دارند.</p>
<p>ما مقادیر یک آرایه را به صورت یک لیست جدا شده با کاما در داخل کروشه می‌نویسیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>آرایه‌ها زمانی مفید هستند که بخواهید داده‌های شما در استک تخصیص یابد، همانند سایر انواعی که تاکنون دیده‌ایم، نه در هیپ (ما در فصل <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">۴</a><!-- ignore --> استک و هیپ را بیشتر توضیح خواهیم داد) یا وقتی می‌خواهید مطمئن شوید که همیشه تعداد عناصر ثابتی دارید. با این حال، آرایه به اندازه نوع وکتور انعطاف‌پذیر نیست. یک <em>وکتور</em> یک نوع مجموعه مشابه است که توسط کتابخانه استاندارد فراهم شده و می‌تواند به اندازه تغییر کند. اگر مطمئن نیستید که از آرایه یا وکتور استفاده کنید، احتمالاً باید از وکتور استفاده کنید. فصل <a href="ch08-01-vectors.html">۸</a><!-- ignore --> وکتورها را با جزئیات بیشتری توضیح می‌دهد.</p>
<p>با این حال، آرایه‌ها زمانی مفیدتر هستند که بدانید تعداد عناصر نیاز به تغییر ندارد. برای مثال، اگر از نام‌های ماه در یک برنامه استفاده می‌کردید، احتمالاً از یک آرایه به جای یک وکتور استفاده می‌کردید زیرا می‌دانید همیشه ۱۲ عنصر خواهد داشت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>شما نوع یک آرایه را با استفاده از کروشه‌ها به همراه نوع هر عنصر، یک نقطه ویرگول، و سپس تعداد عناصر در آرایه می‌نویسید، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>در اینجا، <code>i32</code> نوع هر عنصر است. پس از نقطه ویرگول، عدد <code>۵</code> نشان می‌دهد که آرایه شامل پنج عنصر است.</p>
<p>شما همچنین می‌توانید یک آرایه را طوری مقداردهی اولیه کنید که هر عنصر مقدار یکسانی داشته باشد، با مشخص کردن مقدار اولیه، یک نقطه ویرگول، و سپس طول آرایه در کروشه‌ها، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>آرایه‌ای با نام <code>a</code> شامل <code>۵</code> عنصر خواهد بود که همه ابتدا مقدار <code>۳</code> دارند. این همان نوشتن <code>let a = [3, 3, 3, 3, 3];</code> است، اما به شیوه‌ای مختصرتر.</p>
<h5 id="دسترسی-به-عناصر-آرایه"><a class="header" href="#دسترسی-به-عناصر-آرایه">دسترسی به عناصر آرایه</a></h5>
<p>یک آرایه یک بخش واحد از حافظه با اندازه‌ای مشخص و ثابت است که می‌تواند روی استک تخصیص داده شود. شما می‌توانید به عناصر یک آرایه با استفاده از ایندکس دسترسی پیدا کنید، مانند این:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>در این مثال، متغیری با نام <code>first</code> مقدار <code>1</code> را می‌گیرد زیرا این مقدار در ایندکس <code>[0]</code> در آرایه قرار دارد. متغیری با نام <code>second</code> مقدار <code>2</code> را از ایندکس <code>[1]</code> در آرایه می‌گیرد.</p>
<h5 id="دسترسی-نامعتبر-به-عنصر-آرایه"><a class="header" href="#دسترسی-نامعتبر-به-عنصر-آرایه">دسترسی نامعتبر به عنصر آرایه</a></h5>
<p>ببینیم چه اتفاقی می‌افتد اگر بخواهید به عنصری از آرایه دسترسی پیدا کنید که خارج از محدوده آرایه است. فرض کنید این کد را اجرا کنید که مشابه بازی حدس در فصل ۲ است، تا یک ایندکس آرایه را از کاربر دریافت کند:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p>این کد به درستی کامپایل می‌شود. اگر این کد را با استفاده از <code>cargo run</code> اجرا کنید و مقادیری مانند <code>0</code>، <code>1</code>، <code>2</code>، <code>3</code> یا <code>4</code> را وارد کنید، برنامه مقدار متناظر در آن ایندکس از آرایه را چاپ می‌کند. اما اگر به جای آن عددی خارج از محدوده آرایه، مانند <code>10</code>، وارد کنید، خروجی چیزی شبیه به این خواهد بود:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>این برنامه در نقطه استفاده از مقدار نامعتبر در عملیات ایندکس‌گذاری دچار خطای <em>زمان اجرا</em> شد. برنامه با یک پیام خطا خاتمه یافت و دستور نهایی <code>println!</code> را اجرا نکرد. زمانی که شما تلاش می‌کنید به یک عنصر با استفاده از ایندکس دسترسی پیدا کنید، راست بررسی می‌کند که ایندکسی که مشخص کرده‌اید کمتر از طول آرایه باشد. اگر ایندکس بزرگ‌تر یا برابر با طول باشد، راست متوقف می‌شود (پانیک می‌کند). این بررسی باید در زمان اجرا انجام شود، به‌ویژه در این مورد، زیرا کامپایلر نمی‌تواند بداند که کاربر چه مقداری را هنگام اجرای کد وارد خواهد کرد.</p>
<p>این یک مثال از اصول ایمنی حافظه راست در عمل است. در بسیاری از زبان‌های سطح پایین، این نوع بررسی انجام نمی‌شود و زمانی که شما یک ایندکس اشتباه ارائه می‌کنید، می‌توان به حافظه نامعتبر دسترسی پیدا کرد. راست شما را از این نوع خطا با متوقف کردن فوری برنامه به جای اجازه دسترسی به حافظه و ادامه برنامه محافظت می‌کند. فصل ۹ خطایابی در راست و نحوه نوشتن کد خوانا و ایمن که نه دچار پانیک شود و نه اجازه دسترسی نامعتبر به حافظه را بدهد، بیشتر بررسی می‌کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="توابع"><a class="header" href="#توابع">توابع</a></h2>
<p>توابع در کدهای راست بسیار رایج هستند. شما تاکنون یکی از مهم‌ترین توابع در این زبان را دیده‌اید: تابع <code>main</code>، که نقطه ورود بسیاری از برنامه‌ها است. همچنین با کلمه کلیدی <code>fn</code> آشنا شدید که به شما امکان تعریف توابع جدید را می‌دهد.</p>
<p>کدهای راست از <em>حالت snake case</em> به عنوان سبک متعارف برای نام‌گذاری توابع و متغیرها استفاده می‌کنند، که در آن تمام حروف کوچک هستند و کلمات با زیرخط از یکدیگر جدا می‌شوند. این یک برنامه است که شامل یک مثال از تعریف تابع می‌باشد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}</code></pre></pre>
<p>ما با وارد کردن <code>fn</code> به همراه نام تابع و یک مجموعه پرانتز، یک تابع را در راست تعریف می‌کنیم. کروشه‌های باز و بسته به کامپایلر می‌گویند که بدنه تابع از کجا شروع و پایان می‌یابد.</p>
<p>ما می‌توانیم هر تابعی را که تعریف کرده‌ایم با وارد کردن نام آن به همراه یک مجموعه پرانتز فراخوانی کنیم. از آنجا که <code>another_function</code> در برنامه تعریف شده است، می‌توان آن را از داخل تابع <code>main</code> فراخوانی کرد. توجه داشته باشید که ما <code>another_function</code> را <em>بعد از</em> تابع <code>main</code> در کد منبع تعریف کردیم؛ همچنین می‌توانستیم آن را قبل از آن تعریف کنیم. راست اهمیتی نمی‌دهد که توابع شما کجا تعریف شده‌اند، فقط باید در محدوده‌ای باشند که توسط فراخوانی کننده قابل مشاهده باشد.</p>
<p>بیایید یک پروژه باینری جدید به نام <em>functions</em> ایجاد کنیم تا توابع را بیشتر بررسی کنیم. مثال <code>another_function</code> را در فایل <em>src/main.rs</em> قرار دهید و آن را اجرا کنید. باید خروجی زیر را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>دستورات به ترتیبی که در تابع <code>main</code> ظاهر شده‌اند اجرا می‌شوند. ابتدا پیام “Hello, world!” چاپ می‌شود و سپس <code>another_function</code> فراخوانی شده و پیام آن چاپ می‌شود.</p>
<h3 id="پارامترها"><a class="header" href="#پارامترها">پارامترها</a></h3>
<p>ما می‌توانیم توابعی تعریف کنیم که <em>پارامتر</em> داشته باشند، که متغیرهای خاصی هستند که بخشی از امضای تابع محسوب می‌شوند. وقتی یک تابع پارامتر دارد، شما می‌توانید مقادیر مشخصی برای آن پارامترها ارائه دهید. از نظر فنی، به مقادیر مشخص <em>آرگومان</em> گفته می‌شود، اما در مکالمات معمول، مردم معمولاً از کلمات <em>پارامتر</em> و <em>آرگومان</em> به جای یکدیگر استفاده می‌کنند، چه برای متغیرهای تعریف شده در یک تابع یا مقادیر مشخص هنگام فراخوانی تابع.</p>
<p>در این نسخه از <code>another_function</code>، ما یک پارامتر اضافه می‌کنیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>این برنامه را اجرا کنید؛ باید خروجی زیر را ببینید:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>اعلان <code>another_function</code> دارای یک پارامتر به نام <code>x</code> است. نوع <code>x</code> به عنوان <code>i32</code> مشخص شده است. وقتی ما مقدار <code>5</code> را به <code>another_function</code> می‌دهیم، ماکروی <code>println!</code> مقدار <code>5</code> را در جایی که جفت کروشه حاوی <code>x</code> در رشته فرمت بود، قرار می‌دهد.</p>
<p>در امضای توابع، شما <em>باید</em> نوع هر پارامتر را اعلام کنید. این یک تصمیم عمدی در طراحی راست است: نیاز به حاشیه‌نویسی نوع در تعریف توابع به این معنا است که کامپایلر تقریباً هرگز نیازی به استفاده از آنها در جاهای دیگر کد برای فهمیدن نوع مورد نظر شما ندارد. کامپایلر همچنین قادر است پیام‌های خطای مفیدتری ارائه دهد اگر بداند تابع چه نوع‌هایی انتظار دارد.</p>
<p>هنگام تعریف چندین پارامتر، اعلام پارامترها را با کاما جدا کنید، مانند این:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}</code></pre></pre>
<p>این مثال یک تابع به نام <code>print_labeled_measurement</code> با دو پارامتر ایجاد می‌کند. پارامتر اول به نام <code>value</code> و از نوع <code>i32</code> است. پارامتر دوم به نام <code>unit_label</code> و از نوع <code>char</code> است. سپس تابع متنی حاوی هر دو <code>value</code> و <code>unit_label</code> را چاپ می‌کند.</p>
<p>بیایید این کد را اجرا کنیم. برنامه‌ای که در حال حاضر در فایل <em>src/main.rs</em> پروژه <em>functions</em> شما است را با مثال بالا جایگزین کنید و آن را با استفاده از <code>cargo run</code> اجرا کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>از آنجا که ما تابع را با <code>5</code> به عنوان مقدار برای <code>value</code> و <code>'h'</code> به عنوان مقدار برای <code>unit_label</code> فراخوانی کردیم، خروجی برنامه شامل این مقادیر است.</p>
<h3 id="اظهارات-و-عبارات"><a class="header" href="#اظهارات-و-عبارات">اظهارات و عبارات</a></h3>
<p>بدنه توابع از یک سری اظهارات تشکیل شده است که به طور اختیاری با یک عبارت پایان می‌یابند. تاکنون، توابعی که پوشش داده‌ایم شامل یک عبارت پایانی نبوده‌اند، اما شما یک عبارت را به عنوان بخشی از یک اظهار دیده‌اید. از آنجا که راست یک زبان مبتنی بر عبارات است، این تمایز بسیار مهم است که درک شود. زبان‌های دیگر این تمایز را ندارند، بنابراین بیایید نگاهی به اظهارات و عبارات بیندازیم و ببینیم چگونه تفاوت‌های آنها بر بدن توابع تأثیر می‌گذارد.</p>
<ul>
<li><strong>اظهارات</strong> دستورالعمل‌هایی هستند که یک عمل انجام می‌دهند و هیچ مقداری باز نمی‌گردانند.</li>
<li><strong>عبارات</strong> به یک مقدار نتیجه‌گیری می‌رسند. بیایید چند مثال را بررسی کنیم.</li>
</ul>
<p>ما در واقع قبلاً از اظهارات و عبارات استفاده کرده‌ایم. ایجاد یک متغیر و اختصاص یک مقدار به آن با کلمه کلیدی <code>let</code> یک اظهار است. در لیستینگ ۳-۱، <code>let y = 6;</code> یک اظهار است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = 6;
}</code></pre></pre>
<figcaption>Listing 3-1: تعریف تابع <code>main</code> که شامل یک اظهار است</figcaption>
</figure>
<p>تعریف توابع نیز اظهارات هستند؛ کل مثال پیشین خود یک اظهار است. (همانطور که در زیر خواهیم دید، <em>فراخوانی</em> یک تابع یک اظهار نیست.)</p>
<p>اظهارات هیچ مقداری باز نمی‌گردانند. بنابراین، نمی‌توانید یک اظهار <code>let</code> را به یک متغیر دیگر اختصاص دهید، همانطور که کد زیر سعی دارد انجام دهد؛ شما با یک خطا روبرو خواهید شد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>وقتی این برنامه را اجرا کنید، خطایی که دریافت خواهید کرد به شکل زیر خواهد بود:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>اظهار <code>let y = 6</code> هیچ مقداری باز نمی‌گرداند، بنابراین چیزی برای اتصال به <code>x</code> وجود ندارد. این با آنچه در زبان‌های دیگر، مانند C و Ruby رخ می‌دهد، متفاوت است، جایی که تخصیص مقدار باز می‌گرداند. در آن زبان‌ها، می‌توانید <code>x = y = 6</code> بنویسید و هر دو <code>x</code> و <code>y</code> مقدار <code>6</code> را داشته باشند؛ این حالت در راست وجود ندارد.</p>
<p>عبارات به یک مقدار ارزیابی می‌شوند و بیشتر بقیه کدی که در راست می‌نویسید را تشکیل می‌دهند. به عنوان مثال یک عملیات ریاضی، مانند <code>5 + 6</code>، که یک عبارت است که به مقدار <code>11</code> ارزیابی می‌شود. عبارات می‌توانند بخشی از اظهارات باشند: در لیستینگ ۳-۱، مقدار <code>6</code> در اظهار <code>let y = 6;</code> یک عبارت است که به مقدار <code>6</code> ارزیابی می‌شود. فراخوانی یک تابع یک عبارت است. فراخوانی یک ماکرو یک عبارت است. یک بلوک جدید از دامنه که با کروشه‌های باز و بسته ایجاد شده است نیز یک عبارت است، برای مثال:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>این عبارت:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>یک بلوک است که در این مورد به مقدار <code>4</code> ارزیابی می‌شود. آن مقدار به عنوان بخشی از اظهار <code>let</code> به <code>y</code> متصل می‌شود. توجه داشته باشید که خط <code>x + 1</code> در انتها یک نقطه ویرگول ندارد، که برخلاف اکثر خطوطی است که تاکنون دیده‌اید. عبارات شامل نقطه ویرگول انتهایی نمی‌شوند. اگر به انتهای یک عبارت یک نقطه ویرگول اضافه کنید، آن را به یک اظهار تبدیل می‌کنید و دیگر مقداری باز نمی‌گرداند. این نکته را در ذهن داشته باشید زیرا در ادامه به بررسی مقادیر بازگشتی توابع و عبارات می‌پردازیم.</p>
<h3 id="توابع-با-مقادیر-بازگشتی"><a class="header" href="#توابع-با-مقادیر-بازگشتی">توابع با مقادیر بازگشتی</a></h3>
<p>توابع می‌توانند مقادیری را به کدی که آنها را فراخوانی کرده است بازگردانند. ما به مقادیر بازگشتی نام نمی‌دهیم، اما باید نوع آنها را بعد از یک فلش (<code>-&gt;</code>) اعلام کنیم. در راست، مقدار بازگشتی تابع معادل مقدار عبارت نهایی در بلوک بدنه تابع است. شما می‌توانید با استفاده از کلمه کلیدی <code>return</code> و مشخص کردن یک مقدار، زودتر از یک تابع بازگردید، اما بیشتر توابع به طور ضمنی مقدار آخرین عبارت را بازمی‌گردانند. در اینجا یک مثال از یک تابع که مقدار بازمی‌گرداند آورده شده است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>هیچ فراخوانی تابع، ماکرو یا حتی اظهار <code>let</code> در تابع <code>five</code> وجود ندارد—فقط عدد <code>5</code> به تنهایی. این یک تابع کاملاً معتبر در راست است. توجه کنید که نوع مقدار بازگشتی تابع نیز به صورت <code>-&gt; i32</code> مشخص شده است. این کد را اجرا کنید؛ خروجی باید به صورت زیر باشد:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>عدد <code>5</code> در <code>five</code> مقدار بازگشتی تابع است، به همین دلیل نوع بازگشتی <code>i32</code> است. بیایید این موضوع را با جزئیات بیشتری بررسی کنیم. دو نکته مهم وجود دارد: اول، خط <code>let x = five();</code> نشان می‌دهد که ما از مقدار بازگشتی یک تابع برای مقداردهی یک متغیر استفاده می‌کنیم. چون تابع <code>five</code> مقدار <code>5</code> را بازمی‌گرداند، این خط مشابه خط زیر است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>دوم، تابع <code>five</code> هیچ پارامتری ندارد و نوع مقدار بازگشتی را تعریف می‌کند، اما بدنه تابع یک عدد تنها <code>5</code> بدون نقطه ویرگول است زیرا این یک عبارت است که مقدار آن را می‌خواهیم بازگردانیم.</p>
<p>بیایید به مثال دیگری نگاه کنیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>اجرای این کد مقدار <code>The value of x is: 6</code> را چاپ خواهد کرد. اما اگر یک نقطه ویرگول به انتهای خط حاوی <code>x + 1</code> اضافه کنیم و آن را از یک عبارت به یک اظهار تبدیل کنیم، با خطا مواجه خواهیم شد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>کامپایل این کد خطایی به شرح زیر تولید می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>پیام خطای اصلی، <code>mismatched types</code>، مسئله اصلی این کد را آشکار می‌کند. تعریف تابع <code>plus_one</code> می‌گوید که این تابع یک <code>i32</code> بازمی‌گرداند، اما اظهارات به یک مقدار ارزیابی نمی‌شوند، که با <code>()</code>، نوع واحد، نشان داده می‌شود. بنابراین، چیزی بازگردانده نمی‌شود که با تعریف تابع تناقض دارد و باعث ایجاد خطا می‌شود. در این خروجی، راست پیامی ارائه می‌دهد تا شاید به حل این مشکل کمک کند: پیشنهاد حذف نقطه ویرگول، که این خطا را برطرف می‌کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="کامنتها"><a class="header" href="#کامنتها">کامنت‌ها</a></h2>
<p>تمام برنامه‌نویسان تلاش می‌کنند کدهایشان را به گونه‌ای بنویسند که به راحتی قابل فهم باشد، اما گاهی اوقات توضیحات اضافی لازم است. در این موارد، برنامه‌نویسان <em>کامنت‌هایی</em> را در کد منبع خود می‌گذارند که کامپایلر آنها را نادیده می‌گیرد اما ممکن است برای افرادی که کد منبع را می‌خوانند مفید باشد.</p>
<p>در اینجا یک کامنت ساده آورده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<p>در راست، سبک متعارف کامنت‌گذاری با دو اسلش شروع می‌شود و کامنت تا پایان خط ادامه دارد. برای کامنت‌هایی که بیشتر از یک خط هستند، باید روی هر خط از <code>//</code> استفاده کنید، به این صورت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// پس اینجا داریم کاری پیچیده انجام می‌دهیم، به قدری طولانی که به چندین
// خط کامنت نیاز داریم! هاه! امیدواریم این کامنت توضیح دهد که چه اتفاقی
// در حال وقوع است.
<span class="boring">}</span></code></pre></pre>
<p>کامنت‌ها همچنین می‌توانند در انتهای خطوطی که حاوی کد هستند قرار گیرند:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}</code></pre></pre>
<p>اما بیشتر مواقع کامنت‌ها را در این قالب خواهید دید، با کامنتی که در خط جداگانه‌ای بالای کدی که توضیح می‌دهد قرار دارد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}</code></pre></pre>
<p>راست همچنین نوع دیگری از کامنت‌ها، کامنت‌های مستندات (documentation comments) دارد که آنها را در بخش <a href="ch14-02-publishing-to-crates-io.html">“انتشار یک کرات در Crates.io”</a><!-- ignore --> از فصل 14 بررسی خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="کنترل-جریان"><a class="header" href="#کنترل-جریان">کنترل جریان</a></h2>
<p>توانایی اجرای کدی که وابسته به درست بودن یا نبودن یک شرط است و اجرای مکرر کدی در حالی که یک شرط درست است، از ساختارهای اساسی در بیشتر زبان‌های برنامه‌نویسی محسوب می‌شود. رایج‌ترین ساختارهایی که به شما امکان کنترل جریان اجرای کد در راست را می‌دهند، عبارتند از عبارات <code>if</code> و حلقه‌ها.</p>
<h3 id="عبارات-if"><a class="header" href="#عبارات-if">عبارات <code>if</code></a></h3>
<p>یک عبارت <code>if</code> به شما امکان می‌دهد کد خود را بسته به شرایطی شاخه‌بندی کنید. شما یک شرط مشخص می‌کنید و سپس می‌گویید: «اگر این شرط برقرار بود، این بلوک کد اجرا شود. اگر شرط برقرار نبود، این بلوک کد اجرا نشود.»</p>
<p>یک پروژه جدید به نام <em>branches</em> در دایرکتوری <em>projects</em> خود ایجاد کنید تا عبارت <code>if</code> را بررسی کنید. در فایل <em>src/main.rs</em> کد زیر را وارد کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}</code></pre></pre>
<p>تمام عبارات <code>if</code> با کلمه کلیدی <code>if</code> شروع می‌شوند و سپس یک شرط دنبال می‌شود. در این مثال، شرط بررسی می‌کند که آیا مقدار متغیر <code>number</code> کمتر از 5 است یا خیر. بلوک کدی که در صورت درست بودن شرط باید اجرا شود، بلافاصله بعد از شرط و داخل کروشه‌ها قرار می‌گیرد. بلوک‌های کدی که با شرایط در عبارات <code>if</code> مرتبط هستند، گاهی <em>بازو</em> (arm) نامیده می‌شوند، همانند بازوهای موجود در عبارات <code>match</code> که در بخش <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“مقایسه حدس با عدد مخفی”</a><!-- ignore --> از فصل 2 مورد بحث قرار گرفت.</p>
<p>به‌صورت اختیاری، می‌توانیم یک عبارت <code>else</code> نیز اضافه کنیم، همان‌طور که اینجا انتخاب کردیم، تا به برنامه یک بلوک کد جایگزین برای اجرا ارائه دهیم، در صورتی که شرط به <code>false</code> ارزیابی شود. اگر عبارت <code>else</code> ارائه ندهید و شرط <code>false</code> باشد، برنامه بلوک <code>if</code> را نادیده گرفته و به بخش بعدی کد می‌رود.</p>
<p>این کد را اجرا کنید؛ باید خروجی زیر را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>بیایید مقدار <code>number</code> را به مقداری تغییر دهیم که شرط <code>false</code> شود تا ببینیم چه اتفاقی می‌افتد:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("condition was true");
</span><span class="boring">    } else {
</span><span class="boring">        println!("condition was false");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>برنامه را دوباره اجرا کنید و خروجی را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>همچنین قابل توجه است که شرط در این کد <em>باید</em> یک <code>bool</code> باشد. اگر شرط یک <code>bool</code> نباشد، خطا دریافت خواهیم کرد. به عنوان مثال، این کد را اجرا کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}</code></pre>
<p>این بار شرط <code>if</code> به مقدار <code>3</code> ارزیابی می‌شود و راست خطا می‌دهد:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>خطا نشان می‌دهد که راست انتظار یک <code>bool</code> داشت اما یک عدد صحیح دریافت کرد. برخلاف زبان‌هایی مانند Ruby و JavaScript، راست به‌صورت خودکار تلاش نمی‌کند انواع غیر <code>bool</code> را به یک <code>bool</code> تبدیل کند. شما باید صریح باشید و همیشه یک <code>bool</code> را به‌عنوان شرط به <code>if</code> بدهید. اگر می‌خواهید بلوک کد <code>if</code> فقط زمانی اجرا شود که یک عدد برابر <code>0</code> نباشد، می‌توانید عبارت <code>if</code> را به این صورت تغییر دهید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}</code></pre></pre>
<p>اجرای این کد <code>number was something other than zero</code> را چاپ خواهد کرد.</p>
<h4 id="مدیریت-شرایط-متعدد-با-else-if"><a class="header" href="#مدیریت-شرایط-متعدد-با-else-if">مدیریت شرایط متعدد با <code>else if</code></a></h4>
<p>شما می‌توانید با ترکیب <code>if</code> و <code>else</code> در یک عبارت <code>else if</code>، شرایط متعددی را مدیریت کنید. به عنوان مثال:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<p>این برنامه چهار مسیر ممکن برای اجرا دارد. پس از اجرای آن، باید خروجی زیر را مشاهده کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>هنگامی که این برنامه اجرا می‌شود، هر عبارت <code>if</code> را به ترتیب بررسی کرده و اولین بلوکی که شرط آن به <code>true</code> ارزیابی شود، اجرا می‌کند. توجه داشته باشید که حتی با وجود اینکه 6 بر 2 بخش‌پذیر است، خروجی <code>number is divisible by 2</code> را نمی‌بینیم و همچنین متن <code>number is not divisible by 4, 3, or 2</code> از بلوک <code>else</code> را نیز نمی‌بینیم. این به این دلیل است که راست فقط بلوک مربوط به اولین شرط درست را اجرا می‌کند و پس از یافتن آن، بقیه را بررسی نمی‌کند.</p>
<p>استفاده از تعداد زیادی عبارت <code>else if</code> می‌تواند کد شما را شلوغ کند، بنابراین اگر بیش از یک مورد دارید، ممکن است بخواهید کد خود را بازنویسی کنید. فصل 6 یک ساختار شاخه‌بندی قدرتمند در راست به نام <code>match</code> را برای این موارد توضیح می‌دهد.</p>
<h4 id="استفاده-از-if-در-یک-عبارت-let"><a class="header" href="#استفاده-از-if-در-یک-عبارت-let">استفاده از <code>if</code> در یک عبارت <code>let</code></a></h4>
<p>از آنجایی که <code>if</code> یک عبارت است، می‌توانیم از آن در سمت راست یک عبارت <code>let</code> برای تخصیص نتیجه به یک متغیر استفاده کنیم، همان‌طور که در لیست 3-2 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}</code></pre></pre>
<figcaption>Listing 3-2: تخصیص نتیجه یک عبارت <code>if</code> به یک متغیر</figcaption>
</figure>
<p>متغیر <code>number</code> به مقداری بر اساس نتیجه عبارت <code>if</code> متصل خواهد شد. این کد را اجرا کنید تا ببینید چه اتفاقی می‌افتد:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>به خاطر داشته باشید که بلوک‌های کد به آخرین عبارت در آن‌ها ارزیابی می‌شوند و اعداد به تنهایی نیز عبارات محسوب می‌شوند. در این حالت، مقدار کل عبارت <code>if</code> بستگی به این دارد که کدام بلوک کد اجرا شود. این بدان معناست که مقادیری که می‌توانند نتایج هر بازوی <code>if</code> باشند، باید از یک نوع باشند. در لیست 3-2، نتایج بازوی <code>if</code> و بازوی <code>else</code> هر دو اعداد صحیح <code>i32</code> بودند. اگر انواع ناسازگار باشند، مانند مثال زیر، خطایی دریافت خواهیم کرد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}</code></pre>
<p>هنگامی که تلاش می‌کنیم این کد را کامپایل کنیم، خطایی دریافت می‌کنیم. بازوهای <code>if</code> و <code>else</code> دارای انواع مقداری ناسازگار هستند و راست دقیقاً نشان می‌دهد که مشکل در برنامه کجاست:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>عبارت موجود در بلوک <code>if</code> به یک عدد صحیح ارزیابی می‌شود و عبارت موجود در بلوک <code>else</code> به یک رشته ارزیابی می‌شود. این کار نمی‌کند زیرا متغیرها باید یک نوع مشخص داشته باشند و راست باید در زمان کامپایل بداند که نوع متغیر <code>number</code> چیست. دانستن نوع <code>number</code> به کامپایلر این امکان را می‌دهد که بررسی کند نوع آن در هر جایی که از <code>number</code> استفاده می‌کنیم معتبر است. راست نمی‌توانست این کار را انجام دهد اگر نوع <code>number</code> تنها در زمان اجرا مشخص می‌شد. کامپایلر پیچیده‌تر می‌شد و تضمین‌های کمتری درباره کد ارائه می‌داد اگر مجبور بود انواع فرضی مختلفی را برای هر متغیر پیگیری کند.</p>
<h3 id="تکرار-با-حلقهها"><a class="header" href="#تکرار-با-حلقهها">تکرار با حلقه‌ها</a></h3>
<p>اغلب مفید است که یک بلوک کد بیش از یک بار اجرا شود. برای این کار، Rust چندین <em>حلقه</em> ارائه می‌دهد که کد داخل بدنه حلقه را اجرا کرده و سپس بلافاصله به ابتدای حلقه بازمی‌گردند. برای آزمایش با حلقه‌ها، یک پروژه جدید به نام <em>loops</em> ایجاد کنید.</p>
<p>Rust سه نوع حلقه دارد: <code>loop</code>، <code>while</code> و <code>for</code>. بیایید هر کدام را امتحان کنیم.</p>
<h4 id="تکرار-کد-با-loop"><a class="header" href="#تکرار-کد-با-loop">تکرار کد با <code>loop</code></a></h4>
<p>کلمه کلیدی <code>loop</code> به Rust می‌گوید که یک بلوک کد را بارها و بارها اجرا کند، تا زمانی که شما به طور صریح به آن بگویید متوقف شود.</p>
<p>به عنوان مثال، فایل <em>src/main.rs</em> را در دایرکتوری <em>loops</em> خود به شکل زیر تغییر دهید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("again!");
    }
}</code></pre>
<p>وقتی این برنامه را اجرا کنیم، <code>again!</code> بارها و بارها به طور مداوم چاپ می‌شود تا زمانی که برنامه را به صورت دستی متوقف کنیم. اکثر ترمینال‌ها از میانبر صفحه کلید <kbd>ctrl</kbd>-<kbd>c</kbd> برای متوقف کردن برنامه‌ای که در یک حلقه بی‌پایان گیر کرده است، پشتیبانی می‌کنند. آن را امتحان کنید:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>نماد <code>^C</code> نشان می‌دهد که شما <kbd>ctrl</kbd>-<kbd>c</kbd> را فشار داده‌اید. ممکن است کلمه <code>again!</code> پس از <code>^C</code> چاپ شود یا نشود، بسته به اینکه کد در حلقه در چه مرحله‌ای بوده است که سیگنال قطع دریافت شده است.</p>
<p>خوشبختانه، Rust همچنین روشی برای خروج از یک حلقه با استفاده از کد ارائه می‌دهد. شما می‌توانید کلمه کلیدی <code>break</code> را درون حلقه قرار دهید تا به برنامه بگویید که چه زمانی اجرای حلقه را متوقف کند. به یاد داشته باشید که این کار را در بازی حدس عدد در بخش <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“خروج پس از یک حدس درست”</a><!-- ignore --> در فصل 2 انجام دادیم تا زمانی که کاربر با حدس درست بازی را برنده شد، برنامه خاتمه یابد.</p>
<p>ما همچنین از <code>continue</code> در بازی حدس عدد استفاده کردیم که در یک حلقه به برنامه می‌گوید هر کد باقی‌مانده در این تکرار حلقه را نادیده بگیرد و به تکرار بعدی برود.</p>
<h4 id="بازگرداندن-مقادیر-از-حلقهها"><a class="header" href="#بازگرداندن-مقادیر-از-حلقهها">بازگرداندن مقادیر از حلقه‌ها</a></h4>
<p>یکی از کاربردهای <code>loop</code> این است که یک عملیات را که ممکن است شکست بخورد دوباره امتحان کنید، مثلاً بررسی کنید که آیا یک نخ (thread) کار خود را تمام کرده است یا نه. همچنین ممکن است نیاز داشته باشید نتیجه این عملیات را از حلقه به بقیه کد خود منتقل کنید. برای انجام این کار، می‌توانید مقداری که می‌خواهید برگردانده شود را پس از عبارت <code>break</code> اضافه کنید. این مقدار از حلقه بازگردانده می‌شود تا بتوانید از آن استفاده کنید، همان‌طور که در اینجا نشان داده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}</code></pre></pre>
<p>قبل از حلقه، یک متغیر به نام <code>counter</code> اعلام می‌کنیم و مقدار آن را <code>0</code> مقداردهی اولیه می‌کنیم. سپس یک متغیر به نام <code>result</code> اعلام می‌کنیم تا مقدار بازگشتی از حلقه را نگه دارد. در هر تکرار حلقه، مقدار <code>1</code> را به متغیر <code>counter</code> اضافه می‌کنیم و سپس بررسی می‌کنیم که آیا مقدار <code>counter</code> برابر با <code>10</code> است یا نه. زمانی که این شرط برقرار باشد، از کلمه کلیدی <code>break</code> با مقدار <code>counter * 2</code> استفاده می‌کنیم. پس از حلقه، با استفاده از یک سمی‌کالن، مقدار به <code>result</code> تخصیص داده می‌شود. در نهایت، مقدار <code>result</code> را چاپ می‌کنیم که در این مثال برابر با <code>20</code> است.</p>
<p>شما همچنین می‌توانید از داخل یک حلقه <code>return</code> استفاده کنید. در حالی که <code>break</code> فقط از حلقه جاری خارج می‌شود، <code>return</code> همیشه از تابع جاری خارج می‌شود.</p>
<h4 id="برچسب-حلقهها-برای-رفع-ابهام-بین-چندین-حلقه"><a class="header" href="#برچسب-حلقهها-برای-رفع-ابهام-بین-چندین-حلقه">برچسب حلقه‌ها برای رفع ابهام بین چندین حلقه</a></h4>
<p>اگر حلقه‌هایی تو در تو داشته باشید، <code>break</code> و <code>continue</code> به حلقه داخلی‌ترین حلقه در آن نقطه اعمال می‌شوند. به طور اختیاری می‌توانید یک <em>برچسب حلقه</em> روی یک حلقه مشخص کنید که سپس می‌توانید از آن برچسب با <code>break</code> یا <code>continue</code> استفاده کنید تا مشخص کنید که این کلمات کلیدی به حلقه برچسب‌دار اعمال می‌شوند نه حلقه داخلی‌ترین. برچسب‌های حلقه باید با یک آپاستروف شروع شوند. در اینجا یک مثال با دو حلقه تو در تو آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}</code></pre></pre>
<p>حلقه بیرونی دارای برچسب <code>'counting_up</code> است و از 0 تا 2 شمارش می‌کند. حلقه داخلی بدون برچسب از 10 تا 9 شمارش معکوس می‌کند. اولین <code>break</code> که برچسبی مشخص نمی‌کند فقط از حلقه داخلی خارج می‌شود. عبارت <code>break 'counting_up;</code> از حلقه بیرونی خارج می‌شود. این کد موارد زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="حلقههای-شرطی-با-while"><a class="header" href="#حلقههای-شرطی-با-while">حلقه‌های شرطی با <code>while</code></a></h4>
<p>یک برنامه اغلب نیاز دارد که یک شرط را درون یک حلقه ارزیابی کند. تا زمانی که شرط <code>true</code> باشد، حلقه اجرا می‌شود. زمانی که شرط دیگر <code>true</code> نباشد، برنامه با فراخوانی <code>break</code>، حلقه را متوقف می‌کند. امکان پیاده‌سازی چنین رفتاری با استفاده از ترکیب <code>loop</code>، <code>if</code>، <code>else</code> و <code>break</code> وجود دارد. می‌توانید این را اکنون در یک برنامه امتحان کنید، اگر مایل هستید. با این حال، این الگو آن‌قدر رایج است که Rust یک سازه زبان داخلی برای آن دارد که به آن حلقه <code>while</code> گفته می‌شود. در Listing 3-3، از <code>while</code> برای اجرای برنامه سه بار، شمارش معکوس در هر بار، و سپس چاپ یک پیام و خروج از حلقه استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}</code></pre></pre>
<figcaption>Listing 3-3: استفاده از یک حلقه <code>while</code> برای اجرای کد تا زمانی که شرط برقرار باشد</figcaption>
</figure>
<p>این سازه مقدار زیادی از تو در تویی که در صورت استفاده از <code>loop</code>، <code>if</code>، <code>else</code> و <code>break</code> لازم بود را حذف می‌کند و واضح‌تر است. تا زمانی که یک شرط به مقدار <code>true</code> ارزیابی شود، کد اجرا می‌شود؛ در غیر این صورت، حلقه متوقف می‌شود.</p>
<h4 id="تکرار-از-طریق-یک-مجموعه-با-for"><a class="header" href="#تکرار-از-طریق-یک-مجموعه-با-for">تکرار از طریق یک مجموعه با <code>for</code></a></h4>
<p>شما همچنین می‌توانید از ساختار <code>while</code> برای تکرار در عناصر یک مجموعه مانند یک آرایه استفاده کنید. به عنوان مثال، حلقه در Listing 3-4 هر عنصر در آرایه <code>a</code> را چاپ می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
<figcaption>Listing 3-4: تکرار در هر عنصر یک مجموعه با استفاده از حلقه <code>while</code></figcaption>
</figure>
<p>در اینجا، کد از طریق عناصر آرایه شمارش می‌کند. از اندیس (index)<code>0</code> شروع می‌کند و سپس تا زمانی که به آخرین اندیس (index)در آرایه برسد (یعنی وقتی که <code>index &lt; 5</code> دیگر <code>true</code> نباشد) حلقه می‌زند. اجرای این کد هر عنصر در آرایه را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>همه پنج مقدار آرایه همانطور که انتظار می‌رود در ترمینال ظاهر می‌شوند. حتی اگر <code>index</code> در نهایت به مقدار <code>5</code> برسد، حلقه قبل از تلاش برای گرفتن مقدار ششم از آرایه متوقف می‌شود.</p>
<p>با این حال، این روش مستعد خطاست؛ ما می‌توانیم باعث شویم برنامه در صورت اشتباه بودن مقدار اندیس (index)یا شرط آزمایشی متوقف شود. به عنوان مثال، اگر تعریف آرایه <code>a</code> را به چهار عنصر تغییر دهید اما فراموش کنید شرط را به <code>while index &lt; 4</code> به‌روزرسانی کنید، کد متوقف خواهد شد. همچنین این روش کند است، زیرا کامپایلر کد زمان اجرا را برای انجام بررسی شرطی در مورد اینکه آیا اندیس (index)در محدوده آرایه است یا نه در هر تکرار حلقه اضافه می‌کند.</p>
<p>به عنوان یک جایگزین مختصرتر، می‌توانید از حلقه <code>for</code> استفاده کنید و برای هر مورد در یک مجموعه، کدی اجرا کنید. یک حلقه <code>for</code> شبیه کدی در Listing 3-5 است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}</code></pre></pre>
<figcaption>Listing 3-5: تکرار در هر عنصر یک مجموعه با استفاده از حلقه <code>for</code></figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، خروجی مشابه Listing 3-4 را مشاهده خواهیم کرد. مهم‌تر اینکه، اکنون ایمنی کد را افزایش داده‌ایم و احتمال خطاهایی که ممکن است ناشی از فراتر رفتن از انتهای آرایه یا عدم دسترسی به برخی از آیتم‌ها باشد را حذف کرده‌ایم.</p>
<p>با استفاده از حلقه <code>for</code>، نیازی به به خاطر سپردن تغییر کد دیگری ندارید اگر تعداد مقادیر در آرایه را تغییر دهید، همانطور که با روش استفاده شده در Listing 3-4 باید انجام می‌دادید.</p>
<p>ایمنی و مختصر بودن حلقه‌های <code>for</code> آنها را به رایج‌ترین سازه حلقه‌ای در Rust تبدیل کرده است. حتی در موقعیت‌هایی که می‌خواهید کدی را تعداد مشخصی از دفعات اجرا کنید، مانند مثال شمارش معکوس که از حلقه <code>while</code> در Listing 3-3 استفاده می‌کرد، اکثر برنامه‌نویسان Rust از حلقه <code>for</code> استفاده می‌کنند. روش انجام این کار استفاده از <code>Range</code>، که توسط کتابخانه استاندارد ارائه می‌شود، است که تمام اعداد را به ترتیب از یک عدد شروع کرده و قبل از عدد دیگری به پایان می‌رساند.</p>
<p>این چیزی است که شمارش معکوس با استفاده از یک حلقه <code>for</code> و روش دیگری که هنوز در مورد آن صحبت نکرده‌ایم، یعنی <code>rev</code> برای معکوس کردن محدوده، به نظر می‌رسد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}</code></pre></pre>
<p>این کد کمی بهتر نیست؟</p>
<h2 id="خلاصه-2"><a class="header" href="#خلاصه-2">خلاصه</a></h2>
<p>شما موفق شدید! این یک فصل بزرگ بود: شما درباره متغیرها، انواع داده اسکالر و مرکب، توابع، نظرات، عبارات <code>if</code> و حلقه‌ها یاد گرفتید! برای تمرین با مفاهیم مطرح‌شده در این فصل، سعی کنید برنامه‌هایی برای انجام موارد زیر بسازید:</p>
<ul>
<li>تبدیل دما بین فارنهایت و سلسیوس.</li>
<li>تولید عدد <em>n</em>ام دنباله فیبوناچی.</li>
<li>چاپ متن سرود کریسمس “The Twelve Days of Christmas”، با استفاده از تکرار موجود در این آهنگ.</li>
</ul>
<p>وقتی آماده شدید تا به مرحله بعد بروید، ما درباره مفهومی در Rust صحبت خواهیم کرد که <em>معمولاً</em> در زبان‌های برنامه‌نویسی دیگر وجود ندارد: مالکیت.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="درک-مالکیت"><a class="header" href="#درک-مالکیت">درک مالکیت</a></h1>
<p>مالکیت یکی از ویژگی‌های منحصر به فرد Rust است و تأثیرات عمیقی بر سایر بخش‌های زبان دارد. این ویژگی به Rust اجازه می‌دهد تا بدون نیاز به یک جمع‌آوری زباله (garbage collector)، تضمین‌های ایمنی حافظه را فراهم کند، بنابراین درک چگونگی کارکرد مالکیت بسیار مهم است. در این فصل، ما درباره مالکیت و چند ویژگی مرتبط دیگر صحبت خواهیم کرد: قرض گرفتن (borrowing)، برش‌ها (slices) و نحوه چیدمان داده‌ها در حافظه توسط Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="مالکیت-چیست"><a class="header" href="#مالکیت-چیست">مالکیت چیست؟</a></h2>
<p><em>مالکیت</em> مجموعه‌ای از قوانین است که نحوه مدیریت حافظه را در برنامه‌های Rust تعیین می‌کند. همه برنامه‌ها باید نحوه استفاده از حافظه کامپیوتر را در هنگام اجرا مدیریت کنند. برخی زبان‌ها از جمع‌آوری زباله استفاده می‌کنند که به طور منظم حافظه‌ای را که دیگر استفاده نمی‌شود بررسی می‌کند؛ در دیگر زبان‌ها، برنامه‌نویس باید حافظه را به صورت صریح تخصیص داده و آزاد کند. Rust از یک روش سوم استفاده می‌کند: حافظه از طریق سیستمی از مالکیت با مجموعه‌ای از قوانین مدیریت می‌شود که کامپایلر آن‌ها را بررسی می‌کند. اگر هر یک از این قوانین نقض شود، برنامه کامپایل نخواهد شد. هیچ‌یک از ویژگی‌های مالکیت برنامه شما را در هنگام اجرا کند نمی‌کند.</p>
<p>از آنجا که مالکیت یک مفهوم جدید برای بسیاری از برنامه‌نویسان است، زمان می‌برد تا به آن عادت کنید. خبر خوب این است که هر چه بیشتر با Rust و قوانین سیستم مالکیت آن آشنا شوید، نوشتن کدی که امن و کارآمد باشد برایتان آسان‌تر خواهد شد. به تلاش ادامه دهید!</p>
<p>وقتی مالکیت را درک کنید، پایه‌ای محکم برای درک ویژگی‌هایی که Rust را منحصر به فرد می‌کنند خواهید داشت. در این فصل، مالکیت را با کار بر روی چند مثال که بر یک ساختار داده بسیار رایج تمرکز دارند یاد خواهید گرفت: رشته‌ها.</p>
<section class="note" aria-role="note">
<h3 id="پشته-و-حافظه"><a class="header" href="#پشته-و-حافظه">پشته و حافظه</a></h3>
<p>بسیاری از زبان‌های برنامه‌نویسی شما را مجبور نمی‌کنند که به پشته و حافظه زیاد فکر کنید. اما در یک زبان برنامه‌نویسی سیستمی مانند Rust، این که آیا یک مقدار در پشته است یا در حافظه تأثیر می‌گذارد که زبان چگونه رفتار می‌کند و چرا باید تصمیمات خاصی بگیرید. بخش‌هایی از مالکیت در رابطه با پشته و حافظه در ادامه این فصل توضیح داده خواهند شد، بنابراین در اینجا توضیحی مختصر به عنوان آمادگی آورده شده است.</p>
<p>پشته و حافظه هر دو بخش‌هایی از حافظه هستند که در زمان اجرا در اختیار کد شما قرار می‌گیرند، اما به روش‌های مختلفی ساختار یافته‌اند. پشته مقادیر را به ترتیبی که دریافت می‌کند ذخیره می‌کند و مقادیر را به ترتیب معکوس حذف می‌کند. این به عنوان <em>آخرین ورودی، اولین خروجی</em> شناخته می‌شود. به یک دسته بشقاب فکر کنید: وقتی بشقاب‌های بیشتری اضافه می‌کنید، آن‌ها را روی بالای دسته قرار می‌دهید و وقتی به یک بشقاب نیاز دارید، یکی را از بالای دسته برمی‌دارید. افزودن یا حذف بشقاب‌ها از وسط یا پایین دسته به خوبی کار نمی‌کند! افزودن داده به پشته <em>پوش‌کردن به پشته</em> نامیده می‌شود و حذف داده از آن <em>پاپ‌کردن از پشته</em>. تمام داده‌هایی که در پشته ذخیره می‌شوند باید اندازه‌ای شناخته‌شده و ثابت داشته باشند. داده‌هایی با اندازه ناشناخته در زمان کامپایل یا اندازه‌ای که ممکن است تغییر کند باید در حافظه ذخیره شوند.</p>
<p>حافظه کمتر سازمان‌یافته است: وقتی داده‌ای را در حافظه قرار می‌دهید، مقدار مشخصی از فضا را درخواست می‌کنید. تخصیص‌دهنده حافظه یک مکان خالی در حافظه پیدا می‌کند که به اندازه کافی بزرگ باشد، آن را به عنوان استفاده شده علامت‌گذاری می‌کند و یک <em>اشاره‌گر (Pointer)</em> بازمی‌گرداند که آدرس آن مکان است. این فرآیند <em>تخصیص در حافظه</em> نامیده می‌شود و گاهی اوقات به اختصار <em>تخصیص</em> نامیده می‌شود (پوش‌کردن مقادیر به پشته به عنوان تخصیص در نظر گرفته نمی‌شود). از آنجا که اشاره‌گر (Pointer) به حافظه اندازه‌ای شناخته‌شده و ثابت دارد، می‌توانید اشاره‌گر (Pointer) را در پشته ذخیره کنید، اما وقتی داده واقعی را می‌خواهید، باید اشاره‌گر (Pointer) را دنبال کنید. به ورود به یک رستوران فکر کنید. وقتی وارد می‌شوید، تعداد افراد گروه خود را اعلام می‌کنید و میزبان یک میز خالی پیدا می‌کند که همه را جا دهد و شما را به آنجا می‌برد. اگر کسی از گروه شما دیر برسد، می‌تواند بپرسد کجا نشسته‌اید تا شما را پیدا کند.</p>
<p>پوش‌کردن به پشته سریع‌تر از تخصیص در حافظه است، زیرا تخصیص‌دهنده هرگز مجبور نیست مکان جدیدی برای ذخیره داده‌ها جستجو کند؛ آن مکان همیشه بالای پشته است. در مقایسه، تخصیص فضا در حافظه نیاز به کار بیشتری دارد زیرا تخصیص‌دهنده باید ابتدا مکانی به اندازه کافی بزرگ برای داده پیدا کند و سپس برای تخصیص بعدی آماده‌سازی انجام دهد.</p>
<p>دسترسی به داده در حافظه کندتر از دسترسی به داده در پشته است زیرا باید یک اشاره‌گر (Pointer) را دنبال کنید تا به آن برسید. پردازنده‌های معاصر سریع‌تر هستند اگر در حافظه کمتر پرش کنند. ادامه دادن این تمثیل، در نظر بگیرید که یک پیشخدمت در رستوران سفارش‌های بسیاری از میزها را می‌گیرد. این کارآمدتر است که تمام سفارش‌های یک میز را بگیرد قبل از اینکه به میز بعدی برود. گرفتن سفارش از میز A، سپس از میز B، سپس دوباره یکی از A، و سپس یکی از B فرآیند بسیار کندتری خواهد بود. به همین ترتیب، یک پردازنده می‌تواند بهتر کار خود را انجام دهد اگر روی داده‌ای کار کند که به داده‌های دیگر نزدیک باشد (مانند آنچه در پشته است) تا داده‌ای که دورتر باشد (مانند آنچه ممکن است در حافظه باشد).</p>
<p>وقتی کد شما یک تابع را فراخوانی می‌کند، مقادیری که به تابع منتقل می‌شوند (از جمله، احتمالاً، اشاره‌گر (Pointer)هایی به داده در حافظه) و متغیرهای محلی تابع به پشته پوش می‌شوند. وقتی تابع تمام می‌شود، آن مقادیر از پشته پاپ می‌شوند.</p>
<p>پیگیری این که چه بخش‌هایی از کد از چه داده‌هایی در حافظه استفاده می‌کنند، به حداقل رساندن مقدار داده‌های تکراری در حافظه، و پاک کردن داده‌های استفاده نشده در حافظه به طوری که فضای بیشتری اشغال نشود همه مشکلاتی هستند که مالکیت به آن‌ها می‌پردازد. هنگامی که مالکیت را درک کنید، نیازی نخواهید داشت که اغلب به پشته و حافظه فکر کنید، اما دانستن این که هدف اصلی مالکیت مدیریت داده‌های حافظه است می‌تواند توضیح دهد که چرا به این صورت عمل می‌کند.</p>
</section>
<h3 id="قوانین-مالکیت"><a class="header" href="#قوانین-مالکیت">قوانین مالکیت</a></h3>
<p>ابتدا، بیایید نگاهی به قوانین مالکیت بیندازیم. این قوانین را در ذهن داشته باشید زیرا با مثال‌هایی که آن‌ها را نشان می‌دهند کار می‌کنیم:</p>
<ul>
<li>هر مقدار در Rust یک <em>مالک</em> دارد.</li>
<li>در یک زمان فقط می‌تواند یک مالک وجود داشته باشد.</li>
<li>زمانی که مالک از دامنه خارج شود، مقدار <em>حذف</em> خواهد شد.</li>
</ul>
<h3 id="دامنه-متغیر"><a class="header" href="#دامنه-متغیر">دامنه متغیر</a></h3>
<p>حال که از سینتکس پایه Rust گذشته‌ایم، در مثال‌ها کد کامل <code>fn main() {</code> را نخواهیم آورد. بنابراین، اگر دنبال می‌کنید، مطمئن شوید که مثال‌های زیر را به صورت دستی داخل یک تابع <code>main</code> قرار دهید. در نتیجه، مثال‌های ما کمی مختصرتر خواهند بود و می‌توانیم بر روی جزئیات واقعی به جای کد ابتدایی تمرکز کنیم.</p>
<p>به عنوان اولین مثال از مالکیت، به <em>دامنه</em> برخی متغیرها نگاه می‌کنیم. دامنه محدوده‌ای است که در آن یک آیتم در یک برنامه معتبر است. به متغیر زیر توجه کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>متغیر <code>s</code> به یک رشته‌ی ثابت اشاره دارد، جایی که مقدار رشته به صورت ثابت در متن برنامه ما کدنویسی شده است. این متغیر از نقطه‌ای که اعلام شده معتبر است تا انتهای <em>دامنه</em> جاری. لیست 4-1 برنامه‌ای را با توضیحاتی که نشان می‌دهند متغیر <code>s</code> در کجا معتبر است، نمایش می‌دهد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 4-1: یک متغیر و دامنه‌ای که در آن معتبر است</figcaption>
</figure>
<p>به عبارت دیگر، در اینجا دو نقطه‌ی مهم زمانی وجود دارد:</p>
<ul>
<li>وقتی <code>s</code> وارد دامنه می‌شود، معتبر است.</li>
<li>تا زمانی که از دامنه خارج شود معتبر باقی می‌ماند.</li>
</ul>
<p>در این نقطه، رابطه بین دامنه‌ها و زمان‌هایی که متغیرها معتبر هستند مشابه با زبان‌های برنامه‌نویسی دیگر است. حالا بر اساس این درک، نوع <code>String</code> را معرفی می‌کنیم.</p>
<h3 id="نوع-string"><a class="header" href="#نوع-string">نوع <code>String</code></a></h3>
<p>برای نشان دادن قوانین مالکیت، به نوع داده‌ای نیاز داریم که پیچیده‌تر از آن‌هایی باشد که در بخش <a href="ch03-02-data-types.html#data-types">“انواع داده”</a><!-- ignore --> فصل ۳ بررسی کردیم. انواعی که قبلاً پوشش داده شد، اندازه‌ی مشخصی دارند، می‌توانند در استک ذخیره شوند و وقتی دامنه‌شان تمام شد از استک برداشته شوند و می‌توانند به سرعت و به سادگی برای ساختن یک نمونه‌ی جدید و مستقل کپی شوند اگر قسمت دیگری از کد بخواهد همان مقدار را در دامنه‌ی دیگری استفاده کند. اما ما می‌خواهیم به داده‌هایی نگاه کنیم که در هیپ ذخیره شده‌اند و بررسی کنیم چگونه Rust می‌داند چه زمانی باید این داده‌ها را پاکسازی کند، و نوع <code>String</code> یک مثال عالی است.</p>
<p>ما روی بخش‌هایی از <code>String</code> تمرکز خواهیم کرد که به مالکیت مربوط می‌شوند. این جنبه‌ها همچنین به سایر انواع داده‌های پیچیده اعمال می‌شوند، چه آن‌هایی که توسط کتابخانه استاندارد ارائه شده‌اند و چه آن‌هایی که خودتان ایجاد کرده‌اید. ما <code>String</code> را در فصل <a href="ch08-02-strings.html">۸</a><!-- ignore --> با جزئیات بیشتری بررسی خواهیم کرد.</p>
<p>قبلاً رشته‌های ثابت را دیده‌ایم، جایی که مقدار رشته در کد ما به صورت ثابت قرار گرفته است. رشته‌های ثابت راحت هستند، اما برای هر موقعیتی که ممکن است بخواهیم از متن استفاده کنیم مناسب نیستند. یکی از دلایل این است که آن‌ها تغییرناپذیر هستند. دلیل دیگر این است که نمی‌توان هر مقدار رشته را هنگام نوشتن کد خود دانست: به عنوان مثال، اگر بخواهیم ورودی کاربر را بگیریم و ذخیره کنیم چه؟ برای این شرایط، Rust یک نوع رشته‌ی دیگر به نام <code>String</code> دارد. این نوع داده‌های تخصیص‌یافته در هیپ را مدیریت می‌کند و به همین دلیل می‌تواند مقدار متنی را ذخیره کند که اندازه‌ی آن در زمان کامپایل برای ما ناشناخته است. شما می‌توانید یک <code>String</code> را از یک رشته‌ی ثابت با استفاده از تابع <code>from</code> ایجاد کنید، به این صورت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>عملگر <code>::</code> به ما اجازه می‌دهد این تابع <code>from</code> خاص را تحت نوع <code>String</code> نام‌گذاری کنیم به جای استفاده از نوعی نام مانند <code>string_from</code>. این سینتکس را بیشتر در بخش <a href="ch05-03-method-syntax.html#method-syntax">“سینتکس متد”</a><!-- ignore --> فصل ۵ و هنگامی که در مورد نام‌گذاری با ماژول‌ها صحبت می‌کنیم در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“مسیرها برای ارجاع به یک آیتم در درخت ماژول”</a><!-- ignore --> فصل ۷ بررسی خواهیم کرد.</p>
<p>این نوع رشته <em>می‌تواند</em> تغییر کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // This will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>پس، تفاوت اینجا چیست؟ چرا <code>String</code> می‌تواند تغییر کند اما رشته‌های ثابت نمی‌توانند؟ تفاوت در نحوه‌ی مدیریت حافظه توسط این دو نوع است.</p>
<h3 id="حافظه-و-تخصیص"><a class="header" href="#حافظه-و-تخصیص">حافظه و تخصیص</a></h3>
<p>در مورد یک رشته‌ی ثابت، ما محتوا را در زمان کامپایل می‌دانیم، بنابراین متن به طور مستقیم در فایل اجرایی نهایی کدنویسی شده است. به همین دلیل رشته‌های ثابت سریع و کارآمد هستند. اما این ویژگی‌ها فقط از تغییرناپذیری رشته‌ی ثابت ناشی می‌شوند. متأسفانه، نمی‌توانیم یک تکه حافظه را برای هر قطعه متنی که اندازه‌ی آن در زمان کامپایل ناشناخته است و ممکن است در حین اجرای برنامه تغییر کند، در فایل باینری قرار دهیم.</p>
<p>با نوع <code>String</code>، برای پشتیبانی از یک متن قابل تغییر و قابل رشد، ما نیاز داریم مقداری حافظه را در هیپ تخصیص دهیم که در زمان کامپایل ناشناخته است تا محتوا را نگه داریم. این به این معناست که:</p>
<ul>
<li>حافظه باید در زمان اجرا از تخصیص‌دهنده حافظه درخواست شود.</li>
<li>ما نیاز داریم راهی برای بازگرداندن این حافظه به تخصیص‌دهنده زمانی که کارمان با <code>String</code> تمام شد، داشته باشیم.</li>
</ul>
<p>قسمت اول توسط ما انجام می‌شود: وقتی که <code>String::from</code> را فراخوانی می‌کنیم، پیاده‌سازی آن حافظه‌ای را که نیاز دارد درخواست می‌کند. این تقریباً در تمام زبان‌های برنامه‌نویسی رایج است.</p>
<p>اما قسمت دوم متفاوت است. در زبان‌هایی که دارای <em>جمع‌کننده زباله (GC)</em> هستند، GC حافظه‌ای را که دیگر استفاده نمی‌شود پیگیری و پاک‌سازی می‌کند و ما نیازی به فکر کردن در مورد آن نداریم. در بیشتر زبان‌هایی که GC ندارند، این مسئولیت بر عهده ماست که مشخص کنیم چه زمانی حافظه دیگر استفاده نمی‌شود و کدی را برای آزادسازی صریح آن فراخوانی کنیم، دقیقاً همان‌طور که آن را درخواست کرده‌ایم. انجام درست این کار در تاریخ برنامه‌نویسی یک مشکل دشوار بوده است. اگر فراموش کنیم، حافظه هدر می‌رود. اگر خیلی زود این کار را انجام دهیم، یک متغیر نامعتبر خواهیم داشت. اگر دو بار این کار را انجام دهیم، این هم یک باگ است. ما نیاز داریم دقیقاً یک <code>allocate</code> را با دقیقاً یک <code>free</code> جفت کنیم.</p>
<p>Rust مسیر متفاوتی را طی می‌کند: حافظه به طور خودکار وقتی که متغیری که مالک آن است از دامنه خارج می‌شود بازگردانده می‌شود. در اینجا نسخه‌ای از مثال دامنه ما از فهرست ۴-۱ وجود دارد که از یک <code>String</code> به جای یک رشته‌ی ثابت استفاده می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}</span></code></pre></pre>
<p>یک نقطه طبیعی وجود دارد که می‌توانیم حافظه‌ای را که <code>String</code> ما نیاز دارد به تخصیص‌دهنده بازگردانیم: وقتی <code>s</code> از دامنه خارج می‌شود. وقتی یک متغیر از دامنه خارج می‌شود، Rust یک تابع خاص را برای ما فراخوانی می‌کند. این تابع <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore --> نامیده می‌شود، و اینجا جایی است که نویسنده <code>String</code> می‌تواند کدی برای بازگرداندن حافظه قرار دهد. Rust به طور خودکار <code>drop</code> را در زمان بستن آکولاد فراخوانی می‌کند.</p>
<blockquote>
<p>نکته: در C++، این الگو که منابع در انتهای دوره عمر یک آیتم آزاد می‌شوند گاهی اوقات <em>Resource Acquisition Is Initialization (RAII)</em> نامیده می‌شود. تابع <code>drop</code> در Rust برای کسانی که از الگوهای RAII استفاده کرده‌اند آشنا خواهد بود.</p>
</blockquote>
<p>این الگو تأثیر عمیقی بر نحوه نوشتن کد در Rust دارد. ممکن است اکنون ساده به نظر برسد، اما رفتار کد می‌تواند در موقعیت‌های پیچیده‌تر که می‌خواهیم متغیرهای متعددی از داده‌هایی که در هیپ تخصیص داده‌ایم استفاده کنند، غیرمنتظره باشد. اکنون به بررسی برخی از این موقعیت‌ها می‌پردازیم.</p>
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="تعامل-متغیرها-و-دادهها-با-انتقال-move"><a class="header" href="#تعامل-متغیرها-و-دادهها-با-انتقال-move">تعامل متغیرها و داده‌ها با انتقال (Move)</a></h4>
<p>متغیرهای مختلف می‌توانند در Rust به روش‌های مختلفی با داده‌ها تعامل داشته باشند. بیایید به مثالی با استفاده از یک عدد صحیح در فهرست ۴-۲ نگاه کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 4-2: اختصاص مقدار عدد صحیح متغیر <code>x</code> به <code>y</code></figcaption>
</figure>
<p>ما احتمالاً می‌توانیم حدس بزنیم این کد چه می‌کند: “مقدار <code>5</code> را به <code>x</code> اختصاص بده؛ سپس یک کپی از مقدار <code>x</code> بگیر و آن را به <code>y</code> اختصاص بده.” اکنون دو متغیر داریم، <code>x</code> و <code>y</code>، و هر دو برابر <code>5</code> هستند. این دقیقاً همان چیزی است که اتفاق می‌افتد، زیرا اعداد صحیح مقادیر ساده‌ای با اندازه‌ی مشخص هستند، و این دو مقدار <code>5</code> به استک اضافه می‌شوند.</p>
<p>اکنون بیایید به نسخه <code>String</code> نگاه کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>این بسیار مشابه به نظر می‌رسد، بنابراین ممکن است فرض کنیم که نحوه عملکرد آن نیز مشابه است: یعنی، خط دوم یک کپی از مقدار موجود در <code>s1</code> می‌گیرد و آن را به <code>s2</code> اختصاص می‌دهد. اما این دقیقاً چیزی نیست که اتفاق می‌افتد.</p>
<p>به شکل ۴-۱ نگاه کنید تا ببینید که در پشت صحنه با <code>String</code> چه اتفاقی می‌افتد. یک <code>String</code> از سه بخش تشکیل شده است که در سمت چپ نشان داده شده‌اند: یک اشاره‌گر (Pointer) به حافظه‌ای که محتوای رشته را نگه می‌دارد، یک طول، و یک ظرفیت. این گروه داده‌ها روی استک ذخیره می‌شوند. در سمت راست، حافظه روی هیپ قرار دارد که محتوای رشته را نگه می‌دارد.</p>
<img alt="دو جدول: جدول اول نمایش s1 روی استک را نشان می‌دهد که شامل طول (۵)، ظرفیت (۵)، و اشاره‌گر (Pointer)ی به اولین مقدار در جدول دوم است. جدول دوم نمایش داده‌های رشته روی هیپ را بایت به بایت نشان می‌دهد." src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۴-۱: نمایش در حافظه یک <code>String</code> که مقدار <code>"hello"</code> به <code>s1</code> متصل است</span></p>
<p>طول مشخص می‌کند که محتوای <code>String</code> در حال حاضر چقدر حافظه به بایت استفاده می‌کند. ظرفیت مقدار کل حافظه‌ای است که <code>String</code> از تخصیص‌دهنده دریافت کرده است. تفاوت بین طول و ظرفیت اهمیت دارد، اما نه در این زمینه، بنابراین در حال حاضر می‌توان ظرفیت را نادیده گرفت.</p>
<p>وقتی <code>s1</code> را به <code>s2</code> اختصاص می‌دهیم، داده‌های <code>String</code> کپی می‌شوند، به این معنی که اشاره‌گر (Pointer)، طول، و ظرفیت موجود روی استک را کپی می‌کنیم. ما داده‌های روی هیپ را که اشاره‌گر (Pointer) به آن اشاره می‌کند، کپی نمی‌کنیم. به عبارت دیگر، نمایش داده‌ها در حافظه به شکل ۴-۲ به نظر می‌رسد.</p>
<img alt="سه جدول: جدول‌های s1 و s2 به ترتیب نمایش‌دهنده رشته‌ها روی استک هستند و هر دو به داده‌های رشته یکسان روی هیپ اشاره می‌کنند." src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۴-۲: نمایش در حافظه متغیر <code>s2</code> که یک کپی از اشاره‌گر (Pointer)، طول، و ظرفیت <code>s1</code> دارد</span></p>
<p>نمایش داده‌ها <em>به این شکل</em> نیست که در شکل ۴-۳ آمده است، که نشان می‌دهد حافظه به گونه‌ای باشد که Rust همچنین داده‌های هیپ را کپی کند. اگر Rust این کار را انجام می‌داد، عملیات <code>s2 = s1</code> می‌توانست از نظر عملکرد زمان اجرا بسیار گران باشد اگر داده‌های روی هیپ بزرگ بودند.</p>
<img alt="چهار جدول: دو جدول نمایانگر داده‌های استک برای s1 و s2 هستند و هر کدام به نسخه خود از داده‌های رشته روی هیپ اشاره می‌کنند." src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۴-۳: یک امکان دیگر برای آنچه که <code>s2 = s1</code> ممکن است انجام دهد اگر Rust داده‌های هیپ را نیز کپی کند</span></p>
<p>قبلاً گفتیم که وقتی یک متغیر از دامنه خارج می‌شود، Rust به طور خودکار تابع <code>drop</code> را فراخوانی می‌کند و حافظه هیپ را برای آن متغیر پاک‌سازی می‌کند. اما شکل ۴-۲ نشان می‌دهد که هر دو اشاره‌گر (Pointer) داده‌ها به یک مکان اشاره می‌کنند. این یک مشکل است: وقتی <code>s2</code> و <code>s1</code> از دامنه خارج می‌شوند، هر دو سعی می‌کنند همان حافظه را آزاد کنند. این به عنوان یک خطای <em>آزادسازی دوباره</em> شناخته می‌شود و یکی از مشکلات ایمنی حافظه است که قبلاً ذکر کردیم. آزادسازی حافظه دو بار می‌تواند منجر به خراب شدن حافظه شود، که به طور بالقوه می‌تواند منجر به آسیب‌پذیری‌های امنیتی شود.</p>
<p>برای اطمینان از ایمنی حافظه، پس از خط <code>let s2 = s1;</code>، Rust متغیر <code>s1</code> را دیگر معتبر نمی‌داند. بنابراین، Rust نیازی به آزادسازی هیچ چیزی ندارد وقتی <code>s1</code> از دامنه خارج می‌شود. بررسی کنید که وقتی سعی می‌کنید <code>s1</code> را پس از ایجاد <code>s2</code> استفاده کنید، چه اتفاقی می‌افتد؛ این کار جواب نمی‌دهد:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>شما خطایی مشابه این دریافت خواهید کرد زیرا Rust از استفاده از مرجع نامعتبر جلوگیری می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>اگر اصطلاحات <em>کپی سطحی</em> و <em>کپی عمیق</em> را هنگام کار با زبان‌های دیگر شنیده‌اید، مفهوم کپی کردن اشاره‌گر (Pointer)، طول، و ظرفیت بدون کپی کردن داده احتمالاً شبیه به انجام یک کپی سطحی است. اما به دلیل اینکه Rust همچنین متغیر اول را نامعتبر می‌کند، به جای اینکه آن را کپی سطحی بنامند، به عنوان یک <em>انتقال</em> شناخته می‌شود. در این مثال، می‌توانیم بگوییم که <code>s1</code> به <code>s2</code> <em>منتقل</em> شده است. بنابراین، آنچه در واقع اتفاق می‌افتد در شکل ۴-۴ نشان داده شده است.</p>
<img alt="سه جدول: جدول‌های s1 و s2 که به ترتیب نمایش‌دهنده رشته‌ها روی استک هستند و هر دو به داده‌های رشته یکسان روی هیپ اشاره می‌کنند. جدول s1 خاکستری شده زیرا s1 دیگر معتبر نیست؛ تنها s2 می‌تواند برای دسترسی به داده‌های هیپ استفاده شود." src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۴-۴: نمایش در حافظه پس از اینکه <code>s1</code> نامعتبر شده است</span></p>
<p>این مشکل ما را حل می‌کند! با تنها <code>s2</code> که معتبر است، وقتی از دامنه خارج می‌شود، تنها آن حافظه را آزاد خواهد کرد و کار ما تمام است.</p>
<p>علاوه بر این، یک انتخاب طراحی وجود دارد که از این نتیجه‌گیری می‌شود: Rust هرگز به طور خودکار “کپی عمیق” داده‌های شما را ایجاد نمی‌کند. بنابراین، هر گونه کپی <em>خودکار</em> می‌تواند به‌عنوان عملی ارزان از نظر عملکرد زمان اجرا در نظر گرفته شود.</p>
<h4 id="دامنه-و-انتساب"><a class="header" href="#دامنه-و-انتساب">دامنه و انتساب</a></h4>
<p>عکس این رابطه بین دامنه‌بندی، مالکیت، و آزادسازی حافظه از طریق تابع <code>drop</code> نیز صحیح است. وقتی یک مقدار کاملاً جدید به یک متغیر موجود اختصاص می‌دهید، Rust تابع <code>drop</code> را فراخوانی می‌کند و حافظه مقدار اصلی را بلافاصله آزاد می‌کند. به این کد توجه کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>ابتدا یک متغیر <code>s</code> را اعلان می‌کنیم و آن را به یک <code>String</code> با مقدار <code>"hello"</code> اختصاص می‌دهیم. سپس بلافاصله یک <code>String</code> جدید با مقدار <code>"ahoy"</code> ایجاد می‌کنیم و آن را به <code>s</code> اختصاص می‌دهیم. در این نقطه، هیچ چیزی به مقدار اصلی روی هیپ اشاره نمی‌کند.</p>
<img alt="یک جدول s که نمایانگر مقدار رشته روی استک است و به بخش دوم داده‌های رشته (ahoy) روی هیپ اشاره می‌کند، با داده‌های رشته اصلی (hello) که خاکستری شده زیرا دیگر نمی‌توان به آن دسترسی داشت." src="img/trpl04-05.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۴-۵: نمایش در حافظه پس از اینکه مقدار اولیه به طور کامل جایگزین شده است.</span></p>
<p>رشته اصلی بلافاصله از دامنه خارج می‌شود. Rust تابع <code>drop</code> را روی آن اجرا می‌کند و حافظه آن بلافاصله آزاد می‌شود. وقتی مقدار را در انتها چاپ می‌کنیم، مقدار <code>"ahoy, world!"</code> خواهد بود.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="تعامل-متغیرها-و-دادهها-با-clone"><a class="header" href="#تعامل-متغیرها-و-دادهها-با-clone">تعامل متغیرها و داده‌ها با Clone</a></h4>
<p>اگر بخواهیم داده‌های هیپ <code>String</code> را عمیقاً کپی کنیم، نه فقط داده‌های استک، می‌توانیم از یک متد معمول به نام <code>clone</code> استفاده کنیم. ما نحو متدها را در فصل ۵ بررسی خواهیم کرد، اما از آنجا که متدها یک ویژگی رایج در بسیاری از زبان‌های برنامه‌نویسی هستند، احتمالاً قبلاً آنها را دیده‌اید.</p>
<p>در اینجا یک مثال از روش <code>clone</code> در عمل آورده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>این کد به خوبی کار می‌کند و به وضوح رفتار نشان داده شده در شکل ۴-۳ را تولید می‌کند، جایی که داده‌های هیپ <em>کپی</em> می‌شوند.</p>
<p>وقتی یک فراخوانی به <code>clone</code> می‌بینید، می‌دانید که کدی دلخواه اجرا می‌شود و ممکن است این کد هزینه‌بر باشد. این یک شاخص بصری است که نشان می‌دهد چیزی متفاوت در حال رخ دادن است.</p>
<h4 id="دادههای-فقط-استک-copy"><a class="header" href="#دادههای-فقط-استک-copy">داده‌های فقط استک: Copy</a></h4>
<p>یک نکته دیگر وجود دارد که هنوز درباره آن صحبت نکرده‌ایم. این کد که از اعداد صحیح استفاده می‌کند - بخشی از آن در لیستینگ ۴-۲ نشان داده شده است - کار می‌کند و معتبر است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>اما این کد به نظر می‌رسد با آنچه که به تازگی یاد گرفتیم تناقض دارد: ما یک فراخوانی به <code>clone</code> نداریم، اما <code>x</code> همچنان معتبر است و به <code>y</code> منتقل نشده است.</p>
<p>دلیل این است که انواعی مانند اعداد صحیح که اندازه مشخصی در زمان کامپایل دارند، به طور کامل روی استک ذخیره می‌شوند، بنابراین کپی کردن مقادیر واقعی سریع است. این به این معناست که هیچ دلیلی وجود ندارد که بخواهیم <code>x</code> پس از ایجاد متغیر <code>y</code> نامعتبر شود. به عبارت دیگر، در اینجا تفاوتی بین کپی عمیق و کپی سطحی وجود ندارد، بنابراین فراخوانی <code>clone</code> کاری متفاوت از کپی سطحی معمول انجام نمی‌دهد و می‌توانیم آن را حذف کنیم.</p>
<p>Rust دارای یک نشانه‌گذاری ویژه به نام ویژگی <code>Copy</code> است که می‌توانیم روی انواعی که روی استک ذخیره می‌شوند (مانند اعداد صحیح) اعمال کنیم (ما در <a href="ch10-02-traits.html">فصل ۱۰</a><!-- ignore --> بیشتر درباره ویژگی‌ها صحبت خواهیم کرد). اگر یک نوع ویژگی <code>Copy</code> را پیاده‌سازی کند، متغیرهایی که از آن استفاده می‌کنند جابه‌جا نمی‌شوند، بلکه به سادگی کپی می‌شوند و پس از اختصاص به متغیر دیگری همچنان معتبر باقی می‌مانند.</p>
<p>Rust به ما اجازه نمی‌دهد یک نوع را با <code>Copy</code> نشانه‌گذاری کنیم اگر نوع یا هر یک از اجزای آن ویژگی <code>Drop</code> را پیاده‌سازی کرده باشند. اگر نوع به چیزی خاص نیاز داشته باشد تا زمانی که مقدار از دامنه خارج شود و ما ویژگی <code>Copy</code> را به آن نوع اضافه کنیم، یک خطای زمان کامپایل دریافت خواهیم کرد. برای یادگیری نحوه افزودن ویژگی <code>Copy</code> به نوع خود برای پیاده‌سازی این ویژگی، به <a href="appendix-03-derivable-traits.html">“ویژگی‌های قابل اشتقاق”</a><!-- ignore --> در ضمیمه ج مراجعه کنید.</p>
<p>پس، چه نوع‌هایی ویژگی <code>Copy</code> را پیاده‌سازی می‌کنند؟ می‌توانید برای اطمینان، مستندات نوع داده شده را بررسی کنید، اما به عنوان یک قانون کلی، هر گروه از مقادیر ساده و اسکالر می‌توانند ویژگی <code>Copy</code> را پیاده‌سازی کنند و هیچ چیزی که نیاز به تخصیص یا نوعی منبع داشته باشد نمی‌تواند ویژگی <code>Copy</code> را پیاده‌سازی کند. در اینجا تعدادی از انواعی که ویژگی <code>Copy</code> را پیاده‌سازی می‌کنند آورده شده است:</p>
<ul>
<li>تمام انواع اعداد صحیح، مانند <code>u32</code>.</li>
<li>نوع بولی، <code>bool</code>، با مقادیر <code>true</code> و <code>false</code>.</li>
<li>تمام انواع اعشاری، مانند <code>f64</code>.</li>
<li>نوع کاراکتر، <code>char</code>.</li>
<li>تاپل‌ها، اگر تنها شامل انواعی باشند که ویژگی <code>Copy</code> را نیز پیاده‌سازی می‌کنند. برای مثال، <code>(i32, i32)</code> ویژگی <code>Copy</code> را پیاده‌سازی می‌کند، اما <code>(i32, String)</code> این کار را نمی‌کند.</li>
</ul>
<h3 id="مالکیت-و-توابع"><a class="header" href="#مالکیت-و-توابع">مالکیت و توابع</a></h3>
<p>مکانیزم‌های انتقال یک مقدار به یک تابع مشابه زمانی است که مقداری را به یک متغیر اختصاص می‌دهیم. انتقال یک متغیر به یک تابع به همان صورت که تخصیص انجام می‌شود، جابه‌جا یا کپی می‌شود. لیستینگ ۴-۳ مثالی با برخی حاشیه‌نویسی‌ها دارد که نشان می‌دهد متغیرها کجا وارد و از دامنه خارج می‌شوند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // because i32 implements the Copy trait,
                                    // x does NOT move into the function,
    println!("{}", x);              // so it's okay to use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<figcaption>Listing 4-3: توابع با مالکیت و دامنه حاشیه‌نویسی شده</figcaption>
</figure>
<p>اگر بخواهیم از <code>s</code> پس از فراخوانی به <code>takes_ownership</code> استفاده کنیم، Rust یک خطای زمان کامپایل صادر می‌کند. این بررسی‌های استاتیک ما را از اشتباهات محافظت می‌کنند. سعی کنید کدی به <code>main</code> اضافه کنید که از <code>s</code> و <code>x</code> استفاده کند تا ببینید کجا می‌توانید از آن‌ها استفاده کنید و کجا قوانین مالکیت مانع شما می‌شوند.</p>
<h3 id="مقادیر-بازگشتی-و-دامنه"><a class="header" href="#مقادیر-بازگشتی-و-دامنه">مقادیر بازگشتی و دامنه</a></h3>
<p>بازگرداندن مقادیر نیز می‌تواند مالکیت را منتقل کند. لیستینگ ۴-۴ مثالی از یک تابع که مقداری را بازمی‌گرداند نشان می‌دهد، با حاشیه‌نویسی‌هایی مشابه آنچه در لیستینگ ۴-۳ وجود داشت.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<figcaption>Listing 4-4: انتقال مالکیت مقادیر بازگشتی</figcaption>
</figure>
<p>مالکیت یک متغیر همیشه از یک الگوی یکسان پیروی می‌کند: تخصیص یک مقدار به متغیر دیگر آن را جابه‌جا می‌کند. زمانی که یک متغیر شامل داده‌هایی در هیپ از دامنه خارج می‌شود، مقدار با استفاده از <code>drop</code> پاک‌سازی می‌شود مگر اینکه مالکیت داده‌ها به متغیر دیگری منتقل شده باشد.</p>
<p>در حالی که این روش کار می‌کند، گرفتن مالکیت و سپس بازگرداندن آن با هر تابع کمی خسته‌کننده است. اگر بخواهیم اجازه دهیم یک تابع از یک مقدار استفاده کند اما مالکیت آن را نگیرد، چه می‌شود؟ این که هر چیزی که به تابع ارسال می‌کنیم باید بازگردانده شود تا بتوانیم دوباره از آن استفاده کنیم، علاوه بر هر داده‌ای که از بدنه تابع ممکن است بخواهیم بازگردانیم، کمی آزاردهنده است.</p>
<p>Rust به ما اجازه می‌دهد مقادیر متعددی را با استفاده از یک tuple بازگردانیم، همانطور که در لیستینگ ۴-۵ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<figcaption>Listing 4-5: بازگرداندن مالکیت پارامترها</figcaption>
</figure>
<p>اما این کار بسیار رسمی و زمان‌بر است برای مفهومی که باید رایج باشد. خوشبختانه، Rust ویژگی‌ای برای استفاده از یک مقدار بدون انتقال مالکیت دارد که <em>ارجاعات</em> نامیده می‌شود.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ارجاعات-و-قرض-گرفتن-references-and-borrowing"><a class="header" href="#ارجاعات-و-قرض-گرفتن-references-and-borrowing">ارجاعات و قرض گرفتن (References and Borrowing)</a></h2>
<p>مشکل کدی که در لیستینگ 4-5 با استفاده از تاپل وجود دارد این است که باید
<code>String</code> را به تابع فراخوانی‌کننده بازگردانیم تا بعد از فراخوانی
<code>calculate_length</code> بتوانیم همچنان از
<code>String</code> استفاده کنیم، زیرا
<code>String</code> به
<code>calculate_length</code> منتقل شده است. در عوض، می‌توانیم یک ارجاع به مقدار
<code>String</code> ارائه دهیم. یک <em>ارجاع</em> مشابه یک اشاره‌گر (Pointer) است، به این معنا که یک آدرس است که می‌توانیم از آن پیروی کنیم تا به داده‌هایی که در آن آدرس ذخیره شده‌اند دسترسی پیدا کنیم؛ این داده‌ها متعلق به متغیر دیگری هستند. برخلاف اشاره‌گر (Pointer)، یک ارجاع تضمین می‌کند که به یک مقدار معتبر از نوع خاصی در طول عمر آن ارجاع اشاره می‌کند.</p>
<p>در اینجا نحوه تعریف و استفاده از یک تابع
<code>calculate_length</code> آورده شده است که به جای گرفتن مالکیت مقدار، یک ارجاع به یک شی به عنوان پارامتر دارد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>اول، توجه کنید که تمام کد مربوط به تاپل در اعلام متغیر و مقدار بازگشتی تابع حذف شده است. دوم، دقت کنید که ما
<code>&amp;s1</code> را به
<code>calculate_length</code> می‌دهیم و در تعریف آن،
<code>&amp;String</code> می‌گیریم به جای
<code>String</code>. این علامت‌های &amp; نماینده‌ی <em>ارجاعات</em> هستند و به شما اجازه می‌دهند تا به مقداری اشاره کنید بدون اینکه مالکیت آن را بگیرید. شکل 4-6 این مفهوم را نشان می‌دهد.</p>
<img alt="سه جدول: جدول s فقط یک اشاره‌گر (Pointer) به جدول s1 دارد. جدول s1 شامل داده‌های استک برای s1 است و به داده‌های رشته‌ای در هیپ اشاره می‌کند." src="img/trpl04-06.svg" class="center" />
<p><span class="caption">شکل 4-6: نمودار <code>&amp;String s</code> که به <code>String s1</code> اشاره می‌کند</span></p>
<blockquote>
<p>توجه: متضاد ارجاع دادن با استفاده از <code>&amp;</code>، <em>عدم ارجاع</em> است که با عملگر عدم ارجاع، یعنی <code>*</code>، انجام می‌شود. برخی از موارد استفاده از عملگر عدم ارجاع را در فصل 8 خواهیم دید و جزئیات مربوط به عدم ارجاع را در فصل 15 بحث خواهیم کرد.</p>
</blockquote>
<p>بیایید نگاهی دقیق‌تر به فراخوانی تابع بیندازیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>سینتکس <code>&amp;s1</code> به ما اجازه می‌دهد یک ارجاع ایجاد کنیم که به مقدار
<code>s1</code> <em>اشاره می‌کند</em> اما مالک آن نیست. از آنجایی که ارجاع مالک آن نیست، مقداری که به آن اشاره می‌کند زمانی که ارجاع استفاده نمی‌شود حذف نخواهد شد.</p>
<p>به همین ترتیب، امضای تابع از <code>&amp;</code> استفاده می‌کند تا نشان دهد که نوع پارامتر <code>s</code> یک ارجاع است. بیایید برخی توضیحات اضافه کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because s does not have ownership of what
  // it refers to, the value is not dropped.</code></pre></pre>
<p>دامنه‌ای که متغیر <code>s</code> در آن معتبر است، مشابه دامنه‌ی هر پارامتر تابع است، اما مقدار اشاره‌شده توسط ارجاع زمانی که <code>s</code> استفاده نمی‌شود حذف نمی‌شود، زیرا <code>s</code> مالکیت ندارد. وقتی توابع ارجاعات را به جای مقادیر واقعی به عنوان پارامتر دارند، نیازی نخواهیم داشت مقادیر را بازگردانیم تا مالکیت را بازگردانیم، زیرا هرگز مالکیتی نداشته‌ایم.</p>
<p>ما عمل ایجاد یک ارجاع را <em>قرض گرفتن</em> می‌نامیم. همانند زندگی واقعی، اگر شخصی چیزی را مالک باشد، شما می‌توانید آن را از او قرض بگیرید. وقتی کارتان تمام شد، باید آن را بازگردانید. شما مالک آن نیستید.</p>
<p>پس چه اتفاقی می‌افتد اگر بخواهیم چیزی که قرض گرفته‌ایم را تغییر دهیم؟ کد موجود در لیستینگ 4-6 را امتحان کنید. هشدار: این کار نمی‌کند!</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
<figcaption>Listing 4-6: تلاش برای تغییر مقدار قرض گرفته شده</figcaption>
</figure>
<p>در اینجا خطا آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>همانطور که متغیرها به صورت پیش‌فرض غیرقابل تغییر هستند، ارجاعات نیز به همین صورت هستند. ما اجازه نداریم چیزی که به آن ارجاع داریم را تغییر دهیم.</p>
<h3 id="ارجاعات-متغیر"><a class="header" href="#ارجاعات-متغیر">ارجاعات متغیر</a></h3>
<p>ما می‌توانیم کد موجود در لیستینگ 4-6 را طوری اصلاح کنیم که به ما اجازه دهد یک مقدار قرض گرفته شده را تغییر دهیم، با چند تغییر کوچک که به جای آن از <em>ارجاع متغیر</em> استفاده کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</figure>
<p>ابتدا <code>s</code> را به <code>mut</code> تغییر می‌دهیم. سپس یک ارجاع متغیر با <code>&amp;mut s</code> ایجاد می‌کنیم، جایی که تابع <code>change</code> را فراخوانی می‌کنیم، و امضای تابع را به‌روزرسانی می‌کنیم تا یک ارجاع متغیر با <code>some_string: &amp;mut String</code> بپذیرد. این بسیار واضح می‌کند که تابع <code>change</code> مقدار قرض گرفته شده را تغییر خواهد داد.</p>
<p>ارجاعات متغیر یک محدودیت بزرگ دارند: اگر یک ارجاع متغیر به یک مقدار داشته باشید، نمی‌توانید هیچ ارجاع دیگری به آن مقدار داشته باشید. این کد که تلاش می‌کند دو ارجاع متغیر به <code>s</code> ایجاد کند، ناموفق خواهد بود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
</figure>
<p>در اینجا خطا آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>این خطا می‌گوید که این کد نامعتبر است زیرا نمی‌توانیم <code>s</code> را به طور همزمان بیش از یک بار به صورت متغیر قرض بگیریم. اولین قرض متغیر در <code>r1</code> است و باید تا زمانی که در <code>println!</code> استفاده شود باقی بماند، اما بین ایجاد آن ارجاع متغیر و استفاده از آن، ما سعی کردیم یک ارجاع متغیر دیگر در <code>r2</code> ایجاد کنیم که همان داده‌ای را قرض می‌گیرد که <code>r1</code> نیز قرض گرفته است.</p>
<p>محدودیتی که از ایجاد چند ارجاع متغیر به داده‌های یکسان به طور همزمان جلوگیری می‌کند، امکان تغییر داده‌ها را فراهم می‌کند اما به صورت بسیار کنترل شده. این چیزی است که تازه‌کاران زبان Rust ممکن است با آن مشکل داشته باشند زیرا اکثر زبان‌ها به شما اجازه می‌دهند هر زمان که بخواهید داده‌ها را تغییر دهید. مزیت این محدودیت این است که Rust می‌تواند از مسابقات داده (<em>data race</em>) در زمان کامپایل جلوگیری کند. یک <em>مسابقه داده</em> مشابه یک شرایط مسابقه (<em>race condition</em>) است و زمانی رخ می‌دهد که این سه رفتار اتفاق بیفتند:</p>
<ul>
<li>دو یا چند اشاره‌گر (Pointer) به طور همزمان به داده‌های یکسان دسترسی پیدا می‌کنند.</li>
<li>حداقل یکی از اشاره‌گر (Pointer)ها برای نوشتن در داده‌ها استفاده می‌شود.</li>
<li>هیچ مکانیزمی برای هماهنگ کردن دسترسی به داده‌ها استفاده نمی‌شود.</li>
</ul>
<p>مسابقات داده باعث رفتار نامشخص می‌شوند و در زمان اجرای برنامه ممکن است یافتن و رفع آن‌ها دشوار باشد؛ Rust با عدم کامپایل کدهای دارای مسابقات داده از این مشکل جلوگیری می‌کند!</p>
<p>همانطور که همیشه، می‌توانیم از آکولادها برای ایجاد یک اسکوپ جدید استفاده کنیم که امکان وجود ارجاعات متغیر متعدد را فراهم می‌کند، اما نه به صورت <em>همزمان</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust یک قانون مشابه برای ترکیب ارجاعات متغیر و غیرمتغیر اعمال می‌کند. این کد منجر به خطا می‌شود:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>در اینجا خطا آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>ای وای! ما <em>همچنین</em> نمی‌توانیم یک ارجاع متغیر داشته باشیم در حالی که یک ارجاع غیرمتغیر به همان مقدار داریم.</p>
<p>کاربرانی که از یک ارجاع غیرمتغیر استفاده می‌کنند، انتظار ندارند که مقدار به طور ناگهانی تغییر کند! با این حال، چندین ارجاع غیرمتغیر مجاز هستند زیرا هیچ‌کسی که فقط داده‌ها را می‌خواند، نمی‌تواند خواندن دیگران را تحت تأثیر قرار دهد.</p>
<p>توجه داشته باشید که اسکوپ یک ارجاع از جایی که معرفی می‌شود شروع شده و تا آخرین باری که از آن استفاده می‌شود ادامه دارد. به عنوان مثال، این کد کامپایل می‌شود زیرا آخرین استفاده از ارجاعات غیرمتغیر در <code>println!</code> است، قبل از اینکه ارجاع متغیر معرفی شود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!("{r1} and {r2}");
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>اسکوپ‌های ارجاعات غیرمتغیر <code>r1</code> و <code>r2</code> بعد از <code>println!</code> که در آنجا آخرین بار استفاده شده‌اند به پایان می‌رسند، که این قبل از ایجاد ارجاع متغیر <code>r3</code> است. این اسکوپ‌ها همپوشانی ندارند، بنابراین این کد مجاز است: کامپایلر می‌تواند تشخیص دهد که ارجاع دیگر در نقطه‌ای قبل از پایان اسکوپ استفاده نمی‌شود.</p>
<p>حتی اگر خطاهای قرض گرفتن ممکن است گاهی اوقات ناامیدکننده باشند، به یاد داشته باشید که این کامپایلر Rust است که به شما نشان می‌دهد یک باگ بالقوه در اوایل (در زمان کامپایل به جای زمان اجرا) وجود دارد و دقیقا به شما می‌گوید مشکل کجاست. سپس نیازی نیست که پیگیری کنید چرا داده‌های شما آن چیزی نیست که فکر می‌کردید.</p>
<h3 id="ارجاعات-آویزان"><a class="header" href="#ارجاعات-آویزان">ارجاعات آویزان</a></h3>
<p>در زبان‌هایی که از اشاره‌گر (Pointer)ها استفاده می‌کنند، ایجاد اشتباه یک <em>اشاره‌گر (Pointer) آویزان</em> آسان است—اشاره‌گر (Pointer)ی که به مکانی در حافظه اشاره می‌کند که ممکن است به شخص دیگری داده شده باشد—با آزاد کردن مقداری حافظه در حالی که اشاره‌گر (Pointer) به آن حافظه را حفظ می‌کنید. در Rust، برعکس، کامپایلر تضمین می‌کند که ارجاعات هرگز ارجاعات آویزان نخواهند بود: اگر به داده‌هایی ارجاع دارید، کامپایلر اطمینان می‌دهد که داده‌ها قبل از ارجاع به داده‌ها از محدوده خارج نمی‌شوند.</p>
<p>بیایید سعی کنیم یک ارجاع آویزان ایجاد کنیم تا ببینیم چگونه Rust با یک خطای زمان کامپایل از این اتفاق جلوگیری می‌کند:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
<p>در اینجا خطا آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>این پیام خطا به ویژگی‌ای اشاره دارد که هنوز پوشش نداده‌ایم: طول عمرها (<em>lifetimes</em>). ما طول عمرها را به طور مفصل در فصل 10 مورد بحث قرار خواهیم داد. اما، اگر بخش‌های مربوط به طول عمرها را نادیده بگیرید، پیام کلید مشکل این کد را بیان می‌کند:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>بیایید نگاهی دقیق‌تر به آنچه که در هر مرحله از کد <code>dangle</code> اتفاق می‌افتد بیندازیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!</code></pre>
<p>از آنجا که <code>s</code> داخل <code>dangle</code> ایجاد می‌شود، زمانی که کد <code>dangle</code> تمام می‌شود، <code>s</code> از محدوده خارج می‌شود و آزاد می‌گردد. اما ما سعی کردیم یک ارجاع به آن برگردانیم. این بدان معناست که این ارجاع به یک <code>String</code> نامعتبر اشاره می‌کند. این خوب نیست! Rust اجازه نمی‌دهد این کار را انجام دهیم.</p>
<p>راه‌حل در اینجا این است که به جای آن <code>String</code> را به طور مستقیم برگردانید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>این بدون هیچ مشکلی کار می‌کند. مالکیت به بیرون منتقل می‌شود و هیچ چیزی آزاد نمی‌شود.</p>
<h3 id="قوانین-ارجاعات"><a class="header" href="#قوانین-ارجاعات">قوانین ارجاعات</a></h3>
<p>بیایید آنچه درباره ارجاعات بحث کردیم را مرور کنیم:</p>
<ul>
<li>در هر زمان مشخص، می‌توانید <em>یا</em> یک ارجاع متغیر داشته باشید <em>یا</em> هر تعداد ارجاع غیرمتغیر.</li>
<li>ارجاعات باید همیشه معتبر باشند.</li>
</ul>
<p>در مرحله بعد، به نوع دیگری از ارجاع خواهیم پرداخت: بخش‌ها (<em>slices</em>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="نوع-slice"><a class="header" href="#نوع-slice">نوع Slice</a></h2>
<p><em>Slice</em> ها به شما اجازه می‌دهند تا به یک توالی پیوسته از عناصر در یک <a href="ch08-00-common-collections.html">مجموعه</a> ارجاع دهید، به جای کل مجموعه. یک slice نوعی ارجاع است، بنابراین مالکیت ندارد.</p>
<p>در اینجا یک مسئله برنامه‌نویسی کوچک داریم: یک تابع بنویسید که یک رشته از کلمات جدا شده با فاصله‌ها را بگیرد و اولین کلمه‌ای که در آن رشته پیدا می‌کند را برگرداند. اگر تابع هیچ فاصله‌ای در رشته پیدا نکند، کل رشته باید یک کلمه باشد، بنابراین باید کل رشته برگردانده شود.</p>
<p>بیایید بررسی کنیم که چگونه می‌توانیم امضای این تابع را بدون استفاده از slices بنویسیم تا مسئله‌ای که slices حل می‌کنند را بهتر درک کنیم:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>تابع <code>first_word</code> یک <code>&amp;String</code> به عنوان پارامتر دارد. ما به مالکیت نیاز نداریم، بنابراین این مشکلی ندارد. (در Rust ایدئال، توابع مالکیت آرگومان‌های خود را مگر در مواقع ضروری نمی‌گیرند، و دلایل این موضوع در ادامه مشخص خواهد شد!) اما چه چیزی باید برگردانیم؟ ما واقعاً راهی برای صحبت درباره بخشی از یک رشته نداریم. با این حال، می‌توانیم شاخص انتهای کلمه را که با یک فاصله مشخص می‌شود، برگردانیم. بیایید این کار را انجام دهیم، همانطور که در لیستینگ 4-7 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 4-7: تابع <code>first_word</code> که یک مقدار شاخص بایت در <code>String</code> پارامتر را برمی‌گرداند</figcaption>
</figure>
<p>زیرا ما نیاز داریم عنصر به عنصر از <code>String</code> عبور کنیم و بررسی کنیم که آیا یک مقدار فاصله است یا خیر، رشته خود را به یک آرایه از بایت‌ها با استفاده از متد <code>as_bytes</code> تبدیل می‌کنیم.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>در مرحله بعد، یک iterator روی آرایه بایت‌ها با استفاده از متد <code>iter</code> ایجاد می‌کنیم:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>ما در <a href="ch13-02-iterators.html">فصل 13</a><!-- ignore --> بیشتر درباره iterators بحث خواهیم کرد. فعلاً بدانید که <code>iter</code> یک متد است که هر عنصر در یک مجموعه را برمی‌گرداند و <code>enumerate</code> نتیجه <code>iter</code> را می‌پیچد و هر عنصر را به عنوان بخشی از یک tuple برمی‌گرداند. اولین عنصر tuple برگردانده شده از <code>enumerate</code> شاخص است و دومین عنصر ارجاع به عنصر است. این کار کمی راحت‌تر از محاسبه شاخص به صورت دستی است.</p>
<p>زیرا متد <code>enumerate</code> یک tuple برمی‌گرداند، می‌توانیم از الگوها برای جدا کردن این tuple استفاده کنیم. ما در <a href="ch06-02-match.html#patterns-that-bind-to-values">فصل 6</a><!-- ignore --> بیشتر درباره الگوها صحبت خواهیم کرد. در حلقه <code>for</code>، الگویی مشخص می‌کنیم که <code>i</code> برای شاخص در tuple و <code>&amp;item</code> برای بایت منفرد در tuple باشد. زیرا ما یک ارجاع به عنصر از <code>.iter().enumerate()</code> دریافت می‌کنیم، از <code>&amp;</code> در الگو استفاده می‌کنیم.</p>
<p>داخل حلقه <code>for</code>، به دنبال بایتی که نماینده فاصله باشد می‌گردیم با استفاده از نحوه نوشتن بایت به صورت literale. اگر یک فاصله پیدا کردیم، موقعیت را برمی‌گردانیم. در غیر این صورت، طول رشته را با استفاده از <code>s.len()</code> برمی‌گردانیم.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>اکنون راهی برای یافتن شاخص انتهای اولین کلمه در رشته داریم، اما مشکلی وجود دارد. ما یک <code>usize</code> به تنهایی برمی‌گردانیم، اما این تنها یک عدد معنادار در زمینه <code>&amp;String</code> است. به عبارت دیگر، زیرا این مقدار از <code>String</code> جدا است، هیچ تضمینی وجود ندارد که در آینده همچنان معتبر باشد. برنامه‌ای که در لیستینگ 4-8 استفاده می‌شود و از تابع <code>first_word</code> از لیستینگ 4-7 استفاده می‌کند را در نظر بگیرید.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // `word` still has the value `5` here, but `s` no longer has any content
    // that we could meaningfully use with the value `5`, so `word` is now
    // totally invalid!
}</code></pre></pre>
<figcaption>Listing 4-8: ذخیره نتیجه از فراخوانی تابع <code>first_word</code> و سپس تغییر محتوای <code>String</code></figcaption>
</figure>
<p>این برنامه بدون هیچ خطایی کامپایل می‌شود و حتی اگر <code>word</code> را بعد از فراخوانی <code>s.clear()</code> استفاده کنیم، همچنان درست کار خواهد کرد. زیرا <code>word</code> اصلاً به حالت <code>s</code> متصل نیست، <code>word</code> همچنان مقدار <code>5</code> را دارد. ما می‌توانیم از مقدار <code>5</code> همراه با متغیر <code>s</code> استفاده کنیم تا تلاش کنیم اولین کلمه را استخراج کنیم، اما این یک باگ خواهد بود زیرا محتوای <code>s</code> از زمانی که <code>5</code> را در <code>word</code> ذخیره کردیم، تغییر کرده است.</p>
<p>نگران هماهنگ نگه داشتن شاخص در <code>word</code> با داده‌های موجود در <code>s</code> بودن، خسته‌کننده و مستعد خطاست! مدیریت این شاخص‌ها حتی شکننده‌تر می‌شود اگر بخواهیم یک تابع <code>second_word</code> بنویسیم. امضای آن باید به این صورت باشد:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>حالا ما یک شاخص شروع و یک شاخص پایان را دنبال می‌کنیم و مقادیر بیشتری داریم که از داده‌ها در یک وضعیت خاص محاسبه شده‌اند اما اصلاً به آن وضعیت مرتبط نیستند. ما سه متغیر نامرتبط داریم که باید همگام نگه داشته شوند.</p>
<p>خوشبختانه، Rust یک راه‌حل برای این مشکل دارد: برش‌های رشته‌ای.</p>
<h3 id="برشهای-رشتهای"><a class="header" href="#برشهای-رشتهای">برش‌های رشته‌ای</a></h3>
<p><em>برش رشته‌ای</em> یک ارجاع به بخشی از یک <code>String</code> است و به این شکل به نظر می‌رسد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>به جای یک ارجاع به کل <code>String</code>، <code>hello</code> یک ارجاع به بخشی از <code>String</code> است که در بخش اضافی <code>[0..5]</code> مشخص شده است. ما با استفاده از یک محدوده در داخل کروشه‌ها برش‌ها را ایجاد می‌کنیم، با مشخص کردن <code>[starting_index..ending_index]</code> که در آن <code>starting_index</code> اولین موقعیت در برش و <code>ending_index</code> یکی بیشتر از آخرین موقعیت در برش است. به صورت داخلی، ساختار داده برش موقعیت شروع و طول برش را ذخیره می‌کند که متناظر با <code>ending_index</code> منهای <code>starting_index</code> است. بنابراین، در حالت <code>let world = &amp;s[6..11];</code>، <code>world</code> یک برش است که شامل یک اشاره‌گر (Pointer) به بایت در شاخص 6 از <code>s</code> با یک مقدار طول <code>5</code> است.</p>
<p>شکل 4-7 این موضوع را در یک نمودار نشان می‌دهد.</p>
<img alt="سه جدول: جدولی که داده‌های پشته‌ای s را نشان می‌دهد، که به بایت در شاخص 0 در یک جدول از داده‌های رشته &quot;hello world&quot; در heap اشاره می‌کند. جدول سوم داده‌های پشته‌ای برش world را نشان می‌دهد که دارای مقدار طول 5 است و به بایت 6 از جدول داده‌های heap اشاره می‌کند." src="img/trpl04-07.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل 4-7: برش رشته‌ای اشاره به بخشی از یک <code>String</code></span></p>
<p>با استفاده از نحوی محدوده <code>..</code> در Rust، اگر می‌خواهید از شاخص 0 شروع کنید، می‌توانید مقدار قبل از دو نقطه را حذف کنید. به عبارت دیگر، این دو معادل هستند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>به همین ترتیب، اگر برش شما شامل آخرین بایت <code>String</code> باشد، می‌توانید عدد پایانی را حذف کنید. این به این معناست که این دو معادل هستند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>شما همچنین می‌توانید هر دو مقدار را حذف کنید تا یک برش از کل رشته بگیرید. بنابراین این دو معادل هستند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>توجه: شاخص‌های محدوده برش رشته باید در مرزهای معتبر کاراکتر UTF-8 رخ دهند. اگر بخواهید یک برش رشته در وسط یک کاراکتر چندبایتی ایجاد کنید، برنامه شما با یک خطا خاتمه خواهد یافت. برای مقاصد معرفی برش‌های رشته‌ای، ما فقط ASCII را در این بخش در نظر گرفته‌ایم؛ بحث دقیق‌تری در مورد مدیریت UTF-8 در بخش <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“ذخیره متن رمزگذاری شده UTF-8 با رشته‌ها”</a><!-- ignore --> در فصل 8 وجود دارد.</p>
</blockquote>
<p>با در نظر گرفتن این اطلاعات، بیایید <code>first_word</code> را بازنویسی کنیم تا یک برش برگرداند. نوعی که نشان‌دهنده “برش رشته‌ای” است به صورت <code>&amp;str</code> نوشته می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</figure>
<p>ما شاخص پایان کلمه را به همان روشی که در لیستینگ 4-7 انجام دادیم، پیدا می‌کنیم، یعنی با جستجوی اولین فضای خالی. وقتی یک فضای خالی پیدا می‌کنیم، یک برش رشته‌ای با استفاده از شروع رشته و شاخص فضای خالی به‌عنوان شاخص‌های شروع و پایان برمی‌گردانیم.</p>
<p>اکنون وقتی <code>first_word</code> را فراخوانی می‌کنیم، یک مقدار واحد دریافت می‌کنیم که به داده‌های پایه متصل است. این مقدار شامل یک ارجاع به نقطه شروع برش و تعداد عناصر موجود در برش است.</p>
<p>بازگرداندن یک برش برای یک تابع <code>second_word</code> نیز کار می‌کند:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>اکنون یک API ساده داریم که بسیار سخت‌تر است اشتباه شود زیرا کامپایلر اطمینان حاصل می‌کند که ارجاع‌ها به داخل <code>String</code> معتبر باقی می‌مانند. به یاد دارید خطای منطقی برنامه در لیستینگ 4-8، وقتی شاخص انتهای اولین کلمه را به دست آوردیم اما سپس رشته را پاک کردیم، بنابراین شاخص ما نامعتبر شد؟ آن کد منطقی نادرست بود اما هیچ خطای فوری نشان نمی‌داد. مشکلات بعداً وقتی تلاش می‌کردیم از شاخص اولین کلمه با یک رشته خالی استفاده کنیم، ظاهر می‌شد. برش‌ها این خطا را غیرممکن می‌کنند و به ما اطلاع می‌دهند که مشکلی در کد ما وجود دارد خیلی زودتر. استفاده از نسخه برش <code>first_word</code> یک خطای زمان کامپایل ایجاد می‌کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>
</figure>
<p>این هم خطای کامپایلر:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>به یاد بیاورید از قوانین وام گرفتن که اگر ما یک ارجاع غیرقابل تغییر به چیزی داشته باشیم، نمی‌توانیم یک ارجاع قابل تغییر نیز بگیریم. از آنجایی که <code>clear</code> نیاز دارد که <code>String</code> را کوتاه کند، نیاز دارد یک ارجاع قابل تغییر بگیرد. <code>println!</code> بعد از فراخوانی به <code>clear</code> از ارجاع در <code>word</code> استفاده می‌کند، بنابراین ارجاع غیرقابل تغییر باید هنوز در آن نقطه فعال باشد. Rust ارجاع قابل تغییر در <code>clear</code> و ارجاع غیرقابل تغییر در <code>word</code> را از همزمان وجود داشتن ممنوع می‌کند و کامپایل شکست می‌خورد. نه تنها Rust API ما را آسان‌تر کرده، بلکه یک دسته کامل از خطاها را در زمان کامپایل حذف کرده است!</p>
<!-- عنوان قدیمی. حذف نکنید یا لینک‌ها ممکن است خراب شوند. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="رشتههای-متنی-به-عنوان-برش"><a class="header" href="#رشتههای-متنی-به-عنوان-برش">رشته‌های متنی به عنوان برش</a></h4>
<p>به یاد بیاورید که ما درباره ذخیره رشته‌های متنی در داخل باینری صحبت کردیم. اکنون که درباره برش‌ها می‌دانیم، می‌توانیم رشته‌های متنی را به درستی درک کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>نوع <code>s</code> در اینجا <code>&amp;str</code> است: این یک برش است که به یک نقطه خاص از باینری اشاره می‌کند. این همچنین دلیل غیرقابل تغییر بودن رشته‌های متنی است؛ <code>&amp;str</code> یک ارجاع غیرقابل تغییر است.</p>
<h4 id="برشهای-رشتهای-به-عنوان-پارامترها"><a class="header" href="#برشهای-رشتهای-به-عنوان-پارامترها">برش‌های رشته‌ای به عنوان پارامترها</a></h4>
<p>دانستن اینکه می‌توانید برش‌هایی از رشته‌های متنی و مقادیر <code>String</code> بگیرید ما را به یک بهبود دیگر در <code>first_word</code> می‌رساند، و آن امضای آن است:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>یک برنامه‌نویس باتجربه‌تر Rust امضای نشان داده شده در لیستینگ 4-9 را می‌نویسد زیرا این اجازه را می‌دهد که از همان تابع برای مقادیر <code>&amp;String</code> و <code>&amp;str</code> استفاده کنیم.</p>
<figure class="listing">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 4-9: بهبود تابع <code>first_word</code> با استفاده از برش رشته‌ای برای نوع پارامتر <code>s</code></figcaption>
</figure>
<p>اگر ما یک برش رشته‌ای داشته باشیم، می‌توانیم آن را مستقیماً ارسال کنیم. اگر یک <code>String</code> داشته باشیم، می‌توانیم یک برش از <code>String</code> یا یک ارجاع به <code>String</code> ارسال کنیم. این انعطاف‌پذیری از ویژگی <em>دریف کوئرسین</em> استفاده می‌کند، که در بخش <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">“Implicit Deref Coercions with Functions and Methods”</a><!--ignore--> در فصل 15 به آن خواهیم پرداخت.</p>
<p>تعریف یک تابع برای گرفتن یک برش رشته‌ای به جای یک ارجاع به <code>String</code>، API ما را عمومی‌تر و مفیدتر می‌کند بدون اینکه هیچ کاربردی از دست برود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</figure>
<h3 id="برشهای-دیگر"><a class="header" href="#برشهای-دیگر">برش‌های دیگر</a></h3>
<p>برش‌های رشته‌ای، همانطور که تصور می‌کنید، مختص رشته‌ها هستند. اما یک نوع برش عمومی‌تر نیز وجود دارد. این آرایه را در نظر بگیرید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>همانطور که ممکن است بخواهیم به بخشی از یک رشته ارجاع دهیم، ممکن است بخواهیم به بخشی از یک آرایه نیز ارجاع دهیم. این کار را می‌توانیم به این شکل انجام دهیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>این برش دارای نوع <code>&amp;[i32]</code> است. این دقیقاً همانطور که برش‌های رشته‌ای کار می‌کنند، با ذخیره یک ارجاع به اولین عنصر و یک طول عمل می‌کند. شما از این نوع برش برای انواع دیگر مجموعه‌ها نیز استفاده خواهید کرد. ما این مجموعه‌ها را به تفصیل وقتی درباره وکتورها در فصل 8 صحبت کنیم، بررسی خواهیم کرد.</p>
<h2 id="خلاصه-3"><a class="header" href="#خلاصه-3">خلاصه</a></h2>
<p>مفاهیم مالکیت، وام گرفتن، و برش‌ها، ایمنی حافظه را در برنامه‌های Rust در زمان کامپایل تضمین می‌کنند. زبان Rust به شما همان کنترلی بر استفاده از حافظه می‌دهد که سایر زبان‌های برنامه‌نویسی سیستم ارائه می‌دهند، اما این واقعیت که مالک داده به طور خودکار آن داده را هنگامی که مالک از حوزه خارج می‌شود، پاکسازی می‌کند، به این معنی است که نیازی به نوشتن و اشکال‌زدایی کد اضافی برای دستیابی به این کنترل ندارید.</p>
<p>مالکیت بر نحوه عملکرد بسیاری از بخش‌های دیگر Rust تأثیر می‌گذارد، بنابراین در طول بقیه کتاب این مفاهیم را بیشتر بررسی خواهیم کرد. بیایید به فصل 5 برویم و نگاهی به گروه‌بندی قطعات داده در یک <code>struct</code> بیندازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="استفاده-از-structها-برای-سازماندهی-دادههای-مرتبط"><a class="header" href="#استفاده-از-structها-برای-سازماندهی-دادههای-مرتبط">استفاده از Structها برای سازماندهی داده‌های مرتبط</a></h1>
<p>یک <em>struct</em> یا <em>ساختار</em>، نوع داده‌ای سفارشی است که به شما اجازه می‌دهد چندین مقدار مرتبط را به صورت گروهی در کنار هم بسته‌بندی و نام‌گذاری کنید. اگر با یک زبان برنامه‌نویسی شیءگرا آشنا باشید، یک <em>struct</em> شبیه به ویژگی‌های داده‌ای یک شیء است. در این فصل، ما ساختارها را با تاپل‌ها مقایسه و مقایسه خواهیم کرد تا نشان دهیم چه زمانی ساختارها روش بهتری برای گروه‌بندی داده‌ها هستند.</p>
<p>ما نحوه تعریف و نمونه‌سازی ساختارها را نشان خواهیم داد. همچنین بحث خواهیم کرد که چگونه توابع مرتبط، به‌ویژه نوعی از توابع مرتبط به نام <em>متدها</em> را تعریف کنیم تا رفتار مرتبط با یک نوع ساختار را مشخص کنیم. ساختارها و Enumها (که در فصل ۶ مورد بحث قرار گرفته‌اند) بلوک‌های سازنده‌ای برای ایجاد انواع جدید در حوزه برنامه شما هستند که از بررسی نوع در زمان کامپایل در Rust به طور کامل استفاده می‌کنند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="تعریف-و-نمونهسازی-structها"><a class="header" href="#تعریف-و-نمونهسازی-structها">تعریف و نمونه‌سازی Structها</a></h2>
<p>ساختارها مشابه تاپل‌ها هستند که در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> مورد بحث قرار گرفتند، به این معنا که هر دو شامل مقادیر مرتبط متعددی هستند. مانند تاپل‌ها، اجزای یک ساختار می‌توانند از انواع مختلفی باشند. اما برخلاف تاپل‌ها، در یک ساختار شما برای هر جزء داده نام تعیین می‌کنید تا معنای مقادیر روشن‌تر شود. افزودن این نام‌ها باعث می‌شود که ساختارها از تاپل‌ها انعطاف‌پذیرتر باشند: شما مجبور نیستید برای مشخص کردن یا دسترسی به مقادیر یک نمونه به ترتیب داده‌ها تکیه کنید.</p>
<p>برای تعریف یک ساختار، کلمه کلیدی <code>struct</code> را وارد کرده و نام کل ساختار را تعیین می‌کنیم. نام یک ساختار باید توصیف‌کننده اهمیت اجزای داده‌ای باشد که با هم گروه‌بندی می‌شوند. سپس، داخل آکولادها، نام‌ها و انواع اجزای داده‌ای را که به آن‌ها <em>فیلد</em> می‌گوییم، تعریف می‌کنیم. برای مثال، لیست ۵-۱ یک ساختار را نشان می‌دهد که اطلاعات مربوط به یک حساب کاربری را ذخیره می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 5-1: تعریف یک ساختار <code>User</code></figcaption>
</figure>
<p>برای استفاده از یک ساختار پس از تعریف آن، ما یک <em>نمونه</em> از آن ساختار ایجاد می‌کنیم که مقادیر مشخصی را برای هر یک از فیلدها مشخص می‌کند. ما نمونه‌ای را با تعیین نام ساختار و سپس اضافه کردن آکولادهایی که شامل زوج‌های <em>کلید: مقدار</em> هستند، ایجاد می‌کنیم، جایی که کلیدها نام فیلدها و مقادیر داده‌ای هستند که می‌خواهیم در آن فیلدها ذخیره کنیم. نیازی نیست که فیلدها را به همان ترتیبی که در ساختار تعریف شده‌اند، مشخص کنیم. به عبارت دیگر، تعریف ساختار مانند یک قالب کلی برای نوع است و نمونه‌ها این قالب را با داده‌های خاص پر می‌کنند تا مقادیر آن نوع را ایجاد کنند. برای مثال، می‌توانیم کاربر خاصی را همان‌طور که در لیست ۵-۲ نشان داده شده است، تعریف کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<figcaption>Listing 5-2: ایجاد یک نمونه از ساختار <code>User</code></figcaption>
</figure>
<p>برای به‌دست‌آوردن مقدار خاصی از یک ساختار، از نشانه‌گذاری نقطه استفاده می‌کنیم. به عنوان مثال، برای دسترسی به آدرس ایمیل این کاربر، از <code>user1.email</code> استفاده می‌کنیم. اگر نمونه قابل تغییر باشد، می‌توانیم مقدار را با استفاده از نشانه‌گذاری نقطه تغییر داده و در یک فیلد خاص مقداردهی کنیم. لیست ۵-۳ نشان می‌دهد که چگونه مقدار در فیلد <code>email</code> یک نمونه قابل تغییر <code>User</code> را تغییر دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<figcaption>Listing 5-3: تغییر مقدار در فیلد <code>email</code> یک نمونه <code>User</code></figcaption>
</figure>
<p>توجه داشته باشید که کل نمونه باید قابل تغییر باشد؛ Rust به ما اجازه نمی‌دهد که فقط برخی از فیلدها را به صورت قابل تغییر علامت‌گذاری کنیم. مانند هر عبارت دیگری، می‌توانیم یک نمونه جدید از ساختار را به عنوان آخرین عبارت در بدنه یک تابع بسازیم تا به طور ضمنی آن نمونه جدید را بازگردانیم.</p>
<p>لیست ۵-۴ یک تابع <code>build_user</code> را نشان می‌دهد که یک نمونه از <code>User</code> را با ایمیل و نام کاربری مشخص برمی‌گرداند. فیلد <code>active</code> مقدار <code>true</code> می‌گیرد و <code>sign_in_count</code> مقدار <code>1</code> دریافت می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 5-4: یک تابع <code>build_user</code> که یک ایمیل و نام کاربری می‌گیرد و یک نمونه <code>User</code> را بازمی‌گرداند</figcaption>
</figure>
<p>نوشتن نام پارامترهای تابع با همان نام فیلدهای ساختار منطقی است، اما تکرار نام‌های <code>email</code> و <code>username</code> برای هر دو فیلد و متغیرها کمی خسته‌کننده است. اگر ساختار فیلدهای بیشتری داشت، تکرار هر نام حتی آزاردهنده‌تر می‌شد. خوشبختانه، یک راه میانبر راحت وجود دارد!</p>
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="استفاده-از-میانبر-مقداردهی-فیلد"><a class="header" href="#استفاده-از-میانبر-مقداردهی-فیلد">استفاده از میانبر مقداردهی فیلد</a></h3>
<p>از آنجا که نام پارامترها و نام فیلدهای ساختار دقیقاً یکسان هستند، می‌توانیم از نحو <em>میانبر مقداردهی فیلد</em> برای بازنویسی <code>build_user</code> استفاده کنیم تا همان رفتار را داشته باشد اما تکرار <code>username</code> و <code>email</code> را نداشته باشد، همان‌طور که در لیست ۵-۵ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 5-5: یک تابع <code>build_user</code> که از میانبر مقداردهی فیلد استفاده می‌کند زیرا پارامترهای <code>username</code> و <code>email</code> همان نام فیلدهای ساختار را دارند</figcaption>
</figure>
<p>اینجا، ما یک نمونه جدید از ساختار <code>User</code> می‌سازیم که فیلدی به نام <code>email</code> دارد. ما می‌خواهیم مقدار فیلد <code>email</code> را به مقداری که در پارامتر <code>email</code> تابع <code>build_user</code> وجود دارد تنظیم کنیم. از آنجا که فیلد <code>email</code> و پارامتر <code>email</code> نام یکسانی دارند، فقط نیاز داریم <code>email</code> بنویسیم، نه <code>email: email</code>.</p>
<h3 id="ایجاد-نمونهها-از-نمونههای-دیگر-با-استفاده-از-نحو-بهروزرسانی-struct"><a class="header" href="#ایجاد-نمونهها-از-نمونههای-دیگر-با-استفاده-از-نحو-بهروزرسانی-struct">ایجاد نمونه‌ها از نمونه‌های دیگر با استفاده از نحو به‌روزرسانی Struct</a></h3>
<p>اغلب مفید است که یک نمونه جدید از یک ساختار ایجاد کنیم که شامل اکثر مقادیر از یک نمونه دیگر است، اما برخی از آن‌ها تغییر کرده‌اند. شما می‌توانید این کار را با استفاده از <em>نحو به‌روزرسانی Struct</em> انجام دهید.</p>
<p>ابتدا، در لیست ۵-۶ نشان داده شده است که چگونه می‌توان یک نمونه جدید <code>User</code> در <code>user2</code> ایجاد کرد، بدون استفاده از نحو به‌روزرسانی. ما یک مقدار جدید برای <code>email</code> تنظیم می‌کنیم اما در غیر این صورت از همان مقادیر در <code>user1</code> که قبلاً در لیست ۵-۲ ایجاد شده است، استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<figcaption>Listing 5-6: ایجاد یک نمونه جدید <code>User</code> با استفاده از تمام مقادیر به جز یکی از <code>user1</code></figcaption>
</figure>
<p>با استفاده از نحو به‌روزرسانی Struct، می‌توانیم همان نتیجه را با کد کمتری به دست آوریم، همان‌طور که در لیست ۵-۷ نشان داده شده است. نحو <code>..</code> مشخص می‌کند که فیلدهای باقی‌مانده‌ای که به صورت صریح تنظیم نشده‌اند باید همان مقادیری را داشته باشند که در نمونه داده شده هستند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<figcaption>Listing 5-7: استفاده از نحو به‌روزرسانی Struct برای تنظیم یک مقدار جدید <code>email</code> برای یک نمونه <code>User</code> اما استفاده از مقادیر باقی‌مانده از <code>user1</code></figcaption>
</figure>
<p>کد در لیست ۵-۷ همچنین نمونه‌ای در <code>user2</code> ایجاد می‌کند که مقدار متفاوتی برای <code>email</code> دارد اما دارای مقادیر مشابهی برای فیلدهای <code>username</code>، <code>active</code> و <code>sign_in_count</code> از <code>user1</code> است. <code>..user1</code> باید در انتها بیاید تا مشخص کند که فیلدهای باقی‌مانده باید مقادیر خود را از فیلدهای مربوطه در <code>user1</code> دریافت کنند، اما می‌توانیم مقادیر را برای هر تعداد فیلدی که می‌خواهیم به هر ترتیبی مشخص کنیم، بدون توجه به ترتیب فیلدها در تعریف ساختار.</p>
<p>توجه داشته باشید که نحو به‌روزرسانی Struct از <code>=</code> مانند یک عملگر انتساب استفاده می‌کند؛ این به این دلیل است که داده‌ها را جابه‌جا می‌کند، همان‌طور که در بخش <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">«تعامل متغیرها و داده‌ها با انتقال»</a><!-- ignore --> مورد بحث قرار گرفت. در این مثال، دیگر نمی‌توانیم از <code>user1</code> به عنوان یک کل پس از ایجاد <code>user2</code> استفاده کنیم، زیرا <code>String</code> در فیلد <code>username</code> از <code>user1</code> به <code>user2</code> منتقل شد. اگر ما به <code>user2</code> مقادیر جدید <code>String</code> برای هر دو <code>email</code> و <code>username</code> داده بودیم و بنابراین فقط از مقادیر <code>active</code> و <code>sign_in_count</code> از <code>user1</code> استفاده کرده بودیم، <code>user1</code> پس از ایجاد <code>user2</code> همچنان معتبر باقی می‌ماند. هم <code>active</code> و هم <code>sign_in_count</code> از انواعی هستند که ویژگی <code>Copy</code> را پیاده‌سازی می‌کنند، بنابراین رفتار مورد بحث در بخش <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">«داده‌های فقط روی پشته: Copy»</a><!-- ignore --> اعمال می‌شود. در این مثال، همچنان می‌توانیم از <code>user1.email</code> استفاده کنیم، زیرا مقدار آن منتقل نشده است.</p>
<h3 id="استفاده-از-ساختارهای-tuple-بدون-فیلدهای-نامگذاریشده-برای-ایجاد-انواع-مختلف"><a class="header" href="#استفاده-از-ساختارهای-tuple-بدون-فیلدهای-نامگذاریشده-برای-ایجاد-انواع-مختلف">استفاده از ساختارهای Tuple بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف</a></h3>
<p>Rust همچنین از ساختارهایی که شبیه تاپل‌ها هستند پشتیبانی می‌کند که به آن‌ها <em>ساختارهای Tuple</em> می‌گویند. ساختارهای Tuple به دلیل نام ساختار معنای بیشتری دارند اما نام‌هایی برای فیلدهای خود ندارند؛ بلکه فقط نوع فیلدها را دارند. ساختارهای Tuple زمانی مفید هستند که بخواهید به کل تاپل یک نام بدهید و آن را به عنوان نوعی متفاوت از تاپل‌های دیگر مشخص کنید، و وقتی نام‌گذاری هر فیلد مانند یک ساختار معمولی طولانی یا زائد باشد.</p>
<p>برای تعریف یک ساختار Tuple، با کلمه کلیدی <code>struct</code> و نام ساختار شروع کنید و سپس نوع‌های موجود در تاپل را مشخص کنید. به عنوان مثال، در اینجا ما دو ساختار Tuple به نام‌های <code>Color</code> و <code>Point</code> تعریف و استفاده کرده‌ایم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</figure>
<p>توجه کنید که مقادیر <code>black</code> و <code>origin</code> انواع متفاوتی دارند زیرا آن‌ها نمونه‌هایی از ساختارهای Tuple متفاوت هستند. هر ساختاری که تعریف می‌کنید نوع خودش را دارد، حتی اگر فیلدهای درون ساختار نوع یکسانی داشته باشند. برای مثال، یک تابع که پارامتری از نوع <code>Color</code> می‌گیرد نمی‌تواند یک <code>Point</code> را به عنوان آرگومان بگیرد، حتی اگر هر دو نوع از سه مقدار <code>i32</code> تشکیل شده باشند. در غیر این صورت، نمونه‌های ساختار Tuple مشابه تاپل‌ها هستند به این معنا که می‌توانید آن‌ها را به اجزای فردی تجزیه کنید و می‌توانید از یک <code>.</code> به همراه ایندکس برای دسترسی به مقدار خاصی استفاده کنید. برخلاف تاپل‌ها، ساختارهای Tuple نیاز دارند که هنگام تجزیه آن‌ها نوع ساختار را مشخص کنید. برای مثال، می‌توانیم بنویسیم <code>let Point(x, y, z) = point</code>.</p>
<h3 id="ساختارهای-شبیه-به-unit-بدون-هیچ-فیلدی"><a class="header" href="#ساختارهای-شبیه-به-unit-بدون-هیچ-فیلدی">ساختارهای شبیه به Unit بدون هیچ فیلدی</a></h3>
<p>شما همچنین می‌توانید ساختارهایی تعریف کنید که هیچ فیلدی ندارند! این‌ها به عنوان <em>ساختارهای شبیه Unit</em> شناخته می‌شوند زیرا شبیه به نوع <code>()</code>، نوع Unit، رفتار می‌کنند که در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> مورد اشاره قرار گرفت. ساختارهای شبیه Unit زمانی مفید هستند که نیاز به پیاده‌سازی یک ویژگی بر روی یک نوع داشته باشید اما هیچ داده‌ای برای ذخیره در خود نوع نداشته باشید. ما ویژگی‌ها را در فصل ۱۰ بحث خواهیم کرد. در اینجا مثالی از اعلام و نمونه‌سازی یک ساختار شبیه Unit به نام <code>AlwaysEqual</code> آورده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</figure>
<p>برای تعریف <code>AlwaysEqual</code>، از کلمه کلیدی <code>struct</code>، نام دلخواه و سپس یک نقطه ویرگول استفاده می‌کنیم. نیازی به آکولاد یا پرانتز نیست! سپس می‌توانیم یک نمونه از <code>AlwaysEqual</code> را در متغیر <code>subject</code> با استفاده از همان نامی که تعریف کرده‌ایم، بدون هیچ آکولاد یا پرانتزی دریافت کنیم. تصور کنید که در آینده رفتاری را برای این نوع پیاده‌سازی خواهیم کرد که همه نمونه‌های <code>AlwaysEqual</code> همیشه با تمام نمونه‌های دیگر برابر باشند، شاید برای داشتن نتیجه‌ای مشخص برای اهداف آزمایشی. برای پیاده‌سازی آن رفتار نیازی به هیچ داده‌ای نداریم! شما در فصل ۱۰ خواهید دید که چگونه می‌توانید ویژگی‌ها را تعریف و آن‌ها را بر روی هر نوعی، از جمله ساختارهای شبیه به Unit، پیاده‌سازی کنید.</p>
<section class="note" aria-role="note">
<h3 id="مالکیت-دادههای-struct"><a class="header" href="#مالکیت-دادههای-struct">مالکیت داده‌های Struct</a></h3>
<p>در تعریف ساختار <code>User</code> در لیست ۵-۱، ما از نوع مالک <code>String</code> به جای نوع برش رشته <code>&amp;str</code> استفاده کردیم. این یک انتخاب عمدی است زیرا ما می‌خواهیم هر نمونه از این ساختار همه داده‌های خود را مالک باشد و این داده‌ها به مدت زمانی که کل ساختار معتبر است، معتبر باقی بمانند.</p>
<p>همچنین ممکن است ساختارهایی وجود داشته باشند که به داده‌های متعلق به چیز دیگری ارجاع می‌دهند، اما برای انجام این کار نیاز به استفاده از <em>طول عمر‌ها</em> داریم، یک ویژگی از Rust که ما در فصل ۱۰ مورد بحث قرار خواهیم داد. طول عمرها اطمینان حاصل می‌کنند که داده‌هایی که توسط یک ساختار ارجاع داده شده‌اند تا زمانی که ساختار معتبر است، معتبر باقی می‌مانند. بیایید بگوییم شما سعی دارید یک ارجاع را در یک ساختار ذخیره کنید بدون اینکه طول عمرها را مشخص کنید، مانند مثال زیر؛ این کار نخواهد کرد:</p>
</section>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</figure>
<p>کامپایلر شکایت خواهد کرد که به مشخص‌کننده‌های طول عمر نیاز دارد:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>در فصل ۱۰، ما بحث خواهیم کرد که چگونه این خطاها را برطرف کنید تا بتوانید ارجاع‌ها را در ساختارها ذخیره کنید، اما در حال حاضر، ما این خطاها را با استفاده از انواع مالک مانند <code>String</code> به جای ارجاع‌ها مانند <code>&amp;str</code> برطرف خواهیم کرد.</p>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="یک-برنامه-نمونه-با-استفاده-از-structها"><a class="header" href="#یک-برنامه-نمونه-با-استفاده-از-structها">یک برنامه نمونه با استفاده از Structها</a></h2>
<p>برای درک بهتر زمانی که ممکن است بخواهیم از ساختارها استفاده کنیم، بیایید یک برنامه بنویسیم که مساحت یک مستطیل را محاسبه کند. ما ابتدا با استفاده از متغیرهای جداگانه شروع می‌کنیم و سپس برنامه را بازنویسی می‌کنیم تا از ساختارها استفاده کند.</p>
<p>بیایید یک پروژه باینری جدید با Cargo به نام <em>rectangles</em> ایجاد کنیم که عرض و ارتفاع یک مستطیل را بر حسب پیکسل مشخص کرده و مساحت آن را محاسبه کند. لیست ۵-۸ یک برنامه کوتاه نشان می‌دهد که دقیقاً همین کار را در فایل <em>src/main.rs</em> پروژه ما انجام می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<figcaption>Listing 5-8: محاسبه مساحت یک مستطیل که با متغیرهای عرض و ارتفاع جداگانه مشخص شده است</figcaption>
</figure>
<p>اکنون، این برنامه را با استفاده از دستور <code>cargo run</code> اجرا کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>این کد با فراخوانی تابع <code>area</code> با هر یک از ابعاد موفق به محاسبه مساحت مستطیل می‌شود، اما می‌توانیم این کد را خواناتر و قابل درک‌تر کنیم.</p>
<p>مشکل این کد در امضای تابع <code>area</code> مشخص است:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>تابع <code>area</code> قرار است مساحت یک مستطیل را محاسبه کند، اما تابعی که نوشتیم دو پارامتر دارد و هیچ‌کجا در برنامه مشخص نیست که این پارامترها به هم مرتبط هستند. بهتر است عرض و ارتفاع را به صورت گروهی تعریف کنیم تا خوانایی و مدیریت کد بهتر شود. یکی از روش‌هایی که قبلاً در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> فصل ۳ بحث کردیم این است که از تاپل‌ها استفاده کنیم.</p>
<h3 id="بازنویسی-با-استفاده-از-tupleها"><a class="header" href="#بازنویسی-با-استفاده-از-tupleها">بازنویسی با استفاده از Tupleها</a></h3>
<p>لیست ۵-۹ نسخه دیگری از برنامه ما را نشان می‌دهد که از تاپل‌ها استفاده می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<figcaption>Listing 5-9: مشخص کردن عرض و ارتفاع مستطیل با یک Tuple</figcaption>
</figure>
<p>از یک منظر، این برنامه بهتر است. تاپل‌ها کمی ساختار اضافه می‌کنند و اکنون ما فقط یک آرگومان ارسال می‌کنیم. اما از منظر دیگر، این نسخه کمتر واضح است: تاپل‌ها اجزای خود را نام‌گذاری نمی‌کنند، بنابراین باید به بخش‌های تاپل با استفاده از ایندکس‌ها دسترسی پیدا کنیم که محاسبات ما را کمتر شفاف می‌کند.</p>
<p>اگر بخواهیم مستطیل را روی صفحه نمایش بکشیم، جابه‌جایی عرض و ارتفاع اهمیتی ندارد، اما برای رسم آن اهمیت پیدا می‌کند! ما باید به خاطر داشته باشیم که <code>width</code> ایندکس <code>0</code> تاپل و <code>height</code> ایندکس <code>1</code> تاپل است. این کار حتی برای کسی که از کد ما استفاده می‌کند سخت‌تر خواهد بود و به اشتباهات بیشتری منجر می‌شود. چون معنای داده‌های ما در کد مشخص نشده است، احتمال خطا بیشتر می‌شود.</p>
<h3 id="بازنویسی-با-استفاده-از-structها-افزودن-معنای-بیشتر"><a class="header" href="#بازنویسی-با-استفاده-از-structها-افزودن-معنای-بیشتر">بازنویسی با استفاده از Structها: افزودن معنای بیشتر</a></h3>
<p>ما از ساختارها استفاده می‌کنیم تا با نام‌گذاری داده‌ها، معنای بیشتری به آن‌ها بدهیم. می‌توانیم تاپلی که استفاده می‌کنیم را به یک ساختار تبدیل کنیم که برای کل داده‌ها یک نام و همچنین برای بخش‌های مختلف آن نام‌هایی مشخص کنیم، همان‌طور که در لیست ۵-۱۰ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<figcaption>Listing 5-10: تعریف یک ساختار <code>Rectangle</code></figcaption>
</figure>
<p>در اینجا یک ساختار تعریف کرده‌ایم و نام آن را <code>Rectangle</code> گذاشته‌ایم. داخل آکولادها، فیلدهایی به نام‌های <code>width</code> و <code>height</code> تعریف کرده‌ایم که هر دو از نوع <code>u32</code> هستند. سپس، در <code>main</code>، یک نمونه خاص از <code>Rectangle</code> ایجاد کرده‌ایم که عرض آن <code>30</code> و ارتفاع آن <code>50</code> است.</p>
<p>تابع <code>area</code> ما اکنون با یک پارامتر تعریف شده است که آن را <code>rectangle</code> نامیده‌ایم و نوع آن یک ارجاع غیرقابل تغییر به یک نمونه از ساختار <code>Rectangle</code> است. همان‌طور که در فصل ۴ اشاره شد، ما می‌خواهیم ساختار را قرض بگیریم نه اینکه مالکیت آن را بگیریم. به این ترتیب، <code>main</code> مالکیت خود را حفظ می‌کند و می‌تواند همچنان از <code>rect1</code> استفاده کند. به همین دلیل است که از <code>&amp;</code> در امضای تابع و در جایی که تابع را فراخوانی می‌کنیم استفاده می‌کنیم.</p>
<p>تابع <code>area</code> به فیلدهای <code>width</code> و <code>height</code> در نمونه <code>Rectangle</code> دسترسی پیدا می‌کند (توجه داشته باشید که دسترسی به فیلدهای یک نمونه قرض‌گرفته‌شده باعث انتقال مقادیر فیلدها نمی‌شود، به همین دلیل است که اغلب قرض‌گیری ساختارها را مشاهده می‌کنید). امضای تابع <code>area</code> ما اکنون دقیقاً همان چیزی را می‌گوید که منظور ماست: مساحت <code>Rectangle</code> را با استفاده از فیلدهای <code>width</code> و <code>height</code> آن محاسبه کن. این کار نشان می‌دهد که عرض و ارتفاع به یکدیگر مرتبط هستند و نام‌های توصیفی به مقادیر می‌دهد، به جای استفاده از مقادیر ایندکس تاپل‌ها مانند <code>0</code> و <code>1</code>. این یک پیروزی برای شفافیت است.</p>
<h3 id="افزودن-قابلیتهای-مفید-با-traits-مشتقشده"><a class="header" href="#افزودن-قابلیتهای-مفید-با-traits-مشتقشده">افزودن قابلیت‌های مفید با Traits مشتق‌شده</a></h3>
<p>زمانی که در حال اشکال‌زدایی برنامه خود هستیم، مفید است که بتوانیم نمونه‌ای از <code>Rectangle</code> را چاپ کرده و مقادیر تمام فیلدهای آن را ببینیم. لیست ۵-۱۱ تلاش می‌کند با استفاده از ماکروی <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore --> که در فصل‌های قبلی استفاده کرده‌ایم، این کار را انجام دهد. با این حال، این کار موفق نخواهد بود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}</code></pre>
<figcaption>Listing 5-11: تلاش برای چاپ یک نمونه از <code>Rectangle</code></figcaption>
</figure>
<p>وقتی این کد را کامپایل می‌کنیم، با خطایی مواجه می‌شویم که پیام اصلی آن به این صورت است:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>ماکروی <code>println!</code> می‌تواند بسیاری از انواع فرمت‌بندی را انجام دهد، و به صورت پیش‌فرض، آکولادها به <code>println!</code> می‌گویند که از فرمت‌بندی‌ای که به نام <code>Display</code> شناخته می‌شود استفاده کند: خروجی‌ای که برای مصرف مستقیم کاربر نهایی در نظر گرفته شده است. انواع ابتدایی که تاکنون دیده‌ایم به صورت پیش‌فرض ویژگی <code>Display</code> را پیاده‌سازی می‌کنند زیرا تنها یک روش برای نمایش یک مقدار مانند <code>1</code> یا هر نوع ابتدایی دیگری به کاربر وجود دارد. اما با ساختارها، روش فرمت‌بندی خروجی کمتر واضح است زیرا امکانات بیشتری برای نمایش وجود دارد: آیا می‌خواهید از ویرگول استفاده شود یا خیر؟ آیا می‌خواهید آکولادها چاپ شوند؟ آیا تمام فیلدها باید نشان داده شوند؟ به دلیل این ابهام، Rust سعی نمی‌کند حدس بزند که ما چه می‌خواهیم، و ساختارها پیاده‌سازی‌ای برای <code>Display</code> ندارند که بتوان با <code>println!</code> و جایگزین <code>{}</code> استفاده کرد.</p>
<p>اگر به خواندن خطاها ادامه دهیم، به این یادداشت مفید خواهیم رسید:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>بیایید آن را امتحان کنیم! اکنون فراخوانی ماکروی <code>println!</code> به صورت <code>println!("rect1 is {rect1:?}");</code> خواهد بود. قرار دادن مشخص‌کننده <code>:?</code> داخل آکولادها به <code>println!</code> می‌گوید که می‌خواهیم از یک فرمت خروجی به نام <code>Debug</code> استفاده کنیم. ویژگی <code>Debug</code> به ما اجازه می‌دهد تا ساختار خود را به روشی که برای توسعه‌دهندگان مفید است چاپ کنیم تا مقدار آن را هنگام اشکال‌زدایی کد خود ببینیم.</p>
<p>کد را با این تغییر کامپایل کنید. خب، باز هم یک خطا دریافت می‌کنیم:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>اما باز هم کامپایلر یادداشتی مفید به ما می‌دهد:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>در واقع</em> قابلیت چاپ اطلاعات اشکال‌زدایی را دارد، اما باید به صورت صریح این قابلیت را برای ساختار خود فعال کنیم. برای انجام این کار، ویژگی بیرونی <code>#[derive(Debug)]</code> را دقیقاً قبل از تعریف ساختار اضافه می‌کنیم، همان‌طور که در لیست ۵-۱۲ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<figcaption>Listing 5-12: افزودن ویژگی برای مشتق کردن <code>Debug</code> و چاپ نمونه <code>Rectangle</code> با استفاده از فرمت اشکال‌زدایی</figcaption>
</figure>
<p>اکنون وقتی برنامه را اجرا می‌کنیم، هیچ خطایی دریافت نخواهیم کرد و خروجی زیر را خواهیم دید:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>عالی! این خروجی ممکن است زیباترین نباشد، اما مقادیر تمام فیلدها را برای این نمونه نشان می‌دهد که قطعاً در هنگام اشکال‌زدایی کمک می‌کند. زمانی که ساختارهای بزرگ‌تری داریم، مفید است که خروجی کمی آسان‌تر خوانده شود؛ در چنین مواردی می‌توانیم به جای <code>{:?}</code> از <code>{:#?}</code> در رشته <code>println!</code> استفاده کنیم. در این مثال، استفاده از سبک <code>{:#?}</code> خروجی زیر را ایجاد خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>روش دیگر برای چاپ مقدار با استفاده از فرمت <code>Debug</code>، استفاده از ماکروی <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a><!-- ignore --> است که مالکیت یک عبارت را می‌گیرد (برخلاف <code>println!</code>، که ارجاع می‌گیرد)، فایل و شماره خطی که فراخوانی <code>dbg!</code> در آن اتفاق می‌افتد همراه با مقدار حاصل از آن عبارت را چاپ می‌کند و مالکیت مقدار را بازمی‌گرداند.</p>
<p>Here is the continuation of the translation for <strong>“ch05-02-example-structs.md”</strong> into Persian:</p>
<p>در اینجا مثالی آورده شده است که در آن ما به مقدار اختصاص داده شده به فیلد <code>width</code> و همچنین مقدار کل ساختار در <code>rect1</code> علاقه‌مند هستیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>ما می‌توانیم <code>dbg!</code> را در اطراف عبارت <code>30 * scale</code> قرار دهیم و چون <code>dbg!</code> مالکیت مقدار عبارت را بازمی‌گرداند، فیلد <code>width</code> همان مقداری را خواهد داشت که اگر فراخوانی <code>dbg!</code> در آنجا وجود نداشت. ما نمی‌خواهیم <code>dbg!</code> مالکیت <code>rect1</code> را بگیرد، بنابراین از یک ارجاع به <code>rect1</code> در فراخوانی بعدی استفاده می‌کنیم. در اینجا خروجی این مثال آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>می‌توانیم ببینیم که اولین بخش خروجی از خط ۱۰ در <em>src/main.rs</em> آمده است، جایی که ما در حال اشکال‌زدایی عبارت <code>30 * scale</code> هستیم، و مقدار حاصل آن <code>60</code> است (فرمت‌بندی <code>Debug</code> که برای اعداد صحیح پیاده‌سازی شده است فقط مقدار آن‌ها را چاپ می‌کند). فراخوانی <code>dbg!</code> در خط ۱۴ از <em>src/main.rs</em> مقدار <code>&amp;rect1</code> را چاپ می‌کند که ساختار <code>Rectangle</code> است. این خروجی از فرمت‌بندی زیبا و مفید <code>Debug</code> برای نوع <code>Rectangle</code> استفاده می‌کند. ماکروی <code>dbg!</code> می‌تواند در هنگام تلاش برای درک رفتار کدتان بسیار مفید باشد!</p>
<p>علاوه بر ویژگی <code>Debug</code>، Rust تعدادی ویژگی برای ما فراهم کرده است که می‌توانیم با استفاده از ویژگی <code>derive</code> آن‌ها را به نوع‌های سفارشی خود اضافه کنیم و رفتار مفیدی ارائه دهند. این ویژگی‌ها و رفتار آن‌ها در <a href="appendix-03-derivable-traits.html">ضمیمه ج</a><!-- ignore --> فهرست شده‌اند. ما در فصل ۱۰ به نحوه پیاده‌سازی این ویژگی‌ها با رفتار سفارشی و همچنین نحوه ایجاد ویژگی‌های خود می‌پردازیم. همچنین بسیاری از ویژگی‌های دیگر به غیر از <code>derive</code> وجود دارند؛ برای اطلاعات بیشتر، به <a href="../reference/attributes.html">بخش «ویژگی‌ها» در مرجع Rust</a> مراجعه کنید.</p>
<p>تابع <code>area</code> ما بسیار خاص است: فقط مساحت مستطیل‌ها را محاسبه می‌کند. مفید خواهد بود اگر این رفتار را به صورت نزدیک‌تر با ساختار <code>Rectangle</code> مرتبط کنیم، زیرا این تابع با هیچ نوع دیگری کار نخواهد کرد. بیایید ببینیم که چگونه می‌توانیم با تبدیل تابع <code>area</code> به یک <em>متد</em> که برای نوع <code>Rectangle</code> تعریف شده است، این کد را بازنویسی کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="متد"><a class="header" href="#متد">متد</a></h2>
<p><em>متدها</em> شبیه به توابع هستند: ما آن‌ها را با کلمه کلیدی <code>fn</code> و یک نام تعریف می‌کنیم، می‌توانند پارامترها و یک مقدار بازگشتی داشته باشند و شامل کدی هستند که وقتی متد از جایی دیگر فراخوانی می‌شود، اجرا می‌شود. برخلاف توابع، متدها در زمینه یک ساختار (یا یک Enum یا یک Trait Object، که آن‌ها را به ترتیب در <a href="ch06-00-enums.html">فصل ۶</a><!-- ignore --> و <a href="ch18-02-trait-objects.html">فصل ۱۷</a><!-- ignore --> پوشش می‌دهیم) تعریف می‌شوند و پارامتر اول آن‌ها همیشه <code>self</code> است که نمونه‌ای از ساختاری که متد روی آن فراخوانی شده است را نمایش می‌دهد.</p>
<h3 id="تعریف-متدها"><a class="header" href="#تعریف-متدها">تعریف متدها</a></h3>
<p>بیایید تابع <code>area</code> که یک نمونه از <code>Rectangle</code> را به عنوان پارامتر می‌گیرد، تغییر دهیم و به جای آن، یک متد <code>area</code> تعریف کنیم که روی ساختار <code>Rectangle</code> تعریف شده است، همان‌طور که در لیست ۵-۱۳ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
<figcaption>Listing 5-13: تعریف یک متد <code>area</code> روی ساختار <code>Rectangle</code></figcaption>
</figure>
<p>برای تعریف تابع در زمینه <code>Rectangle</code>، یک بلوک <code>impl</code> (پیاده‌سازی) برای <code>Rectangle</code> شروع می‌کنیم. هر چیزی در این بلوک <code>impl</code> با نوع <code>Rectangle</code> مرتبط خواهد بود. سپس، تابع <code>area</code> را به درون آکولادهای <code>impl</code> منتقل کرده و اولین (و در اینجا تنها) پارامتر آن را در امضا و در هر جایی در بدنه به <code>self</code> تغییر می‌دهیم. در <code>main</code>، جایی که تابع <code>area</code> را فراخوانی می‌کردیم و <code>rect1</code> را به عنوان آرگومان ارسال می‌کردیم، اکنون می‌توانیم از <em>نحو متد</em> برای فراخوانی متد <code>area</code> روی نمونه <code>Rectangle</code> خود استفاده کنیم. نحو متد بعد از یک نمونه قرار می‌گیرد: نقطه‌ای اضافه می‌کنیم و به دنبال آن نام متد، پرانتزها و هر آرگومان دیگری قرار می‌دهیم.</p>
<p>در امضای <code>area</code>، از <code>&amp;self</code> به جای <code>rectangle: &amp;Rectangle</code> استفاده می‌کنیم. <code>&amp;self</code> در واقع معادل کوتاه‌شده‌ای از <code>self: &amp;Self</code> است. درون یک بلوک <code>impl</code>، نوع <code>Self</code> نام مستعاری برای نوعی است که بلوک <code>impl</code> برای آن تعریف شده است. متدها باید به عنوان پارامتر اول خود یک پارامتری به نام <code>self</code> از نوع <code>Self</code> داشته باشند، بنابراین Rust به شما اجازه می‌دهد این عبارت را با فقط نوشتن <code>self</code> در محل اولین پارامتر کوتاه کنید. توجه داشته باشید که همچنان باید از <code>&amp;</code> در مقابل اختصار <code>self</code> استفاده کنیم تا نشان دهیم که این متد نمونه <code>Self</code> را قرض می‌گیرد، دقیقاً همان‌طور که در <code>rectangle: &amp;Rectangle</code> استفاده می‌کردیم. متدها می‌توانند مالکیت <code>self</code> را بگیرند، <code>self</code> را به صورت غیرقابل تغییر قرض بگیرند، همان‌طور که در اینجا انجام داده‌ایم، یا <code>self</code> را به صورت قابل تغییر قرض بگیرند، دقیقاً مانند هر پارامتر دیگری.</p>
<p>ما در اینجا <code>&amp;self</code> را انتخاب کرده‌ایم به همان دلیلی که در نسخه تابع از <code>&amp;Rectangle</code> استفاده کردیم: ما نمی‌خواهیم مالکیت را بگیریم و فقط می‌خواهیم داده‌ها را در ساختار بخوانیم، نه اینکه آن‌ها را تغییر دهیم. اگر بخواهیم نمونه‌ای که متد روی آن فراخوانی شده است را به عنوان بخشی از کاری که متد انجام می‌دهد تغییر دهیم، به عنوان پارامتر اول از <code>&amp;mut self</code> استفاده می‌کنیم. داشتن متدی که مالکیت نمونه را می‌گیرد با استفاده از فقط <code>self</code> به عنوان پارامتر اول به ندرت اتفاق می‌افتد؛ این تکنیک معمولاً زمانی استفاده می‌شود که متد <code>self</code> را به چیز دیگری تبدیل کند و شما بخواهید از استفاده از نمونه اصلی پس از تبدیل جلوگیری کنید.</p>
<p>دلیل اصلی استفاده از متدها به جای توابع، علاوه بر ارائه نحو متد و عدم نیاز به تکرار نوع <code>self</code> در امضای هر متد، سازمان‌دهی است. ما تمام کارهایی که می‌توانیم با یک نمونه از یک نوع انجام دهیم را در یک بلوک <code>impl</code> قرار داده‌ایم، به جای اینکه کاربران آینده کد ما به دنبال قابلیت‌های <code>Rectangle</code> در مکان‌های مختلف در کتابخانه‌ای که ارائه می‌دهیم بگردند.</p>
<p>توجه داشته باشید که می‌توانیم تصمیم بگیریم متدی با همان نام یک فیلد ساختار تعریف کنیم. برای مثال، می‌توانیم متدی روی <code>Rectangle</code> تعریف کنیم که نام آن نیز <code>width</code> باشد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}</code></pre></pre>
</figure>
<p>Here is the continuation of the translation for <strong>“ch05-03-method-syntax.md”</strong> into Persian:</p>
<p>در اینجا ما تصمیم گرفته‌ایم متد <code>width</code> را طوری تعریف کنیم که اگر مقدار در فیلد <code>width</code> نمونه بزرگ‌تر از <code>0</code> باشد مقدار <code>true</code> و در غیر این صورت مقدار <code>false</code> برگرداند: ما می‌توانیم از یک فیلد درون یک متد با همان نام برای هر منظوری استفاده کنیم. در <code>main</code>، وقتی که ما <code>rect1.width</code> را با پرانتز دنبال می‌کنیم، Rust می‌داند که منظور ما متد <code>width</code> است. وقتی از پرانتز استفاده نمی‌کنیم، Rust می‌داند که منظور ما فیلد <code>width</code> است.</p>
<p>اغلب، اما نه همیشه، زمانی که به یک متد نامی مشابه یک فیلد می‌دهیم، می‌خواهیم که این متد تنها مقدار موجود در فیلد را بازگرداند و هیچ کار دیگری انجام ندهد. متدهایی مانند این‌ها <em>getter</em> نامیده می‌شوند، و Rust آن‌ها را به صورت خودکار برای فیلدهای ساختار پیاده‌سازی نمی‌کند، همان‌طور که برخی از زبان‌های دیگر انجام می‌دهند. Getterها مفید هستند زیرا می‌توانید فیلد را خصوصی کنید اما متد را عمومی کنید و به این ترتیب دسترسی فقط-خواندنی به آن فیلد را به عنوان بخشی از API عمومی نوع فعال کنید. ما در فصل <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">۷</a><!-- ignore --> در مورد عمومی و خصوصی بودن و چگونگی تعیین عمومی یا خصوصی بودن یک فیلد یا متد بحث خواهیم کرد.</p>
<section class="note" aria-role="note">
<h3 id="کجاست-عملگر--"><a class="header" href="#کجاست-عملگر--">کجاست عملگر <code>-&gt;</code>؟</a></h3>
<p>در C و C++، دو عملگر مختلف برای فراخوانی متدها استفاده می‌شود: شما از <code>.</code> استفاده می‌کنید اگر متد را روی خود شیء فراخوانی می‌کنید و از <code>-&gt;</code> اگر متد را روی یک اشاره‌گر (Pointer) به شیء فراخوانی می‌کنید و نیاز دارید ابتدا اشاره‌گر (Pointer) را اشاره‌برداری کنید. به عبارت دیگر، اگر <code>object</code> یک اشاره‌گر (Pointer) باشد، <code>object-&gt;something()</code> شبیه به <code>(*object).something()</code> است.</p>
<p>Rust معادل عملگر <code>-&gt;</code> را ندارد؛ به جای آن، Rust یک ویژگی به نام <em>ارجاع‌دهی و اشاره‌برداری خودکار</em> دارد. فراخوانی متدها یکی از معدود مکان‌هایی در Rust است که این رفتار را دارد.</p>
<p>این‌گونه کار می‌کند: وقتی یک متد را با <code>object.something()</code> فراخوانی می‌کنید، Rust به طور خودکار <code>&amp;</code>، <code>&amp;mut</code> یا <code>*</code> را اضافه می‌کند تا <code>object</code> با امضای متد مطابقت داشته باشد. به عبارت دیگر، موارد زیر یکسان هستند:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>اولین مورد خیلی تمیزتر به نظر می‌رسد. این رفتار ارجاع‌دهی خودکار کار می‌کند زیرا متدها یک گیرنده واضح دارند—نوع <code>self</code>. با توجه به گیرنده و نام یک متد، Rust می‌تواند به طور قطعی تعیین کند که آیا متد در حال خواندن (<code>&amp;self</code>)، تغییر (<code>&amp;mut self</code>) یا مصرف (<code>self</code>) است. این واقعیت که Rust قرض‌گیری را برای گیرنده‌های متد ضمنی می‌کند، بخش بزرگی از راحتی کار با مالکیت در عمل است.</p>
</section>
<h3 id="متدهایی-با-پارامترهای-بیشتر"><a class="header" href="#متدهایی-با-پارامترهای-بیشتر">متدهایی با پارامترهای بیشتر</a></h3>
<p>بیایید با تعریف یک متد دیگر روی ساختار <code>Rectangle</code> تمرین کنیم. این بار می‌خواهیم یک نمونه از <code>Rectangle</code> نمونه دیگری از <code>Rectangle</code> را بگیرد و مقدار <code>true</code> برگرداند اگر <code>Rectangle</code> دوم کاملاً در <code>self</code> (اولین <code>Rectangle</code>) جای گیرد؛ در غیر این صورت مقدار <code>false</code> برگرداند. به عبارت دیگر، پس از تعریف متد <code>can_hold</code>، می‌خواهیم بتوانیم برنامه‌ای بنویسیم که در لیست ۵-۱۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
<figcaption>Listing 5-14: استفاده از متد <code>can_hold</code> که هنوز نوشته نشده است</figcaption>
</figure>
<p>خروجی مورد انتظار به صورت زیر خواهد بود زیرا هر دو بُعد <code>rect2</code> کوچکتر از ابعاد <code>rect1</code> هستند، اما <code>rect3</code> از <code>rect1</code> عریض‌تر است:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>ما می‌دانیم که می‌خواهیم یک متد تعریف کنیم، بنابراین این متد در بلوک <code>impl Rectangle</code> خواهد بود. نام متد <code>can_hold</code> خواهد بود و یک قرض غیرقابل تغییر از یک <code>Rectangle</code> دیگر به عنوان پارامتر خواهد گرفت. می‌توانیم نوع پارامتر را با نگاه به کدی که متد را فراخوانی می‌کند تشخیص دهیم: <code>rect1.can_hold(&amp;rect2)</code> مقدار <code>&amp;rect2</code> را ارسال می‌کند، که یک قرض غیرقابل تغییر به <code>rect2</code>، یک نمونه از <code>Rectangle</code> است. این منطقی است زیرا ما فقط نیاز به خواندن <code>rect2</code> داریم (نه نوشتن، که به یک قرض قابل تغییر نیاز داشت) و می‌خواهیم مالکیت <code>rect2</code> در <code>main</code> باقی بماند تا بتوانیم پس از فراخوانی متد <code>can_hold</code> دوباره از آن استفاده کنیم. مقدار بازگشتی <code>can_hold</code> یک مقدار بولی خواهد بود و پیاده‌سازی بررسی می‌کند که آیا عرض و ارتفاع <code>self</code> به ترتیب بزرگ‌تر از عرض و ارتفاع <code>Rectangle</code> دیگر هستند. بیایید متد جدید <code>can_hold</code> را به بلوک <code>impl</code> از لیست ۵-۱۳ اضافه کنیم، همان‌طور که در لیست ۵-۱۵ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 5-15: پیاده‌سازی متد <code>can_hold</code> روی <code>Rectangle</code> که یک نمونه دیگر از <code>Rectangle</code> را به عنوان پارامتر می‌گیرد</figcaption>
</figure>
<p>Here is the continuation of the translation for <strong>“ch05-03-method-syntax.md”</strong> into Persian:</p>
<p>وقتی این کد را با تابع <code>main</code> موجود در لیست ۵-۱۴ اجرا می‌کنیم، خروجی دلخواه را دریافت خواهیم کرد. متدها می‌توانند چندین پارامتر بگیرند که ما آن‌ها را پس از پارامتر <code>self</code> به امضا اضافه می‌کنیم، و این پارامترها همانند پارامترهای توابع عمل می‌کنند.</p>
<h3 id="توابع-مرتبط"><a class="header" href="#توابع-مرتبط">توابع مرتبط</a></h3>
<p>تمام توابعی که در یک بلوک <code>impl</code> تعریف شده‌اند <em>توابع مرتبط</em> نامیده می‌شوند، زیرا با نوعی که بعد از <code>impl</code> نام‌گذاری شده است، مرتبط هستند. ما می‌توانیم توابع مرتبطی را تعریف کنیم که <code>self</code> را به عنوان اولین پارامتر خود ندارند (و بنابراین متد نیستند) زیرا نیازی به کار با یک نمونه از نوع ندارند. ما قبلاً از یک تابع مشابه استفاده کرده‌ایم: تابع <code>String::from</code> که روی نوع <code>String</code> تعریف شده است.</p>
<p>توابع مرتبطی که متد نیستند اغلب برای سازنده‌ها استفاده می‌شوند که نمونه جدیدی از ساختار را بازمی‌گردانند. این توابع معمولاً <code>new</code> نامیده می‌شوند، اما <code>new</code> یک نام خاص نیست و در زبان به صورت داخلی تعریف نشده است. برای مثال، ما می‌توانیم تصمیم بگیریم تابع مرتبطی به نام <code>square</code> ارائه دهیم که یک پارامتر برای ابعاد بگیرد و از آن به عنوان عرض و ارتفاع استفاده کند، بنابراین ایجاد یک <code>Rectangle</code> مربعی را آسان‌تر می‌کند به جای اینکه مجبور باشیم مقدار یکسان را دو بار مشخص کنیم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>کلمات کلیدی <code>Self</code> در نوع بازگشتی و در بدنه تابع، نام مستعاری برای نوعی هستند که بعد از کلمه کلیدی <code>impl</code> ظاهر می‌شود، که در اینجا <code>Rectangle</code> است.</p>
<p>برای فراخوانی این تابع مرتبط، از نحو <code>::</code> همراه با نام ساختار استفاده می‌کنیم؛ برای مثال: <code>let sq = Rectangle::square(3);</code>. این تابع با ساختار فضای نام‌گذاری شده است: نحو <code>::</code> برای توابع مرتبط و فضای نام‌های ایجاد شده توسط ماژول‌ها استفاده می‌شود. ما ماژول‌ها را در <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">فصل ۷</a><!-- ignore --> بررسی خواهیم کرد.</p>
<h3 id="بلوکهای-متعدد-impl"><a class="header" href="#بلوکهای-متعدد-impl">بلوک‌های متعدد <code>impl</code></a></h3>
<p>هر ساختار اجازه دارد چندین بلوک <code>impl</code> داشته باشد. برای مثال، لیست ۵-۱۵ معادل کدی است که در لیست ۵-۱۶ نشان داده شده است، که هر متد در بلوک <code>impl</code> خود قرار دارد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 5-16: بازنویسی لیست ۵-۱۵ با استفاده از بلوک‌های متعدد <code>impl</code></figcaption>
</figure>
<p>هیچ دلیلی برای جدا کردن این متدها به بلوک‌های متعدد <code>impl</code> در اینجا وجود ندارد، اما این یک نحو معتبر است. ما در فصل ۱۰ موردی را خواهیم دید که در آن بلوک‌های متعدد <code>impl</code> مفید هستند، جایی که ما نوع‌های عمومی و ویژگی‌ها را بررسی خواهیم کرد.</p>
<h2 id="خلاصه-4"><a class="header" href="#خلاصه-4">خلاصه</a></h2>
<p>ساختارها به شما اجازه می‌دهند تا نوع‌های سفارشی ایجاد کنید که برای حوزه کاری شما معنادار باشند. با استفاده از ساختارها، می‌توانید قطعات داده‌ای مرتبط را به هم متصل کنید و برای هر قطعه نامی تعیین کنید تا کد شما شفاف شود. در بلوک‌های <code>impl</code>، شما می‌توانید توابعی را تعریف کنید که با نوع شما مرتبط هستند، و متدها نوعی از توابع مرتبط هستند که به شما اجازه می‌دهند رفتار نمونه‌های ساختارهایتان را مشخص کنید.</p>
<p>اما ساختارها تنها راه ایجاد نوع‌های سفارشی نیستند: بیایید به ویژگی Enum در Rust بپردازیم تا ابزار دیگری به جعبه ابزار شما اضافه کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="شمارندهها-و-تطابق-الگو"><a class="header" href="#شمارندهها-و-تطابق-الگو">شمارنده‌ها و تطابق الگو</a></h1>
<p>در این فصل، به <em>شمارنده‌ها</em> که همچنین به عنوان <em>enums</em> شناخته می‌شوند، می‌پردازیم. شمارنده‌ها به شما اجازه می‌دهند
یک نوع را با شمردن <em>مقادیر ممکن</em> آن تعریف کنید. ابتدا، یک شمارنده تعریف کرده و از آن استفاده می‌کنیم تا نشان دهیم چگونه
شمارنده می‌تواند معنی را همراه با داده کدگذاری کند. سپس، به شمارنده‌ای بسیار مفید به نام <code>Option</code> خواهیم پرداخت که
بیان می‌کند یک مقدار می‌تواند <em>چیزی</em> باشد یا <em>هیچ چیز</em>. بعد، بررسی خواهیم کرد که چگونه تطابق الگو در عبارت <code>match</code>
باعث می‌شود اجرای کد مختلف برای مقادیر مختلف یک شمارنده آسان شود. در نهایت، پوشش خواهیم داد که ساختار <code>if let</code> چگونه
ایده‌آل و مختصر برای مدیریت شمارنده‌ها در کد شما است.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="تعریف-یک-enum"><a class="header" href="#تعریف-یک-enum">تعریف یک Enum</a></h2>
<p>در حالی که ساختارها (Structs) روشی برای گروه‌بندی فیلدها و داده‌های مرتبط فراهم می‌کنند، Enumها به شما امکان می‌دهند که بگویید یک مقدار یکی از مجموعه مقادیر ممکن است. به عنوان مثال، ممکن است بخواهیم بگوییم که <code>Rectangle</code> یکی از مجموعه اشکالی است که همچنین شامل <code>Circle</code> و <code>Triangle</code> می‌شود. برای انجام این کار، زبان Rust به ما اجازه می‌دهد تا این امکان‌ها را به‌عنوان یک Enum کدگذاری کنیم.</p>
<p>بیایید نگاهی به یک موقعیت بیندازیم که ممکن است بخواهیم در کد بیان کنیم و ببینیم چرا Enumها مفیدتر و مناسب‌تر از Structها هستند. فرض کنید باید با آدرس‌های IP کار کنیم. در حال حاضر، دو استاندارد اصلی برای آدرس‌های IP وجود دارد: نسخه چهار و نسخه شش. از آنجا که این تنها حالت‌های ممکن برای آدرس‌های IP هستند که برنامه ما با آن‌ها مواجه خواهد شد، می‌توانیم تمام حالت‌های ممکن را شمارش کنیم، که همین موضوع اساس نام‌گذاری Enumها است.</p>
<p>هر آدرس IP می‌تواند یا نسخه چهار یا نسخه شش باشد، اما نمی‌تواند به‌طور همزمان هر دو باشد. این ویژگی آدرس‌های IP استفاده از ساختار داده Enum را مناسب می‌کند زیرا مقدار یک Enum می‌تواند فقط یکی از حالت‌هایش باشد. هر دو آدرس نسخه چهار و نسخه شش همچنان اساساً آدرس IP هستند، بنابراین باید هنگام کار با کدی که به هر نوع آدرس IP اعمال می‌شود، به‌عنوان یک نوع یکسان رفتار شوند.</p>
<p>ما می‌توانیم این مفهوم را در کد با تعریف یک Enumeration به نام <code>IpAddrKind</code> و فهرست کردن انواع ممکن یک آدرس IP، یعنی <code>V4</code> و <code>V6</code>، بیان کنیم. این‌ها حالت‌های Enum هستند:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>اکنون <code>IpAddrKind</code> یک نوع داده سفارشی است که می‌توانیم در قسمت‌های دیگر کد خود استفاده کنیم.</p>
<h3 id="مقادیر-enum"><a class="header" href="#مقادیر-enum">مقادیر Enum</a></h3>
<p>می‌توانیم نمونه‌هایی از هر یک از دو حالت <code>IpAddrKind</code> را به این صورت ایجاد کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>توجه داشته باشید که حالت‌های Enum تحت شناسه آن نام‌گذاری شده‌اند و برای جدا کردن دو حالت از یکدیگر از دو نقطه استفاده می‌کنیم. این ویژگی مفید است زیرا اکنون هر دو مقدار <code>IpAddrKind::V4</code> و <code>IpAddrKind::V6</code> از نوع یکسان <code>IpAddrKind</code> هستند. سپس می‌توانیم به عنوان مثال یک تابع تعریف کنیم که هر نوع <code>IpAddrKind</code> را به عنوان ورودی بپذیرد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>و می‌توانیم این تابع را با هر دو حالت فراخوانی کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>استفاده از Enumها مزایای بیشتری دارد. اگر بیشتر به نوع آدرس IP خود فکر کنیم، متوجه می‌شویم که در حال حاضر راهی برای ذخیره داده‌های واقعی آدرس IP نداریم؛ فقط می‌دانیم که چه نوعی است. با توجه به اینکه به‌تازگی درباره Structها در فصل 5 یاد گرفته‌اید، ممکن است وسوسه شوید این مشکل را با Structها همانطور که در فهرست 6-1 نشان داده شده است، حل کنید.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 6-1: ذخیره داده‌ها و حالت <code>IpAddrKind</code> یک آدرس IP با استفاده از یک <code>struct</code></figcaption>
</figure>
<p>در اینجا ما یک Struct به نام <code>IpAddr</code> تعریف کرده‌ایم که دو فیلد دارد: یک فیلد <code>kind</code> که از نوع <code>IpAddrKind</code> است (همان Enum که قبلاً تعریف کردیم) و یک فیلد <code>address</code> از نوع <code>String</code>. ما دو نمونه از این Struct داریم. اولین مورد <code>home</code> نام دارد و مقدار <code>IpAddrKind::V4</code> به‌عنوان <code>kind</code> با داده‌های آدرس مرتبط <code>127.0.0.1</code> دارد. نمونه دوم <code>loopback</code> نام دارد. این نمونه حالت دیگر Enum یعنی <code>V6</code> را به‌عنوان مقدار <code>kind</code> دارد و آدرس مرتبط <code>::1</code> است. ما از یک Struct برای بسته‌بندی مقادیر <code>kind</code> و <code>address</code> با هم استفاده کرده‌ایم، بنابراین اکنون حالت با مقدار مرتبط شده است.</p>
<p>با این حال، نمایش همان مفهوم با استفاده از فقط یک Enum مختصرتر است: به‌جای استفاده از Enum داخل یک Struct، می‌توانیم داده‌ها را مستقیماً به هر حالت Enum متصل کنیم. این تعریف جدید Enum <code>IpAddr</code> نشان می‌دهد که هر دو حالت <code>V4</code> و <code>V6</code> مقادیر <code>String</code> مرتبط دارند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>ما داده‌ها را مستقیماً به هر حالت Enum متصل کرده‌ایم، بنابراین نیازی به یک Struct اضافی نیست. در اینجا همچنین می‌توان جزئیات دیگری از نحوه عملکرد Enumها را مشاهده کرد: نام هر حالت Enum که تعریف می‌کنیم به‌صورت یک تابع تبدیل می‌شود که نمونه‌ای از Enum ایجاد می‌کند. یعنی <code>IpAddr::V4()</code> یک فراخوانی تابع است که یک آرگومان از نوع <code>String</code> می‌گیرد و نمونه‌ای از نوع <code>IpAddr</code> برمی‌گرداند. این تابع سازنده به‌طور خودکار به‌عنوان نتیجه تعریف Enum تعریف می‌شود.</p>
<p>یک مزیت دیگر استفاده از Enum به‌جای Struct این است که هر حالت می‌تواند انواع و مقادیر داده مرتبط متفاوتی داشته باشد. آدرس‌های IP نسخه چهار همیشه چهار مؤلفه عددی خواهند داشت که مقادیرشان بین 0 و 255 است. اگر بخواهیم آدرس‌های <code>V4</code> را به‌صورت چهار مقدار <code>u8</code> ذخیره کنیم اما همچنان آدرس‌های <code>V6</code> را به‌صورت یک مقدار <code>String</code> بیان کنیم، با یک Struct نمی‌توانیم این کار را انجام دهیم. Enumها به‌راحتی این حالت را مدیریت می‌کنند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>ما چندین روش مختلف برای تعریف ساختارهای داده برای ذخیره آدرس‌های IP نسخه چهار و نسخه شش نشان داده‌ایم. با این حال، همان‌طور که مشخص است، ذخیره آدرس‌های IP و کدگذاری نوع آن‌ها به‌قدری رایج است که <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">کتابخانه استاندارد تعریفی برای این کار ارائه می‌دهد!</a><!-- ignore --> بیایید نگاهی به نحوه تعریف <code>IpAddr</code> در کتابخانه استاندارد بیندازیم: این کتابخانه دارای همان Enum و حالت‌هایی است که ما تعریف کرده و استفاده کرده‌ایم، اما داده‌های آدرس را به‌صورت داخلی در حالت‌ها در قالب دو Struct مختلف تعبیه کرده است، که به‌طور متفاوت برای هر حالت تعریف شده‌اند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>این کد نشان می‌دهد که شما می‌توانید هر نوع داده‌ای مانند رشته‌ها، انواع عددی، یا Structها را داخل حالت‌های Enum قرار دهید. حتی می‌توانید یک Enum دیگر را نیز شامل کنید! همچنین، انواع استاندارد کتابخانه معمولاً خیلی پیچیده‌تر از چیزی نیستند که ممکن است خودتان ارائه دهید.</p>
<p>توجه داشته باشید که با وجود اینکه کتابخانه استاندارد تعریفی برای <code>IpAddr</code> دارد، ما همچنان می‌توانیم تعریف خودمان را ایجاد و استفاده کنیم بدون اینکه تضادی پیش بیاید زیرا تعریف کتابخانه استاندارد را به محدوده خود وارد نکرده‌ایم. ما در فصل 7 درباره وارد کردن انواع به محدوده بیشتر صحبت خواهیم کرد.</p>
<p>بیایید به مثال دیگری از یک Enum در فهرست 6-2 نگاه کنیم: این مورد دارای انواع متنوعی از داده‌های جاسازی‌شده در حالت‌های خود است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 6-2: یک Enum به نام <code>Message</code> که هر یک از حالت‌های آن مقادیر متفاوتی ذخیره می‌کنند</figcaption>
</figure>
<p>این Enum دارای چهار حالت با انواع مختلف است:</p>
<ul>
<li><code>Quit</code> هیچ داده‌ای با آن مرتبط نیست.</li>
<li><code>Move</code> دارای فیلدهای نام‌گذاری شده، شبیه به یک Struct است.</li>
<li><code>Write</code> شامل یک مقدار <code>String</code> است.</li>
<li><code>ChangeColor</code> شامل سه مقدار <code>i32</code> است.</li>
</ul>
<p>تعریف یک Enum با حالت‌هایی مانند حالت‌های فهرست 6-2 مشابه تعریف انواع مختلف ساختارها است، با این تفاوت که Enum از کلمه کلیدی <code>struct</code> استفاده نمی‌کند و تمام حالت‌ها تحت نوع <code>Message</code> گروه‌بندی شده‌اند. ساختارهای زیر می‌توانند همان داده‌هایی را نگه دارند که حالت‌های Enum قبلی نگه می‌دارند:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>اما اگر از ساختارهای مختلفی استفاده کنیم که هر یک نوع خاص خود را دارند، نمی‌توانیم به‌راحتی یک تابع تعریف کنیم که بتواند هر یک از این انواع پیام‌ها را مانند چیزی که با Enum <code>Message</code> تعریف‌شده در فهرست 6-2 امکان‌پذیر است، دریافت کند.</p>
<p>یک شباهت دیگر بین Enumها و ساختارها این است: همان‌طور که می‌توانیم متدها را با استفاده از <code>impl</code> برای ساختارها تعریف کنیم، می‌توانیم متدها را برای Enumها نیز تعریف کنیم. اینجا یک متد به نام <code>call</code> است که می‌توانیم برای Enum <code>Message</code> خود تعریف کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>بدنه این متد از <code>self</code> برای دسترسی به مقداری که متد روی آن فراخوانی شده است استفاده می‌کند. در این مثال، ما یک متغیر به نام <code>m</code> ایجاد کرده‌ایم که مقدار <code>Message::Write(String::from("hello"))</code> را دارد و این همان چیزی است که <code>self</code> در بدن متد <code>call</code> هنگام اجرای <code>m.call()</code> خواهد بود.</p>
<p>بیایید به یک Enum دیگر در کتابخانه استاندارد که بسیار متداول و مفید است نگاهی بیندازیم: <code>Option</code>.</p>
<h3 id="enum-option-و-مزایای-آن-نسبت-به-مقادیر-null"><a class="header" href="#enum-option-و-مزایای-آن-نسبت-به-مقادیر-null">Enum <code>Option</code> و مزایای آن نسبت به مقادیر Null</a></h3>
<p>این بخش به مطالعه موردی <code>Option</code> می‌پردازد که یکی دیگر از Enumهای تعریف شده در کتابخانه استاندارد است. نوع <code>Option</code> سناریوی بسیار رایجی را نشان می‌دهد که در آن یک مقدار می‌تواند وجود داشته باشد یا هیچ مقداری وجود نداشته باشد.</p>
<p>به عنوان مثال، اگر اولین مورد را در یک لیست غیر خالی درخواست کنید، مقداری دریافت خواهید کرد. اگر اولین مورد را در یک لیست خالی درخواست کنید، هیچ مقداری دریافت نخواهید کرد. بیان این مفهوم در قالب سیستم نوع به کامپایلر امکان می‌دهد تا بررسی کند آیا تمام مواردی که باید مدیریت شوند را در نظر گرفته‌اید؛ این ویژگی می‌تواند از بروز باگ‌هایی که در دیگر زبان‌های برنامه‌نویسی بسیار رایج هستند جلوگیری کند.</p>
<p>طراحی زبان‌های برنامه‌نویسی اغلب از نظر ویژگی‌هایی که شامل می‌شوند بررسی می‌شود، اما ویژگی‌هایی که کنار گذاشته می‌شوند نیز مهم هستند. Rust ویژگی null را که بسیاری از زبان‌های دیگر دارند، ندارد. <em>Null</em> یک مقدار است که به معنای وجود نداشتن مقدار می‌باشد. در زبان‌هایی که دارای null هستند، متغیرها می‌توانند همیشه در یکی از دو حالت باشند: null یا not-null.</p>
<p>در ارائه سال 2009 خود به نام “Null References: The Billion Dollar Mistake”، تونی هور، مخترع null، چنین می‌گوید:</p>
<blockquote>
<p>من آن را اشتباه میلیارد دلاری خود می‌نامم. در آن زمان، من در حال طراحی اولین سیستم نوع جامع برای مراجع در یک زبان شیءگرا بودم. هدف من اطمینان از این بود که تمام استفاده‌های از مراجع کاملاً امن باشند، با بررسی‌هایی که به‌طور خودکار توسط کامپایلر انجام می‌شوند. اما نتوانستم در برابر وسوسه قرار دادن یک مرجع null مقاومت کنم، فقط به این دلیل که پیاده‌سازی آن بسیار آسان بود. این منجر به خطاها، آسیب‌پذیری‌ها، و خرابی‌های سیستم‌های بی‌شماری شده است که احتمالاً باعث یک میلیارد دلار درد و ضرر در چهل سال گذشته شده‌اند.</p>
</blockquote>
<p>مشکل مقادیر null این است که اگر بخواهید از یک مقدار null به‌عنوان یک مقدار not-null استفاده کنید، نوعی خطا دریافت خواهید کرد. از آنجا که خاصیت null یا not-null فراگیر است، بسیار آسان است که این نوع خطا را مرتکب شوید.</p>
<p>با این حال، مفهومی که null سعی در بیان آن دارد همچنان مفید است: null یک مقدار است که در حال حاضر به دلایلی نامعتبر یا غایب است.</p>
<p>مشکل واقعاً با مفهوم نیست، بلکه با پیاده‌سازی خاص است. به این ترتیب، Rust مقادیر null ندارد، اما یک Enum دارد که می‌تواند مفهوم وجود داشتن یا نداشتن یک مقدار را کدگذاری کند. این Enum <code>Option&lt;T&gt;</code> است که به صورت زیر توسط کتابخانه استاندارد تعریف شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Enum <code>Option&lt;T&gt;</code> آن‌قدر مفید است که حتی در بخش پیش‌فرض (Prelude) گنجانده شده است؛ نیازی نیست که به‌طور صریح آن را به محدوده بیاورید. حالت‌های آن نیز در بخش پیش‌فرض هستند: می‌توانید مستقیماً از <code>Some</code> و <code>None</code> بدون پیشوند <code>Option::</code> استفاده کنید. Enum <code>Option&lt;T&gt;</code> همچنان یک Enum معمولی است، و <code>Some(T)</code> و <code>None</code> همچنان حالت‌هایی از نوع <code>Option&lt;T&gt;</code> هستند.</p>
<p>سینتکس <code>&lt;T&gt;</code> یک ویژگی از Rust است که هنوز درباره آن صحبت نکرده‌ایم. این یک پارامتر نوع عمومی (Generic) است و ما در فصل 10 به جزئیات بیشتری درباره آن خواهیم پرداخت. برای حالا، تنها چیزی که باید بدانید این است که <code>&lt;T&gt;</code> به این معنا است که حالت <code>Some</code> از Enum <code>Option</code> می‌تواند یک قطعه داده از هر نوعی را نگه دارد، و هر نوع مشخصی که به جای <code>T</code> استفاده شود، کل نوع <code>Option&lt;T&gt;</code> را به یک نوع متفاوت تبدیل می‌کند. در اینجا چند مثال از استفاده از مقادیر <code>Option</code> برای نگه‌داری انواع عددی و کاراکتری آورده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>نوع <code>some_number</code> برابر با <code>Option&lt;i32&gt;</code> است. نوع <code>some_char</code> برابر با <code>Option&lt;char&gt;</code> است که یک نوع متفاوت است. Rust می‌تواند این انواع را تشخیص دهد زیرا ما مقداری را در حالت <code>Some</code> مشخص کرده‌ایم. برای <code>absent_number</code>، Rust از ما می‌خواهد که نوع کلی <code>Option</code> را مشخص کنیم: کامپایلر نمی‌تواند نوعی را که حالت <code>Some</code> مرتبط نگه خواهد داشت فقط با نگاه کردن به یک مقدار <code>None</code> تشخیص دهد. در اینجا، ما به Rust می‌گوییم که منظور ما این است که <code>absent_number</code> از نوع <code>Option&lt;i32&gt;</code> باشد.</p>
<p>هنگامی که ما یک مقدار <code>Some</code> داریم، می‌دانیم که یک مقدار وجود دارد و این مقدار درون <code>Some</code> نگه‌داری می‌شود. هنگامی که ما یک مقدار <code>None</code> داریم، از یک نظر، این همان معنای null را دارد: ما یک مقدار معتبر نداریم. پس چرا داشتن <code>Option&lt;T&gt;</code> بهتر از داشتن null است؟</p>
<p>به طور خلاصه، به این دلیل که <code>Option&lt;T&gt;</code> و <code>T</code> (جایی که <code>T</code> می‌تواند هر نوعی باشد) انواع متفاوتی هستند، کامپایلر به ما اجازه نمی‌دهد که یک مقدار <code>Option&lt;T&gt;</code> را به‌عنوان یک مقدار قطعاً معتبر استفاده کنیم. به عنوان مثال، این کد کامپایل نخواهد شد، زیرا سعی در جمع یک <code>i8</code> با یک <code>Option&lt;i8&gt;</code> دارد:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>اگر این کد را اجرا کنیم، پیام خطایی شبیه به این دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;'a i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>شدید است! در واقع، این پیام خطا به این معنا است که Rust نمی‌داند چگونه یک <code>i8</code> و یک <code>Option&lt;i8&gt;</code> را جمع کند، زیرا آن‌ها انواع مختلفی هستند. هنگامی که یک مقدار از نوعی مانند <code>i8</code> در Rust داریم، کامپایلر اطمینان می‌دهد که همیشه یک مقدار معتبر داریم. می‌توانیم با اطمینان ادامه دهیم بدون اینکه مجبور باشیم قبل از استفاده از آن مقدار، null را بررسی کنیم. فقط زمانی که یک <code>Option&lt;i8&gt;</code> (یا هر نوع مقداری که با آن کار می‌کنیم) داریم باید نگران احتمال عدم وجود مقدار باشیم، و کامپایلر اطمینان می‌دهد که ما آن حالت را قبل از استفاده از مقدار مدیریت کرده‌ایم.</p>
<p>به عبارت دیگر، شما باید یک مقدار <code>Option&lt;T&gt;</code> را به یک مقدار <code>T</code> تبدیل کنید قبل از اینکه بتوانید عملیات <code>T</code> را با آن انجام دهید. به طور کلی، این به جلوگیری از یکی از شایع‌ترین مشکلات null کمک می‌کند: فرض غلط که چیزی null نیست در حالی که واقعاً null است.</p>
<p>از بین بردن خطر فرض نادرست درباره یک مقدار not-null به شما کمک می‌کند تا در کد خود اطمینان بیشتری داشته باشید. برای داشتن مقداری که ممکن است null باشد، باید صریحاً با تعیین نوع آن مقدار به‌عنوان <code>Option&lt;T&gt;</code> به آن رضایت دهید. سپس، هنگامی که از آن مقدار استفاده می‌کنید، موظف هستید که به‌طور صریح حالتی را که مقدار null است مدیریت کنید. هر جا که مقداری از نوعی است که <code>Option&lt;T&gt;</code> نیست، می‌توانید با خیال راحت فرض کنید که مقدار null نیست. این تصمیم طراحی برای محدود کردن شیوع null و افزایش ایمنی کدهای Rust بود.</p>
<p>پس چگونه مقدار <code>T</code> را از حالت <code>Some</code> وقتی که یک مقدار از نوع <code>Option&lt;T&gt;</code> دارید استخراج می‌کنید تا بتوانید از آن مقدار استفاده کنید؟ Enum <code>Option&lt;T&gt;</code> تعداد زیادی متد دارد که در موقعیت‌های مختلف مفید هستند؛ می‌توانید آن‌ها را در <a href="https://doc.rust-lang.org/std/option/enum.Option.html">مستندات آن</a> بررسی کنید. آشنایی با متدهای موجود در <code>Option&lt;T&gt;</code> در مسیر یادگیری Rust بسیار مفید خواهد بود.</p>
<p>به طور کلی، برای استفاده از یک مقدار <code>Option&lt;T&gt;</code>، می‌خواهید کدی داشته باشید که هر حالت را مدیریت کند. می‌خواهید کدی داشته باشید که تنها زمانی اجرا شود که یک مقدار <code>Some(T)</code> دارید، و این کد اجازه دارد از مقدار داخلی <code>T</code> استفاده کند. همچنین، می‌خواهید کدی داشته باشید که فقط در صورت وجود مقدار <code>None</code> اجرا شود، و این کد به هیچ مقدار <code>T</code> دسترسی ندارد. عبارت <code>match</code> یک سازه جریان کنترلی است که وقتی با Enumها استفاده می‌شود دقیقاً این کار را انجام می‌دهد: این عبارت کد متفاوتی را بسته به اینکه کدام حالت از Enum موجود است اجرا می‌کند، و آن کد می‌تواند از داده داخل مقدار منطبق شده استفاده کند.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="سازه-جریان-کنترلی-match"><a class="header" href="#سازه-جریان-کنترلی-match">سازه جریان کنترلی <code>match</code></a></h2>
<p>زبان Rust دارای یک سازه جریان کنترلی بسیار قدرتمند به نام <code>match</code> است که به شما اجازه می‌دهد تا یک مقدار را با یک سری الگوها مقایسه کنید و سپس بر اساس الگویی که مطابقت دارد، کد مربوطه را اجرا کنید. الگوها می‌توانند شامل مقادیر ثابت، نام متغیرها، wildcardها و چیزهای دیگر باشند. <a href="ch19-00-patterns.html">فصل 19</a><!-- ignore --> انواع مختلف الگوها و عملکرد آن‌ها را پوشش می‌دهد. قدرت <code>match</code> از بیان‌پذیری الگوها و این واقعیت ناشی می‌شود که کامپایلر تأیید می‌کند که همه حالت‌های ممکن مدیریت شده‌اند.</p>
<p>می‌توانید یک عبارت <code>match</code> را مانند یک دستگاه مرتب‌کننده سکه تصور کنید: سکه‌ها در یک مسیر با سوراخ‌هایی با اندازه‌های مختلف قرار می‌گیرند و هر سکه از اولین سوراخی که در آن جا می‌شود عبور می‌کند. به همین ترتیب، مقادیر از هر الگو در یک <code>match</code> عبور می‌کنند و در اولین الگویی که مقدار “جا می‌شود”، مقدار به بلوک کد مرتبط می‌افتد و برای اجرا استفاده می‌شود.</p>
<p>حال بیایید از یک مثال واقعی با سکه‌ها استفاده کنیم! می‌توانیم تابعی بنویسیم که یک سکه ناشناخته از ایالات متحده را بگیرد و به شیوه‌ای مشابه دستگاه شمارنده سکه‌ها، تعیین کند که آن سکه کدام نوع است و ارزش آن را به سنت برگرداند، همانطور که در فهرست 6-3 نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 6-3: یک enum و یک عبارت <code>match</code> که حالت‌های enum را به عنوان الگوهای خود دارد</figcaption>
</figure>
<h3 id="بازبینی-تابع-value_in_cents"><a class="header" href="#بازبینی-تابع-value_in_cents">بازبینی تابع <code>value_in_cents</code></a></h3>
<p>ابتدا کلمه کلیدی <code>match</code> و سپس یک عبارت را فهرست می‌کنیم که در این مورد مقدار <code>coin</code> است. این کار بسیار مشابه یک عبارت شرطی که با <code>if</code> استفاده می‌شود به نظر می‌رسد، اما تفاوت بزرگی دارد: با <code>if</code>، شرط باید به یک مقدار بولین ارزیابی شود، اما اینجا می‌تواند هر نوعی باشد. نوع <code>coin</code> در این مثال enum <code>Coin</code> است که در اولین خط تعریف کردیم.</p>
<p>بازوهای <code>match</code> دو قسمت دارند: یک الگو و مقداری کد. اولین بازو در اینجا دارای الگویی است که مقدار <code>Coin::Penny</code> است و سپس اپراتور <code>=&gt;</code> که الگو و کد اجرایی را از هم جدا می‌کند. کد در اینجا فقط مقدار <code>1</code> است. هر بازو با یک کاما از بازوی بعدی جدا می‌شود.</p>
<p>هنگامی که عبارت <code>match</code> اجرا می‌شود، مقدار حاصل را با الگوی هر بازو به ترتیب مقایسه می‌کند. اگر الگویی با مقدار مطابقت داشته باشد، کدی که با آن الگو مرتبط است اجرا می‌شود. اگر آن الگو با مقدار مطابقت نداشته باشد، اجرا به بازوی بعدی ادامه می‌یابد، همانطور که در یک دستگاه مرتب‌کننده سکه‌ها عمل می‌کند. ما می‌توانیم به هر تعداد بازو که نیاز داریم داشته باشیم: در فهرست 6-3، <code>match</code> ما چهار بازو دارد.</p>
<p>کد مرتبط با هر بازو یک عبارت است و مقدار حاصل از عبارت در بازوی منطبق شده، مقداری است که برای کل عبارت <code>match</code> بازگردانده می‌شود.</p>
<p>معمولاً اگر کد بازوی <code>match</code> کوتاه باشد، از آکولاد استفاده نمی‌کنیم، همانطور که در فهرست 6-3 که هر بازو فقط یک مقدار را برمی‌گرداند. اگر بخواهید چندین خط کد را در یک بازو اجرا کنید، باید از آکولاد استفاده کنید، و در این صورت کاما پس از بازو اختیاری است. به عنوان مثال، کد زیر هر بار که متد با یک <code>Coin::Penny</code> فراخوانی می‌شود، “Lucky penny!” را چاپ می‌کند، اما همچنان آخرین مقدار بلوک یعنی <code>1</code> را بازمی‌گرداند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="الگوهایی-که-به-مقادیر-متصل-میشوند"><a class="header" href="#الگوهایی-که-به-مقادیر-متصل-میشوند">الگوهایی که به مقادیر متصل می‌شوند</a></h3>
<p>یکی دیگر از ویژگی‌های مفید بازوهای <code>match</code> این است که می‌توانند به بخش‌هایی از مقادیر که با الگو مطابقت دارند متصل شوند. این همان روشی است که می‌توانیم مقادیر را از حالت‌های enum استخراج کنیم.</p>
<p>به عنوان مثال، بیایید یکی از حالت‌های enum خود را تغییر دهیم تا داده‌هایی را درون خود نگه دارد. از سال 1999 تا 2008، ایالات متحده ربع‌هایی با طرح‌های مختلف برای هر یک از 50 ایالت در یک طرف ضرب کرد. هیچ سکه دیگری طرح ایالتی نداشت، بنابراین فقط ربع‌ها این مقدار اضافی را دارند. می‌توانیم این اطلاعات را به enum خود با تغییر حالت <code>Quarter</code> به گونه‌ای که یک مقدار <code>UsState</code> درون آن ذخیره شود اضافه کنیم، همانطور که در فهرست 6-4 انجام دادیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 6-4: یک enum به نام <code>Coin</code> که حالت <code>Quarter</code> آن همچنین یک مقدار <code>UsState</code> را نگه می‌دارد</figcaption>
</figure>
<p>بیایید تصور کنیم که یک دوست ما سعی دارد تمام 50 ربع ایالتی را جمع‌آوری کند. در حالی که ما پول‌های خود را بر اساس نوع سکه مرتب می‌کنیم، همچنین نام ایالتی که با هر ربع مرتبط است را اعلام می‌کنیم تا اگر این یکی از آن‌هایی باشد که دوست ما ندارد، بتوانند آن را به مجموعه خود اضافه کنند.</p>
<p>در عبارت <code>match</code> برای این کد، یک متغیر به نام <code>state</code> به الگو اضافه می‌کنیم که مقادیری از حالت <code>Coin::Quarter</code> را تطبیق می‌دهد. وقتی که یک مقدار <code>Coin::Quarter</code> منطبق می‌شود، متغیر <code>state</code> به مقدار ایالت آن ربع متصل خواهد شد. سپس می‌توانیم از <code>state</code> در کد بازوی آن استفاده کنیم، به این صورت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>اگر ما <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> را فراخوانی کنیم، مقدار <code>coin</code> برابر با <code>Coin::Quarter(UsState::Alaska)</code> خواهد بود. هنگامی که آن مقدار را با هر بازوی <code>match</code> مقایسه می‌کنیم، هیچ‌کدام از آن‌ها مطابقت ندارند تا اینکه به <code>Coin::Quarter(state)</code> برسیم. در این نقطه، اتصال برای <code>state</code> مقدار <code>UsState::Alaska</code> خواهد بود. سپس می‌توانیم از آن اتصال در عبارت <code>println!</code> استفاده کنیم و به این ترتیب مقدار داخلی ایالت را از حالت <code>Quarter</code> enum <code>Coin</code> استخراج کنیم.</p>
<h3 id="تطبیق-با-optiont"><a class="header" href="#تطبیق-با-optiont">تطبیق با <code>Option&lt;T&gt;</code></a></h3>
<p>در بخش قبلی، ما می‌خواستیم مقدار داخلی <code>T</code> را از حالت <code>Some</code> استخراج کنیم زمانی که از <code>Option&lt;T&gt;</code> استفاده می‌کردیم؛ همچنین می‌توانیم با استفاده از <code>match</code> حالت‌های <code>Option&lt;T&gt;</code> را مدیریت کنیم، همانطور که با enum <code>Coin</code> انجام دادیم! به جای مقایسه سکه‌ها، حالت‌های <code>Option&lt;T&gt;</code> را مقایسه می‌کنیم، اما روش کار عبارت <code>match</code> همان باقی می‌ماند.</p>
<p>بیایید فرض کنیم که می‌خواهیم تابعی بنویسیم که یک <code>Option&lt;i32&gt;</code> بگیرد و اگر یک مقدار درون آن باشد، مقدار 1 را به آن اضافه کند. اگر هیچ مقداری درون آن نباشد، تابع باید مقدار <code>None</code> را بازگرداند و هیچ عملیاتی را انجام ندهد.</p>
<p>نوشتن این تابع با استفاده از <code>match</code> بسیار آسان است و به این صورت خواهد بود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p>اجازه دهید اولین اجرای <code>plus_one</code> را با جزئیات بیشتری بررسی کنیم. وقتی که <code>plus_one(five)</code> را فراخوانی می‌کنیم، متغیر <code>x</code> در بدنه <code>plus_one</code> مقدار <code>Some(5)</code> خواهد داشت. سپس آن را با هر بازوی <code>match</code> مقایسه می‌کنیم:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>مقدار <code>Some(5)</code> با الگوی <code>None</code> مطابقت ندارد، بنابراین به بازوی بعدی می‌رویم:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>آیا <code>Some(5)</code> با <code>Some(i)</code> مطابقت دارد؟ بله! ما همان حالت را داریم. مقدار <code>i</code> به مقدار داخل <code>Some</code> متصل می‌شود، بنابراین <code>i</code> مقدار <code>5</code> می‌گیرد. سپس کد موجود در بازوی <code>match</code> اجرا می‌شود، بنابراین مقدار 1 به مقدار <code>i</code> اضافه می‌کنیم و یک مقدار جدید <code>Some</code> با مقدار کل <code>6</code> ایجاد می‌کنیم.</p>
<p>حالا اجازه دهید اجرای دوم <code>plus_one</code> را در فهرست 6-5 در نظر بگیریم، جایی که مقدار <code>x</code> برابر با <code>None</code> است. ما وارد <code>match</code> می‌شویم و آن را با اولین بازو مقایسه می‌کنیم:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>این بار مطابقت دارد! هیچ مقداری برای اضافه کردن وجود ندارد، بنابراین برنامه متوقف می‌شود و مقدار <code>None</code> در سمت راست <code>=&gt;</code> را بازمی‌گرداند. از آنجا که اولین بازو مطابقت داشت، بازوهای دیگر بررسی نمی‌شوند.</p>
<p>ترکیب <code>match</code> و enumها در بسیاری از موقعیت‌ها مفید است. این الگو را در کد Rust زیاد خواهید دید: <code>match</code> روی یک enum، اتصال یک متغیر به داده داخل، و سپس اجرای کد بر اساس آن. ممکن است در ابتدا کمی سخت باشد، اما وقتی به آن عادت کنید، آرزو خواهید کرد که در همه زبان‌ها وجود داشته باشد. این سازه همواره یکی از ویژگی‌های مورد علاقه کاربران است.</p>
<h3 id="تطابقها-exhaustive-هستند"><a class="header" href="#تطابقها-exhaustive-هستند">تطابق‌ها Exhaustive هستند</a></h3>
<p>یکی دیگر از جنبه‌های عبارت <code>match</code> این است که الگوهای بازوها باید تمام حالت‌های ممکن را پوشش دهند. به این نسخه از تابع <code>plus_one</code> که یک باگ دارد و کامپایل نمی‌شود توجه کنید:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>ما حالت <code>None</code> را مدیریت نکرده‌ایم، بنابراین این کد باعث بروز یک باگ خواهد شد. خوشبختانه، این یک باگ است که Rust می‌تواند آن را تشخیص دهد. اگر تلاش کنیم این کد را کامپایل کنیم، این خطا را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/option.rs:571:1
    |
571 | pub enum Option&lt;T&gt; {
    | ^^^^^^^^^^^^^^^^^^
...
575 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust می‌داند که ما هر حالت ممکن را پوشش نداده‌ایم و حتی می‌داند که کدام الگو را فراموش کرده‌ایم! تطابق‌ها در Rust <em>exhaustive</em> هستند: ما باید هر حالت ممکن را مدیریت کنیم تا کد معتبر باشد. به ویژه در مورد <code>Option&lt;T&gt;</code>، وقتی که Rust از فراموش کردن مدیریت صریح حالت <code>None</code> جلوگیری می‌کند، از فرض نادرست وجود مقدار زمانی که ممکن است null باشد محافظت می‌کند و به این ترتیب اشتباه میلیارد دلاری که قبلاً بحث شد را غیرممکن می‌سازد.</p>
<h3 id="الگوهای-catch-all-و-placeholder-_"><a class="header" href="#الگوهای-catch-all-و-placeholder-_">الگوهای Catch-all و Placeholder <code>_</code></a></h3>
<p>با استفاده از Enumها، می‌توانیم اقدامات ویژه‌ای برای چند مقدار خاص انجام دهیم، اما برای تمام مقادیر دیگر یک عمل پیش‌فرض داشته باشیم. تصور کنید که در حال پیاده‌سازی یک بازی هستید که اگر بازیکن عدد 3 روی تاس بیاورد، حرکت نمی‌کند اما یک کلاه زیبا جدید می‌گیرد. اگر عدد 7 بیاورد، بازیکن یک کلاه زیبا از دست می‌دهد. برای تمام مقادیر دیگر، بازیکن به اندازه عدد روی تخته بازی حرکت می‌کند. در اینجا یک عبارت <code>match</code> آورده شده است که این منطق را پیاده‌سازی می‌کند. نتیجه‌ی پرتاب تاس به جای مقدار تصادفی، به صورت هاردکد شده قرار داده شده است، و تمام منطق دیگر با توابعی بدون بدنه نشان داده شده‌اند زیرا پیاده‌سازی آن‌ها خارج از محدوده این مثال است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>برای دو بازوی اول، الگوها مقادیر ثابت <code>3</code> و <code>7</code> هستند. برای بازوی آخر که تمام مقادیر ممکن دیگر را پوشش می‌دهد، الگو یک متغیر است که ما آن را <code>other</code> نامیده‌ایم. کدی که برای بازوی <code>other</code> اجرا می‌شود، متغیر را با استفاده از تابع <code>move_player</code> می‌فرستد.</p>
<p>این کد کامپایل می‌شود، حتی اگر تمام مقادیر ممکن یک <code>u8</code> را فهرست نکرده باشیم، زیرا بازوی آخر همه مقادیر ذکر نشده را تطبیق می‌دهد. این الگوی catch-all نیاز تطابق exhaustive را برآورده می‌کند. توجه داشته باشید که باید بازوی catch-all را در آخر قرار دهیم زیرا الگوها به ترتیب ارزیابی می‌شوند. اگر بازوی catch-all را زودتر قرار دهیم، بازوهای دیگر هرگز اجرا نخواهند شد، بنابراین Rust به ما هشدار می‌دهد اگر بعد از یک بازوی catch-all بازوهای دیگری اضافه کنیم!</p>
<p>Rust همچنین یک الگو به نام <code>_</code> دارد که می‌توانیم از آن استفاده کنیم وقتی که می‌خواهیم یک catch-all داشته باشیم اما نمی‌خواهیم مقدار در الگوی catch-all را <em>استفاده کنیم</em>. این به Rust می‌گوید که ما قصد نداریم مقدار را استفاده کنیم، بنابراین Rust درباره یک متغیر استفاده نشده به ما هشدار نمی‌دهد.</p>
<p>بیایید قوانین بازی را تغییر دهیم: حالا اگر بازیکن هر چیزی به غیر از 3 یا 7 بیاورد، باید دوباره تاس بیندازد. دیگر نیازی به استفاده از مقدار catch-all نیست، بنابراین می‌توانیم کد خود را به‌جای متغیری به نام <code>other</code> از <code>_</code> استفاده کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>این مثال نیز نیاز تطابق exhaustive را برآورده می‌کند زیرا ما صریحاً تمام مقادیر دیگر را در بازوی آخر نادیده گرفته‌ایم و چیزی را فراموش نکرده‌ایم.</p>
<p>در نهایت، قوانین بازی را یک بار دیگر تغییر می‌دهیم، بنابراین اگر بازیکن هر چیزی غیر از 3 یا 7 بیاورد، هیچ کار دیگری در نوبت او انجام نمی‌شود. می‌توانیم این موضوع را با استفاده از مقدار واحد (نوع <code>tuple</code> خالی که قبلاً در بخش <a href="ch03-02-data-types.html#the-tuple-type">“نوع Tuple”</a><!-- ignore --> ذکر شد) به عنوان کدی که با بازوی <code>_</code> همراه است بیان کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>اینجا، ما به Rust صریحاً می‌گوییم که قصد نداریم هیچ مقدار دیگری را که با هیچ الگویی در بازوهای قبلی مطابقت ندارد استفاده کنیم و نمی‌خواهیم در این حالت کدی اجرا کنیم.</p>
<p>درباره الگوها و تطبیق آن‌ها مطالب بیشتری در <a href="ch19-00-patterns.html">فصل 19</a> پوشش خواهیم داد. فعلاً به سینتکس <code>if let</code> می‌پردازیم که می‌تواند در مواقعی که عبارت <code>match</code> کمی طولانی به نظر می‌رسد، مفید باشد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="جریان-کنترلی-مختصر-با-if-let-و-let-else"><a class="header" href="#جریان-کنترلی-مختصر-با-if-let-و-let-else">جریان کنترلی مختصر با <code>if let</code> و <code>let else</code></a></h2>
<p>دستور <code>if let</code> به شما اجازه می‌دهد که <code>if</code> و <code>let</code> را ترکیب کنید و به شکلی کمتر پرحجم، مقادیر مطابق با یک الگو را مدیریت کنید و سایر مقادیر را نادیده بگیرید. برنامه‌ای که در لیستینگ 6-6 نشان داده شده است، بر روی یک مقدار <code>Option&lt;u8&gt;</code> در متغیر <code>config_max</code> مطابقت دارد، اما تنها زمانی که مقدار <code>Some</code> باشد کد را اجرا می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {max}"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 6-6: یک <code>match</code> که تنها به اجرای کد زمانی که مقدار <code>Some</code> است اهمیت می‌دهد</figcaption>
</figure>
<p>اگر مقدار <code>Some</code> باشد، مقدار موجود در متغیر <code>Some</code> را با اتصال به متغیر <code>max</code> در الگو چاپ می‌کنیم. ما نمی‌خواهیم با مقدار <code>None</code> کاری انجام دهیم. برای برآورده کردن دستور <code>match</code>، باید <code>_ =&gt; ()</code> را بعد از پردازش تنها یک مورد اضافه کنیم، که کد اضافی آزاردهنده‌ای است.</p>
<p>در عوض، می‌توانیم این کد را به شکلی کوتاه‌تر با استفاده از <code>if let</code> بنویسیم. کد زیر به همان شکل <code>match</code> در لیستینگ 6-6 عمل می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {max}");
    }
<span class="boring">}</span></code></pre></pre>
<p>دستور <code>if let</code> یک الگو و یک عبارت را می‌گیرد که با یک علامت مساوی جدا شده‌اند. این دستور همانند <code>match</code> عمل می‌کند، جایی که عبارت به <code>match</code> داده می‌شود و الگو بازوی اول آن است. در این مورد، الگو <code>Some(max)</code> است و متغیر <code>max</code> مقدار داخل <code>Some</code> را می‌گیرد. سپس می‌توانیم از <code>max</code> در بدنه بلوک <code>if let</code> همان‌طور که در بازوی متناظر <code>match</code> استفاده کردیم، استفاده کنیم. کد در بلوک <code>if let</code> تنها در صورتی اجرا می‌شود که مقدار با الگو مطابقت داشته باشد.</p>
<p>استفاده از <code>if let</code> به معنای تایپ کمتر، تورفتگی کمتر و کد اضافی کمتر است. با این حال، شما بررسی کامل که <code>match</code> اعمال می‌کند را از دست می‌دهید. انتخاب بین <code>match</code> و <code>if let</code> به این بستگی دارد که در وضعیت خاص شما چه کاری انجام می‌دهید و آیا به‌دست آوردن اختصار به بهای از دست دادن بررسی کامل، معامله‌ی مناسبی است یا خیر.</p>
<p>به عبارت دیگر، می‌توانید <code>if let</code> را به عنوان یک قند سینتکس برای <code>match</code> تصور کنید که کد را زمانی که مقدار با یک الگو مطابقت دارد اجرا می‌کند و سپس تمام مقادیر دیگر را نادیده می‌گیرد.</p>
<p>ما می‌توانیم یک <code>else</code> با یک <code>if let</code> اضافه کنیم. بلوک کدی که با <code>else</code> همراه می‌شود همان بلوک کدی است که با مورد <code>_</code> در دستور <code>match</code> که معادل <code>if let</code> و <code>else</code> است همراه می‌شود. دستور <code>Coin</code> را در لیستینگ 6-4 به یاد بیاورید، جایی که نوع <code>Quarter</code> یک مقدار <code>UsState</code> را نیز در خود جای داده بود. اگر می‌خواستیم تمام سکه‌های غیر <code>Quarter</code> را که می‌بینیم بشماریم، هم‌زمان ایالت‌های سکه‌های <code>Quarter</code> را اعلام کنیم، می‌توانستیم این کار را با یک دستور <code>match</code> انجام دهیم، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("State quarter from {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>یا می‌توانستیم از یک عبارت <code>if let</code> و <code>else</code> استفاده کنیم، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="ماندن-در-مسیر-خوشحال-با-let-else"><a class="header" href="#ماندن-در-مسیر-خوشحال-با-let-else">ماندن در “مسیر خوشحال” با <code>let else</code></a></h2>
<p>یک الگوی معمول این است که زمانی که مقداری وجود دارد محاسباتی را انجام دهید و در غیر این صورت یک مقدار پیش‌فرض را بازگردانید. با ادامه مثال ما از سکه‌ها با مقدار <code>UsState</code>، اگر می‌خواستیم چیزی خنده‌دار بگوییم که بسته به سن ایالت بر روی سکه بود، ممکن است متدی برای بررسی سن ایالت ایجاد کنیم، مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // -- snip --
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("{state:?} is pretty old, for America!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("{state:?} is relatively new."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>سپس ممکن است از <code>if let</code> برای مطابقت با نوع سکه استفاده کنیم، متغیری به نام <code>state</code> را در بدنه شرط معرفی کنیم، همان‌طور که در لیستینگ 6-7 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} is pretty old, for America!"))
        } else {
            Some(format!("{state:?} is relatively new."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 6-7: استفاده از <code>if let</code> برای تولید یک مقدار یا بازگشت زودهنگام.</figcaption>
</figure>
<p>این کار انجام می‌شود، اما کار را به داخل بدنه دستور <code>if let</code> منتقل می‌کند، و اگر کار انجام‌شده پیچیده‌تر باشد، ممکن است دشوار باشد که دقیقاً چگونه شاخه‌های سطح بالا به هم مربوط هستند. ما همچنین می‌توانیم از این واقعیت استفاده کنیم که عبارات یک مقدار تولید می‌کنند، یا برای تولید <code>state</code> از <code>if let</code> یا برای بازگشت زودهنگام، همان‌طور که در لیستینگ 6-8 نشان داده شده است. (شما می‌توانید مشابه آن را با یک <code>match</code> نیز انجام دهید!)</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 6-8: استفاده از <code>if let</code> برای تولید یک مقدار یا بازگشت زودهنگام.</figcaption>
</figure>
<p>این تا حدی آزاردهنده است! یک شاخه <code>if let</code> یک مقدار تولید می‌کند و دیگری کاملاً از تابع بازمی‌گردد.</p>
<p>برای زیباتر کردن این الگوی رایج، Rust از <code>let</code>-<code>else</code> استفاده می‌کند. سینتکس <code>let</code>-<code>else</code> یک الگو در سمت چپ و یک عبارت در سمت راست می‌گیرد، بسیار شبیه به <code>if let</code>، اما شاخه <code>if</code> ندارد و فقط یک شاخه <code>else</code> دارد. اگر الگو تطابق داشته باشد، مقدار الگو را در دامنه خارجی بایند می‌کند. اگر الگو <em>تطابق نداشته باشد</em>، برنامه به شاخه <code>else</code> منتقل می‌شود که باید از تابع بازگردد.</p>
<p>در لیستینگ 6-9، می‌توانید ببینید که لیستینگ 6-8 چگونه با استفاده از <code>let else</code> به جای <code>if let</code> به نظر می‌رسد. توجه کنید که این روش “در مسیر خوشحال” در بدنه اصلی تابع باقی می‌ماند، بدون اینکه کنترل جریان برای دو شاخه به طور قابل توجهی متفاوت باشد همان‌طور که <code>if let</code> انجام داد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 6-9: استفاده از <code>let else</code> برای واضح‌تر کردن جریان درون تابع.</figcaption>
</figure>
<p>اگر در موقعیتی هستید که منطق برنامه شما برای استفاده از یک <code>match</code> بسیار پرحجم است، به یاد داشته باشید که <code>if let</code> و <code>let else</code> نیز در ابزارهای Rust شما موجود هستند.</p>
<h2 id="خلاصه-5"><a class="header" href="#خلاصه-5">خلاصه</a></h2>
<p>ما اکنون پوشش داده‌ایم که چگونه از enumها برای ایجاد انواع سفارشی که می‌توانند یکی از مجموعه مقادیر شمارش‌شده باشند استفاده کنید. ما نشان داده‌ایم که چگونه نوع <code>Option&lt;T&gt;</code> از کتابخانه استاندارد به شما کمک می‌کند از سیستم نوع برای جلوگیری از خطاها استفاده کنید. وقتی مقادیر enum داده‌هایی درون خود دارند، می‌توانید از <code>match</code> یا <code>if let</code> برای استخراج و استفاده از آن مقادیر استفاده کنید، بسته به تعداد مواردی که باید مدیریت کنید.</p>
<p>برنامه‌های Rust شما اکنون می‌توانند مفاهیمی را در حوزه خود بیان کنند و از ساختارها و enumها استفاده کنند. ایجاد انواع سفارشی برای استفاده در API شما ایمنی نوع را تضمین می‌کند: کامپایلر مطمئن می‌شود که توابع شما فقط مقادیری از نوعی که هر تابع انتظار دارد دریافت می‌کنند.</p>
<p>برای ارائه یک API سازمان‌یافته به کاربران خود که استفاده از آن ساده باشد و فقط دقیقاً آنچه کاربران شما نیاز دارند را آشکار کند، حالا به ماژول‌های Rust می‌پردازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مدیریت-پروژههای-بزرگ-با-بستهها-جعبهها-crates-و-ماژولها"><a class="header" href="#مدیریت-پروژههای-بزرگ-با-بستهها-جعبهها-crates-و-ماژولها">مدیریت پروژه‌های بزرگ با بسته‌ها، جعبه‌ها (crates) و ماژول‌ها</a></h1>
<p>با نوشتن برنامه‌های بزرگ‌تر، سازماندهی کد شما اهمیت بیشتری پیدا می‌کند. با گروه‌بندی قابلیت‌های مرتبط و جدا کردن کدی که ویژگی‌های متمایزی دارد، می‌توانید مشخص کنید که کد یک ویژگی خاص در کجا پیاده‌سازی شده و کجا می‌توان آن را تغییر داد.</p>
<p>برنامه‌هایی که تاکنون نوشته‌ایم در یک ماژول و یک فایل بوده‌اند. همان‌طور که پروژه رشد می‌کند، باید کد را با تقسیم آن به ماژول‌های مختلف و سپس فایل‌های مختلف سازماندهی کنید. یک بسته می‌تواند شامل چندین جعبه (crate) باینری و به صورت اختیاری یک جعبه (crate) کتابخانه باشد. همان‌طور که بسته رشد می‌کند، می‌توانید بخش‌هایی را به جعبه‌ها (crates)ی جداگانه‌ای که به عنوان وابستگی‌های خارجی عمل می‌کنند استخراج کنید. این فصل تمام این تکنیک‌ها را پوشش می‌دهد. برای پروژه‌های بسیار بزرگ که شامل مجموعه‌ای از بسته‌های مرتبط است که با یکدیگر تکامل می‌یابند، Cargo ویژگی‌هایی به نام <em>فضای کاری</em> ارائه می‌دهد که در بخش <a href="ch14-03-cargo-workspaces.html">«فضای کاری Cargo»</a> فصل ۱۴ به آن می‌پردازیم.</p>
<p>همچنین درباره جزئیات پیاده‌سازی که به شما امکان می‌دهد کد را در سطح بالاتری بازاستفاده کنید صحبت خواهیم کرد: وقتی یک عملیات را پیاده‌سازی کرده‌اید، سایر کدها می‌توانند از طریق رابط عمومی کد شما آن را فراخوانی کنند بدون این که لازم باشد بدانند چگونه پیاده‌سازی شده است. نحوه نوشتن کد شما مشخص می‌کند که کدام بخش‌ها برای سایر کدها عمومی و قابل استفاده هستند و کدام بخش‌ها جزئیات پیاده‌سازی خصوصی هستند که می‌توانید هر زمان بخواهید تغییر دهید. این رویکرد یکی دیگر از روش‌هایی است که مقدار جزئیاتی که باید به خاطر بسپارید را محدود می‌کند.</p>
<p>یک مفهوم مرتبط، محدوده (scope) است: زمینه‌ای که در آن کد نوشته شده است و مجموعه‌ای از نام‌ها که به عنوان «در محدوده» تعریف می‌شوند. هنگام خواندن، نوشتن و کامپایل کد، برنامه‌نویسان و کامپایلرها باید بدانند که آیا یک نام خاص در یک مکان خاص به متغیر، تابع، ساختار، enum، ماژول، ثابت یا مورد دیگری اشاره دارد و معنای آن مورد چیست. شما می‌توانید محدوده‌ها ایجاد کنید و مشخص کنید که کدام نام‌ها در محدوده هستند یا خارج از آن. نمی‌توانید دو مورد با نام یکسان در یک محدوده داشته باشید؛ ابزارهایی برای رفع تعارض نام‌ها در دسترس هستند.</p>
<p>Rust مجموعه‌ای از ویژگی‌ها دارد که به شما امکان می‌دهد سازماندهی کد خود را مدیریت کنید، از جمله جزئیاتی که آشکار می‌شوند، جزئیاتی که خصوصی هستند، و نام‌هایی که در هر محدوده در برنامه‌های شما قرار دارند. این ویژگی‌ها که گاهی به صورت جمعی <em>سیستم ماژول</em> نامیده می‌شوند شامل موارد زیر هستند:</p>
<ul>
<li><strong>بسته‌ها:</strong> ویژگی‌ای در Cargo که به شما امکان ساخت، تست و اشتراک‌گذاری جعبه‌ها (crates) را می‌دهد.</li>
<li><strong>جعبه‌ها (crates):</strong> درختی از ماژول‌ها که یک کتابخانه یا یک اجرایی تولید می‌کنند.</li>
<li><strong>ماژول‌ها</strong> و <strong>use:</strong> به شما اجازه می‌دهند سازماندهی، محدوده و حریم خصوصی مسیرها را کنترل کنید.</li>
<li><strong>مسیرها:</strong> راهی برای نام‌گذاری یک مورد مانند یک ساختار، تابع یا ماژول.</li>
</ul>
<p>در این فصل، تمام این ویژگی‌ها را پوشش خواهیم داد، نحوه تعامل آن‌ها را توضیح می‌دهیم و نحوه استفاده از آن‌ها برای مدیریت محدوده را بررسی می‌کنیم. تا پایان، باید درک جامعی از سیستم ماژول داشته باشید و بتوانید با محدوده‌ها مانند یک حرفه‌ای کار کنید!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="بستهها-و-جعبهها-crates"><a class="header" href="#بستهها-و-جعبهها-crates">بسته‌ها و جعبه‌ها (crates)</a></h2>
<p>اولین بخش‌هایی که در سیستم ماژول بررسی خواهیم کرد، بسته‌ها و جعبه‌ها (crates) هستند.</p>
<p>یک <em>جعبه (crate)</em> کوچک‌ترین واحد کدی است که کامپایلر Rust در یک زمان در نظر می‌گیرد. حتی اگر به جای <code>cargo</code> از <code>rustc</code> استفاده کنید و یک فایل کد منبع را ارسال کنید (همان‌طور که در بخش «نوشتن و اجرای یک برنامه Rust» در فصل ۱ انجام دادیم)، کامپایلر آن فایل را به عنوان یک جعبه (crate) در نظر می‌گیرد. جعبه‌ها (crates) می‌توانند شامل ماژول‌ها باشند، و این ماژول‌ها ممکن است در فایل‌های دیگری تعریف شوند که همراه با جعبه (crate) کامپایل می‌شوند، همان‌طور که در بخش‌های آینده خواهیم دید.</p>
<p>یک جعبه (crate) می‌تواند به یکی از دو شکل باشد: جعبه (crate) باینری یا جعبه (crate) کتابخانه‌ای.
<em>جعبه‌ها (crates)ی باینری</em> برنامه‌هایی هستند که می‌توانید آن‌ها را به یک فایل اجرایی کامپایل کنید و اجرا کنید، مانند یک برنامه خط فرمان یا یک سرور. هر جعبه (crate) باینری باید یک تابع به نام <code>main</code> داشته باشد که مشخص کند وقتی فایل اجرایی اجرا می‌شود چه اتفاقی می‌افتد. تمامی جعبه‌ها (crates)یی که تاکنون ایجاد کرده‌ایم، جعبه‌ها (crates)ی باینری بوده‌اند.</p>
<p><em>جعبه‌ها (crates)ی کتابخانه‌ای</em> تابع <code>main</code> ندارند و به یک فایل اجرایی کامپایل نمی‌شوند. بلکه، آن‌ها عملکردهایی را تعریف می‌کنند که برای اشتراک‌گذاری میان چندین پروژه طراحی شده‌اند. به عنوان مثال، جعبه (crate) <code>rand</code> که در <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">فصل ۲</a> از آن استفاده کردیم، قابلیت تولید اعداد تصادفی را فراهم می‌کند. اغلب اوقات وقتی Rustaceanها می‌گویند “جعبه (crate)”، منظورشان جعبه (crate) کتابخانه‌ای است، و آن را به صورت متناوب با مفهوم عمومی برنامه‌نویسی “کتابخانه” استفاده می‌کنند.</p>
<p><em>ریشه جعبه (crate)</em> یک فایل منبع است که کامپایلر Rust از آن شروع می‌کند و ریشه ماژول جعبه (crate) را تشکیل می‌دهد (ماژول‌ها را در بخش <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">«تعریف ماژول‌ها برای کنترل محدوده و حریم خصوصی»</a> به طور کامل بررسی خواهیم کرد).</p>
<p>یک <em>بسته</em> مجموعه‌ای از یک یا چند جعبه (crate) است که مجموعه‌ای از عملکردها را فراهم می‌کند. یک بسته شامل یک فایل <em>Cargo.toml</em> است که توضیح می‌دهد چگونه باید این جعبه‌ها (crates) ساخته شوند. Cargo خود یک بسته است که شامل جعبه (crate) باینری ابزار خط فرمانی که از آن برای ساخت کدتان استفاده کرده‌اید می‌شود. بسته Cargo همچنین شامل یک جعبه (crate) کتابخانه‌ای است که جعبه (crate) باینری به آن وابسته است. پروژه‌های دیگر می‌توانند به جعبه (crate) کتابخانه‌ای Cargo وابسته شوند تا از همان منطقی که ابزار خط فرمان Cargo استفاده می‌کند بهره‌مند شوند. یک بسته می‌تواند شامل هر تعداد جعبه (crate) باینری باشد که می‌خواهید، اما در بیشترین حالت تنها یک جعبه (crate) کتابخانه‌ای می‌تواند داشته باشد. یک بسته باید حداقل یک جعبه (crate) شامل باشد، چه آن جعبه (crate) یک کتابخانه باشد یا یک جعبه (crate) باینری.</p>
<p>بیایید ببینیم وقتی یک بسته ایجاد می‌کنیم چه اتفاقی می‌افتد. ابتدا دستور <code>cargo new my-project</code> را وارد می‌کنیم:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>بعد از اجرای <code>cargo new my-project</code>، از دستور <code>ls</code> استفاده می‌کنیم تا ببینیم Cargo چه چیزی ایجاد کرده است. در دایرکتوری پروژه، یک فایل <em>Cargo.toml</em> وجود دارد که به ما یک بسته می‌دهد. همچنین یک دایرکتوری <em>src</em> وجود دارد که شامل فایل <em>main.rs</em> است. فایل <em>Cargo.toml</em> را در ویرایشگر متن خود باز کنید و توجه کنید که هیچ اشاره‌ای به <em>src/main.rs</em> نشده است. Cargo از یک قرارداد پیروی می‌کند که <em>src/main.rs</em> ریشه جعبه (crate) یک جعبه (crate) باینری با همان نام بسته است. به همین ترتیب، Cargo می‌داند که اگر دایرکتوری بسته شامل <em>src/lib.rs</em> باشد، بسته شامل یک جعبه (crate) کتابخانه‌ای با همان نام بسته است و <em>src/lib.rs</em> ریشه جعبه (crate) آن است. Cargo فایل‌های ریشه جعبه (crate) را به <code>rustc</code> ارسال می‌کند تا کتابخانه یا فایل اجرایی ساخته شود.</p>
<p>در اینجا، ما یک بسته داریم که تنها شامل <em>src/main.rs</em> است، به این معنی که تنها یک جعبه (crate) باینری به نام <code>my-project</code> دارد. اگر یک بسته شامل <em>src/main.rs</em> و <em>src/lib.rs</em> باشد، آن بسته دو جعبه (crate) خواهد داشت: یک جعبه (crate) باینری و یک کتابخانه، هر دو با همان نام بسته. یک بسته می‌تواند چندین جعبه (crate) باینری داشته باشد با قرار دادن فایل‌ها در دایرکتوری <em>src/bin</em>: هر فایل یک جعبه (crate) باینری جداگانه خواهد بود.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="تعریف-ماژولها-برای-کنترل-محدوده-و-حریم-خصوصی"><a class="header" href="#تعریف-ماژولها-برای-کنترل-محدوده-و-حریم-خصوصی">تعریف ماژول‌ها برای کنترل محدوده و حریم خصوصی</a></h2>
<p>در این بخش، ما درباره ماژول‌ها و سایر بخش‌های سیستم ماژول صحبت خواهیم کرد، یعنی <em>مسیرها</em> که به شما امکان می‌دهند آیتم‌ها را نام‌گذاری کنید؛ کلمه کلیدی <code>use</code> که مسیر را به محدوده وارد می‌کند؛ و کلمه کلیدی <code>pub</code> برای عمومی کردن آیتم‌ها. همچنین درباره کلمه کلیدی <code>as</code>، بسته‌های خارجی، و عملگر <code>glob</code> صحبت خواهیم کرد.</p>
<h3 id="خلاصهای-از-ماژولها"><a class="header" href="#خلاصهای-از-ماژولها">خلاصه‌ای از ماژول‌ها</a></h3>
<p>قبل از اینکه به جزئیات ماژول‌ها و مسیرها بپردازیم، اینجا یک مرجع سریع در مورد نحوه عملکرد ماژول‌ها، مسیرها، کلمه کلیدی <code>use</code> و کلمه کلیدی <code>pub</code> در کامپایلر ارائه می‌دهیم و همچنین نحوه سازماندهی کد توسط اکثر توسعه‌دهندگان را نشان می‌دهیم. ما در طول این فصل به مثال‌هایی از هر یک از این قواعد خواهیم پرداخت، اما این یک مکان عالی برای یادآوری نحوه عملکرد ماژول‌ها است.</p>
<ul>
<li><strong>شروع از ریشه جعبه (crate):</strong> هنگام کامپایل یک جعبه (crate)، کامپایلر ابتدا در فایل ریشه جعبه (crate) (معمولاً <em>src/lib.rs</em> برای یک جعبه (crate) کتابخانه‌ای یا <em>src/main.rs</em> برای یک جعبه (crate) باینری) به دنبال کد برای کامپایل می‌گردد.</li>
<li><strong>تعریف ماژول‌ها:</strong> در فایل ریشه جعبه (crate)، می‌توانید ماژول‌های جدید تعریف کنید؛ مثلاً می‌توانید یک ماژول “garden” با <code>mod garden;</code> تعریف کنید. کامپایلر کد ماژول را در مکان‌های زیر جستجو می‌کند:
<ul>
<li>به صورت درون‌خطی، داخل براکت‌های موج‌دار که به جای علامت نقطه‌ویرگول بعد از <code>mod garden</code> قرار می‌گیرند.</li>
<li>در فایل <em>src/garden.rs</em></li>
<li>در فایل <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>تعریف زیرماژول‌ها:</strong> در هر فایلی به جز فایل ریشه جعبه (crate)، می‌توانید زیرماژول‌ها تعریف کنید. برای مثال، ممکن است <code>mod vegetables;</code> را در فایل <em>src/garden.rs</em> تعریف کنید. کامپایلر کد زیرماژول را در دایرکتوری‌ای که به نام ماژول والد است، در مکان‌های زیر جستجو می‌کند:
<ul>
<li>به صورت درون‌خطی، مستقیماً بعد از <code>mod vegetables</code>، داخل براکت‌های موج‌دار به جای نقطه‌ویرگول</li>
<li>در فایل <em>src/garden/vegetables.rs</em></li>
<li>در فایل <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>مسیرها به کد در ماژول‌ها:</strong> وقتی یک ماژول بخشی از جعبه (crate) شما باشد، می‌توانید از هر جای دیگر در همان جعبه (crate) (تا زمانی که قواعد حریم خصوصی اجازه دهند) با استفاده از مسیر به کد آن ارجاع دهید. برای مثال، یک نوع <code>Asparagus</code> در ماژول vegetables در garden به این صورت پیدا می‌شود:
<code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>خصوصی در مقابل عمومی:</strong> کد درون یک ماژول به صورت پیش‌فرض برای ماژول‌های والد خصوصی است. برای عمومی کردن یک ماژول، آن را با <code>pub mod</code> به جای <code>mod</code> تعریف کنید. برای عمومی کردن آیتم‌های داخل یک ماژول عمومی، از <code>pub</code> قبل از اعلان آن‌ها استفاده کنید.</li>
<li><strong>کلمه کلیدی <code>use</code>:</strong> در یک محدوده، کلمه کلیدی <code>use</code> میانبری به آیتم‌ها ایجاد می‌کند تا تکرار مسیرهای طولانی کاهش یابد. در هر محدوده‌ای که می‌تواند به <code>crate::garden::vegetables::Asparagus</code> ارجاع دهد، می‌توانید یک میانبر با <code>use crate::garden::vegetables::Asparagus;</code> ایجاد کنید و از آن به بعد فقط کافی است <code>Asparagus</code> را در آن محدوده استفاده کنید.</li>
</ul>
<p>اینجا، ما یک جعبه (crate) باینری به نام <code>backyard</code> ایجاد می‌کنیم که این قواعد را نشان می‌دهد. دایرکتوری جعبه (crate) که آن هم <code>backyard</code> نامیده می‌شود شامل این فایل‌ها و دایرکتوری‌ها است:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>فایل ریشه جعبه (crate) در اینجا <em>src/main.rs</em> است و حاوی موارد زیر است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}</code></pre>
</figure>
<p>خط <code>pub mod garden;</code> به کامپایلر می‌گوید که کدی را که در <em>src/garden.rs</em> پیدا می‌کند وارد کند، که شامل موارد زیر است:</p>
<figure class="listing">
<span class="file-name">Filename: src/garden.rs</span>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
</figure>
<p>اینجا، <code>pub mod vegetables;</code> به این معنا است که کد موجود در <em>src/garden/vegetables.rs</em> نیز وارد می‌شود. آن کد به صورت زیر است:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>حالا بیایید به جزئیات این قواعد بپردازیم و آن‌ها را در عمل نشان دهیم!</p>
<h3 id="گروهبندی-کدهای-مرتبط-در-ماژولها"><a class="header" href="#گروهبندی-کدهای-مرتبط-در-ماژولها">گروه‌بندی کدهای مرتبط در ماژول‌ها</a></h3>
<p><em>ماژول‌ها</em> به ما امکان می‌دهند کد را در یک جعبه (crate) برای خوانایی و بازاستفاده آسان سازماندهی کنیم. ماژول‌ها همچنین به ما امکان کنترل <em>حریم خصوصی</em> آیتم‌ها را می‌دهند زیرا کد درون یک ماژول به صورت پیش‌فرض خصوصی است. آیتم‌های خصوصی جزئیات پیاده‌سازی داخلی هستند که برای استفاده خارجی در دسترس نیستند. ما می‌توانیم انتخاب کنیم که ماژول‌ها و آیتم‌های درون آن‌ها عمومی باشند، که این موارد را برای استفاده خارجی آشکار می‌کند.</p>
<p>برای مثال، بیایید یک جعبه (crate) کتابخانه‌ای بنویسیم که عملکرد یک رستوران را ارائه دهد. امضای توابع را تعریف می‌کنیم اما بدنه آن‌ها را خالی می‌گذاریم تا بیشتر بر سازماندهی کد تمرکز کنیم تا پیاده‌سازی عملکرد یک رستوران.</p>
<p>در صنعت رستوران، برخی قسمت‌های یک رستوران به عنوان <em>جلوی خانه</em> و دیگر قسمت‌ها به عنوان <em>پشت خانه</em> شناخته می‌شوند. جلوی خانه جایی است که مشتریان هستند؛ این شامل جایی است که میزبان‌ها مشتریان را می‌نشانند، گارسون‌ها سفارش می‌گیرند و پرداخت‌ها را انجام می‌دهند، و بارتندرها نوشیدنی درست می‌کنند. پشت خانه جایی است که سرآشپزها و آشپزها در آشپزخانه کار می‌کنند، ظرف‌شورها ظروف را تمیز می‌کنند، و مدیران کارهای اداری انجام می‌دهند.</p>
<p>برای ساختاردهی جعبه (crate) خود به این روش، می‌توانیم عملکردها را در ماژول‌های تو در تو سازماندهی کنیم. یک کتابخانه جدید به نام <code>restaurant</code> با اجرای دستور <code>cargo new restaurant --lib</code> ایجاد کنید. سپس کد لیستینگ 7-1 را در <em>src/lib.rs</em> وارد کنید تا برخی ماژول‌ها و امضای توابع تعریف شود. این کد بخش جلوی خانه را تعریف می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<figcaption>Listing 7-1: یک ماژول <code>front_of_house</code> که شامل ماژول‌های دیگر است که سپس شامل توابع می‌شوند</figcaption>
</figure>
<p>ما یک ماژول با کلمه کلیدی <code>mod</code> و سپس نام ماژول تعریف می‌کنیم (در این مورد، <code>front_of_house</code>). بدنه ماژول سپس داخل براکت‌های موج‌دار قرار می‌گیرد. داخل ماژول‌ها، می‌توانیم ماژول‌های دیگری قرار دهیم، همان‌طور که در اینجا با ماژول‌های <code>hosting</code> و <code>serving</code> انجام داده‌ایم. ماژول‌ها همچنین می‌توانند تعاریف آیتم‌های دیگر را نگه دارند، مانند ساختارها، enumها، ثابت‌ها، traits و—همان‌طور که در لیستینگ 7-1 دیده می‌شود—توابع.</p>
<p>با استفاده از ماژول‌ها، می‌توانیم تعاریف مرتبط را با هم گروه‌بندی کنیم و دلیل ارتباط آن‌ها را نام‌گذاری کنیم. برنامه‌نویسانی که از این کد استفاده می‌کنند می‌توانند بر اساس گروه‌ها کد را مرور کنند، به جای اینکه مجبور باشند تمام تعاریف را بخوانند. این کار پیدا کردن تعاریف مرتبط با آن‌ها را آسان‌تر می‌کند. برنامه‌نویسانی که عملکرد جدیدی به این کد اضافه می‌کنند می‌دانند که کد را کجا قرار دهند تا برنامه سازماندهی شده باقی بماند.</p>
<h3 id="درخت-ماژول"><a class="header" href="#درخت-ماژول">درخت ماژول</a></h3>
<p>قبلاً اشاره کردیم که <em>src/main.rs</em> و <em>src/lib.rs</em> به نام ریشه جعبه (crate) شناخته می‌شوند. دلیل نام‌گذاری آن‌ها این است که محتوای هر یک از این دو فایل یک ماژول به نام <code>crate</code> را در ریشه ساختار ماژول جعبه (crate) تشکیل می‌دهند، که به عنوان <em>درخت ماژول</em> شناخته می‌شود.</p>
<p>لیستینگ 7-2 درخت ماژول را برای ساختار موجود در لیستینگ 7-1 نشان می‌دهد.</p>
<figure class="listing">
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<figcaption>Listing 7-2: درخت ماژول برای کد موجود در لیستینگ 7-1</figcaption>
</figure>
<p>این درخت نشان می‌دهد که برخی از ماژول‌ها در داخل ماژول‌های دیگر قرار دارند؛ برای مثال، <code>hosting</code> در داخل <code>front_of_house</code> قرار دارد. درخت همچنین نشان می‌دهد که برخی از ماژول‌ها <em>هم‌سطح</em> هستند، به این معنی که در همان ماژول تعریف شده‌اند؛ <code>hosting</code> و <code>serving</code> هم‌سطح هستند و درون <code>front_of_house</code> تعریف شده‌اند. اگر ماژول A درون ماژول B قرار گیرد، می‌گوییم ماژول A <em>فرزند</em> ماژول B است و ماژول B <em>والد</em> ماژول A است. توجه کنید که کل درخت ماژول در زیر ماژول ضمنی به نام <code>crate</code> ریشه دارد.</p>
<p>درخت ماژول ممکن است شما را به یاد درخت دایرکتوری‌های فایل‌سیستم کامپیوتر بیندازد؛ این مقایسه بسیار مناسبی است! درست همان‌طور که دایرکتوری‌ها در فایل‌سیستم کد را سازماندهی می‌کنند، شما می‌توانید از ماژول‌ها برای سازماندهی کد خود استفاده کنید. و درست مانند فایل‌ها در یک دایرکتوری، ما نیاز به روشی برای پیدا کردن ماژول‌ها داریم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="مسیرها-برای-اشاره-به-یک-آیتم-در-درخت-ماژول"><a class="header" href="#مسیرها-برای-اشاره-به-یک-آیتم-در-درخت-ماژول">مسیرها برای اشاره به یک آیتم در درخت ماژول</a></h2>
<p>برای نشان دادن به Rust که یک آیتم را در درخت ماژول کجا پیدا کند، از یک مسیر استفاده می‌کنیم، مشابه استفاده از مسیر هنگام پیمایش در یک فایل‌سیستم. برای فراخوانی یک تابع، باید مسیر آن را بدانیم.</p>
<p>یک مسیر می‌تواند به دو شکل باشد:</p>
<ul>
<li>یک <em>مسیر مطلق</em> مسیری کامل است که از ریشه جعبه (crate) شروع می‌شود؛ برای کدی که از یک جعبه (crate) خارجی می‌آید، مسیر مطلق با نام جعبه (crate) شروع می‌شود، و برای کدی که از جعبه (crate) فعلی می‌آید، با کلمه کلیدی <code>crate</code> شروع می‌شود.</li>
<li>یک <em>مسیر نسبی</em> از ماژول فعلی شروع می‌شود و از <code>self</code>، <code>super</code> یا یک شناسه در ماژول فعلی استفاده می‌کند.</li>
</ul>
<p>هر دو مسیر مطلق و نسبی با یک یا چند شناسه که با دو نقطه دوبل (<code>::</code>) جدا شده‌اند دنبال می‌شوند.</p>
<p>با بازگشت به لیستینگ 7-1، فرض کنید که می‌خواهیم تابع <code>add_to_waitlist</code> را فراخوانی کنیم. این کار مشابه پرسیدن این است: مسیر تابع <code>add_to_waitlist</code> چیست؟ لیستینگ 7-3 شامل لیستینگ 7-1 با حذف برخی از ماژول‌ها و توابع است.</p>
<p>ما دو روش برای فراخوانی تابع <code>add_to_waitlist</code> از یک تابع جدید، <code>eat_at_restaurant</code>، که در ریشه جعبه (crate) تعریف شده است، نشان خواهیم داد. این مسیرها درست هستند، اما یک مشکل دیگر وجود دارد که مانع کامپایل این مثال به شکل فعلی می‌شود. بعداً توضیح خواهیم داد که چرا.</p>
<p>تابع <code>eat_at_restaurant</code> بخشی از API عمومی جعبه (crate) کتابخانه‌ای ما است، بنابراین آن را با کلمه کلیدی <code>pub</code> علامت می‌زنیم. در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">«آشکار کردن مسیرها با کلمه کلیدی <code>pub</code>»</a>، به جزئیات بیشتری درباره <code>pub</code> خواهیم پرداخت.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-3: فراخوانی تابع <code>add_to_waitlist</code> با استفاده از مسیرهای مطلق و نسبی</figcaption>
</figure>
<p>بار اولی که تابع <code>add_to_waitlist</code> را در <code>eat_at_restaurant</code> فراخوانی می‌کنیم، از یک مسیر مطلق استفاده می‌کنیم. تابع <code>add_to_waitlist</code> در همان جعبه (crate) تعریف شده است که <code>eat_at_restaurant</code> در آن قرار دارد، که به این معنی است که می‌توانیم از کلمه کلیدی <code>crate</code> برای شروع مسیر مطلق استفاده کنیم. سپس هر یک از ماژول‌های متوالی را شامل می‌کنیم تا به <code>add_to_waitlist</code> برسیم. می‌توانید یک فایل‌سیستم با ساختار مشابه تصور کنید: ما مسیر <code>/front_of_house/hosting/add_to_waitlist</code> را برای اجرای برنامه <code>add_to_waitlist</code> مشخص می‌کنیم؛ استفاده از نام <code>crate</code> برای شروع از ریشه جعبه (crate) مانند استفاده از <code>/</code> برای شروع از ریشه فایل‌سیستم در شل است.</p>
<p>بار دوم که تابع <code>add_to_waitlist</code> را در <code>eat_at_restaurant</code> فراخوانی می‌کنیم، از یک مسیر نسبی استفاده می‌کنیم. مسیر با <code>front_of_house</code> شروع می‌شود، که نام ماژولی است که در همان سطح از درخت ماژول به عنوان <code>eat_at_restaurant</code> تعریف شده است. اینجا معادل فایل‌سیستم استفاده از مسیر <code>front_of_house/hosting/add_to_waitlist</code> است. شروع با نام ماژول به این معنی است که مسیر نسبی است.</p>
<h3 id="انتخاب-بین-مسیرهای-مطلق-و-نسبی"><a class="header" href="#انتخاب-بین-مسیرهای-مطلق-و-نسبی">انتخاب بین مسیرهای مطلق و نسبی</a></h3>
<p>انتخاب بین استفاده از مسیر نسبی یا مطلق یک تصمیم است که بر اساس پروژه شما گرفته می‌شود، و به این بستگی دارد که آیا احتمال بیشتری دارد کد تعریف آیتم را به طور مستقل از یا همراه با کدی که از آیتم استفاده می‌کند جابجا کنید. برای مثال، اگر ماژول <code>front_of_house</code> و تابع <code>eat_at_restaurant</code> را به یک ماژول به نام <code>customer_experience</code> منتقل کنیم، باید مسیر مطلق به <code>add_to_waitlist</code> را به‌روزرسانی کنیم، اما مسیر نسبی همچنان معتبر خواهد بود. با این حال، اگر تابع <code>eat_at_restaurant</code> را به طور مستقل به یک ماژول به نام <code>dining</code> منتقل کنیم، مسیر مطلق به فراخوانی <code>add_to_waitlist</code> تغییر نمی‌کند، اما مسیر نسبی باید به‌روزرسانی شود. ترجیح ما به طور کلی این است که مسیرهای مطلق را مشخص کنیم زیرا احتمال بیشتری دارد که بخواهیم تعریف کد و فراخوانی آیتم‌ها را مستقل از یکدیگر جابجا کنیم.</p>
<p>بیایید سعی کنیم کد لیستینگ 7-3 را کامپایل کنیم و ببینیم چرا هنوز کامپایل نمی‌شود! خطاهایی که دریافت می‌کنیم در لیستینگ 7-4 نشان داده شده‌اند.</p>
<figure class="listing">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption>Listing 7-4: خطاهای کامپایلر هنگام ساخت کد در لیستینگ 7-3</figcaption>
</figure>
<p>پیام‌های خطا می‌گویند که ماژول <code>hosting</code> خصوصی است. به عبارت دیگر، ما مسیرهای صحیح برای ماژول <code>hosting</code> و تابع <code>add_to_waitlist</code> داریم، اما Rust به ما اجازه نمی‌دهد از آن‌ها استفاده کنیم زیرا به بخش‌های خصوصی دسترسی ندارد. در Rust، تمام آیتم‌ها (توابع، متدها، ساختارها، enumها، ماژول‌ها و ثابت‌ها) به صورت پیش‌فرض برای ماژول‌های والد خصوصی هستند. اگر بخواهید آیتمی مانند یک تابع یا ساختار را خصوصی کنید، آن را در یک ماژول قرار می‌دهید.</p>
<p>آیتم‌های موجود در یک ماژول والد نمی‌توانند از آیتم‌های خصوصی درون ماژول‌های فرزند استفاده کنند، اما آیتم‌های درون ماژول‌های فرزند می‌توانند از آیتم‌های ماژول‌های اجداد خود استفاده کنند. این به این دلیل است که ماژول‌های فرزند جزئیات پیاده‌سازی خود را بسته‌بندی و پنهان می‌کنند، اما ماژول‌های فرزند می‌توانند زمینه‌ای که در آن تعریف شده‌اند را ببینند. برای ادامه مثال، قواعد حریم خصوصی را مانند دفتر پشتی یک رستوران تصور کنید: آنچه در آنجا می‌گذرد برای مشتریان رستوران خصوصی است، اما مدیران دفتر می‌توانند همه چیز را در رستوران ببینند و انجام دهند.</p>
<p>Rust تصمیم گرفته است که سیستم ماژول به این صورت کار کند تا پنهان کردن جزئیات پیاده‌سازی داخلی به صورت پیش‌فرض باشد. به این ترتیب، می‌دانید کدام بخش‌های کد داخلی را می‌توانید تغییر دهید بدون اینکه کد بیرونی را خراب کنید. با این حال، Rust به شما این امکان را می‌دهد که بخش‌های داخلی کد ماژول‌های فرزند را به ماژول‌های اجداد بیرونی با استفاده از کلمه کلیدی <code>pub</code> عمومی کنید.</p>
<h3 id="آشکار-کردن-مسیرها-با-کلمه-کلیدی-pub"><a class="header" href="#آشکار-کردن-مسیرها-با-کلمه-کلیدی-pub">آشکار کردن مسیرها با کلمه کلیدی <code>pub</code></a></h3>
<p>بیایید به خطای لیستینگ 7-4 برگردیم که به ما گفت ماژول <code>hosting</code> خصوصی است. ما می‌خواهیم تابع <code>eat_at_restaurant</code> در ماژول والد به تابع <code>add_to_waitlist</code> در ماژول فرزند دسترسی داشته باشد، بنابراین ماژول <code>hosting</code> را با کلمه کلیدی <code>pub</code> علامت می‌زنیم، همان‌طور که در لیستینگ 7-5 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-5: اعلان ماژول <code>hosting</code> به عنوان <code>pub</code> برای استفاده از آن در <code>eat_at_restaurant</code></figcaption>
</figure>
<p>متأسفانه، کد در لیستینگ 7-5 همچنان به خطاهای کامپایلر منجر می‌شود، همان‌طور که در لیستینگ 7-6 نشان داده شده است.</p>
<figure class="listing">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption>Listing 7-6: خطاهای کامپایلر هنگام ساخت کد در لیستینگ 7-5</figcaption>
</figure>
<p>چه اتفاقی افتاد؟ اضافه کردن کلمه کلیدی <code>pub</code> در جلوی <code>mod hosting</code> ماژول را عمومی می‌کند. با این تغییر، اگر به <code>front_of_house</code> دسترسی داشته باشیم، می‌توانیم به <code>hosting</code> نیز دسترسی داشته باشیم. اما <em>محتویات</em> <code>hosting</code> همچنان خصوصی است؛ عمومی کردن ماژول به معنای عمومی کردن محتوای آن نیست. کلمه کلیدی <code>pub</code> روی یک ماژول فقط به کدهای موجود در ماژول‌های اجداد اجازه می‌دهد به آن ارجاع دهند، نه اینکه به کد داخلی آن دسترسی داشته باشند. از آنجایی که ماژول‌ها به عنوان ظرف عمل می‌کنند، تنها عمومی کردن ماژول کافی نیست؛ باید فراتر رفته و یک یا چند مورد از آیتم‌های درون ماژول را نیز عمومی کنیم.</p>
<p>خطاهای موجود در لیستینگ 7-6 نشان می‌دهند که تابع <code>add_to_waitlist</code> خصوصی است. قواعد حریم خصوصی برای ساختارها، enumها، توابع، متدها و همچنین ماژول‌ها اعمال می‌شوند.</p>
<p>بیایید تابع <code>add_to_waitlist</code> را نیز با اضافه کردن کلمه کلیدی <code>pub</code> قبل از تعریف آن عمومی کنیم، همان‌طور که در لیستینگ 7-7 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-7: اضافه کردن کلمه کلیدی <code>pub</code> به <code>mod hosting</code> و <code>fn add_to_waitlist</code> به ما اجازه می‌دهد تابع را از <code>eat_at_restaurant</code> فراخوانی کنیم</figcaption>
</figure>
<p>حالا کد کامپایل می‌شود! برای اینکه ببینیم چرا اضافه کردن کلمه کلیدی <code>pub</code> به ما اجازه می‌دهد از این مسیرها در <code>eat_at_restaurant</code> استفاده کنیم، بیایید به مسیرهای مطلق و نسبی نگاه کنیم.</p>
<p>در مسیر مطلق، با <code>crate</code>، ریشه درخت ماژول جعبه (crate) خود شروع می‌کنیم. ماژول <code>front_of_house</code> در ریشه جعبه (crate) تعریف شده است. اگرچه <code>front_of_house</code> عمومی نیست، از آنجا که تابع <code>eat_at_restaurant</code> در همان ماژول به عنوان <code>front_of_house</code> تعریف شده است (یعنی <code>eat_at_restaurant</code> و <code>front_of_house</code> هم‌سطح هستند)، می‌توانیم از <code>eat_at_restaurant</code> به <code>front_of_house</code> ارجاع دهیم. بعد، ماژول <code>hosting</code> که با <code>pub</code> علامت‌گذاری شده است قرار دارد. ما می‌توانیم به ماژول والد <code>hosting</code> دسترسی داشته باشیم، بنابراین می‌توانیم به <code>hosting</code> دسترسی داشته باشیم. در نهایت، تابع <code>add_to_waitlist</code> با <code>pub</code> علامت‌گذاری شده است و می‌توانیم به ماژول والد آن دسترسی داشته باشیم، بنابراین این فراخوانی تابع کار می‌کند!</p>
<p>در مسیر نسبی، منطق همان مسیر مطلق است با این تفاوت که مرحله اول متفاوت است: به جای شروع از ریشه جعبه (crate)، مسیر از <code>front_of_house</code> شروع می‌شود. ماژول <code>front_of_house</code> در همان ماژولی که <code>eat_at_restaurant</code> تعریف شده است قرار دارد، بنابراین مسیر نسبی که از ماژولی که <code>eat_at_restaurant</code> در آن تعریف شده است شروع می‌شود کار می‌کند. سپس، از آنجا که <code>hosting</code> و <code>add_to_waitlist</code> با <code>pub</code> علامت‌گذاری شده‌اند، بقیه مسیر کار می‌کند و این فراخوانی تابع معتبر است!</p>
<p>اگر قصد دارید جعبه (crate) کتابخانه خود را به اشتراک بگذارید تا پروژه‌های دیگر بتوانند از کد شما استفاده کنند، API عمومی شما قرارداد شما با کاربران جعبه (crate) است که تعیین می‌کند چگونه می‌توانند با کد شما تعامل داشته باشند. نکات زیادی در مورد مدیریت تغییرات API عمومی شما وجود دارد که به افراد کمک می‌کند به جعبه (crate) شما وابسته باشند. این ملاحظات خارج از دامنه این کتاب هستند؛ اگر به این موضوع علاقه‌مند هستید، به <a href="https://rust-lang.github.io/api-guidelines/">راهنمای API Rust</a> مراجعه کنید.</p>
<section class="note" aria-role="note">
<h4 id="بهترین-شیوهها-برای-بستههایی-که-یک-جعبه-crate-باینری-و-یک-جعبه-crate-کتابخانهای-دارند"><a class="header" href="#بهترین-شیوهها-برای-بستههایی-که-یک-جعبه-crate-باینری-و-یک-جعبه-crate-کتابخانهای-دارند">بهترین شیوه‌ها برای بسته‌هایی که یک جعبه (crate) باینری و یک جعبه (crate) کتابخانه‌ای دارند</a></h4>
<p>ما اشاره کردیم که یک بسته می‌تواند هم یک ریشه جعبه (crate) باینری در <em>src/main.rs</em> و هم یک ریشه جعبه (crate) کتابخانه‌ای در <em>src/lib.rs</em> داشته باشد، و هر دو جعبه (crate) به صورت پیش‌فرض نام بسته را خواهند داشت. معمولاً بسته‌هایی که این الگو را دنبال می‌کنند فقط به اندازه کافی کد در جعبه (crate) باینری دارند تا یک فایل اجرایی ایجاد کنند که کدی درون جعبه (crate) کتابخانه‌ای را فراخوانی کند. این کار به پروژه‌های دیگر اجازه می‌دهد از بیشتر عملکردهایی که بسته ارائه می‌دهد بهره‌مند شوند، زیرا کد جعبه (crate) کتابخانه‌ای می‌تواند به اشتراک گذاشته شود.</p>
<p>درخت ماژول باید در <em>src/lib.rs</em> تعریف شود. سپس، هر آیتم عمومی را می‌توان در جعبه (crate) باینری با شروع مسیرها با نام بسته استفاده کرد. جعبه (crate) باینری به یک کاربر از جعبه (crate) کتابخانه‌ای تبدیل می‌شود، درست مثل اینکه یک جعبه (crate) کاملاً خارجی از جعبه (crate) کتابخانه‌ای استفاده می‌کند: تنها می‌تواند از API عمومی استفاده کند. این کار به شما کمک می‌کند یک API خوب طراحی کنید؛ نه تنها نویسنده آن هستید، بلکه یک کاربر نیز هستید!</p>
<p>در <a href="ch12-00-an-io-project.html">فصل ۱۲</a>، ما این شیوه سازمان‌دهی را با یک برنامه خط فرمان که هم یک جعبه (crate) باینری و هم یک جعبه (crate) کتابخانه‌ای دارد نشان خواهیم داد.</p>
</section>
<h3 id="شروع-مسیرهای-نسبی-با-super"><a class="header" href="#شروع-مسیرهای-نسبی-با-super">شروع مسیرهای نسبی با <code>super</code></a></h3>
<p>ما می‌توانیم مسیرهای نسبی‌ای بسازیم که از ماژول والد شروع شوند، نه از ماژول فعلی یا ریشه جعبه (crate)، با استفاده از <code>super</code> در ابتدای مسیر. این مشابه شروع مسیر در فایل‌سیستم با سینتکس <code>..</code> است. استفاده از <code>super</code> به ما امکان می‌دهد به آیتمی که می‌دانیم در ماژول والد قرار دارد ارجاع دهیم، که می‌تواند جابجایی درخت ماژول را آسان‌تر کند، به خصوص زمانی که ماژول به ماژول والد مرتبط است اما ممکن است روزی والد به جای دیگری در درخت ماژول منتقل شود.</p>
<p>کد موجود در لیستینگ 7-8 را در نظر بگیرید که موقعیتی را مدل‌سازی می‌کند که در آن یک آشپز سفارش نادرست را اصلاح کرده و شخصاً آن را به مشتری می‌آورد. تابع <code>fix_incorrect_order</code> که در ماژول <code>back_of_house</code> تعریف شده است، تابع <code>deliver_order</code> را که در ماژول والد تعریف شده است، فراخوانی می‌کند و مسیر <code>deliver_order</code> را با شروع از <code>super</code> مشخص می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<figcaption>Listing 7-8: فراخوانی یک تابع با استفاده از یک مسیر نسبی که با <code>super</code> شروع می‌شود</figcaption>
</figure>
<p>تابع <code>fix_incorrect_order</code> در ماژول <code>back_of_house</code> است، بنابراین می‌توانیم از <code>super</code> برای رفتن به ماژول والد <code>back_of_house</code> استفاده کنیم، که در این مورد <code>crate</code>، یعنی ریشه است. از آنجا به دنبال <code>deliver_order</code> می‌گردیم و آن را پیدا می‌کنیم. موفقیت! ما فکر می‌کنیم که ماژول <code>back_of_house</code> و تابع <code>deliver_order</code> احتمالاً در همان رابطه با یکدیگر باقی می‌مانند و اگر بخواهیم درخت ماژول جعبه (crate) را سازماندهی مجدد کنیم، با هم جابجا می‌شوند. بنابراین، از <code>super</code> استفاده کردیم تا در آینده، اگر این کد به ماژول دیگری منتقل شد، تغییرات کمتری در کد لازم باشد.</p>
<h3 id="عمومی-کردن-ساختارها-و-enumها"><a class="header" href="#عمومی-کردن-ساختارها-و-enumها">عمومی کردن ساختارها و enumها</a></h3>
<p>ما همچنین می‌توانیم از <code>pub</code> برای مشخص کردن ساختارها و enumها به عنوان عمومی استفاده کنیم، اما چند جزئیات اضافی در مورد استفاده از <code>pub</code> با ساختارها و enumها وجود دارد. اگر از <code>pub</code> قبل از تعریف یک ساختار استفاده کنیم، ساختار عمومی می‌شود، اما فیلدهای ساختار همچنان خصوصی خواهند بود. ما می‌توانیم هر فیلد را به صورت موردی عمومی یا خصوصی کنیم. در لیستینگ 7-9، یک ساختار عمومی به نام <code>back_of_house::Breakfast</code> تعریف کرده‌ایم که یک فیلد عمومی به نام <code>toast</code> دارد اما فیلد <code>seasonal_fruit</code> خصوصی است. این مدل‌سازی حالتی است که در آن مشتری می‌تواند نوع نان همراه با وعده غذایی را انتخاب کند، اما سرآشپز تصمیم می‌گیرد که کدام میوه همراه وعده غذایی باشد بر اساس آنچه در فصل و موجودی است. میوه‌های موجود به سرعت تغییر می‌کنند، بنابراین مشتریان نمی‌توانند میوه را انتخاب کنند یا حتی ببینند که چه میوه‌ای دریافت خواهند کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<figcaption>Listing 7-9: یک ساختار با برخی فیلدهای عمومی و برخی خصوصی</figcaption>
</figure>
<p>از آنجا که فیلد <code>toast</code> در ساختار <code>back_of_house::Breakfast</code> عمومی است، می‌توانیم در <code>eat_at_restaurant</code> به این فیلد با استفاده از نقطه‌گذاری مقدار بدهیم یا مقدار آن را بخوانیم. توجه کنید که نمی‌توانیم از فیلد <code>seasonal_fruit</code> در <code>eat_at_restaurant</code> استفاده کنیم، زیرا <code>seasonal_fruit</code> خصوصی است. خطی که مقدار فیلد <code>seasonal_fruit</code> را تغییر می‌دهد را لغو کامنت کنید تا ببینید چه خطایی دریافت می‌کنید!</p>
<p>همچنین توجه کنید که چون <code>back_of_house::Breakfast</code> یک فیلد خصوصی دارد، ساختار باید یک تابع وابسته عمومی ارائه دهد که یک نمونه از <code>Breakfast</code> بسازد (ما آن را اینجا <code>summer</code> نامیده‌ایم). اگر <code>Breakfast</code> چنین تابعی نداشت، نمی‌توانستیم یک نمونه از <code>Breakfast</code> را در <code>eat_at_restaurant</code> ایجاد کنیم، زیرا نمی‌توانستیم مقدار فیلد خصوصی <code>seasonal_fruit</code> را در <code>eat_at_restaurant</code> تنظیم کنیم.</p>
<p>در مقابل، اگر یک enum را عمومی کنیم، تمام متغیرهای آن نیز عمومی می‌شوند. ما فقط به <code>pub</code> قبل از کلمه کلیدی <code>enum</code> نیاز داریم، همان‌طور که در لیستینگ 7-10 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<figcaption>Listing 7-10: عمومی کردن یک enum تمام متغیرهای آن را عمومی می‌کند</figcaption>
</figure>
<p>از آنجایی که enum <code>Appetizer</code> را عمومی کردیم، می‌توانیم از متغیرهای <code>Soup</code> و <code>Salad</code> در <code>eat_at_restaurant</code> استفاده کنیم.</p>
<p>Enums خیلی مفید نیستند مگر اینکه متغیرهای آن‌ها عمومی باشند؛ اضافه کردن <code>pub</code> به تمام متغیرهای enum در هر مورد کار خسته‌کننده‌ای خواهد بود، بنابراین به طور پیش‌فرض متغیرهای enum عمومی هستند. ساختارها اغلب بدون عمومی بودن فیلدهایشان مفید هستند، بنابراین فیلدهای ساختار از قانون کلی پیروی می‌کنند که همه چیز به صورت پیش‌فرض خصوصی است مگر اینکه با <code>pub</code> مشخص شود.</p>
<p>یک وضعیت دیگر مرتبط با <code>pub</code> وجود دارد که هنوز آن را پوشش نداده‌ایم، و آن آخرین ویژگی سیستم ماژول ما است: کلمه کلیدی <code>use</code>. ابتدا <code>use</code> را به تنهایی بررسی خواهیم کرد، و سپس نشان خواهیم داد چگونه <code>pub</code> و <code>use</code> را ترکیب کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="وارد-کردن-مسیرها-به-محدوده-با-کلمه-کلیدی-use"><a class="header" href="#وارد-کردن-مسیرها-به-محدوده-با-کلمه-کلیدی-use">وارد کردن مسیرها به محدوده با کلمه کلیدی <code>use</code></a></h2>
<p>نوشتن مسیرهای کامل برای فراخوانی توابع می‌تواند خسته‌کننده و تکراری باشد. در لیستینگ 7-7، چه مسیر مطلق یا نسبی را برای تابع <code>add_to_waitlist</code> انتخاب کنیم، هر بار که بخواهیم این تابع را فراخوانی کنیم باید <code>front_of_house</code> و <code>hosting</code> را نیز مشخص کنیم. خوشبختانه، راهی برای ساده‌تر کردن این فرآیند وجود دارد: می‌توانیم یک میانبر به یک مسیر با استفاده از کلمه کلیدی <code>use</code> ایجاد کنیم و سپس در هر جای دیگر محدوده، از نام کوتاه‌تر استفاده کنیم.</p>
<p>در لیستینگ 7-11، ماژول <code>crate::front_of_house::hosting</code> را به محدوده تابع <code>eat_at_restaurant</code> می‌آوریم تا فقط نیاز به مشخص کردن <code>hosting::add_to_waitlist</code> برای فراخوانی تابع <code>add_to_waitlist</code> در <code>eat_at_restaurant</code> داشته باشیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-11: وارد کردن یک ماژول به محدوده با <code>use</code></figcaption>
</figure>
<p>اضافه کردن <code>use</code> و یک مسیر در یک محدوده مشابه ایجاد یک لینک نمادین در فایل‌سیستم است. با اضافه کردن <code>use crate::front_of_house::hosting</code> در ریشه جعبه (crate)، <code>hosting</code> اکنون یک نام معتبر در آن محدوده است، درست مانند اینکه ماژول <code>hosting</code> در ریشه جعبه (crate) تعریف شده باشد. مسیرهایی که با <code>use</code> به محدوده آورده می‌شوند مانند هر مسیر دیگری حریم خصوصی را بررسی می‌کنند.</p>
<p>توجه کنید که <code>use</code> فقط میانبر را برای محدوده خاصی که در آن <code>use</code> استفاده شده ایجاد می‌کند. لیستینگ 7-12 تابع <code>eat_at_restaurant</code> را به یک زیرماژول جدید به نام <code>customer</code> منتقل می‌کند که سپس یک محدوده متفاوت از دستور <code>use</code> است، بنابراین بدنه تابع کامپایل نمی‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<figcaption>Listing 7-12: یک دستور <code>use</code> فقط در محدوده‌ای که در آن قرار دارد اعمال می‌شود</figcaption>
</figure>
<p>خطای کامپایلر نشان می‌دهد که میانبر دیگر در ماژول <code>customer</code> اعمال نمی‌شود:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>توجه کنید که همچنین یک هشدار وجود دارد که <code>use</code> دیگر در محدوده خود استفاده نمی‌شود! برای رفع این مشکل، دستور <code>use</code> را نیز به داخل ماژول <code>customer</code> منتقل کنید، یا میانبر را در ماژول والد با <code>super::hosting</code> در داخل ماژول <code>customer</code> ارجاع دهید.</p>
<h3 id="ایجاد-مسیرهای-use-به-صورت-ایدیوماتیک"><a class="header" href="#ایجاد-مسیرهای-use-به-صورت-ایدیوماتیک">ایجاد مسیرهای <code>use</code> به صورت ایدیوماتیک</a></h3>
<p>در لیستینگ 7-11، ممکن است این سوال پیش بیاید که چرا ما <code>use crate::front_of_house::hosting</code> را مشخص کرده‌ایم و سپس <code>hosting::add_to_waitlist</code> را در <code>eat_at_restaurant</code> فراخوانی کرده‌ایم، به جای اینکه مسیر <code>use</code> را تا تابع <code>add_to_waitlist</code> مشخص کنیم تا همان نتیجه را به دست آوریم، همان‌طور که در لیستینگ 7-13 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-13: وارد کردن تابع <code>add_to_waitlist</code> به محدوده با <code>use</code> که غیر ایدیوماتیک است</figcaption>
</figure>
<p>اگرچه هم لیستینگ 7-11 و هم لیستینگ 7-13 کار مشابهی انجام می‌دهند، لیستینگ 7-11 روش ایدیوماتیک برای وارد کردن یک تابع به محدوده با <code>use</code> است. وارد کردن ماژول والد تابع با <code>use</code> به این معنا است که باید ماژول والد را هنگام فراخوانی تابع مشخص کنیم. مشخص کردن ماژول والد هنگام فراخوانی تابع نشان می‌دهد که تابع به صورت محلی تعریف نشده است، در حالی که همچنان تکرار مسیر کامل را به حداقل می‌رساند. کد موجود در لیستینگ 7-13 مشخص نمی‌کند که <code>add_to_waitlist</code> کجا تعریف شده است.</p>
<p>از طرف دیگر، وقتی ساختارها، enumها، و سایر آیتم‌ها را با <code>use</code> وارد می‌کنیم، ایدیوماتیک است که مسیر کامل را مشخص کنیم. لیستینگ 7-14 روش ایدیوماتیک برای وارد کردن ساختار <code>HashMap</code> از کتابخانه استاندارد به محدوده جعبه (crate) باینری را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<figcaption>Listing 7-14: وارد کردن <code>HashMap</code> به محدوده به روش ایدیوماتیک</figcaption>
</figure>
<p>هیچ دلیل قوی پشت این عرف نیست: این فقط کنوانسیونی است که در جامعه Rust به وجود آمده و افراد به خواندن و نوشتن کد Rust به این روش عادت کرده‌اند.</p>
<p>استثنای این عرف زمانی است که دو آیتم با نام یکسان را با دستورات <code>use</code> وارد محدوده می‌کنیم، زیرا Rust این اجازه را نمی‌دهد. لیستینگ 7-15 نشان می‌دهد که چگونه دو نوع <code>Result</code> را که نام یکسانی دارند اما از ماژول‌های والد متفاوتی می‌آیند وارد محدوده کنیم و چگونه به آن‌ها ارجاع دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption>Listing 7-15: وارد کردن دو نوع با نام یکسان به یک محدوده نیازمند استفاده از ماژول‌های والد آن‌ها است.</figcaption>
</figure>
<p>همان‌طور که می‌بینید، استفاده از ماژول‌های والد دو نوع <code>Result</code> را از هم متمایز می‌کند. اگر به جای آن <code>use std::fmt::Result</code> و <code>use std::io::Result</code> مشخص کنیم، دو نوع <code>Result</code> در یک محدوده خواهیم داشت و Rust نمی‌تواند بفهمد منظور ما از <code>Result</code> کدام است.</p>
<h3 id="ارائه-نامهای-جدید-با-کلمه-کلیدی-as"><a class="header" href="#ارائه-نامهای-جدید-با-کلمه-کلیدی-as">ارائه نام‌های جدید با کلمه کلیدی <code>as</code></a></h3>
<p>یک راه‌حل دیگر برای مشکل وارد کردن دو نوع با نام یکسان به یک محدوده با <code>use</code> این است که پس از مسیر، با استفاده از <code>as</code> یک نام محلی جدید یا <em>نام مستعار</em> برای نوع مشخص کنیم. لیستینگ 7-16 راه دیگری برای نوشتن کد در لیستینگ 7-15 را نشان می‌دهد که در آن یکی از دو نوع <code>Result</code> را با استفاده از <code>as</code> تغییر نام داده‌ایم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption>Listing 7-16: تغییر نام یک نوع هنگام وارد کردن به محدوده با کلمه کلیدی <code>as</code></figcaption>
</figure>
<p>در دستور دوم <code>use</code>، ما نام جدید <code>IoResult</code> را برای نوع <code>std::io::Result</code> انتخاب کردیم، که با نوع <code>Result</code> از <code>std::fmt</code> که آن را نیز وارد محدوده کرده‌ایم، تضاد نخواهد داشت. هر دو لیستینگ 7-15 و 7-16 ایدیوماتیک در نظر گرفته می‌شوند، بنابراین انتخاب با شماست!</p>
<h3 id="دوباره-صادر-کردن-نامها-با-pub-use"><a class="header" href="#دوباره-صادر-کردن-نامها-با-pub-use">دوباره صادر کردن نام‌ها با <code>pub use</code></a></h3>
<p>وقتی با استفاده از کلمه کلیدی <code>use</code> یک نام را وارد محدوده می‌کنیم، نام وارد شده در محدوده جدید خصوصی است. برای این که کدی که کد ما را فراخوانی می‌کند بتواند به این نام به گونه‌ای ارجاع دهد که گویی در محدوده کد خود تعریف شده است، می‌توانیم <code>pub</code> و <code>use</code> را ترکیب کنیم. این تکنیک <em>دوباره صادر کردن</em> نامیده می‌شود زیرا ما یک آیتم را وارد محدوده می‌کنیم و همچنین آن را برای دیگران در دسترس قرار می‌دهیم تا وارد محدوده خودشان کنند.</p>
<p>لیستینگ 7-17 کد موجود در لیستینگ 7-11 را با تغییر دستور <code>use</code> در ماژول ریشه به <code>pub use</code> نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-17: در دسترس قرار دادن یک نام برای هر کدی که از محدوده جدید استفاده می‌کند با <code>pub use</code></figcaption>
</figure>
<p>قبل از این تغییر، کد خارجی باید تابع <code>add_to_waitlist</code> را با استفاده از مسیر <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> فراخوانی می‌کرد، که همچنین نیاز داشت ماژول <code>front_of_house</code> به عنوان <code>pub</code> علامت‌گذاری شود. حالا که این <code>pub use</code> ماژول <code>hosting</code> را از ماژول ریشه دوباره صادر کرده است، کد خارجی می‌تواند از مسیر <code>restaurant::hosting::add_to_waitlist()</code> استفاده کند.</p>
<p>دوباره صادر کردن زمانی مفید است که ساختار داخلی کد شما با نحوه فکر کردن برنامه‌نویسانی که کد شما را فراخوانی می‌کنند در مورد دامنه متفاوت باشد. برای مثال، در این استعاره از رستوران، افرادی که رستوران را مدیریت می‌کنند در مورد “جلوی خانه” و “پشت خانه” فکر می‌کنند. اما مشتریانی که به رستوران می‌آیند احتمالاً در این قالب به بخش‌های رستوران فکر نمی‌کنند. با استفاده از <code>pub use</code>، می‌توانیم کد خود را با یک ساختار بنویسیم اما یک ساختار متفاوت را آشکار کنیم. این کار کتابخانه ما را برای برنامه‌نویسانی که روی آن کار می‌کنند و همچنین برای برنامه‌نویسانی که از آن استفاده می‌کنند، خوب سازمان‌دهی می‌کند. در <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">بخش «صادرات یک API عمومی مناسب با <code>pub use</code>»</a> فصل ۱۴ به مثال دیگری از <code>pub use</code> و تأثیر آن بر مستندات جعبه (crate) شما خواهیم پرداخت.</p>
<h3 id="استفاده-از-بستههای-خارجی"><a class="header" href="#استفاده-از-بستههای-خارجی">استفاده از بسته‌های خارجی</a></h3>
<p>در فصل ۲، ما یک پروژه بازی حدس‌زنی برنامه‌ریزی کردیم که از یک بسته خارجی به نام <code>rand</code> برای تولید اعداد تصادفی استفاده می‌کرد. برای استفاده از <code>rand</code> در پروژه خود، این خط را به <em>Cargo.toml</em> اضافه کردیم:</p>
<figure class="listing">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</figure>
<p>اضافه کردن <code>rand</code> به عنوان یک وابستگی در <em>Cargo.toml</em> به Cargo می‌گوید که بسته <code>rand</code> و هرگونه وابستگی را از <a href="https://crates.io/">crates.io</a> دانلود کرده و <code>rand</code> را در پروژه ما در دسترس قرار دهد.</p>
<p>سپس، برای وارد کردن تعاریف <code>rand</code> به محدوده بسته خود، یک خط <code>use</code> اضافه کردیم که با نام جعبه (crate)، <code>rand</code> شروع می‌شد و آیتم‌هایی را که می‌خواستیم وارد محدوده کنیم فهرست کردیم. به یاد بیاورید که در <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">بخش «تولید یک عدد تصادفی»</a> فصل ۲، ما ویژگی <code>Rng</code> را به محدوده آوردیم و تابع <code>rand::thread_rng</code> را فراخوانی کردیم:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>اعضای جامعه Rust بسیاری از بسته‌ها را در <a href="https://crates.io/">crates.io</a> به اشتراک گذاشته‌اند، و وارد کردن هر یک از آن‌ها به بسته شما شامل این مراحل است: فهرست کردن آن‌ها در فایل <em>Cargo.toml</em> بسته شما و استفاده از <code>use</code> برای وارد کردن آیتم‌ها از جعبه (crate) آن‌ها به محدوده.</p>
<p>توجه داشته باشید که کتابخانه استاندارد <code>std</code> نیز یک جعبه (crate) خارجی برای بسته ما است. از آنجا که کتابخانه استاندارد همراه با زبان Rust ارائه می‌شود، نیازی به تغییر <em>Cargo.toml</em> برای گنجاندن <code>std</code> نداریم. اما برای وارد کردن آیتم‌ها از آن به محدوده بسته خود، باید به آن با <code>use</code> ارجاع دهیم. برای مثال، با <code>HashMap</code> از این خط استفاده می‌کردیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>این یک مسیر مطلق است که با <code>std</code>، نام جعبه (crate) کتابخانه استاندارد، شروع می‌شود.</p>
<h3 id="استفاده-از-مسیرهای-تو-در-تو-برای-سادهسازی-لیستهای-بزرگ-use"><a class="header" href="#استفاده-از-مسیرهای-تو-در-تو-برای-سادهسازی-لیستهای-بزرگ-use">استفاده از مسیرهای تو در تو برای ساده‌سازی لیست‌های بزرگ <code>use</code></a></h3>
<p>اگر از چندین آیتم تعریف‌شده در یک جعبه (crate) یا ماژول استفاده کنیم، فهرست کردن هر آیتم در خط خود می‌تواند فضای عمودی زیادی در فایل‌های ما اشغال کند. برای مثال، این دو دستور <code>use</code> که در بازی حدس‌زنی در لیستینگ ۲-۴ استفاده کردیم آیتم‌هایی از <code>std</code> را به محدوده می‌آورند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>در عوض، می‌توانیم از مسیرهای تو در تو استفاده کنیم تا همان آیتم‌ها را در یک خط به محدوده بیاوریم. این کار را با مشخص کردن بخش مشترک مسیر، به دنبال آن دو نقطه دوبل و سپس یک لیست از بخش‌های متفاوت مسیرها در داخل آکولاد انجام می‌دهیم، همان‌طور که در لیستینگ 7-18 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 7-18: مشخص کردن یک مسیر تو در تو برای وارد کردن چندین آیتم با پیشوند مشابه به محدوده</figcaption>
</figure>
<p>در برنامه‌های بزرگ‌تر، وارد کردن بسیاری از آیتم‌ها از یک جعبه (crate) یا ماژول مشابه با استفاده از مسیرهای تو در تو می‌تواند تعداد دستورات <code>use</code> جداگانه مورد نیاز را به طور قابل‌توجهی کاهش دهد.</p>
<p>ما می‌توانیم در هر سطحی از یک مسیر، از یک مسیر تو در تو استفاده کنیم، که این کار در مواقعی که دو دستور <code>use</code> دارای یک زیرمسیر مشترک هستند، مفید است. برای مثال، لیستینگ 7-19 دو دستور <code>use</code> را نشان می‌دهد: یکی که <code>std::io</code> را به محدوده وارد می‌کند و دیگری که <code>std::io::Write</code> را به محدوده وارد می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<figcaption>Listing 7-19: دو دستور <code>use</code> که یکی زیرمسیر دیگری است</figcaption>
</figure>
<p>بخش مشترک این دو مسیر، <code>std::io</code> است که مسیر کامل اولین دستور <code>use</code> را تشکیل می‌دهد. برای ترکیب این دو مسیر به یک دستور <code>use</code>، می‌توانیم از <code>self</code> در مسیر تو در تو استفاده کنیم، همان‌طور که در لیستینگ 7-20 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<figcaption>Listing 7-20: ترکیب مسیرهای موجود در لیستینگ 7-19 به یک دستور <code>use</code></figcaption>
</figure>
<p>این خط، <code>std::io</code> و <code>std::io::Write</code> را به محدوده وارد می‌کند.</p>
<h3 id="عملگر-glob"><a class="header" href="#عملگر-glob">عملگر Glob</a></h3>
<p>اگر بخواهیم <em>تمام</em> آیتم‌های عمومی تعریف‌شده در یک مسیر را به محدوده وارد کنیم، می‌توانیم آن مسیر را به همراه عملگر <code>*</code> مشخص کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>این دستور <code>use</code> تمام آیتم‌های عمومی تعریف‌شده در <code>std::collections</code> را به محدوده فعلی وارد می‌کند. هنگام استفاده از عملگر glob دقت کنید! استفاده از glob می‌تواند تشخیص این که چه نام‌هایی در محدوده قرار دارند و نامی که در برنامه شما استفاده شده در کجا تعریف شده است را دشوارتر کند.</p>
<p>عملگر glob اغلب در زمان تست استفاده می‌شود تا همه چیز تحت تست به ماژول <code>tests</code> وارد شود؛ در بخش <a href="ch11-01-writing-tests.html#how-to-write-tests">«چگونه تست بنویسیم»</a> در فصل 11 در مورد این موضوع صحبت خواهیم کرد. عملگر glob همچنین گاهی به عنوان بخشی از الگوی prelude استفاده می‌شود: برای اطلاعات بیشتر در مورد این الگو، به <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">مستندات کتابخانه استاندارد</a> مراجعه کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="جدا-کردن-ماژولها-به-فایلهای-مختلف"><a class="header" href="#جدا-کردن-ماژولها-به-فایلهای-مختلف">جدا کردن ماژول‌ها به فایل‌های مختلف</a></h2>
<p>تا به اینجا، تمام مثال‌های این فصل چندین ماژول را در یک فایل تعریف کرده‌اند. هنگامی که ماژول‌ها بزرگ می‌شوند، ممکن است بخواهید تعریف‌های آن‌ها را به یک فایل جداگانه منتقل کنید تا کد آسان‌تر خوانده و مدیریت شود.</p>
<p>برای مثال، بیایید از کد موجود در لیستینگ 7-17 شروع کنیم که شامل چندین ماژول مرتبط با رستوران بود. ما این ماژول‌ها را به جای تعریف در فایل ریشه جعبه (crate)، به فایل‌های جداگانه منتقل می‌کنیم. در این مثال، فایل ریشه جعبه (crate) <em>src/lib.rs</em> است، اما این روش برای جعبه‌ها (crates)ی باینری که فایل ریشه آن‌ها <em>src/main.rs</em> است نیز کار می‌کند.</p>
<p>ابتدا ماژول <code>front_of_house</code> را به فایل خودش منتقل می‌کنیم. کدی که داخل آکولادهای ماژول <code>front_of_house</code> است را حذف کرده و فقط اعلان <code>mod front_of_house;</code> را باقی می‌گذاریم. نتیجه کد در <em>src/lib.rs</em> مانند لیستینگ 7-21 خواهد بود. توجه داشته باشید که این کد تا زمانی که فایل <em>src/front_of_house.rs</em> مطابق لیستینگ 7-22 ایجاد نشود کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption>Listing 7-21: اعلان ماژول <code>front_of_house</code> که بدنه آن در <em>src/front_of_house.rs</em> خواهد بود</figcaption>
</figure>
<p>سپس، کدی که داخل آکولادهای ماژول <code>front_of_house</code> بود را به یک فایل جدید به نام <em>src/front_of_house.rs</em> منتقل می‌کنیم، همان‌طور که در لیستینگ 7-22 نشان داده شده است. کامپایلر می‌داند که باید این فایل را بررسی کند زیرا در فایل ریشه جعبه (crate) با نام <code>front_of_house</code> اعلان ماژول را دیده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/front_of_house.rs</span>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<figcaption>Listing 7-22: تعریف‌های داخل ماژول <code>front_of_house</code> در <em>src/front_of_house.rs</em></figcaption>
</figure>
<p>توجه داشته باشید که شما فقط یک بار نیاز دارید تا یک فایل را با استفاده از دستور <code>mod</code> در درخت ماژول خود بارگذاری کنید. وقتی کامپایلر می‌فهمد که فایل بخشی از پروژه است (و می‌فهمد که کد در کجای درخت ماژول قرار دارد به خاطر جایی که دستور <code>mod</code> را قرار داده‌اید)، سایر فایل‌های پروژه شما باید با استفاده از مسیری که به محل اعلان فایل اشاره می‌کند به کد بارگذاری شده ارجاع دهند، همان‌طور که در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">«مسیرها برای اشاره به یک آیتم در درخت ماژول»</a> توضیح داده شد. به عبارت دیگر، <code>mod</code> یک عملیات “شامل کردن” (include) نیست که ممکن است در زبان‌های برنامه‌نویسی دیگر دیده باشید.</p>
<p>در مرحله بعد، ماژول <code>hosting</code> را به فایل خودش منتقل می‌کنیم. این فرآیند کمی متفاوت است زیرا <code>hosting</code> یک زیرماژول از <code>front_of_house</code> است، نه از ماژول ریشه. فایل مربوط به <code>hosting</code> را در یک دایرکتوری جدید قرار می‌دهیم که به نام والدین آن در درخت ماژول نام‌گذاری شده است، که در اینجا <em>src/front_of_house</em> است.</p>
<p>برای شروع انتقال <code>hosting</code>، فایل <em>src/front_of_house.rs</em> را تغییر می‌دهیم تا فقط شامل اعلان ماژول <code>hosting</code> باشد:</p>
<figure class="listing">
<span class="file-name">Filename: src/front_of_house.rs</span>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
</figure>
<p>سپس یک دایرکتوری به نام <em>src/front_of_house</em> و یک فایل <em>hosting.rs</em> ایجاد می‌کنیم تا تعریف‌هایی که در ماژول <code>hosting</code> انجام شده‌اند را در آن قرار دهیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/front_of_house/hosting.rs</span>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
</figure>
<p>اگر به جای آن فایل <em>hosting.rs</em> را در دایرکتوری <em>src</em> قرار دهیم، کامپایلر انتظار خواهد داشت که کد <em>hosting.rs</em> در یک ماژول <code>hosting</code> که در ریشه جعبه (crate) اعلان شده باشد قرار داشته باشد، نه به عنوان یک زیرماژول از ماژول <code>front_of_house</code>. قوانین کامپایلر برای مشخص کردن این که کدام فایل‌ها برای کدام ماژول‌ها بررسی شوند، به این معناست که دایرکتوری‌ها و فایل‌ها با درخت ماژول مطابقت بیشتری دارند.</p>
<section class="note" aria-role="note">
<h3 id="مسیرهای-فایل-جایگزین"><a class="header" href="#مسیرهای-فایل-جایگزین">مسیرهای فایل جایگزین</a></h3>
<p>تاکنون مسیرهای فایل ایدیوماتیک را که کامپایلر Rust استفاده می‌کند پوشش داده‌ایم، اما Rust از یک سبک قدیمی‌تر از مسیر فایل نیز پشتیبانی می‌کند. برای یک ماژول به نام <code>front_of_house</code> که در ریشه جعبه (crate) اعلان شده است، کامپایلر کد ماژول را در مکان‌های زیر جستجو می‌کند:</p>
<ul>
<li><em>src/front_of_house.rs</em> (روشی که پوشش داده شد)</li>
<li><em>src/front_of_house/mod.rs</em> (مسیر قدیمی‌تر، همچنان پشتیبانی‌شده)</li>
</ul>
<p>برای یک ماژول به نام <code>hosting</code> که زیرماژولی از <code>front_of_house</code> است، کامپایلر کد ماژول را در مکان‌های زیر جستجو می‌کند:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (روشی که پوشش داده شد)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (مسیر قدیمی‌تر، همچنان پشتیبانی‌شده)</li>
</ul>
<p>اگر هر دو سبک را برای یک ماژول استفاده کنید، یک خطای کامپایلر دریافت خواهید کرد. استفاده از ترکیبی از هر دو سبک برای ماژول‌های مختلف در یک پروژه مجاز است، اما ممکن است برای کسانی که پروژه شما را مرور می‌کنند گیج‌کننده باشد.</p>
<p>نکته منفی اصلی سبک استفاده از فایل‌هایی با نام <em>mod.rs</em> این است که پروژه شما ممکن است تعداد زیادی فایل با نام <em>mod.rs</em> داشته باشد، که می‌تواند هنگام باز بودن همزمان این فایل‌ها در ویرایشگر شما گیج‌کننده باشد.</p>
</section>
<p>ما کد هر ماژول را به یک فایل جداگانه منتقل کرده‌ایم و درخت ماژول به همان شکل باقی مانده است. فراخوانی توابع در <code>eat_at_restaurant</code> بدون هیچ تغییری کار خواهد کرد، حتی اگر تعریف‌ها در فایل‌های مختلف قرار داشته باشند. این تکنیک به شما امکان می‌دهد ماژول‌ها را به فایل‌های جدید منتقل کنید زیرا اندازه آن‌ها افزایش می‌یابد.</p>
<p>توجه داشته باشید که دستور <code>pub use crate::front_of_house::hosting</code> در <em>src/lib.rs</em> نیز تغییری نکرده است، و همچنین <code>use</code> هیچ تأثیری بر اینکه چه فایل‌هایی به عنوان بخشی از جعبه (crate) کامپایل شوند ندارد. کلمه کلیدی <code>mod</code> ماژول‌ها را اعلان می‌کند و Rust در فایلی با همان نام ماژول به دنبال کدی می‌گردد که وارد آن ماژول شود.</p>
<h2 id="خلاصه-6"><a class="header" href="#خلاصه-6">خلاصه</a></h2>
<p>Rust به شما اجازه می‌دهد یک بسته را به چندین جعبه (crate) و یک جعبه (crate) را به ماژول‌ها تقسیم کنید تا بتوانید به آیتم‌هایی که در یک ماژول تعریف شده‌اند از ماژول دیگری ارجاع دهید. می‌توانید این کار را با مشخص کردن مسیرهای مطلق یا نسبی انجام دهید. این مسیرها می‌توانند با یک دستور <code>use</code> به محدوده وارد شوند تا بتوانید از یک مسیر کوتاه‌تر برای استفاده‌های متعدد از آن آیتم در آن محدوده استفاده کنید. کد ماژول به صورت پیش‌فرض خصوصی است، اما می‌توانید با افزودن کلمه کلیدی <code>pub</code> تعریف‌ها را عمومی کنید.</p>
<p>در فصل بعدی، به برخی از ساختارهای داده‌ای مجموعه در کتابخانه استاندارد خواهیم پرداخت که می‌توانید در کد مرتب و سازماندهی‌شده خود از آن‌ها استفاده کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مجموعههای-معمول"><a class="header" href="#مجموعههای-معمول">مجموعه‌های معمول</a></h1>
<p>کتابخانه استاندارد زبان Rust شامل تعدادی ساختار داده بسیار مفید به نام
<em>مجموعه‌ها</em> می‌باشد. اکثر انواع داده‌ها نماینده یک مقدار مشخص هستند، اما
مجموعه‌ها می‌توانند شامل مقادیر متعددی باشند. برخلاف انواع داخلی آرایه و
تاپل، داده‌ای که این مجموعه‌ها به آن اشاره می‌کنند در heap ذخیره می‌شود،
که به این معنی است که مقدار داده نیازی به شناخته شدن در زمان کامپایل ندارد
و می‌تواند در حین اجرای برنامه رشد کند یا کوچک شود. هر نوع مجموعه قابلیت‌ها
و هزینه‌های متفاوتی دارد و انتخاب نوع مناسب برای موقعیت فعلی شما، مهارتی
است که با گذشت زمان توسعه خواهید داد. در این فصل، سه مجموعه‌ای که به طور
متداول در برنامه‌های Rust استفاده می‌شوند، مورد بحث قرار خواهند گرفت:</p>
<ul>
<li>یک <em>بردار</em> به شما اجازه می‌دهد که تعداد متغیری از مقادیر را در کنار
یکدیگر ذخیره کنید.</li>
<li>یک <em>رشته</em> یک مجموعه از کاراکترها است. ما قبلاً نوع <code>String</code> را ذکر کرده‌ایم،
اما در این فصل به طور عمیق‌تر درباره آن صحبت خواهیم کرد.</li>
<li>یک <em>هش مپ</em> به شما اجازه می‌دهد که یک مقدار را با یک کلید مشخص مرتبط کنید.
این یک پیاده‌سازی خاص از ساختار داده کلی‌تر به نام <em>نقشه</em> است.</li>
</ul>
<p>برای یادگیری درباره انواع دیگر مجموعه‌هایی که توسط کتابخانه استاندارد ارائه شده‌اند،
<a href="https://doc.rust-lang.org/std/collections/index.html">مستندات</a> را مشاهده کنید.</p>
<p>ما درباره نحوه ایجاد و به‌روزرسانی بردارها، رشته‌ها و هش مپ‌ها، همچنین ویژگی‌هایی
که هر کدام را خاص می‌کند، صحبت خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ذخیره-لیستهایی-از-مقادیر-با-بردارها"><a class="header" href="#ذخیره-لیستهایی-از-مقادیر-با-بردارها">ذخیره لیست‌هایی از مقادیر با بردارها</a></h2>
<p>اولین نوع مجموعه‌ای که به آن خواهیم پرداخت، <code>Vec&lt;T&gt;</code> یا همان <em>بردار</em> است.
بردارها به شما اجازه می‌دهند که بیش از یک مقدار را در یک ساختار داده ذخیره کنید
که تمامی مقادیر را در کنار یکدیگر در حافظه قرار می‌دهد. بردارها فقط می‌توانند
مقادیر از یک نوع را ذخیره کنند. این ابزار زمانی مفید است که لیستی از آیتم‌ها
مانند خطوط متنی در یک فایل یا قیمت آیتم‌ها در یک سبد خرید داشته باشید.</p>
<h3 id="ایجاد-یک-بردار-جدید"><a class="header" href="#ایجاد-یک-بردار-جدید">ایجاد یک بردار جدید</a></h3>
<p>برای ایجاد یک بردار خالی جدید، از تابع <code>Vec::new</code> استفاده می‌کنیم، همانطور که
در لیست ۸-۱ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-1: ایجاد یک بردار جدید و خالی برای نگهداری مقادیر نوع <code>i32</code></figcaption>
</figure>
<p>توجه داشته باشید که ما یک توضیح نوع اضافه کرده‌ایم. چون ما هیچ مقداری به این بردار
اضافه نکرده‌ایم، Rust نمی‌داند چه نوع عناصری را قصد داریم ذخیره کنیم. این نکته
مهمی است. بردارها با استفاده از جنریک‌ها پیاده‌سازی شده‌اند؛ در فصل ۱۰ خواهیم دید
که چگونه می‌توان جنریک‌ها را در انواع خودتان استفاده کرد. در حال حاضر بدانید که
نوع <code>Vec&lt;T&gt;</code> ارائه شده توسط کتابخانه استاندارد می‌تواند هر نوعی را نگهداری کند.
وقتی یک بردار برای نگهداری نوع خاصی ایجاد می‌کنیم، می‌توانیم نوع موردنظر را داخل
براکت‌های زاویه‌ای مشخص کنیم. در لیست ۸-۱، ما به Rust اعلام کرده‌ایم که بردار <code>Vec&lt;T&gt;</code>
در <code>v</code> عناصر نوع <code>i32</code> را نگهداری خواهد کرد.</p>
<p>بیشتر اوقات، شما یک <code>Vec&lt;T&gt;</code> با مقادیر اولیه ایجاد خواهید کرد و Rust نوع مقادیر
را از روی آنها استنتاج خواهد کرد، بنابراین به ندرت نیاز به توضیح نوع خواهید داشت.
Rust به راحتی ماکروی <code>vec!</code> را فراهم می‌کند که یک بردار جدید ایجاد کرده و مقادیر
مورد نظر شما را در آن قرار می‌دهد. لیست ۸-۲ یک بردار جدید <code>Vec&lt;i32&gt;</code> را ایجاد می‌کند
که مقادیر <code>1</code>، <code>2</code> و <code>3</code> را نگهداری می‌کند. نوع عدد صحیح <code>i32</code> است چون این نوع
پیش‌فرض برای اعداد صحیح است، همانطور که در بخش <a href="ch03-02-data-types.html#data-types">“انواع داده‌ها”</a><!-- ignore -->
فصل ۳ بحث کردیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-2: ایجاد یک بردار جدید شامل مقادیر</figcaption>
</figure>
<p>چون مقادیر اولیه <code>i32</code> داده‌ایم، Rust می‌تواند استنتاج کند که نوع <code>v</code>
<code>Vec&lt;i32&gt;</code> است و نیازی به توضیح نوع نیست. حالا به نحوه به‌روزرسانی یک بردار
خواهیم پرداخت.</p>
<h3 id="بهروزرسانی-یک-بردار"><a class="header" href="#بهروزرسانی-یک-بردار">به‌روزرسانی یک بردار</a></h3>
<p>برای ایجاد یک بردار و سپس اضافه کردن عناصر به آن، می‌توانیم از متد <code>push</code> استفاده کنیم،
همانطور که در لیست ۸-۳ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-3: استفاده از متد <code>push</code> برای اضافه کردن مقادیر به یک بردار</figcaption>
</figure>
<p>همانطور که با هر متغیری دیگر انجام می‌دهیم، اگر بخواهیم بتوانیم مقدار آن را تغییر دهیم،
باید آن را با استفاده از کلیدواژه <code>mut</code> قابل تغییر کنیم، همانطور که در فصل ۳ بحث شد.
اعدادی که در داخل بردار قرار می‌دهیم همه از نوع <code>i32</code> هستند و Rust این نوع را از داده‌ها
استنتاج می‌کند، بنابراین نیازی به توضیح نوع <code>Vec&lt;i32&gt;</code> نیست.</p>
<h3 id="خواندن-عناصر-بردار"><a class="header" href="#خواندن-عناصر-بردار">خواندن عناصر بردار</a></h3>
<p>دو روش برای ارجاع به یک مقدار ذخیره شده در بردار وجود دارد: از طریق استفاده از اندیس (index)یا
با استفاده از متد <code>get</code>. در مثال‌های زیر، انواع مقادیر بازگشتی از این توابع برای وضوح بیشتر
مشخص شده‌اند.</p>
<p>لیست ۸-۴ هر دو روش دسترسی به یک مقدار در بردار، با استفاده از سینتکس اندیس (index)و متد <code>get</code>
را نشان می‌دهد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-4: استفاده از سینتکس اندیس (index)و متد <code>get</code> برای دسترسی به یک آیتم در بردار</figcaption>
</figure>
<p>به چند جزئیات اینجا توجه کنید. ما از مقدار اندیس (index)<code>2</code> برای دسترسی به عنصر سوم استفاده می‌کنیم
زیرا بردارها با شماره از صفر اندیس‌گذاری می‌شوند. استفاده از <code>&amp;</code> و <code>[]</code> یک مرجع به عنصر
در مقدار اندیس (index)را به ما می‌دهد. وقتی از متد <code>get</code> با اندیسی که به عنوان آرگومان داده می‌شود
استفاده می‌کنیم، یک <code>Option&lt;&amp;T&gt;</code> دریافت می‌کنیم که می‌توانیم با <code>match</code> از آن استفاده کنیم.</p>
<p>Rust این دو روش ارجاع به یک عنصر را ارائه می‌دهد تا بتوانید انتخاب کنید که برنامه شما چگونه رفتار کند
وقتی تلاش می‌کنید از یک مقدار اندیس (index)خارج از محدوده عناصر موجود استفاده کنید. به عنوان یک مثال،
بیایید ببینیم چه اتفاقی می‌افتد وقتی یک بردار با پنج عنصر داشته باشیم و سپس تلاش کنیم به یک عنصر
در اندیس (index)۱۰۰ با هر دو تکنیک دسترسی پیدا کنیم، همانطور که در لیست ۸-۵ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-5: تلاش برای دسترسی به عنصر در اندیس (index)۱۰۰ در یک بردار شامل پنج عنصر</figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، روش اول <code>[]</code> باعث می‌شود برنامه متوقف شود زیرا به یک
عنصر غیرموجود اشاره می‌کند. این روش زمانی بهترین استفاده را دارد که بخواهید برنامه‌تان
در صورت تلاش برای دسترسی به عنصری خارج از انتهای بردار، متوقف شود.</p>
<p>وقتی متد <code>get</code> یک اندیس (index)خارج از بردار دریافت می‌کند، مقدار <code>None</code> را بدون متوقف کردن
برنامه بازمی‌گرداند. شما از این روش استفاده می‌کنید اگر دسترسی به عنصری خارج از محدوده بردار
ممکن است گاه‌به‌گاه در شرایط عادی رخ دهد. کد شما سپس منطق لازم برای مدیریت داشتن
<code>Some(&amp;element)</code> یا <code>None</code> را خواهد داشت، همانطور که در فصل ۶ بحث شد. برای مثال،
اندیس (index)ممکن است از یک عدد ورودی توسط کاربر بیاید. اگر کاربر تصادفاً عددی وارد کند که بیش از حد
بزرگ باشد و برنامه مقدار <code>None</code> دریافت کند، شما می‌توانید به کاربر اطلاع دهید که چند آیتم
در بردار موجود است و به او فرصت دیگری برای وارد کردن یک مقدار معتبر بدهید. این راهکار برای
کاربر پسندتر است تا این که برنامه به دلیل یک اشتباه تایپی متوقف شود!</p>
<p>وقتی برنامه یک مرجع معتبر دارد، بررسی‌کننده قرض قوانین مالکیت و قرض‌گیری (که در فصل ۴ پوشش داده شد)
را اعمال می‌کند تا اطمینان حاصل کند که این مرجع و هر مرجع دیگری به محتوای بردار معتبر باقی می‌مانند.
به یاد بیاورید که قانون بیان می‌کند نمی‌توانید مرجع‌های قابل تغییر و غیرقابل تغییر را در یک حوزه
داشته باشید. این قانون در لیست ۸-۶ اعمال می‌شود، جایی که یک مرجع غیرقابل تغییر به اولین عنصر
در یک بردار نگه داشته شده است و سعی داریم یک عنصر به انتها اضافه کنیم. این برنامه زمانی کار نخواهد کرد
اگر همچنین بخواهیم بعداً در تابع به آن عنصر ارجاع دهیم.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("The first element is: {first}");
<span class="boring">}</span></code></pre>
<figcaption>Listing 8-6: تلاش برای اضافه کردن یک عنصر به یک بردار در حالی که یک مرجع به یک آیتم نگه داشته شده است</figcaption>
</figure>
<p>کامپایل کردن این کد به این خطا منجر می‌شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>کد در لیست ۸-۶ ممکن است به نظر بیاید که باید کار کند: چرا یک مرجع به اولین عنصر باید
به تغییرات انتهای بردار اهمیت دهد؟ این خطا به نحوه کار بردارها مربوط است: چون بردارها مقادیر
را در کنار یکدیگر در حافظه قرار می‌دهند، اضافه کردن یک عنصر جدید به انتهای بردار ممکن است نیازمند
اختصاص حافظه جدید و کپی کردن عناصر قدیمی به مکان جدید باشد، اگر فضای کافی برای قرار دادن
همه عناصر در کنار یکدیگر در محل کنونی بردار وجود نداشته باشد. در این حالت، مرجع به اولین
عنصر به حافظه‌ای اشاره می‌کند که آزاد شده است. قوانین قرض‌گیری از به وجود آمدن این شرایط
در برنامه‌ها جلوگیری می‌کنند.</p>
<blockquote>
<p>نکته: برای اطلاعات بیشتر درباره جزئیات پیاده‌سازی نوع <code>Vec&lt;T&gt;</code>، به <a href="../nomicon/vec/vec.html">“The Rustonomicon”</a> مراجعه کنید.</p>
</blockquote>
<h3 id="پیمایش-بر-روی-مقادیر-در-یک-بردار"><a class="header" href="#پیمایش-بر-روی-مقادیر-در-یک-بردار">پیمایش بر روی مقادیر در یک بردار</a></h3>
<p>برای دسترسی به هر عنصر در یک بردار به ترتیب، می‌توانیم به جای استفاده از اندیس‌ها
برای دسترسی به یک عنصر در هر بار، بر روی تمامی عناصر پیمایش کنیم. لیست ۸-۷ نشان می‌دهد
چگونه می‌توان از یک حلقه <code>for</code> برای گرفتن مرجع‌های غیرقابل تغییر به هر عنصر در یک بردار
از مقادیر <code>i32</code> استفاده کرد و آنها را چاپ کرد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-7: چاپ هر عنصر در یک بردار با پیمایش بر روی عناصر با استفاده از یک حلقه <code>for</code></figcaption>
</figure>
<p>همچنین می‌توانیم بر روی مرجع‌های قابل تغییر به هر عنصر در یک بردار قابل تغییر پیمایش کنیم
تا تغییراتی روی تمام عناصر اعمال کنیم. حلقه <code>for</code> در لیست ۸-۸ مقدار <code>50</code> را به هر عنصر اضافه می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-8: پیمایش بر روی مرجع‌های قابل تغییر به عناصر در یک بردار</figcaption>
</figure>
<p>برای تغییر مقدار مرجع قابل تغییر، باید از عملگر * (dereference) استفاده کنیم تا به مقدار
موجود در <code>i</code> دسترسی پیدا کنیم، سپس می‌توانیم از عملگر <code>+=</code> استفاده کنیم. درباره عملگر dereference
در بخش <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“دنبال کردن اشاره‌گر (Pointer) به مقدار با عملگر dereference”</a><!-- ignore --> در فصل ۱۵
بیشتر صحبت خواهیم کرد.</p>
<p>پیمایش بر روی یک بردار، چه به صورت غیرقابل تغییر و چه به صورت قابل تغییر، امن است
زیرا از قوانین بررسی‌کننده قرض پیروی می‌کند. اگر بخواهیم در بدنه حلقه‌های <code>for</code> در لیست ۸-۷
و لیست ۸-۸ آیتم‌ها را درج یا حذف کنیم، با خطای کامپایل مشابهی با کدی که در لیست ۸-۶ دیدیم
روبرو خواهیم شد. مرجع به برداری که حلقه <code>for</code> نگه می‌دارد از تغییر همزمان کل بردار
جلوگیری می‌کند.</p>
<h3 id="استفاده-از-enum-برای-ذخیره-انواع-مختلف"><a class="header" href="#استفاده-از-enum-برای-ذخیره-انواع-مختلف">استفاده از Enum برای ذخیره انواع مختلف</a></h3>
<p>بردارها فقط می‌توانند مقادیر از یک نوع را ذخیره کنند. این موضوع ممکن است گاهی
ناخوشایند باشد؛ مطمئناً موارد استفاده‌ای وجود دارند که نیاز به ذخیره یک لیست
از آیتم‌ها با انواع مختلف دارید. خوشبختانه، متغیرهای یک <code>enum</code> تحت یک نوع
<code>enum</code> تعریف شده‌اند، بنابراین وقتی نیاز به یک نوع برای نمایش عناصر از انواع
مختلف دارید، می‌توانید یک <code>enum</code> تعریف کرده و از آن استفاده کنید!</p>
<p>برای مثال، فرض کنید می‌خواهیم مقادیر یک ردیف از یک صفحه گسترده را که برخی از
ستون‌های آن شامل اعداد صحیح، برخی شامل اعداد اعشاری و برخی شامل رشته‌ها
می‌باشند، دریافت کنیم. می‌توانیم یک <code>enum</code> تعریف کنیم که متغیرهای آن انواع
مختلف مقادیر را نگهداری کنند، و تمام متغیرهای <code>enum</code> به عنوان یک نوع مشابه
(یعنی نوع <code>enum</code>) در نظر گرفته می‌شوند. سپس می‌توانیم یک بردار ایجاد کنیم
که این <code>enum</code> را نگهداری کند و در نتیجه انواع مختلف را ذخیره کند. این موضوع
در لیست ۸-۹ نمایش داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-9: تعریف یک <code>enum</code> برای ذخیره انواع مختلف در یک بردار</figcaption>
</figure>
<p>Rust باید بداند چه انواعی در بردار خواهند بود تا بتواند در زمان کامپایل
دقیقاً مشخص کند چه مقدار حافظه در heap برای ذخیره هر عنصر نیاز است.
همچنین باید به طور صریح مشخص کنیم که چه انواعی در این بردار مجاز هستند.
اگر Rust اجازه می‌داد که بردار هر نوعی را نگهداری کند، احتمال داشت که
یک یا چند نوع باعث ایجاد خطا در عملیات انجام شده روی عناصر بردار شوند.
استفاده از یک <code>enum</code> به علاوه یک عبارت <code>match</code> به این معنی است که Rust
در زمان کامپایل اطمینان حاصل خواهد کرد که تمام حالت‌های ممکن مدیریت شده‌اند،
همانطور که در فصل ۶ بحث شد.</p>
<p>اگر مجموعه جامعی از انواعی که برنامه در زمان اجرا دریافت می‌کند و باید
در بردار ذخیره شود را نمی‌دانید، تکنیک <code>enum</code> کار نخواهد کرد. به جای آن،
می‌توانید از یک شیء ویژگی (<code>trait object</code>) استفاده کنید که در فصل ۱۸
مورد بررسی قرار خواهد گرفت.</p>
<p>اکنون که برخی از رایج‌ترین روش‌های استفاده از بردارها را بحث کردیم، مطمئن شوید
که <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">مستندات API</a><!-- ignore --> را برای تمام متدهای مفیدی که کتابخانه
استاندارد روی <code>Vec&lt;T&gt;</code> تعریف کرده است مرور کنید. برای مثال، علاوه بر <code>push</code>،
متد <code>pop</code> عنصر آخر را حذف کرده و بازمی‌گرداند.</p>
<h3 id="حذف-یک-بردار-عناصر-آن-را-نیز-حذف-میکند"><a class="header" href="#حذف-یک-بردار-عناصر-آن-را-نیز-حذف-میکند">حذف یک بردار، عناصر آن را نیز حذف می‌کند</a></h3>
<p>مانند هر <code>struct</code> دیگری، یک بردار وقتی از محدوده خارج می‌شود آزاد می‌شود،
همانطور که در لیست ۸-۱۰ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-10: نمایش زمان حذف بردار و عناصر آن</figcaption>
</figure>
<p>وقتی بردار حذف می‌شود، تمام محتوای آن نیز حذف می‌شوند، به این معنی که اعداد
صحیحی که نگهداری می‌کند تمیزکاری می‌شوند. بررسی‌کننده قرض اطمینان حاصل می‌کند
که هر مرجع به محتوای یک بردار فقط تا زمانی که خود بردار معتبر است استفاده شود.</p>
<p>حال به نوع مجموعه بعدی می‌پردازیم: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ذخیره-متنهای-کدگذاری-شده-utf-8-با--رشتهها-strings"><a class="header" href="#ذخیره-متنهای-کدگذاری-شده-utf-8-با--رشتهها-strings">ذخیره متن‌های کدگذاری شده UTF-8 با  رشته‌ها (strings)</a></h2>
<p>ما در فصل ۴ درباره رشته‌ها صحبت کردیم، اما اکنون به آن‌ها با عمق بیشتری نگاه خواهیم کرد.
Rustaceanهای تازه‌وارد معمولاً به دلیل ترکیبی از سه عامل در رشته‌ها دچار مشکل می‌شوند:
گرایش Rust به آشکارسازی خطاهای ممکن، رشته‌ها به عنوان یک ساختار داده پیچیده‌تر از آنچه
بسیاری از برنامه‌نویسان تصور می‌کنند، و UTF-8. این عوامل به نحوی ترکیب می‌شوند که می‌توانند
برای کسانی که از زبان‌های برنامه‌نویسی دیگر می‌آیند دشوار باشند.</p>
<p>ما رشته‌ها را در زمینه مجموعه‌ها بررسی می‌کنیم، زیرا رشته‌ها به عنوان مجموعه‌ای از بایت‌ها
پیاده‌سازی شده‌اند، به علاوه تعدادی متد برای ارائه قابلیت‌های مفید زمانی که این بایت‌ها
به عنوان متن تفسیر می‌شوند. در این بخش، درباره عملیات‌هایی که روی <code>String</code> انجام می‌شود
و هر نوع مجموعه‌ای آن‌ها را دارد، مانند ایجاد، به‌روزرسانی، و خواندن صحبت خواهیم کرد.
همچنین تفاوت‌های <code>String</code> با سایر مجموعه‌ها را مورد بحث قرار می‌دهیم، به‌ویژه نحوه پیچیدگی
اندیس‌گذاری در یک <code>String</code> به دلیل تفاوت‌های بین تفسیر داده‌های <code>String</code> توسط انسان‌ها
و کامپیوترها.</p>
<h3 id="رشته-string-چیست"><a class="header" href="#رشته-string-چیست">رشته (string) چیست؟</a></h3>
<p>ابتدا تعریف می‌کنیم که منظور ما از اصطلاح <em>رشته</em> چیست. Rust فقط یک نوع رشته در زبان
هسته خود دارد که همان قطعه رشته <code>str</code> است که معمولاً به صورت قرض گرفته شده <code>&amp;str</code>
دیده می‌شود. در فصل ۴ درباره <em>قطعه‌های رشته</em> صحبت کردیم، که ارجاعاتی به داده‌های رشته‌ای
کدگذاری شده UTF-8 هستند که در جای دیگری ذخیره شده‌اند. به عنوان مثال، رشته‌های
لیترال در باینری برنامه ذخیره می‌شوند و بنابراین قطعه‌های رشته هستند.</p>
<p>نوع <code>String</code>، که توسط کتابخانه استاندارد Rust ارائه شده است و نه مستقیماً در زبان هسته
کدگذاری شده، یک نوع رشته رشدپذیر، قابل تغییر، و مالک UTF-8 است. وقتی Rustaceanها
به “رشته‌ها” در Rust اشاره می‌کنند، ممکن است به نوع <code>String</code> یا قطعه رشته <code>&amp;str</code> اشاره
کنند، نه فقط یکی از این دو نوع. اگرچه این بخش عمدتاً درباره <code>String</code> است، اما هر دو نوع
در کتابخانه استاندارد Rust به شدت مورد استفاده قرار می‌گیرند و هر دو <code>String</code> و قطعه‌های
رشته کدگذاری UTF-8 دارند.</p>
<h3 id="ایجاد-یک-رشته-strings-جدید"><a class="header" href="#ایجاد-یک-رشته-strings-جدید">ایجاد یک رشته (strings) جدید</a></h3>
<p>بسیاری از عملیات مشابه موجود در <code>Vec&lt;T&gt;</code> برای <code>String</code> نیز در دسترس است، زیرا <code>String</code>
در واقع به عنوان یک پوششی بر روی یک بردار از بایت‌ها پیاده‌سازی شده است، با برخی
ضمانت‌ها، محدودیت‌ها، و قابلیت‌های اضافی. مثالی از یک تابع که به همان روش با
<code>Vec&lt;T&gt;</code> و <code>String</code> کار می‌کند، تابع <code>new</code> برای ایجاد یک نمونه است، همانطور که در لیست
۸-۱۱ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-11: ایجاد یک <code>String</code> جدید و خالی</figcaption>
</figure>
<p>این خط یک رشته جدید و خالی به نام <code>s</code> ایجاد می‌کند که می‌توانیم داده‌ها را در آن بارگذاری کنیم.
اغلب، داده‌های اولیه‌ای خواهیم داشت که می‌خواهیم رشته را با آن‌ها شروع کنیم. برای این کار،
از متد <code>to_string</code> استفاده می‌کنیم که بر روی هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی
می‌کند، همانند رشته‌های لیترال، در دسترس است. لیست ۸-۱۲ دو مثال را نشان می‌دهد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-12: استفاده از متد <code>to_string</code> برای ایجاد یک <code>String</code> از یک رشته لیترال</figcaption>
</figure>
<p>این کد یک رشته حاوی <code>initial contents</code> ایجاد می‌کند.</p>
<p>ما همچنین می‌توانیم از تابع <code>String::from</code> برای ایجاد یک <code>String</code> از یک رشته لیترال
استفاده کنیم. کد در لیست ۸-۱۳ معادل کدی است که در لیست ۸-۱۲ از <code>to_string</code> استفاده می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-13: استفاده از تابع <code>String::from</code> برای ایجاد یک <code>String</code> از یک رشته لیترال</figcaption>
</figure>
<p>از آنجا که رشته‌ها برای موارد بسیاری استفاده می‌شوند، می‌توانیم از بسیاری از APIهای
جنریک مختلف برای رشته‌ها استفاده کنیم که گزینه‌های زیادی را در اختیار ما قرار می‌دهند.
برخی از این‌ها ممکن است به نظر اضافی بیایند، اما هرکدام جایگاه خاص خود را دارند!
در این مورد، <code>String::from</code> و <code>to_string</code> عملکرد یکسانی دارند، بنابراین انتخاب بین آن‌ها
مسئله سبک و خوانایی کد است.</p>
<p>به یاد داشته باشید که رشته‌ها با کدگذاری UTF-8 هستند، بنابراین می‌توانیم هر داده‌ای که
به طور صحیح کدگذاری شده باشد را در آن‌ها قرار دهیم، همانطور که در لیست ۸-۱۴ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-14: ذخیره سلام‌ها به زبان‌های مختلف در رشته‌ها</figcaption>
</figure>
<p>تمام این موارد مقادیر معتبر <code>String</code> هستند.</p>
<h3 id="بهروزرسانی-یک-رشته"><a class="header" href="#بهروزرسانی-یک-رشته">به‌روزرسانی یک رشته</a></h3>
<p>یک <code>String</code> می‌تواند از نظر اندازه رشد کند و محتوای آن تغییر کند، همانطور که محتوای
یک <code>Vec&lt;T&gt;</code> تغییر می‌کند، اگر داده بیشتری به آن اضافه کنیم. علاوه بر این، می‌توانیم به راحتی
از عملگر <code>+</code> یا ماکروی <code>format!</code> برای الحاق مقادیر <code>String</code> استفاده کنیم.</p>
<h4 id="الحاق-به-یک-رشته-string-با-push_str-و-push"><a class="header" href="#الحاق-به-یک-رشته-string-با-push_str-و-push">الحاق به یک رشته (string) با <code>push_str</code> و <code>push</code></a></h4>
<p>ما می‌توانیم یک <code>String</code> را با استفاده از متد <code>push_str</code> برای الحاق یک قطعه رشته رشد دهیم،
همانطور که در لیست ۸-۱۵ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-15: الحاق یک قطعه رشته به یک <code>String</code> با استفاده از متد <code>push_str</code></figcaption>
</figure>
<p>بعد از این دو خط، مقدار <code>s</code> شامل <code>foobar</code> خواهد بود. متد <code>push_str</code> یک قطعه رشته را به عنوان آرگومان می‌گیرد
زیرا ما لزوماً نمی‌خواهیم مالکیت پارامتر را بگیریم. برای مثال، در کدی که در لیست ۸-۱۶ نشان داده شده است،
ما می‌خواهیم بتوانیم پس از الحاق محتوای <code>s2</code> به <code>s1</code> همچنان از <code>s2</code> استفاده کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-16: استفاده از یک قطعه رشته پس از الحاق محتوای آن به یک <code>String</code></figcaption>
</figure>
<p>اگر متد <code>push_str</code> مالکیت <code>s2</code> را می‌گرفت، نمی‌توانستیم مقدار آن را در خط آخر چاپ کنیم. با این حال،
این کد همانطور که انتظار می‌رود کار می‌کند!</p>
<p>متد <code>push</code> یک کاراکتر را به عنوان پارامتر می‌گیرد و آن را به <code>String</code> اضافه می‌کند. لیست ۸-۱۷
حرف <em>l</em> را با استفاده از متد <code>push</code> به یک <code>String</code> اضافه می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-17: اضافه کردن یک کاراکتر به مقدار <code>String</code> با استفاده از <code>push</code></figcaption>
</figure>
<p>در نتیجه، مقدار <code>s</code> شامل <code>lol</code> خواهد بود.</p>
<h4 id="الحاق-با-استفاده-از-عملگر--یا-ماکروی-format"><a class="header" href="#الحاق-با-استفاده-از-عملگر--یا-ماکروی-format">الحاق با استفاده از عملگر <code>+</code> یا ماکروی <code>format!</code></a></h4>
<p>اغلب، ممکن است بخواهید دو رشته موجود را با هم ترکیب کنید. یکی از راه‌های انجام این کار
استفاده از عملگر <code>+</code> است، همانطور که در لیست ۸-۱۸ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-18: استفاده از عملگر <code>+</code> برای ترکیب دو مقدار <code>String</code> در یک مقدار <code>String</code> جدید</figcaption>
</figure>
<p>مقدار <code>s3</code> شامل <code>Hello, world!</code> خواهد بود. دلیل اینکه <code>s1</code> پس از این الحاق دیگر معتبر نیست
و دلیل اینکه ما از یک مرجع به <code>s2</code> استفاده کردیم، به امضای متدی که هنگام استفاده از
عملگر <code>+</code> فراخوانی می‌شود مربوط است. عملگر <code>+</code> از متد <code>add</code> استفاده می‌کند که امضای آن به شکل زیر است:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>در کتابخانه استاندارد، شما <code>add</code> را خواهید دید که با استفاده از جنریک‌ها و انواع مرتبط تعریف شده است.
اینجا، ما انواع مشخصی را جایگزین کرده‌ایم، که این همان چیزی است که هنگام فراخوانی این متد با مقادیر
<code>String</code> اتفاق می‌افتد. درباره جنریک‌ها در فصل ۱۰ صحبت خواهیم کرد. این امضا به ما سرنخ‌هایی می‌دهد
تا بتوانیم بخش‌های چالش‌برانگیز عملگر <code>+</code> را درک کنیم.</p>
<p>اول، <code>s2</code> یک <code>&amp;</code> دارد، به این معنی که ما یک <em>مرجع</em> از رشته دوم را به رشته اول اضافه می‌کنیم.
این به دلیل پارامتر <code>s</code> در تابع <code>add</code> است: ما فقط می‌توانیم یک <code>&amp;str</code> را به یک <code>String</code> اضافه کنیم؛
نمی‌توانیم دو مقدار <code>String</code> را با هم جمع کنیم. اما صبر کنید—نوع <code>&amp;s2</code>، <code>&amp;String</code> است، نه <code>&amp;str</code>
همانطور که در پارامتر دوم <code>add</code> مشخص شده است. پس چرا کد در لیست ۸-۱۸ کامپایل می‌شود؟</p>
<p>دلیل اینکه می‌توانیم از <code>&amp;s2</code> در فراخوانی <code>add</code> استفاده کنیم این است که کامپایلر می‌تواند آرگومان
<code>&amp;String</code> را به <code>&amp;str</code> تبدیل کند. هنگامی که ما متد <code>add</code> را فراخوانی می‌کنیم، Rust از یک
<em>coercion deref</em> استفاده می‌کند که در اینجا <code>&amp;s2</code> را به <code>&amp;s2[..]</code> تبدیل می‌کند. ما این موضوع
را در فصل ۱۵ به طور عمیق‌تری بررسی خواهیم کرد. از آنجا که <code>add</code> مالکیت پارامتر <code>s</code> را نمی‌گیرد،
<code>s2</code> پس از این عملیات همچنان یک <code>String</code> معتبر باقی خواهد ماند.</p>
<p>دوم، می‌توانیم در امضا ببینیم که <code>add</code> مالکیت <code>self</code> را می‌گیرد زیرا <code>self</code> یک <code>&amp;</code> ندارد.
این بدان معناست که <code>s1</code> در لیست ۸-۱۸ به فراخوانی <code>add</code> منتقل می‌شود و پس از آن دیگر معتبر نخواهد بود.
بنابراین، اگرچه <code>let s3 = s1 + &amp;s2;</code> به نظر می‌رسد که هر دو رشته را کپی می‌کند و یک رشته جدید ایجاد
می‌کند، این عبارت در واقع مالکیت <code>s1</code> را می‌گیرد، یک کپی از محتوای <code>s2</code> را اضافه می‌کند، و سپس مالکیت
نتیجه را بازمی‌گرداند. به عبارت دیگر، به نظر می‌رسد که کپی‌های زیادی انجام می‌دهد، اما اینطور نیست؛
پیاده‌سازی کارآمدتر از کپی کردن است.</p>
<p>اگر نیاز به الحاق چندین رشته داشته باشیم، رفتار عملگر <code>+</code> دست‌وپاگیر می‌شود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>در این نقطه، مقدار <code>s</code> برابر با <code>tic-tac-toe</code> خواهد بود. با تمام این <code>+</code> و کاراکترهای <code>"</code>،
دیدن اینکه چه اتفاقی می‌افتد دشوار است. برای ترکیب رشته‌ها به روش‌های پیچیده‌تر، می‌توانیم
به جای آن از ماکروی <code>format!</code> استفاده کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>این کد نیز مقدار <code>s</code> را به <code>tic-tac-toe</code> تنظیم می‌کند. ماکروی <code>format!</code> شبیه به <code>println!</code> کار می‌کند،
اما به جای چاپ خروجی روی صفحه، یک <code>String</code> با محتوای مورد نظر بازمی‌گرداند. نسخه کد با استفاده از
<code>format!</code> بسیار خواناتر است و کدی که توسط ماکروی <code>format!</code> تولید می‌شود از مراجع استفاده می‌کند،
بنابراین این فراخوانی مالکیت هیچ‌یک از پارامترهایش را نمی‌گیرد.</p>
<h3 id="اندیسگذاری-در-رشتهها"><a class="header" href="#اندیسگذاری-در-رشتهها">اندیس‌گذاری در رشته‌ها</a></h3>
<p>در بسیاری از زبان‌های برنامه‌نویسی دیگر، دسترسی به کاراکترهای منفرد در یک رشته با اشاره به آن‌ها
توسط اندیس (index)یک عملیات معتبر و رایج است. با این حال، اگر تلاش کنید در Rust با استفاده از سینتکس
اندیس‌گذاری به بخش‌هایی از یک <code>String</code> دسترسی پیدا کنید، با خطا مواجه می‌شوید. کد نامعتبر
در لیست ۸-۱۹ را در نظر بگیرید.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<figcaption>Listing 8-19: تلاش برای استفاده از سینتکس اندیس‌گذاری با یک <code>String</code></figcaption>
</figure>
<p>این کد به خطای زیر منجر خواهد شد:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>خطا و توضیحات آن گویای موضوع است: رشته‌های Rust از اندیس‌گذاری پشتیبانی نمی‌کنند. اما چرا؟
برای پاسخ به این سؤال، باید درباره نحوه ذخیره‌سازی رشته‌ها در حافظه توسط Rust صحبت کنیم.</p>
<h4 id="نمایش-داخلی"><a class="header" href="#نمایش-داخلی">نمایش داخلی</a></h4>
<p>یک <code>String</code> در واقع یک پوشش بر روی <code>Vec&lt;u8&gt;</code> است. بیایید به برخی از مثال‌های رشته‌های کدگذاری
شده UTF-8 در لیست ۸-۱۴ نگاه کنیم. ابتدا این مورد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>در این حالت، مقدار <code>len</code> برابر با <code>4</code> خواهد بود، به این معنی که برداری که رشته <code>"Hola"</code> را
ذخیره می‌کند ۴ بایت طول دارد. هر یک از این حروف هنگام کدگذاری در UTF-8 یک بایت می‌گیرد.
با این حال، خط زیر ممکن است شما را شگفت‌زده کند (توجه داشته باشید که این رشته با حرف بزرگ
سیریلیک <em>Ze</em> آغاز می‌شود، نه عدد ۳):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>اگر از شما پرسیده شود طول این رشته چقدر است، ممکن است بگویید ۱۲. اما در واقع، پاسخ Rust
۲۴ است: این تعداد بایت‌هایی است که برای کدگذاری “Здравствуйте” در UTF-8 نیاز است، زیرا هر مقدار
اسکالر Unicode در این رشته ۲ بایت فضای ذخیره‌سازی می‌گیرد. بنابراین، یک اندیس (index)در بایت‌های رشته
همیشه با یک مقدار اسکالر Unicode معتبر مطابقت ندارد. برای نشان دادن این موضوع، کد نامعتبر
زیر در Rust را در نظر بگیرید:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>شما قبلاً می‌دانید که مقدار <code>answer</code> برابر با <code>З</code>، اولین حرف، نخواهد بود. وقتی در UTF-8 کدگذاری
می‌شود، اولین بایت از <code>З</code> برابر با <code>208</code> و دومین بایت برابر با <code>151</code> است، بنابراین ممکن است به نظر
برسد که <code>answer</code> باید در واقع <code>208</code> باشد، اما <code>208</code> به تنهایی یک کاراکتر معتبر نیست. بازگرداندن
<code>208</code> احتمالاً چیزی نیست که یک کاربر بخواهد اگر درخواست اولین حرف این رشته را داشته باشد؛
با این حال، این تنها داده‌ای است که Rust در اندیس (index)بایت ۰ دارد. کاربران به طور کلی نمی‌خواهند
مقدار بایت بازگردانده شود، حتی اگر رشته فقط حروف لاتین داشته باشد: اگر <code>&amp;"hi"[0]</code> یک کد معتبر
بود که مقدار بایت را بازمی‌گرداند، مقدار <code>104</code> و نه <code>h</code> را بازمی‌گرداند.</p>
<p>پاسخ این است که برای جلوگیری از بازگرداندن یک مقدار غیرمنتظره و ایجاد باگ‌هایی که ممکن است فوراً
کشف نشوند، Rust این کد را اصلاً کامپایل نمی‌کند و از سوءتفاهم‌ها در اوایل فرآیند توسعه جلوگیری می‌کند.</p>
<h4 id="بایتها-مقادیر-اسکالر-و-خوشههای-گرافیمی-اوه-خدای-من"><a class="header" href="#بایتها-مقادیر-اسکالر-و-خوشههای-گرافیمی-اوه-خدای-من">بایت‌ها، مقادیر اسکالر و خوشه‌های گرافیمی! اوه خدای من!</a></h4>
<p>نکته دیگری درباره UTF-8 این است که در واقع سه روش مرتبط برای مشاهده رشته‌ها از دیدگاه Rust وجود دارد:
به صورت بایت، مقادیر اسکالر، و خوشه‌های گرافیمی (نزدیک‌ترین چیز به چیزی که ما <em>حروف</em> می‌نامیم).</p>
<p>اگر به کلمه هندی “नमस्ते” نوشته شده در اسکریپت Devanagari نگاه کنیم، این کلمه به صورت یک بردار
از مقادیر <code>u8</code> ذخیره می‌شود که به شکل زیر است:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>این ۱۸ بایت است و این همان چیزی است که کامپیوترها در نهایت این داده را ذخیره می‌کنند.
اگر به آن‌ها به عنوان مقادیر اسکالر Unicode نگاه کنیم، که همان نوع <code>char</code> در Rust است، این بایت‌ها
به این صورت به نظر می‌رسند:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>اینجا شش مقدار <code>char</code> وجود دارد، اما مقدار چهارم و ششم حروف نیستند: این‌ها دیاکریتیک‌هایی هستند که
به تنهایی معنایی ندارند. در نهایت، اگر به آن‌ها به عنوان خوشه‌های گرافیمی نگاه کنیم، همان چیزی
که یک فرد به عنوان حروف کلمه هندی تشخیص می‌دهد، اینطور خواهد بود:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust روش‌های مختلفی برای تفسیر داده خام رشته ارائه می‌دهد که کامپیوترها ذخیره می‌کنند، بنابراین هر
برنامه می‌تواند تفسیری را که نیاز دارد انتخاب کند، صرف نظر از اینکه داده به چه زبان انسانی است.</p>
<p>یکی دیگر از دلایل اینکه Rust به ما اجازه نمی‌دهد در یک <code>String</code> اندیس‌گذاری کنیم تا یک کاراکتر را
دریافت کنیم این است که عملیات اندیس‌گذاری باید همیشه در زمان ثابت (O(1)) انجام شود. اما امکان
تضمین این عملکرد با یک <code>String</code> وجود ندارد، زیرا Rust باید محتویات را از ابتدا تا اندیس (index)مرور کند تا
تعیین کند که چند کاراکتر معتبر وجود دارد.</p>
<h3 id="برش-رشتهها"><a class="header" href="#برش-رشتهها">برش رشته‌ها</a></h3>
<p>اندیس‌گذاری در یک رشته اغلب ایده خوبی نیست زیرا مشخص نیست که نوع بازگشتی عملیات اندیس‌گذاری
رشته چه باید باشد: یک مقدار بایت، یک کاراکتر، یک خوشه گرافیمی، یا یک قطعه رشته. بنابراین،
اگر واقعاً نیاز به استفاده از اندیس‌ها برای ایجاد قطعه‌های رشته دارید، Rust از شما می‌خواهد
بیشتر مشخص کنید.</p>
<p>به جای اندیس‌گذاری با استفاده از <code>[]</code> و یک عدد، می‌توانید از <code>[]</code> با یک بازه استفاده کنید
تا یک قطعه رشته که شامل بایت‌های خاصی است ایجاد کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>اینجا، <code>s</code> یک <code>&amp;str</code> خواهد بود که شامل چهار بایت اول رشته است. پیش‌تر اشاره کردیم که هر
یک از این کاراکترها دو بایت طول دارند، که به این معنی است که مقدار <code>s</code> برابر با <code>Зд</code> خواهد بود.</p>
<p>اگر سعی کنیم فقط بخشی از بایت‌های یک کاراکتر را با چیزی مثل <code>&amp;hello[0..1]</code> برش دهیم،
Rust در زمان اجرا دچار خطا می‌شود، به همان شکلی که اگر یک اندیس (index)نامعتبر در یک بردار
دسترسی داده شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>هنگام ایجاد قطعه‌های رشته با بازه‌ها باید احتیاط کنید، زیرا این کار ممکن است باعث خرابی
برنامه شما شود.</p>
<h3 id="متدهایی-برای-پیمایش-در-رشتهها"><a class="header" href="#متدهایی-برای-پیمایش-در-رشتهها">متدهایی برای پیمایش در رشته‌ها</a></h3>
<p>بهترین راه برای کار با بخش‌هایی از رشته‌ها این است که به وضوح مشخص کنید که آیا می‌خواهید
روی کاراکترها یا بایت‌ها کار کنید. برای مقادیر اسکالر Unicode منفرد، از متد <code>chars</code> استفاده کنید.
فراخوانی <code>chars</code> روی <code>"Зд"</code> دو مقدار از نوع <code>char</code> را جدا کرده و بازمی‌گرداند، و می‌توانید
با استفاده از نتیجه پیمایش کنید تا به هر عنصر دسترسی پیدا کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>این کد خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>به صورت جایگزین، متد <code>bytes</code> هر بایت خام را بازمی‌گرداند که ممکن است برای حوزه کاری شما مناسب باشد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>این کد چهار بایتی که این رشته را تشکیل می‌دهند چاپ خواهد کرد:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>اما حتماً به یاد داشته باشید که مقادیر اسکالر Unicode معتبر ممکن است از بیش از یک بایت تشکیل شده باشند.</p>
<p>دریافت خوشه‌های گرافیمی از رشته‌ها، همانند اسکریپت Devanagari، پیچیده است، بنابراین این قابلیت
توسط کتابخانه استاندارد ارائه نمی‌شود. اگر به این قابلیت نیاز دارید، کرایت‌هایی در
<a href="https://crates.io/">crates.io</a><!-- ignore --> موجود هستند.</p>
<h3 id="رشتهها-اینقدر-ساده-نیستند"><a class="header" href="#رشتهها-اینقدر-ساده-نیستند">رشته‌ها اینقدر ساده نیستند</a></h3>
<p>به طور خلاصه، رشته‌ها پیچیده هستند. زبان‌های برنامه‌نویسی مختلف انتخاب‌های متفاوتی درباره نحوه
نمایش این پیچیدگی به برنامه‌نویس می‌کنند. Rust انتخاب کرده است که مدیریت صحیح داده‌های
<code>String</code> رفتار پیش‌فرض برای تمام برنامه‌های Rust باشد، که به این معنی است که برنامه‌نویسان
باید در ابتدا بیشتر درباره مدیریت داده‌های UTF-8 فکر کنند. این معامله پیچیدگی بیشتری از رشته‌ها
را نسبت به سایر زبان‌های برنامه‌نویسی نشان می‌دهد، اما از مواجهه با خطاهای مربوط به کاراکترهای
غیر-ASCII در مراحل بعدی چرخه توسعه جلوگیری می‌کند.</p>
<p>خبر خوب این است که کتابخانه استاندارد عملکردهای زیادی را بر اساس انواع <code>String</code> و <code>&amp;str</code>
برای کمک به مدیریت صحیح این شرایط پیچیده ارائه می‌دهد. حتماً مستندات را برای متدهای مفیدی مانند
<code>contains</code> برای جستجو در یک رشته و <code>replace</code> برای جایگزینی بخش‌هایی از یک رشته با رشته‌ای دیگر
بررسی کنید.</p>
<p>بیایید به چیزی کمی کمتر پیچیده برویم: هش مپ‌ها!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ذخیره-کلیدها-با-مقادیر-مرتبط-در-هش-مپها"><a class="header" href="#ذخیره-کلیدها-با-مقادیر-مرتبط-در-هش-مپها">ذخیره کلیدها با مقادیر مرتبط در هش مپ‌ها</a></h2>
<p>آخرین مورد از مجموعه‌های رایج ما، <em>هش مپ</em> است. نوع <code>HashMap&lt;K, V&gt;</code> یک نگاشت از کلیدهایی
با نوع <code>K</code> به مقادیری با نوع <code>V</code> را با استفاده از یک <em>تابع هش</em> ذخیره می‌کند، که تعیین می‌کند
چگونه این کلیدها و مقادیر در حافظه قرار بگیرند. بسیاری از زبان‌های برنامه‌نویسی از این نوع
ساختار داده پشتیبانی می‌کنند، اما اغلب از نام‌های متفاوتی مانند <em>هش</em>، <em>مپ</em>، <em>شیء</em>،
<em>جدول هش</em>، <em>دایرکتوری</em>، یا <em>آرایه ارتباطی</em> برای اشاره به آن استفاده می‌کنند.</p>
<p>هش مپ‌ها زمانی مفید هستند که بخواهید داده‌ها را نه با استفاده از یک اندیس، مانند بردارها،
بلکه با استفاده از یک کلید که می‌تواند هر نوعی باشد، جستجو کنید. برای مثال، در یک بازی،
می‌توانید امتیاز هر تیم را در یک هش مپ ذخیره کنید که هر کلید نام یک تیم و هر مقدار
امتیاز آن تیم باشد. با داشتن نام یک تیم، می‌توانید امتیاز آن را بازیابی کنید.</p>
<p>در این بخش، به API اصلی هش مپ‌ها می‌پردازیم، اما امکانات بیشتری در توابع تعریف شده
روی <code>HashMap&lt;K, V&gt;</code> در کتابخانه استاندارد وجود دارد. مانند همیشه، مستندات کتابخانه
استاندارد را برای اطلاعات بیشتر بررسی کنید.</p>
<h3 id="ایجاد-یک-هش-مپ-جدید"><a class="header" href="#ایجاد-یک-هش-مپ-جدید">ایجاد یک هش مپ جدید</a></h3>
<p>یکی از راه‌های ایجاد یک هش مپ خالی استفاده از <code>new</code> و افزودن عناصر با <code>insert</code> است.
در لیست ۸-۲۰، ما امتیازات دو تیم به نام‌های <em>Blue</em> و <em>Yellow</em> را پیگیری می‌کنیم. تیم
آبی با ۱۰ امتیاز و تیم زرد با ۵۰ امتیاز شروع می‌کنند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-20: ایجاد یک هش مپ جدید و درج تعدادی کلید و مقدار</figcaption>
</figure>
<p>توجه داشته باشید که ابتدا باید <code>HashMap</code> را از بخش مجموعه‌های کتابخانه استاندارد <code>use</code>
کنیم. از میان سه مجموعه رایج ما، این یکی کمتر مورد استفاده قرار می‌گیرد، بنابراین به طور
پیش‌فرض در محدوده وارد نمی‌شود. همچنین، هش مپ‌ها از حمایت کمتری از کتابخانه استاندارد
برخوردارند؛ برای مثال، هیچ ماکروی داخلی برای ساخت آن‌ها وجود ندارد.</p>
<p>همانند بردارها، هش مپ‌ها داده‌های خود را روی heap ذخیره می‌کنند. این <code>HashMap</code> دارای
کلیدهایی از نوع <code>String</code> و مقادیری از نوع <code>i32</code> است. مانند بردارها، هش مپ‌ها همگن هستند:
تمام کلیدها باید از یک نوع باشند و تمام مقادیر نیز باید از یک نوع باشند.</p>
<h3 id="دسترسی-به-مقادیر-در-یک-هش-مپ"><a class="header" href="#دسترسی-به-مقادیر-در-یک-هش-مپ">دسترسی به مقادیر در یک هش مپ</a></h3>
<p>می‌توانیم یک مقدار را با ارائه کلید آن به متد <code>get</code> از هش مپ دریافت کنیم، همانطور که
در لیست ۸-۲۱ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-21: دسترسی به امتیاز تیم Blue ذخیره شده در هش مپ</figcaption>
</figure>
<p>اینجا، مقدار <code>score</code> برابر با مقداری خواهد بود که به تیم Blue مرتبط است، و نتیجه <code>10</code> خواهد بود.
متد <code>get</code> یک <code>Option&lt;&amp;V&gt;</code> را بازمی‌گرداند؛ اگر هیچ مقداری برای آن کلید در هش مپ وجود نداشته
باشد، <code>get</code> مقدار <code>None</code> را بازمی‌گرداند. این برنامه مقدار <code>Option</code> را با فراخوانی <code>copied</code>
برای دریافت یک <code>Option&lt;i32&gt;</code> به جای <code>Option&lt;&amp;i32&gt;</code> مدیریت می‌کند، سپس با استفاده از <code>unwrap_or</code>
مقدار <code>score</code> را به صفر تنظیم می‌کند اگر <code>scores</code> یک ورودی برای کلید نداشته باشد.</p>
<p>می‌توانیم بر روی هر جفت کلید–مقدار در یک هش مپ مشابه کاری که با بردارها انجام می‌دهیم،
با استفاده از یک حلقه <code>for</code> پیمایش کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>این کد هر جفت را به ترتیب دلخواه چاپ خواهد کرد:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="هش-مپها-و-مالکیت"><a class="header" href="#هش-مپها-و-مالکیت">هش مپ‌ها و مالکیت</a></h3>
<p>برای انواعی که ویژگی <code>Copy</code> را پیاده‌سازی می‌کنند، مانند <code>i32</code>، مقادیر درون هش مپ کپی می‌شوند.
برای مقادیر مالک مانند <code>String</code>، مقادیر منتقل شده و هش مپ مالک آن‌ها خواهد شد، همانطور که در
لیست ۸-۲۲ نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-22: نشان دادن اینکه کلیدها و مقادیر پس از وارد شدن به هش مپ، متعلق به آن می‌شوند</figcaption>
</figure>
<p>پس از انتقال متغیرهای <code>field_name</code> و <code>field_value</code> به هش مپ با فراخوانی <code>insert</code>، دیگر نمی‌توانیم
از آن‌ها استفاده کنیم.</p>
<p>اگر مراجع به مقادیر را درون هش مپ وارد کنیم، مقادیر به هش مپ منتقل نخواهند شد. مقادیری که
مراجع به آن‌ها اشاره می‌کنند باید حداقل تا زمانی که هش مپ معتبر است، معتبر باقی بمانند. درباره
این مسائل در بخش <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“تأیید مراجع با عمرها”</a><!-- ignore -->
در فصل ۱۰ بیشتر صحبت خواهیم کرد.</p>
<h3 id="بهروزرسانی-یک-هش-مپ"><a class="header" href="#بهروزرسانی-یک-هش-مپ">به‌روزرسانی یک هش مپ</a></h3>
<p>اگرچه تعداد جفت‌های کلید و مقدار قابل افزایش است، هر کلید یکتا فقط می‌تواند یک مقدار
مرتبط داشته باشد (اما نه بالعکس: برای مثال، هر دو تیم Blue و Yellow می‌توانند مقدار <code>10</code>
را در هش مپ <code>scores</code> ذخیره کنند).</p>
<p>وقتی می‌خواهید داده‌ها را در یک هش مپ تغییر دهید، باید تصمیم بگیرید چگونه با حالتی که
یک کلید قبلاً دارای مقدار است برخورد کنید. می‌توانید مقدار قدیمی را با مقدار جدید جایگزین کنید
و مقدار قدیمی را کاملاً نادیده بگیرید. می‌توانید مقدار قدیمی را نگه دارید و مقدار جدید را نادیده بگیرید،
فقط مقدار جدید را اضافه کنید اگر کلید <em>ندارد</em> قبلاً یک مقدار. یا می‌توانید مقدار قدیمی و مقدار جدید
را با هم ترکیب کنید. بیایید ببینیم چگونه هر یک از این کارها را انجام دهیم!</p>
<h4 id="بازنویسی-یک-مقدار"><a class="header" href="#بازنویسی-یک-مقدار">بازنویسی یک مقدار</a></h4>
<p>اگر یک کلید و مقدار را به یک هش مپ وارد کنیم و سپس همان کلید را با یک مقدار متفاوت وارد کنیم،
مقداری که با آن کلید مرتبط است جایگزین خواهد شد. حتی اگر کد در لیست ۸-۲۳ دوبار <code>insert</code> را فراخوانی کند،
هش مپ فقط یک جفت کلید–مقدار را شامل خواهد شد زیرا ما مقدار مرتبط با کلید تیم Blue را در هر دو بار وارد می‌کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-23: جایگزینی یک مقدار ذخیره شده با یک کلید خاص</figcaption>
</figure>
<p>این کد مقدار <code>{"Blue": 25}</code> را چاپ خواهد کرد. مقدار اصلی <code>10</code> بازنویسی شده است.</p>
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="اضافه-کردن-یک-کلید-و-مقدار-فقط-اگر-کلید-وجود-ندارد"><a class="header" href="#اضافه-کردن-یک-کلید-و-مقدار-فقط-اگر-کلید-وجود-ندارد">اضافه کردن یک کلید و مقدار فقط اگر کلید وجود ندارد</a></h4>
<p>بررسی اینکه آیا یک کلید خاص در هش مپ دارای مقدار است یا خیر و سپس انجام اقدامات زیر رایج است:
اگر کلید در هش مپ وجود دارد، مقدار موجود باید همانطور که هست باقی بماند؛ اگر کلید وجود ندارد،
آن را به همراه یک مقدار وارد کنید.</p>
<p>هش مپ‌ها یک API خاص برای این کار دارند که به نام <code>entry</code> شناخته می‌شود و کلیدی که می‌خواهید بررسی کنید
را به عنوان پارامتر می‌گیرد. مقدار بازگشتی متد <code>entry</code> یک enum به نام <code>Entry</code> است که نشان‌دهنده مقداری
است که ممکن است وجود داشته باشد یا نداشته باشد. فرض کنید می‌خواهیم بررسی کنیم که آیا کلید تیم Yellow
دارای مقدار مرتبط است یا خیر. اگر ندارد، می‌خواهیم مقدار <code>50</code> را وارد کنیم، و همینطور برای تیم Blue.
با استفاده از API <code>entry</code>، کد به شکل لیست ۸-۲۴ خواهد بود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-24: استفاده از متد <code>entry</code> برای وارد کردن مقدار فقط در صورتی که کلید قبلاً مقدار ندارد</figcaption>
</figure>
<p>متد <code>or_insert</code> روی <code>Entry</code> به گونه‌ای تعریف شده است که یک مرجع قابل تغییر به مقدار مرتبط با کلید
<code>Entry</code> برمی‌گرداند اگر آن کلید وجود داشته باشد، و اگر نه، پارامتر را به عنوان مقدار جدید برای
این کلید وارد کرده و یک مرجع قابل تغییر به مقدار جدید بازمی‌گرداند. این تکنیک بسیار تمیزتر از نوشتن
منطق به صورت دستی است و علاوه بر این، با بررسی‌کننده قرض بهتر کار می‌کند.</p>
<p>اجرای کد در لیست ۸-۲۴ مقدار <code>{"Yellow": 50, "Blue": 10}</code> را چاپ خواهد کرد. اولین فراخوانی به <code>entry</code>
کلید تیم Yellow را با مقدار <code>50</code> وارد می‌کند زیرا تیم Yellow قبلاً مقداری ندارد. دومین فراخوانی
به <code>entry</code> هش مپ را تغییر نمی‌دهد زیرا تیم Blue قبلاً مقدار <code>10</code> را دارد.</p>
<h4 id="بهروزرسانی-یک-مقدار-بر-اساس-مقدار-قدیمی"><a class="header" href="#بهروزرسانی-یک-مقدار-بر-اساس-مقدار-قدیمی">به‌روزرسانی یک مقدار بر اساس مقدار قدیمی</a></h4>
<p>یکی دیگر از موارد استفاده رایج برای هش مپ‌ها این است که مقدار یک کلید را جستجو کرده و سپس بر اساس
مقدار قدیمی آن را به‌روزرسانی کنیم. برای مثال، لیست ۸-۲۵ کدی را نشان می‌دهد که تعداد دفعات ظاهر شدن
هر کلمه در یک متن را می‌شمارد. ما از یک هش مپ با کلمات به عنوان کلید و مقدار برای نگهداری تعداد دفعات
ظاهر شدن هر کلمه استفاده می‌کنیم. اگر این اولین بار باشد که یک کلمه را مشاهده می‌کنیم، ابتدا مقدار
<code>0</code> را وارد می‌کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 8-25: شمارش تعداد وقوع کلمات با استفاده از یک هش مپ که کلمات و تعداد دفعات آن‌ها را ذخیره می‌کند</figcaption>
</figure>
<p>این کد مقدار <code>{"world": 2, "hello": 1, "wonderful": 1}</code> را چاپ خواهد کرد. ممکن است همین جفت‌های
کلید–مقدار را به ترتیب دیگری مشاهده کنید: به بخش <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">“دسترسی به مقادیر در یک هش مپ”</a><!-- ignore -->
رجوع کنید که توضیح می‌دهد پیمایش بر روی یک هش مپ به صورت دلخواه انجام می‌شود.</p>
<p>متد <code>split_whitespace</code> یک iterator بر روی زیررشته‌هایی که با فضای خالی جدا شده‌اند از مقدار موجود
در <code>text</code> بازمی‌گرداند. متد <code>or_insert</code> یک مرجع قابل تغییر (<code>&amp;mut V</code>) به مقدار مرتبط با کلید مشخص
برمی‌گرداند. اگر آن کلید وجود داشته باشد، مقدار بازگشتی همان مقدار موجود است؛ و اگر نه، پارامتر
را به عنوان مقدار جدید برای این کلید وارد می‌کند و مرجع قابل تغییر به مقدار جدید را بازمی‌گرداند.
در اینجا، ما این مرجع قابل تغییر را در متغیر <code>count</code> ذخیره می‌کنیم، بنابراین برای تخصیص مقدار
به آن، باید ابتدا <code>count</code> را با استفاده از عملگر ستاره (<code>*</code>) dereference کنیم. مرجع قابل تغییر
در انتهای حلقه <code>for</code> از محدوده خارج می‌شود، بنابراین تمام این تغییرات ایمن هستند و قوانین
قرض‌گیری را نقض نمی‌کنند.</p>
<h3 id="توابع-هش"><a class="header" href="#توابع-هش">توابع هش</a></h3>
<p>به طور پیش‌فرض، <code>HashMap</code> از یک تابع هش به نام <em>SipHash</em> استفاده می‌کند که مقاومت در برابر
حملات انکار سرویس (DoS) مربوط به جداول هش<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore --> را فراهم می‌کند. این سریع‌ترین
الگوریتم هش موجود نیست، اما مبادله برای امنیت بهتر با کاهش عملکرد ارزشمند است. اگر کد خود را
پروفایل کنید و متوجه شوید که تابع هش پیش‌فرض برای اهداف شما بسیار کند است، می‌توانید با مشخص کردن
یک هش‌کننده دیگر آن را تغییر دهید. یک <em>هش‌کننده</em> نوعی است که ویژگی <code>BuildHasher</code> را پیاده‌سازی
می‌کند. درباره ویژگی‌ها (traits) و نحوه پیاده‌سازی آن‌ها در <a href="ch10-02-traits.html">فصل ۱۰</a><!-- ignore --> صحبت
خواهیم کرد. نیازی نیست حتماً هش‌کننده خود را از ابتدا پیاده‌سازی کنید؛ در
<a href="https://crates.io/">crates.io</a><!-- ignore --> کتابخانه‌هایی موجود هستند که توسط کاربران Rust به
اشتراک گذاشته شده‌اند و هش‌کننده‌هایی با بسیاری از الگوریتم‌های هش رایج ارائه می‌دهند.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="خلاصه-7"><a class="header" href="#خلاصه-7">خلاصه</a></h2>
<p>بردارها، رشته‌ها، و هش مپ‌ها مقدار زیادی از قابلیت‌های مورد نیاز برای ذخیره، دسترسی، و
تغییر داده‌ها در برنامه‌ها را فراهم می‌کنند. در اینجا چند تمرین وجود دارد که اکنون باید
قادر به حل آن‌ها باشید:</p>
<ol>
<li>با داشتن یک لیست از اعداد صحیح، از یک بردار استفاده کرده و میانه (وقتی مرتب‌سازی شود، مقداری که
در موقعیت وسط قرار دارد) و مد (مقداری که بیشترین بار ظاهر می‌شود؛ یک هش مپ در اینجا مفید خواهد بود)
لیست را بازگردانید.</li>
<li>رشته‌ها را به زبان لاتین خوکی تبدیل کنید. اولین صامت هر کلمه به انتهای کلمه منتقل شده و <em>ay</em>
به آن اضافه می‌شود، بنابراین <em>first</em> به <em>irst-fay</em> تبدیل می‌شود. کلماتی که با یک حرف صدادار
شروع می‌شوند، <em>hay</em> به انتهای آن‌ها اضافه می‌شود (<em>apple</em> به <em>apple-hay</em> تبدیل می‌شود). جزئیات
مربوط به کدگذاری UTF-8 را در نظر داشته باشید!</li>
<li>با استفاده از یک هش مپ و بردارها، یک رابط متنی ایجاد کنید تا به کاربر امکان اضافه کردن نام کارمندان
به یک دپارتمان در شرکت را بدهد؛ برای مثال، “Add Sally to Engineering” یا “Add Amir to Sales”.
سپس به کاربر اجازه دهید لیستی از تمام افراد در یک دپارتمان یا تمام افراد در شرکت بر اساس
دپارتمان، مرتب شده به صورت حروف الفبا، بازیابی کند.</li>
</ol>
<p>مستندات API کتابخانه استاندارد متدهایی را که بردارها، رشته‌ها، و هش مپ‌ها دارند و برای این تمرین‌ها
مفید خواهند بود توصیف می‌کنند!</p>
<p>ما وارد برنامه‌های پیچیده‌تری شده‌ایم که در آن‌ها عملیات ممکن است با شکست مواجه شوند، بنابراین
زمان مناسبی است تا درباره مدیریت خطا صحبت کنیم. این کار را در ادامه انجام خواهیم داد!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مدیریت-خطاها"><a class="header" href="#مدیریت-خطاها">مدیریت خطاها</a></h1>
<p>خطاها واقعیتی در نرم‌افزار هستند، بنابراین Rust تعدادی ویژگی برای مدیریت شرایطی که در آن‌ها
چیزی اشتباه می‌رود ارائه می‌دهد. در بسیاری از موارد، Rust شما را مجبور می‌کند امکان وقوع خطا را
تشخیص داده و اقدامی انجام دهید تا کد شما کامپایل شود. این الزام برنامه شما را مقاوم‌تر می‌کند
زیرا اطمینان حاصل می‌کند که قبل از انتشار کد به تولید، خطاها را کشف کرده و آن‌ها را به درستی مدیریت
می‌کنید!</p>
<p>Rust خطاها را به دو دسته اصلی تقسیم می‌کند: خطاهای <em>قابل بازیابی</em> و خطاهای <em>غیرقابل بازیابی</em>.
برای یک خطای قابل بازیابی، مانند خطای <em>فایل یافت نشد</em>، احتمالاً می‌خواهیم مشکل را به کاربر
گزارش دهیم و عملیات را دوباره انجام دهیم. خطاهای غیرقابل بازیابی همیشه نشانه‌های باگ‌ها هستند،
مانند تلاش برای دسترسی به مکانی خارج از انتهای یک آرایه، بنابراین می‌خواهیم بلافاصله برنامه
را متوقف کنیم.</p>
<p>بیشتر زبان‌ها بین این دو نوع خطا تفاوت قائل نمی‌شوند و هر دو را به یک شکل مدیریت می‌کنند،
با استفاده از مکانیزم‌هایی مانند استثناها. Rust استثناها ندارد. در عوض، نوع <code>Result&lt;T, E&gt;</code> برای
خطاهای قابل بازیابی و ماکروی <code>panic!</code> که اجرای برنامه را زمانی که با یک خطای غیرقابل بازیابی
روبرو می‌شود متوقف می‌کند، ارائه می‌دهد. این فصل ابتدا به فراخوانی <code>panic!</code> می‌پردازد و سپس
در مورد بازگرداندن مقادیر <code>Result&lt;T, E&gt;</code> صحبت می‌کند. علاوه بر این، ملاحظاتی را هنگام تصمیم‌گیری
در مورد اینکه آیا سعی در بازیابی از یک خطا کنیم یا اجرای برنامه را متوقف کنیم، بررسی خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="خطاهای-غیرقابل-بازیابی-با-panic"><a class="header" href="#خطاهای-غیرقابل-بازیابی-با-panic">خطاهای غیرقابل بازیابی با <code>panic!</code></a></h2>
<p>گاهی اوقات اتفاقات بدی در کد شما رخ می‌دهد و هیچ کاری نمی‌توانید در مورد آن انجام دهید. در این موارد،
Rust ماکروی <code>panic!</code> را ارائه می‌دهد. دو راه برای ایجاد یک خطا با <code>panic!</code> وجود دارد: با انجام عملی
که باعث ایجاد خطا می‌شود (مانند دسترسی به یک اندیس (index)خارج از محدوده در یک آرایه) یا با صراحت
فراخوانی ماکروی <code>panic!</code>. در هر دو حالت، ما یک خطا در برنامه خود ایجاد می‌کنیم. به طور پیش‌فرض،
این خطاها یک پیام خطا چاپ می‌کنند، استک را unwind می‌کنند، داده‌ها را پاکسازی می‌کنند و برنامه
را متوقف می‌کنند. با استفاده از یک متغیر محیطی، می‌توانید Rust را مجبور کنید هنگام وقوع یک
<code>panic</code>، استک فراخوانی را نمایش دهد تا ردیابی منبع خطا آسان‌تر شود.</p>
<section class="note" aria-role="note">
<h3 id="unwinding-the-stack-یا-متوقف-کردن-در-پاسخ-به-یک-panic"><a class="header" href="#unwinding-the-stack-یا-متوقف-کردن-در-پاسخ-به-یک-panic">Unwinding the Stack یا متوقف کردن در پاسخ به یک Panic</a></h3>
<p>به طور پیش‌فرض، هنگامی که یک خطا رخ می‌دهد، برنامه شروع به <em>unwinding</em> می‌کند، که به معنی این
است که Rust استک را به سمت بالا پیمایش می‌کند و داده‌ها را از هر تابعی که با آن برخورد می‌کند
پاکسازی می‌کند. با این حال، پیمایش به بالا و پاکسازی کار زیادی است. بنابراین، Rust به شما اجازه
می‌دهد گزینه جایگزین <em>abort</em> کردن فوری را انتخاب کنید، که برنامه را بدون پاکسازی متوقف می‌کند.</p>
<p>حافظه‌ای که برنامه استفاده می‌کرد نیاز به پاکسازی توسط سیستم عامل خواهد داشت. اگر در پروژه
خود نیاز دارید تا فایل باینری حاصل را تا حد ممکن کوچک کنید، می‌توانید از unwind به abort در
زمان خطا تغییر دهید با اضافه کردن <code>panic = 'abort'</code> به بخش‌های مناسب <code>[profile]</code> در فایل
<em>Cargo.toml</em> خود. برای مثال، اگر می‌خواهید در حالت release در زمان وقوع خطا متوقف شوید،
این مورد را اضافه کنید:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</section>
<p>بیایید فراخوانی <code>panic!</code> را در یک برنامه ساده امتحان کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    panic!("crash and burn");
}</code></pre></pre>
</figure>
<p>وقتی برنامه را اجرا کنید، چیزی شبیه به این خواهید دید:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>فراخوانی <code>panic!</code> پیام خطای موجود در دو خط آخر را ایجاد می‌کند. خط اول پیام خطای <code>panic!</code> ما
و مکانی در کد منبع ما که این خطا رخ داده است را نشان می‌دهد: <em>src/main.rs:2:5</em> نشان می‌دهد
که این خط دوم، پنجمین کاراکتر در فایل <em>src/main.rs</em> ما است.</p>
<p>در این مورد، خط نشان داده شده بخشی از کد ما است، و اگر به آن خط برویم، فراخوانی ماکروی
<code>panic!</code> را می‌بینیم. در موارد دیگر، فراخوانی <code>panic!</code> ممکن است در کدی باشد که کد ما آن را
فراخوانی می‌کند، و نام فایل و شماره خط گزارش شده توسط پیام خطا کدی از دیگران را نشان می‌دهد
که در آن ماکروی <code>panic!</code> فراخوانی شده است، نه خطی از کد ما که در نهایت منجر به فراخوانی
<code>panic!</code> شد.</p>
<p><a id="using-a-panic-backtrace"></a></p>
<p>ما می‌توانیم از backtrace توابعی که فراخوانی <code>panic!</code> از آن‌ها آمده است استفاده کنیم تا بخش کد
ما که باعث مشکل شده است را پیدا کنیم. برای درک نحوه استفاده از backtrace یک <code>panic!</code>، بیایید
یک مثال دیگر ببینیم و مشاهده کنیم زمانی که یک فراخوانی <code>panic!</code> از یک کتابخانه به دلیل یک باگ
در کد ما رخ می‌دهد، به جای اینکه کد ما مستقیماً ماکرو را فراخوانی کند، چگونه است. لیست ۹-۱
کدی دارد که تلاش می‌کند به یک اندیس (index)در یک بردار که خارج از محدوده اندیس‌های معتبر است
دسترسی پیدا کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<figcaption>Listing 9-1: تلاش برای دسترسی به عنصری که خارج از انتهای بردار است، که منجر به فراخوانی <code>panic!</code> خواهد شد</figcaption>
</figure>
<p>در اینجا، ما سعی داریم به عنصر صدم بردار خود دسترسی پیدا کنیم (که در اندیس (index)۹۹ است زیرا اندیس‌گذاری از صفر شروع می‌شود)، اما بردار فقط سه عنصر دارد. در این وضعیت، Rust با یک خطا متوقف می‌شود. استفاده از <code>[]</code> قرار است یک عنصر را بازگرداند، اما اگر یک اندیس (index)نامعتبر را ارائه دهید، هیچ عنصری وجود ندارد که Rust بتواند به درستی بازگرداند.</p>
<p>در زبان C، تلاش برای خواندن فراتر از انتهای یک ساختار داده رفتاری نامشخص دارد. ممکن است هر چیزی که در مکان حافظه‌ای که با آن عنصر در ساختار داده مطابقت دارد باشد را دریافت کنید، حتی اگر آن حافظه متعلق به آن ساختار نباشد. این به عنوان <em>buffer overread</em> شناخته می‌شود و می‌تواند به آسیب‌پذیری‌های امنیتی منجر شود اگر یک مهاجم بتواند اندیس (index)را به گونه‌ای دستکاری کند که داده‌هایی را بخواند که نباید به آن‌ها دسترسی داشته باشد و پس از ساختار داده ذخیره شده‌اند.</p>
<p>برای محافظت از برنامه شما در برابر این نوع آسیب‌پذیری، اگر تلاش کنید یک عنصر را در یک اندیسی که وجود ندارد بخوانید، Rust اجرای برنامه را متوقف کرده و از ادامه دادن امتناع می‌کند. بیایید این موضوع را امتحان کنیم و ببینیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>این خطا به خط ۴ فایل <em>main.rs</em> ما اشاره می‌کند، جایی که سعی داریم به اندیس (index)<code>99</code> بردار <code>v</code> دسترسی پیدا کنیم.</p>
<p>خط <code>note:</code> به ما می‌گوید که می‌توانیم متغیر محیطی <code>RUST_BACKTRACE</code> را تنظیم کنیم تا یک backtrace دقیقاً از آنچه باعث خطا شده است دریافت کنیم. یک <em>backtrace</em> لیستی از تمام توابعی است که تا این نقطه فراخوانی شده‌اند. backtraceها در Rust مانند زبان‌های دیگر کار می‌کنند: کلید خواندن backtrace این است که از بالا شروع کرده و تا زمانی که فایل‌هایی که شما نوشته‌اید را ببینید، بخوانید. این همان جایی است که مشکل از آنجا منشأ گرفته است. خطوط بالاتر از آن نقطه کدی است که کد شما فراخوانی کرده است؛ خطوط پایین‌تر کدی است که کد شما را فراخوانی کرده است. این خطوط قبل و بعد ممکن است شامل کد هسته Rust، کد کتابخانه استاندارد، یا جعبه(crate)هایی که استفاده می‌کنید باشند. بیایید با تنظیم متغیر محیطی <code>RUST_BACKTRACE</code> به هر مقداری به غیر از <code>0</code> یک backtrace دریافت کنیم. لیست ۹-۲ خروجی مشابه چیزی را که خواهید دید نشان می‌دهد.</p>
<figure class="listing">
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/std/src/panicking.rs:662:5
   1: core::panicking::panic_fmt
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:74:14
   2: core::panicking::panic_bounds_check
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:276:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:302:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:16:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/alloc/src/vec/mod.rs:2920:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<figcaption>Listing 9-2: backtrace تولید شده توسط فراخوانی به <code>panic!</code> که وقتی متغیر محیطی <code>RUST_BACKTRACE</code> تنظیم شده است نمایش داده می‌شود</figcaption>
</figure>
<p>این مقدار زیادی خروجی است! خروجی دقیق ممکن است بسته به سیستم عامل و نسخه Rust شما متفاوت باشد. برای دریافت backtraceها با این اطلاعات، باید نمادهای اشکال‌زدایی (debug symbols) فعال باشند. نمادهای اشکال‌زدایی به طور پیش‌فرض هنگام استفاده از <code>cargo build</code> یا <code>cargo run</code> بدون فلگ <code>--release</code> فعال هستند، همانطور که در اینجا انجام دادیم.</p>
<p>در خروجی لیست ۹-۲، خط ۶ از backtrace به خطی در پروژه ما اشاره می‌کند که باعث مشکل شده است: خط ۴ فایل <em>src/main.rs</em>. اگر نمی‌خواهیم برنامه ما دچار خطا شود، باید بررسی خود را از مکانی که توسط اولین خطی که اشاره به فایلی که نوشته‌ایم دارد، آغاز کنیم. در لیست ۹-۱، جایی که به عمد کدی نوشته‌ایم که باعث خطا شود، راه حل رفع این خطا این است که درخواست یک عنصر فراتر از محدوده اندیس‌های بردار نکنیم. زمانی که کد شما در آینده دچار خطا می‌شود، باید بفهمید که کد با چه مقادیری چه عملی انجام می‌دهد که باعث خطا می‌شود و کد چه کاری باید انجام دهد.</p>
<p>ما در بخش <a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> or Not to <code>panic!</code>”</a><!-- ignore --> که بعداً در این فصل آمده است، دوباره به موضوع <code>panic!</code> و زمانی که باید و نباید از <code>panic!</code> برای مدیریت شرایط خطا استفاده کنیم بازخواهیم گشت. اکنون، به بررسی نحوه بازیابی از یک خطا با استفاده از <code>Result</code> می‌پردازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="خطاهای-قابل-بازیابی-با-result"><a class="header" href="#خطاهای-قابل-بازیابی-با-result">خطاهای قابل بازیابی با <code>Result</code></a></h2>
<p>بیشتر خطاها به اندازه‌ای جدی نیستند که نیاز به توقف کامل برنامه داشته باشند. گاهی اوقات وقتی
یک تابع با شکست مواجه می‌شود، دلیلی وجود دارد که می‌توانید آن را به راحتی تفسیر کرده و به آن
پاسخ دهید. برای مثال، اگر بخواهید یک فایل را باز کنید و این عملیات به دلیل وجود نداشتن فایل شکست
بخورد، ممکن است بخواهید فایل را ایجاد کنید به جای اینکه فرآیند را متوقف کنید.</p>
<p>به یاد بیاورید از بخش <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“Handling Potential Failure with <code>Result</code>”</a><!-- ignore -->
در فصل ۲ که <code>Result</code> به صورت یک enum تعریف شده که دو حالت دارد، <code>Ok</code> و <code>Err</code>، به صورت زیر:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> و <code>E</code> پارامترهای نوع جنریک هستند: ما درباره جنریک‌ها به طور کامل‌تر در فصل ۱۰ صحبت خواهیم کرد.
چیزی که اکنون باید بدانید این است که <code>T</code> نمایانگر نوع مقداری است که در حالت موفقیت در داخل <code>Ok</code>
بازگردانده می‌شود، و <code>E</code> نمایانگر نوع خطایی است که در حالت شکست در داخل <code>Err</code> بازگردانده می‌شود.
زیرا <code>Result</code> این پارامترهای نوع جنریک را دارد، می‌توانیم نوع <code>Result</code> و توابع تعریف شده روی آن را
در بسیاری از شرایط مختلف که مقادیر موفقیت و خطا ممکن است متفاوت باشند، استفاده کنیم.</p>
<p>بیایید تابعی را فراخوانی کنیم که یک مقدار <code>Result</code> را بازمی‌گرداند زیرا این تابع ممکن است با شکست
مواجه شود. در لیست ۹-۳ سعی می‌کنیم یک فایل را باز کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
<figcaption>Listing 9-3: باز کردن یک فایل</figcaption>
</figure>
<p>نوع بازگشتی <code>File::open</code> یک <code>Result&lt;T, E&gt;</code> است. پارامتر نوع جنریک <code>T</code> توسط پیاده‌سازی
<code>File::open</code> با نوع مقدار موفقیت، یعنی <code>std::fs::File</code>، که یک فایل هندل است، مقداردهی
شده است. نوع <code>E</code> استفاده شده در مقدار خطا <code>std::io::Error</code> است. این نوع بازگشتی به این معنی
است که فراخوانی <code>File::open</code> ممکن است موفقیت‌آمیز باشد و یک فایل هندل بازگرداند که می‌توانیم از
آن برای خواندن یا نوشتن استفاده کنیم. همچنین ممکن است این فراخوانی با شکست مواجه شود: برای مثال،
فایل ممکن است وجود نداشته باشد یا ممکن است مجوز دسترسی به فایل را نداشته باشیم. تابع <code>File::open</code>
باید روشی داشته باشد تا به ما بگوید که آیا موفقیت‌آمیز بود یا شکست خورد و در عین حال فایل هندل یا
اطلاعات خطا را به ما بدهد. این اطلاعات دقیقاً همان چیزی است که enum <code>Result</code> منتقل می‌کند.</p>
<p>در حالتی که <code>File::open</code> موفقیت‌آمیز باشد، مقدار در متغیر <code>greeting_file_result</code> یک نمونه از <code>Ok</code>
خواهد بود که یک فایل هندل را شامل می‌شود. در حالتی که با شکست مواجه شود، مقدار در
<code>greeting_file_result</code> یک نمونه از <code>Err</code> خواهد بود که اطلاعات بیشتری در مورد نوع خطایی که رخ
داده است را شامل می‌شود.</p>
<p>باید به کد در لیست ۹-۳ اضافه کنیم تا اقدامات متفاوتی بسته به مقداری که <code>File::open</code> بازمی‌گرداند
انجام دهیم. لیست ۹-۴ یک روش برای مدیریت <code>Result</code> با استفاده از یک ابزار پایه، یعنی عبارت <code>match</code>
که در فصل ۶ مورد بحث قرار گرفت، نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem opening the file: {error:?}"),
    };
}</code></pre></pre>
<figcaption>Listing 9-4: استفاده از عبارت <code>match</code> برای مدیریت حالت‌های <code>Result</code> که ممکن است بازگردانده شود</figcaption>
</figure>
<p>توجه داشته باشید که مانند enum <code>Option</code>، enum <code>Result</code> و حالات آن به وسیله prelude به محدوده آورده شده‌اند، بنابراین نیازی نیست قبل از حالات <code>Ok</code> و <code>Err</code> در بازوهای <code>match</code> از <code>Result::</code> استفاده کنیم.</p>
<p>وقتی نتیجه <code>Ok</code> باشد، این کد مقدار داخلی <code>file</code> را از حالت <code>Ok</code> بازمی‌گرداند و سپس آن مقدار فایل هندل را به متغیر <code>greeting_file</code> اختصاص می‌دهیم. بعد از <code>match</code>، می‌توانیم از فایل هندل برای خواندن یا نوشتن استفاده کنیم.</p>
<p>بازوی دیگر <code>match</code> حالت زمانی را مدیریت می‌کند که از <code>File::open</code> یک مقدار <code>Err</code> دریافت می‌کنیم. در این مثال، تصمیم گرفته‌ایم ماکروی <code>panic!</code> را فراخوانی کنیم. اگر فایل <em>hello.txt</em> در دایرکتوری فعلی ما وجود نداشته باشد و این کد را اجرا کنیم، خروجی زیر را از ماکروی <code>panic!</code> خواهیم دید:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>مثل همیشه، این خروجی دقیقاً به ما می‌گوید چه اشتباهی رخ داده است.</p>
<h3 id="مطابقت-بر-اساس-خطاهای-مختلف"><a class="header" href="#مطابقت-بر-اساس-خطاهای-مختلف">مطابقت بر اساس خطاهای مختلف</a></h3>
<p>کد در لیست ۹-۴ در هر صورتی که <code>File::open</code> با شکست مواجه شود، ماکروی <code>panic!</code> را فراخوانی می‌کند. با این حال، ما می‌خواهیم اقدامات متفاوتی برای دلایل مختلف شکست انجام دهیم. اگر <code>File::open</code> به دلیل وجود نداشتن فایل شکست بخورد، می‌خواهیم فایل را ایجاد کنیم و هندل فایل جدید را بازگردانیم. اگر <code>File::open</code> به دلایل دیگری شکست بخورد—برای مثال، به دلیل نداشتن مجوز باز کردن فایل—همچنان می‌خواهیم کد مانند لیست ۹-۴ <code>panic!</code> کند. برای این کار، یک عبارت <code>match</code> داخلی اضافه می‌کنیم که در لیست ۹-۵ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {e:?}"),
            },
            other_error =&gt; {
                panic!("Problem opening the file: {other_error:?}");
            }
        },
    };
}</code></pre>
<figcaption>Listing 9-5: مدیریت انواع مختلف خطاها به روش‌های مختلف</figcaption>
</figure>
<p>نوع مقداری که <code>File::open</code> درون حالت <code>Err</code> بازمی‌گرداند، <code>io::Error</code> است که یک ساختار داده ارائه شده توسط کتابخانه استاندارد است. این ساختار دارای متدی به نام <code>kind</code> است که می‌توانیم آن را برای دریافت مقدار <code>io::ErrorKind</code> فراخوانی کنیم. enum <code>io::ErrorKind</code> توسط کتابخانه استاندارد ارائه شده و شامل حالت‌هایی است که انواع مختلف خطاهای ممکن در یک عملیات <code>io</code> را نمایش می‌دهد. حالتی که می‌خواهیم از آن استفاده کنیم <code>ErrorKind::NotFound</code> است که نشان می‌دهد فایل مورد نظر برای باز کردن هنوز وجود ندارد. بنابراین، ما بر روی <code>greeting_file_result</code> مطابقت می‌دهیم، اما همچنین یک <code>match</code> داخلی بر روی <code>error.kind()</code> داریم.</p>
<p>شرطی که می‌خواهیم در <code>match</code> داخلی بررسی کنیم این است که آیا مقدار بازگردانده شده توسط <code>error.kind()</code> همان حالت <code>NotFound</code> از enum <code>ErrorKind</code> است یا خیر. اگر چنین باشد، سعی می‌کنیم فایل را با <code>File::create</code> ایجاد کنیم. با این حال، از آنجایی که <code>File::create</code> نیز ممکن است شکست بخورد، به یک بازوی دوم در عبارت <code>match</code> داخلی نیاز داریم. هنگامی که فایل نمی‌تواند ایجاد شود، یک پیام خطای متفاوت چاپ می‌شود. بازوی دوم <code>match</code> بیرونی به همان شکل باقی می‌ماند، بنابراین برنامه برای هر خطایی به جز خطای وجود نداشتن فایل، با خطا متوقف می‌شود.</p>
<section class="note" aria-role="note">
<h4 id="جایگزینهایی-برای-استفاده-از-match-با-resultt-e"><a class="header" href="#جایگزینهایی-برای-استفاده-از-match-با-resultt-e">جایگزین‌هایی برای استفاده از <code>match</code> با <code>Result&lt;T, E&gt;</code></a></h4>
<p>استفاده از <code>match</code> زیاد است! عبارت <code>match</code> بسیار مفید است اما همچنان ابتدایی محسوب می‌شود.
در فصل ۱۳، درباره closures یاد خواهید گرفت که در بسیاری از متدهایی که روی <code>Result&lt;T, E&gt;</code>
تعریف شده‌اند استفاده می‌شوند. این متدها می‌توانند هنگام مدیریت مقادیر <code>Result&lt;T, E&gt;</code> در کد شما،
مختصرتر از استفاده از <code>match</code> باشند.</p>
<p>برای مثال، در اینجا راه دیگری برای نوشتن همان منطق نشان داده شده در لیست ۹-۵ آورده شده است،
این بار با استفاده از closures و متد <code>unwrap_or_else</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}</code></pre>
<p>اگرچه این کد همان رفتار لیست ۹-۵ را دارد، اما شامل هیچ عبارت <code>match</code> نیست و خواندن آن تمیزتر است.
بعد از خواندن فصل ۱۳، به این مثال بازگردید و متد <code>unwrap_or_else</code> را در مستندات کتابخانه استاندارد
بررسی کنید. بسیاری از این متدها می‌توانند عبارت‌های <code>match</code> تو در تو را هنگام کار با خطاها ساده کنند.</p>
</section>
<h4 id="میانبرهایی-برای-توقف-برنامه-در-صورت-خطا-unwrap-و-expect"><a class="header" href="#میانبرهایی-برای-توقف-برنامه-در-صورت-خطا-unwrap-و-expect">میان‌برهایی برای توقف برنامه در صورت خطا: <code>unwrap</code> و <code>expect</code></a></h4>
<p>استفاده از <code>match</code> به اندازه کافی خوب کار می‌کند، اما ممکن است کمی طولانی باشد و همیشه به خوبی نیت
را منتقل نکند. نوع <code>Result&lt;T, E&gt;</code> دارای بسیاری از متدهای کمکی است که برای انجام وظایف خاص‌تر تعریف
شده‌اند. متد <code>unwrap</code> یک روش میان‌بر است که دقیقاً مانند عبارت <code>match</code> که در لیست ۹-۴ نوشتیم،
پیاده‌سازی شده است. اگر مقدار <code>Result</code> در حالت <code>Ok</code> باشد، <code>unwrap</code> مقدار داخل <code>Ok</code> را بازمی‌گرداند.
اگر مقدار <code>Result</code> در حالت <code>Err</code> باشد، <code>unwrap</code> ماکروی <code>panic!</code> را برای ما فراخوانی می‌کند. در اینجا
یک مثال از استفاده از <code>unwrap</code> آورده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</figure>
<p>اگر این کد را بدون فایل <em>hello.txt</em> اجرا کنیم، یک پیام خطا از فراخوانی <code>panic!</code> که متد <code>unwrap</code> انجام
می‌دهد خواهیم دید:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>به همین ترتیب، متد <code>expect</code> به ما اجازه می‌دهد پیام خطای ماکروی <code>panic!</code> را نیز انتخاب کنیم. استفاده
از <code>expect</code> به جای <code>unwrap</code> و ارائه پیام‌های خطای خوب می‌تواند نیت شما را بهتر منتقل کند و پیگیری منبع
یک خطا را آسان‌تر کند. سینتکس <code>expect</code> به این شکل است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}</code></pre></pre>
</figure>
<p>ما از <code>expect</code> به همان شیوه‌ای استفاده می‌کنیم که از <code>unwrap</code> استفاده می‌کنیم: برای بازگرداندن فایل هندل یا فراخوانی ماکروی <code>panic!</code>. پیام خطایی که توسط <code>expect</code> در فراخوانی <code>panic!</code> استفاده می‌شود، پارامتری است که ما به <code>expect</code> می‌دهیم، به جای پیام پیش‌فرض <code>panic!</code> که توسط <code>unwrap</code> استفاده می‌شود. اینجا چیزی است که به نظر می‌رسد:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>در کد با کیفیت تولید، بیشتر Rustaceanها <code>expect</code> را به جای <code>unwrap</code> انتخاب می‌کنند و اطلاعات بیشتری درباره اینکه چرا عملیات باید همیشه موفقیت‌آمیز باشد ارائه می‌دهند. به این ترتیب، اگر فرضیات شما هرگز اشتباه ثابت شوند، اطلاعات بیشتری برای استفاده در اشکال‌زدایی خواهید داشت.</p>
<h3 id="انتشار-خطاها-propagating-errors"><a class="header" href="#انتشار-خطاها-propagating-errors">انتشار خطاها (Propagating Errors)</a></h3>
<p>وقتی پیاده‌سازی یک تابع چیزی را فراخوانی می‌کند که ممکن است شکست بخورد، به جای مدیریت خطا درون خود تابع، می‌توانید خطا را به کدی که تابع را فراخوانی کرده است بازگردانید تا تصمیم بگیرد چه کاری انجام دهد. این به عنوان <em>انتشار خطا</em> شناخته می‌شود و کنترل بیشتری به کدی که فراخوانی می‌کند می‌دهد، جایی که ممکن است اطلاعات یا منطقی وجود داشته باشد که تعیین کند چگونه باید خطا مدیریت شود بیشتر از آنچه در زمینه کد شما موجود است.</p>
<p>برای مثال، لیست ۹-۶ یک تابع را نشان می‌دهد که یک نام کاربری را از یک فایل می‌خواند. اگر فایل وجود نداشته باشد یا قابل خواندن نباشد، این تابع آن خطاها را به کدی که تابع را فراخوانی کرده بازمی‌گرداند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-6: یک تابع که خطاها را به کد فراخوانی‌کننده بازمی‌گرداند با استفاده از <code>match</code></figcaption>
</figure>
<p>این تابع می‌تواند به روشی بسیار کوتاه‌تر نوشته شود، اما ما قرار است با انجام بسیاری از کارها به صورت دستی، مدیریت خطاها را بررسی کنیم. در انتها، راه کوتاه‌تر را نشان خواهیم داد. بیایید ابتدا به نوع بازگشتی تابع نگاه کنیم: <code>Result&lt;String, io::Error&gt;</code>. این به این معناست که تابع مقداری از نوع <code>Result&lt;T, E&gt;</code> بازمی‌گرداند، جایی که پارامتر جنریک <code>T</code> با نوع مشخص <code>String</code> مقداردهی شده است و نوع جنریک <code>E</code> با نوع مشخص <code>io::Error</code>.</p>
<p>اگر این تابع بدون هیچ مشکلی موفقیت‌آمیز باشد، کدی که این تابع را فراخوانی می‌کند یک مقدار <code>Ok</code> دریافت می‌کند که یک <code>String</code> را نگهداری می‌کند—نام کاربری‌ای که این تابع از فایل خوانده است. اگر این تابع با مشکلی مواجه شود، کدی که آن را فراخوانی کرده است یک مقدار <code>Err</code> دریافت می‌کند که یک نمونه از <code>io::Error</code> را نگهداری می‌کند که اطلاعات بیشتری درباره مشکلاتی که رخ داده‌اند شامل می‌شود. ما <code>io::Error</code> را به عنوان نوع بازگشتی این تابع انتخاب کردیم زیرا این همان نوعی است که مقدار خطا از هر دو عملیات فراخوانی شده در بدنه این تابع که ممکن است شکست بخورند بازمی‌گرداند: تابع <code>File::open</code> و متد <code>read_to_string</code>.</p>
<p>بدنه تابع با فراخوانی تابع <code>File::open</code> شروع می‌شود. سپس مقدار <code>Result</code> را با یک <code>match</code> مشابه
آنچه در لیست ۹-۴ دیدیم مدیریت می‌کنیم. اگر <code>File::open</code> موفق شود، هندل فایل در متغیر الگو <code>file</code>
به مقدار در متغیر قابل تغییر <code>username_file</code> تبدیل می‌شود و تابع ادامه می‌یابد. در حالت <code>Err</code>،
به جای فراخوانی <code>panic!</code>، از کلیدواژه <code>return</code> استفاده می‌کنیم تا زودتر از تابع خارج شویم و مقدار
خطا از <code>File::open</code> که اکنون در متغیر الگو <code>e</code> قرار دارد را به کدی که تابع را فراخوانی کرده بازگردانیم.</p>
<p>بنابراین، اگر یک هندل فایل در <code>username_file</code> داشته باشیم، تابع سپس یک <code>String</code> جدید در متغیر
<code>username</code> ایجاد کرده و متد <code>read_to_string</code> را روی هندل فایل در <code>username_file</code> فراخوانی می‌کند
تا محتوای فایل را در <code>username</code> بخواند. متد <code>read_to_string</code> نیز یک مقدار <code>Result</code> بازمی‌گرداند
زیرا ممکن است با شکست مواجه شود، حتی اگر <code>File::open</code> موفق بوده باشد. بنابراین، به یک <code>match</code>
دیگر برای مدیریت آن <code>Result</code> نیاز داریم: اگر <code>read_to_string</code> موفق شود، آنگاه تابع ما موفقیت‌آمیز
بوده و نام کاربری از فایل که اکنون در <code>username</code> است، درون یک <code>Ok</code> بازمی‌گرداند. اگر
<code>read_to_string</code> شکست بخورد، مقدار خطا را به همان شیوه‌ای که مقدار خطا را در <code>match</code> که مقدار
بازگشتی <code>File::open</code> را مدیریت می‌کرد بازمی‌گردانیم. با این حال، نیازی نیست که به صراحت بگوییم
<code>return</code>، زیرا این آخرین عبارت در تابع است.</p>
<p>کدی که این تابع را فراخوانی می‌کند سپس مدیریت دریافت مقدار <code>Ok</code> که شامل یک نام کاربری است یا
مقدار <code>Err</code> که شامل یک <code>io::Error</code> است را انجام می‌دهد. این به کدی که تابع را فراخوانی می‌کند بستگی دارد
که تصمیم بگیرد با این مقادیر چه کاری انجام دهد. اگر کد فراخوانی‌کننده یک مقدار <code>Err</code> دریافت کند،
می‌تواند <code>panic!</code> را فراخوانی کرده و برنامه را متوقف کند، از یک نام کاربری پیش‌فرض استفاده کند، یا
به جای فایل نام کاربری را از مکان دیگری جستجو کند، برای مثال. ما اطلاعات کافی درباره اینکه کد فراخوانی‌کننده
دقیقاً چه می‌خواهد انجام دهد نداریم، بنابراین تمام اطلاعات موفقیت یا خطا را به بالا منتقل می‌کنیم
تا آن را به درستی مدیریت کند.</p>
<p>این الگوی انتشار خطاها در Rust آن‌قدر رایج است که Rust عملگر <code>?</code> را برای آسان‌تر کردن این کار
فراهم می‌کند.</p>
<h4 id="یک-میانبر-برای-انتشار-خطاها-عملگر-"><a class="header" href="#یک-میانبر-برای-انتشار-خطاها-عملگر-">یک میان‌بر برای انتشار خطاها: عملگر <code>?</code></a></h4>
<p>لیست ۹-۷ پیاده‌سازی <code>read_username_from_file</code> را نشان می‌دهد که همان عملکرد لیست ۹-۶ را دارد،
اما این پیاده‌سازی از عملگر <code>?</code> استفاده می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-7: یک تابع که خطاها را به کد فراخوانی‌کننده با استفاده از عملگر <code>?</code> بازمی‌گرداند</figcaption>
</figure>
<p>عملگر <code>?</code> که پس از یک مقدار <code>Result</code> قرار می‌گیرد تقریباً به همان شیوه‌ای عمل می‌کند که عبارات
<code>match</code> که برای مدیریت مقادیر <code>Result</code> در لیست ۹-۶ تعریف کردیم. اگر مقدار <code>Result</code> در حالت
<code>Ok</code> باشد، مقدار درون <code>Ok</code> از این عبارت بازگردانده می‌شود و برنامه ادامه می‌یابد. اگر مقدار در حالت
<code>Err</code> باشد، مقدار <code>Err</code> از کل تابع بازگردانده می‌شود به گونه‌ای که انگار کلیدواژه <code>return</code> را
استفاده کرده‌ایم تا مقدار خطا به کد فراخوانی‌کننده منتقل شود.</p>
<p>تفاوتی بین کاری که عبارت <code>match</code> در لیست ۹-۶ انجام می‌دهد و کاری که عملگر <code>?</code> انجام می‌دهد وجود
دارد: مقادیر خطا که عملگر <code>?</code> روی آن‌ها فراخوانی می‌شود از طریق تابع <code>from</code> که در ویژگی
<code>From</code> کتابخانه استاندارد تعریف شده است عبور می‌کنند، که برای تبدیل مقادیر از یک نوع به نوع دیگر
استفاده می‌شود. وقتی عملگر <code>?</code> تابع <code>from</code> را فراخوانی می‌کند، نوع خطای دریافت شده به نوع خطای
تعریف شده در نوع بازگشتی تابع فعلی تبدیل می‌شود. این موضوع زمانی مفید است که یک تابع یک نوع خطا
را برای نمایش تمام راه‌هایی که ممکن است یک تابع شکست بخورد بازگرداند، حتی اگر بخش‌هایی ممکن است
به دلایل بسیار مختلفی شکست بخورند.</p>
<p>برای مثال، می‌توانیم تابع <code>read_username_from_file</code> در لیست ۹-۷ را تغییر دهیم تا یک نوع خطای سفارشی به نام <code>OurError</code> که تعریف کرده‌ایم بازگرداند. اگر همچنین <code>impl From&lt;io::Error&gt; for OurError</code> را تعریف کنیم تا یک نمونه از <code>OurError</code> را از یک <code>io::Error</code> بسازد، سپس فراخوانی‌های عملگر <code>?</code> در بدنه تابع <code>read_username_from_file</code> تابع <code>from</code> را فراخوانی کرده و نوع خطاها را بدون نیاز به افزودن کد اضافی به تابع تبدیل می‌کنند.</p>
<p>در زمینه لیست ۹-۷، عملگر <code>?</code> در انتهای فراخوانی <code>File::open</code> مقدار درون یک <code>Ok</code> را به متغیر <code>username_file</code> بازمی‌گرداند. اگر خطایی رخ دهد، عملگر <code>?</code> زودتر از کل تابع خارج شده و هر مقدار <code>Err</code> را به کد فراخوانی‌کننده بازمی‌گرداند. همین موضوع برای عملگر <code>?</code> در انتهای فراخوانی <code>read_to_string</code> صدق می‌کند.</p>
<p>عملگر <code>?</code> مقدار زیادی از کد اضافی را حذف کرده و پیاده‌سازی این تابع را ساده‌تر می‌کند. حتی می‌توانیم این کد را بیشتر کوتاه کنیم با زنجیره کردن فراخوانی متدها بلافاصله بعد از <code>?</code>، همانطور که در لیست ۹-۸ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-8: زنجیره کردن فراخوانی متدها پس از عملگر <code>?</code></figcaption>
</figure>
<p>ما ایجاد <code>String</code> جدید در <code>username</code> را به ابتدای تابع منتقل کرده‌ایم؛ آن قسمت تغییر نکرده است. به جای ایجاد یک متغیر <code>username_file</code>، ما فراخوانی <code>read_to_string</code> را مستقیماً به نتیجه <code>File::open("hello.txt")?</code> زنجیره کرده‌ایم. همچنان یک عملگر <code>?</code> در انتهای فراخوانی <code>read_to_string</code> داریم و همچنان مقدار <code>Ok</code> شامل <code>username</code> را زمانی که هر دو <code>File::open</code> و <code>read_to_string</code> موفق هستند بازمی‌گردانیم، به جای بازگرداندن خطاها. عملکرد دوباره همانند لیست ۹-۶ و لیست ۹-۷ است؛ این فقط یک روش متفاوت و کاربرپسندتر برای نوشتن آن است.</p>
<p>لیست ۹-۹ روشی برای کوتاه‌تر کردن این کد با استفاده از <code>fs::read_to_string</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-9: استفاده از <code>fs::read_to_string</code> به جای باز کردن و سپس خواندن فایل</figcaption>
</figure>
<p>خواندن یک فایل به یک رشته یک عملیات نسبتاً رایج است، بنابراین کتابخانه استاندارد تابع مناسب <code>fs::read_to_string</code> را فراهم می‌کند که فایل را باز می‌کند، یک <code>String</code> جدید ایجاد می‌کند، محتوای فایل را می‌خواند، محتوا را در آن <code>String</code> قرار می‌دهد و آن را بازمی‌گرداند. البته، استفاده از <code>fs::read_to_string</code> به ما فرصتی برای توضیح تمام مدیریت خطاها نمی‌دهد، بنابراین ابتدا آن را به روش طولانی‌تر انجام دادیم.</p>
<h4 id="جایی-که-میتوان-از-عملگر--استفاده-کرد"><a class="header" href="#جایی-که-میتوان-از-عملگر--استفاده-کرد">جایی که می‌توان از عملگر <code>?</code> استفاده کرد</a></h4>
<p>عملگر <code>?</code> فقط در توابعی استفاده می‌شود که نوع بازگشتی آن‌ها با مقدار استفاده شده توسط <code>?</code> سازگار باشد. این به این دلیل است که عملگر <code>?</code> برای بازگرداندن زودهنگام یک مقدار از تابع تعریف شده است، به همان شیوه‌ای که عبارت <code>match</code> در لیست ۹-۶ تعریف شده است. در لیست ۹-۶، <code>match</code> از یک مقدار <code>Result</code> استفاده می‌کرد و بازوی بازگشتی زودهنگام یک مقدار <code>Err(e)</code> را بازمی‌گرداند. نوع بازگشتی تابع باید یک <code>Result</code> باشد تا با این بازگشت سازگار باشد.</p>
<p>در لیست ۹-۱۰، بیایید به خطایی که دریافت می‌کنیم وقتی که از عملگر <code>?</code> در یک تابع <code>main</code> با نوع بازگشتی‌ای که با نوع مقدار استفاده شده در <code>?</code> سازگار نیست استفاده می‌کنیم نگاه کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
<figcaption>Listing 9-10: تلاش برای استفاده از <code>?</code> در تابع <code>main</code> که نوع بازگشتی آن <code>()</code> است و کامپایل نمی‌شود.</figcaption>
</figure>
<p>این کد یک فایل را باز می‌کند، که ممکن است شکست بخورد. عملگر <code>?</code> مقدار <code>Result</code> بازگردانده شده توسط <code>File::open</code> را دنبال می‌کند، اما این تابع <code>main</code> نوع بازگشتی <code>()</code> دارد، نه <code>Result</code>. وقتی این کد را کامپایل می‌کنیم، پیام خطای زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>این خطا نشان می‌دهد که فقط می‌توان از عملگر <code>?</code> در توابعی که نوع بازگشتی آن‌ها <code>Result</code>، <code>Option</code>، یا نوع دیگری که <code>FromResidual</code> را پیاده‌سازی می‌کند استفاده کرد.</p>
<p>برای رفع این خطا، دو انتخاب دارید. یکی این است که نوع بازگشتی تابع خود را تغییر دهید تا با مقداری که از عملگر <code>?</code> استفاده می‌کنید سازگار باشد، به شرطی که محدودیتی مانع از انجام این کار نداشته باشید. انتخاب دیگر این است که از یک <code>match</code> یا یکی از متدهای <code>Result&lt;T, E&gt;</code> برای مدیریت <code>Result&lt;T, E&gt;</code> به شیوه‌ای که مناسب است استفاده کنید.</p>
<p>پیام خطا همچنین اشاره کرد که <code>?</code> می‌تواند با مقادیر <code>Option&lt;T&gt;</code> نیز استفاده شود. همانند استفاده از <code>?</code> روی <code>Result</code>، فقط می‌توانید از <code>?</code> روی <code>Option</code> در تابعی استفاده کنید که یک <code>Option</code> بازمی‌گرداند. رفتار عملگر <code>?</code> وقتی روی یک <code>Option&lt;T&gt;</code> فراخوانی می‌شود شبیه به رفتار آن وقتی روی یک <code>Result&lt;T, E&gt;</code> فراخوانی می‌شود: اگر مقدار <code>None</code> باشد، <code>None</code> زودهنگام از تابع بازگردانده می‌شود. اگر مقدار <code>Some</code> باشد، مقدار داخل <code>Some</code> مقدار نتیجه عبارت است و تابع ادامه می‌دهد. لیست ۹-۱۱ مثالی از تابعی را نشان می‌دهد که آخرین کاراکتر خط اول متن داده شده را پیدا می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\nHow are you today?"),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-11: استفاده از عملگر <code>?</code> روی یک مقدار <code>Option&lt;T&gt;</code></figcaption>
</figure>
<p>این تابع <code>Option&lt;char&gt;</code> بازمی‌گرداند زیرا ممکن است یک کاراکتر وجود داشته باشد، اما ممکن است وجود نداشته باشد. این کد آرگومان قطعه رشته <code>text</code> را می‌گیرد و متد <code>lines</code> را روی آن فراخوانی می‌کند، که یک iterator روی خطوط درون رشته بازمی‌گرداند. چون این تابع می‌خواهد خط اول را بررسی کند، <code>next</code> را روی iterator فراخوانی می‌کند تا اولین مقدار از iterator را دریافت کند. اگر <code>text</code> رشته‌ای خالی باشد، این فراخوانی به <code>next</code> مقدار <code>None</code> بازمی‌گرداند، که در این صورت از <code>?</code> برای متوقف کردن و بازگرداندن <code>None</code> از <code>last_char_of_first_line</code> استفاده می‌کنیم. اگر <code>text</code> رشته خالی نباشد، <code>next</code> یک مقدار <code>Some</code> شامل یک قطعه رشته از خط اول در <code>text</code> بازمی‌گرداند.</p>
<p>عملگر <code>?</code> قطعه رشته را استخراج می‌کند و می‌توانیم متد <code>chars</code> را روی آن فراخوانی کنیم تا یک iterator از کاراکترهای آن دریافت کنیم. ما به آخرین کاراکتر در این خط اول علاقه‌مند هستیم، بنابراین متد <code>last</code> را فراخوانی می‌کنیم تا آخرین مورد در iterator را بازگرداند. این یک <code>Option</code> است زیرا ممکن است خط اول رشته‌ای خالی باشد؛ برای مثال، اگر <code>text</code> با یک خط خالی شروع شود اما کاراکترهایی در خطوط دیگر داشته باشد، مانند <code>"\nhi"</code>. با این حال، اگر آخرین کاراکتری در خط اول وجود داشته باشد، در حالت <code>Some</code> بازگردانده می‌شود. عملگر <code>?</code> در میانه به ما راهی مختصر برای بیان این منطق می‌دهد و اجازه می‌دهد تابع را در یک خط پیاده‌سازی کنیم. اگر نمی‌توانستیم از عملگر <code>?</code> روی <code>Option</code> استفاده کنیم، باید این منطق را با فراخوانی متدهای بیشتر یا یک عبارت <code>match</code> پیاده‌سازی می‌کردیم.</p>
<p>توجه داشته باشید که می‌توانید از عملگر <code>?</code> روی یک <code>Result</code> در یک تابع که یک <code>Result</code> بازمی‌گرداند استفاده کنید، و می‌توانید از عملگر <code>?</code> روی یک <code>Option</code> در یک تابع که یک <code>Option</code> بازمی‌گرداند استفاده کنید، اما نمی‌توانید این دو را با هم ترکیب کنید. عملگر <code>?</code> به طور خودکار یک <code>Result</code> را به یک <code>Option</code> یا برعکس تبدیل نمی‌کند؛ در این موارد، می‌توانید از متدهایی مانند <code>ok</code> روی <code>Result</code> یا <code>ok_or</code> روی <code>Option</code> برای تبدیل صریح استفاده کنید.</p>
<p>تا کنون، تمام توابع <code>main</code> که استفاده کرده‌ایم مقدار <code>()</code> بازمی‌گرداندند. تابع <code>main</code> خاص است زیرا نقطه ورود و خروج یک برنامه اجرایی است، و محدودیت‌هایی در نوع بازگشتی آن وجود دارد تا برنامه همانطور که انتظار می‌رود رفتار کند.</p>
<p>خوشبختانه، <code>main</code> می‌تواند یک <code>Result&lt;(), E&gt;</code> نیز بازگرداند. لیست ۹-۱۲ کد لیست ۹-۱۰ را دارد، اما نوع بازگشتی <code>main</code> را به <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> تغییر داده‌ایم و یک مقدار بازگشتی <code>Ok(())</code> به انتهای آن اضافه کرده‌ایم. این کد اکنون کامپایل می‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
<figcaption>Listing 9-12: تغییر تابع <code>main</code> برای بازگرداندن <code>Result&lt;(), E&gt;</code> اجازه می‌دهد از عملگر <code>?</code> روی مقادیر <code>Result</code> استفاده شود.</figcaption>
</figure>
<p>نوع <code>Box&lt;dyn Error&gt;</code> یک <em>شیء ویژگی</em> (trait object) است که در بخش <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects that Allow for Values of Different Types”</a><!-- ignore --> در فصل ۱۸ درباره آن صحبت خواهیم کرد. در حال حاضر، می‌توانید <code>Box&lt;dyn Error&gt;</code> را به معنای “هر نوع خطا” در نظر بگیرید. استفاده از <code>?</code> روی یک مقدار <code>Result</code> در یک تابع <code>main</code> با نوع خطای <code>Box&lt;dyn Error&gt;</code> مجاز است زیرا این امکان را می‌دهد که هر مقدار <code>Err</code> زودتر بازگردانده شود. اگرچه بدنه این تابع <code>main</code> فقط خطاهای نوع <code>std::io::Error</code> را بازمی‌گرداند، با مشخص کردن <code>Box&lt;dyn Error&gt;</code>، این امضا حتی اگر کد بیشتری که خطاهای دیگری بازمی‌گرداند به بدنه <code>main</code> اضافه شود، صحیح باقی می‌ماند.</p>
<p>وقتی یک تابع <code>main</code> یک <code>Result&lt;(), E&gt;</code> بازمی‌گرداند، برنامه اجرایی با مقدار <code>0</code> خارج می‌شود اگر <code>main</code> مقدار <code>Ok(())</code> بازگرداند و با یک مقدار غیر صفر خارج می‌شود اگر <code>main</code> مقدار <code>Err</code> بازگرداند. برنامه‌های اجرایی نوشته شده در C هنگام خروج مقادیر صحیح بازمی‌گردانند: برنامه‌هایی که با موفقیت خارج می‌شوند مقدار صحیح <code>0</code> را بازمی‌گردانند و برنامه‌هایی که دچار خطا می‌شوند مقداری غیر از <code>0</code> بازمی‌گردانند. Rust نیز مقادیر صحیح را از برنامه‌های اجرایی بازمی‌گرداند تا با این قرارداد سازگار باشد.</p>
<p>تابع <code>main</code> می‌تواند هر نوعی را که ویژگی <a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>std::process::Termination</code></a><!-- ignore --> را پیاده‌سازی می‌کند بازگرداند، که شامل تابع <code>report</code> است که یک <code>ExitCode</code> بازمی‌گرداند. مستندات کتابخانه استاندارد را برای اطلاعات بیشتر درباره پیاده‌سازی ویژگی <code>Termination</code> برای انواع خودتان مطالعه کنید.</p>
<p>اکنون که جزئیات فراخوانی <code>panic!</code> یا بازگرداندن <code>Result</code> را بررسی کردیم، بیایید به موضوع نحوه تصمیم‌گیری درباره اینکه کدامیک در چه مواردی مناسب است بازگردیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="آیا-باید-از-panic-استفاده-کنیم-یا-نه"><a class="header" href="#آیا-باید-از-panic-استفاده-کنیم-یا-نه">آیا باید از <code>panic!</code> استفاده کنیم یا نه؟</a></h2>
<p>چگونه تصمیم می‌گیرید که چه زمانی باید <code>panic!</code> را فراخوانی کنید و چه زمانی باید یک <code>Result</code> بازگردانید؟ وقتی کد دچار خطا می‌شود، هیچ راهی برای بازیابی وجود ندارد. شما می‌توانید در هر وضعیت خطایی، چه قابل بازیابی باشد و چه نباشد، <code>panic!</code> را فراخوانی کنید، اما در این صورت، شما به جای کد فراخوانی‌کننده تصمیم می‌گیرید که وضعیت غیرقابل بازیابی است. وقتی تصمیم می‌گیرید یک مقدار <code>Result</code> بازگردانید، به کد فراخوانی‌کننده گزینه‌هایی می‌دهید. کد فراخوانی‌کننده می‌تواند انتخاب کند که تلاش کند خطا را به روشی که برای وضعیت خودش مناسب است بازیابی کند، یا می‌تواند تصمیم بگیرد که مقدار <code>Err</code> در این مورد غیرقابل بازیابی است و بنابراین <code>panic!</code> را فراخوانی کرده و خطای قابل بازیابی شما را به یک خطای غیرقابل بازیابی تبدیل کند. بنابراین، بازگرداندن <code>Result</code> یک انتخاب پیش‌فرض خوب است وقتی تابعی تعریف می‌کنید که ممکن است شکست بخورد.</p>
<p>در وضعیت‌هایی مانند مثال‌ها، کد نمونه‌سازی (prototype) و آزمون‌ها، مناسب‌تر است که کدی بنویسید که متوقف شود به جای بازگرداندن یک <code>Result</code>. بیایید بررسی کنیم چرا، سپس وضعیت‌هایی را بحث کنیم که کامپایلر نمی‌تواند بفهمد که شکست غیرممکن است، اما شما به عنوان یک انسان می‌توانید. این فصل با برخی دستورالعمل‌های کلی درباره تصمیم‌گیری درباره اینکه آیا در کد کتابخانه باید از <code>panic!</code> استفاده کرد یا نه، به پایان خواهد رسید.</p>
<h3 id="مثالها-کد-نمونهسازی-و-آزمونها"><a class="header" href="#مثالها-کد-نمونهسازی-و-آزمونها">مثال‌ها، کد نمونه‌سازی، و آزمون‌ها</a></h3>
<p>وقتی مثالی می‌نویسید تا یک مفهوم را توضیح دهید، همچنین افزودن کد مدیریت خطای قدرتمند می‌تواند مثال را کمتر واضح کند. در مثال‌ها، این نکته فهمیده می‌شود که فراخوانی به متدی مانند <code>unwrap</code> که ممکن است متوقف شود، به عنوان یک جایگزین برای روشی که می‌خواهید برنامه شما خطاها را مدیریت کند در نظر گرفته می‌شود، که می‌تواند بسته به آنچه بقیه کد شما انجام می‌دهد متفاوت باشد.</p>
<p>به همین ترتیب، متدهای <code>unwrap</code> و <code>expect</code> بسیار مفید هستند وقتی که در حال نمونه‌سازی هستید و هنوز تصمیم نگرفته‌اید که چگونه خطاها را مدیریت کنید. آن‌ها نشانه‌های واضحی در کد شما می‌گذارند برای زمانی که آماده باشید برنامه خود را قدرتمندتر کنید.</p>
<p>اگر یک متد در یک آزمون شکست بخورد، می‌خواهید کل آزمون شکست بخورد، حتی اگر آن متد ویژگی‌ای که تحت آزمون قرار دارد نباشد. از آنجا که <code>panic!</code> راهی است که یک آزمون به عنوان شکست‌خورده علامت‌گذاری می‌شود، فراخوانی <code>unwrap</code> یا <code>expect</code> دقیقاً همان چیزی است که باید اتفاق بیفتد.</p>
<h3 id="مواردی-که-شما-اطلاعات-بیشتری-نسبت-به-کامپایلر-دارید"><a class="header" href="#مواردی-که-شما-اطلاعات-بیشتری-نسبت-به-کامپایلر-دارید">مواردی که شما اطلاعات بیشتری نسبت به کامپایلر دارید</a></h3>
<p>همچنین مناسب است که <code>unwrap</code> یا <code>expect</code> را فراخوانی کنید وقتی منطق دیگری دارید که تضمین می‌کند مقدار <code>Result</code> دارای یک مقدار <code>Ok</code> خواهد بود، اما این منطق چیزی نیست که کامپایلر آن را بفهمد. شما همچنان یک مقدار <code>Result</code> دارید که باید مدیریت کنید: عملیاتی که فراخوانی می‌کنید همچنان امکان شکست خوردن دارد، حتی اگر به صورت منطقی در وضعیت خاص شما غیرممکن باشد. اگر می‌توانید با بازرسی دستی کد تضمین کنید که هرگز یک حالت <code>Err</code> نخواهید داشت، کاملاً قابل قبول است که <code>unwrap</code> را فراخوانی کنید و حتی بهتر است که دلیل خود را در متن <code>expect</code> مستند کنید. در اینجا یک مثال آورده شده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>ما یک نمونه <code>IpAddr</code> را با تجزیه یک رشته ثابت‌شده ایجاد می‌کنیم. ما می‌توانیم ببینیم که <code>127.0.0.1</code> یک آدرس IP معتبر است، بنابراین استفاده از <code>expect</code> در اینجا قابل قبول است. با این حال، داشتن یک رشته ثابت‌شده و معتبر نوع بازگشتی متد <code>parse</code> را تغییر نمی‌دهد: ما همچنان یک مقدار <code>Result</code> دریافت می‌کنیم و کامپایلر همچنان ما را مجبور می‌کند که با <code>Result</code> برخورد کنیم، انگار که حالت <code>Err</code> ممکن است، زیرا کامپایلر به اندازه کافی هوشمند نیست تا ببیند این رشته همیشه یک آدرس IP معتبر است. اگر رشته آدرس IP از یک کاربر می‌آمد به جای اینکه در برنامه ثابت شده باشد و بنابراین امکان شکست وجود داشت، قطعاً می‌خواستیم که <code>Result</code> را به روشی قدرتمندتر مدیریت کنیم. اشاره به این فرض که این آدرس IP ثابت‌شده است، ما را ترغیب می‌کند که در صورت نیاز به دریافت آدرس IP از منبع دیگری در آینده، <code>expect</code> را به کد مدیریت خطای بهتر تغییر دهیم.</p>
<h3 id="دستورالعملهایی-برای-مدیریت-خطاها"><a class="header" href="#دستورالعملهایی-برای-مدیریت-خطاها">دستورالعمل‌هایی برای مدیریت خطاها</a></h3>
<p>توصیه می‌شود که کد شما زمانی که ممکن است به وضعیت نامناسبی برسد، دچار <code>panic!</code> شود. در این زمینه، یک <em>وضعیت نامناسب</em> زمانی رخ می‌دهد که برخی فرضیات، تضمین‌ها، قراردادها، یا تغییرناپذیری‌ها شکسته شوند، مانند زمانی که مقادیر نامعتبر، مقادیر متناقض، یا مقادیر گمشده به کد شما پاس داده می‌شوند—به علاوه یکی یا بیشتر از شرایط زیر:</p>
<ul>
<li>وضعیت نامناسب چیزی غیرمنتظره است، بر خلاف چیزی که احتمالاً گهگاهی رخ می‌دهد، مانند کاربری که داده‌ها را در قالب اشتباه وارد می‌کند.</li>
<li>کد شما پس از این نقطه نیاز دارد که به عدم وجود در این وضعیت نامناسب تکیه کند، به جای اینکه مشکل را در هر مرحله بررسی کند.</li>
<li>راه مناسبی برای رمزگذاری این اطلاعات در نوع‌هایی که استفاده می‌کنید وجود ندارد. ما در بخش <a href="ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“رمزگذاری وضعیت‌ها و رفتار به عنوان نوع‌ها”</a><!-- ignore --> در فصل ۱۸ یک مثال از آنچه که منظورمان است را بررسی خواهیم کرد.</li>
</ul>
<p>اگر کسی کد شما را فراخوانی کند و مقادیری که منطقی نیستند را پاس دهد، بهتر است که یک خطا بازگردانید تا کاربر کتابخانه بتواند تصمیم بگیرد که در آن مورد چه کاری انجام دهد. با این حال، در مواردی که ادامه دادن می‌تواند ناامن یا مضر باشد، بهترین انتخاب ممکن است فراخوانی <code>panic!</code> و هشدار به شخصی که از کتابخانه شما استفاده می‌کند درباره باگ در کد آن‌ها باشد تا بتوانند آن را در حین توسعه رفع کنند. به همین ترتیب، <code>panic!</code> اغلب مناسب است اگر کد خارجی که از کنترل شما خارج است را فراخوانی می‌کنید و آن کد یک وضعیت نامعتبر بازمی‌گرداند که شما هیچ راهی برای رفع آن ندارید.</p>
<p>با این حال، زمانی که شکست مورد انتظار است، مناسب‌تر است که یک <code>Result</code> بازگردانید تا یک فراخوانی <code>panic!</code>. مثال‌ها شامل پردازشی هستند که داده‌های نادرست دریافت می‌کند یا یک درخواست HTTP که بازگشت وضعیت نشان می‌دهد که به محدودیت نرخ برخورد کرده‌اید. در این موارد، بازگرداندن یک <code>Result</code> نشان می‌دهد که شکست یک احتمال مورد انتظار است که کد فراخوانی‌کننده باید تصمیم بگیرد چگونه آن را مدیریت کند.</p>
<p>وقتی کد شما عملیاتی انجام می‌دهد که می‌تواند در صورت فراخوانی با مقادیر نامعتبر کاربر را در معرض خطر قرار دهد، کد شما باید ابتدا مقادیر را تأیید کند و اگر مقادیر نامعتبر هستند دچار <code>panic!</code> شود. این بیشتر به دلایل ایمنی است: تلاش برای انجام عملیات روی داده‌های نامعتبر می‌تواند کد شما را در معرض آسیب‌پذیری‌ها قرار دهد. این دلیل اصلی است که کتابخانه استاندارد اگر شما تلاش کنید به حافظه خارج از محدوده دسترسی پیدا کنید، دچار <code>panic!</code> می‌شود: تلاش برای دسترسی به حافظه‌ای که به ساختار داده جاری تعلق ندارد یک مشکل امنیتی رایج است. توابع اغلب <em>قراردادهایی</em> دارند: رفتار آن‌ها فقط در صورتی تضمین می‌شود که ورودی‌ها نیازمندی‌های خاصی را برآورده کنند. دچار <code>panic!</code> شدن وقتی که قرارداد نقض می‌شود منطقی است زیرا نقض قرارداد همیشه نشان‌دهنده یک باگ در طرف فراخوانی‌کننده است و نوع خطایی نیست که بخواهید کد فراخوانی‌کننده به طور صریح مدیریت کند. در واقع، هیچ راه معقولی برای بازیابی کد فراخوانی‌کننده وجود ندارد؛ <em>برنامه‌نویسان فراخوانی‌کننده</em> باید کد را اصلاح کنند. قراردادهای یک تابع، به خصوص زمانی که نقض آن باعث <code>panic!</code> می‌شود، باید در مستندات API تابع توضیح داده شوند.</p>
<p>با این حال، داشتن بررسی‌های خطا در تمام توابع شما بسیار طولانی و ناخوشایند خواهد بود. خوشبختانه، شما می‌توانید از سیستم نوع Rust (و در نتیجه بررسی نوعی که توسط کامپایلر انجام می‌شود) برای انجام بسیاری از بررسی‌ها استفاده کنید. اگر تابع شما یک نوع خاص را به عنوان پارامتر داشته باشد، می‌توانید با اطمینان از اینکه کامپایلر قبلاً تضمین کرده است که یک مقدار معتبر دارید، منطق کد خود را پیش ببرید. برای مثال، اگر شما یک نوع به جای یک <code>Option</code> داشته باشید، برنامه شما انتظار دارد که <em>چیزی</em> به جای <em>هیچ‌چیز</em> وجود داشته باشد. سپس کد شما نیازی به مدیریت دو حالت برای حالت‌های <code>Some</code> و <code>None</code> ندارد: فقط یک حالت برای داشتن یک مقدار به طور قطعی خواهد داشت. کدی که سعی می‌کند هیچ‌چیز به تابع شما پاس دهد حتی کامپایل نخواهد شد، بنابراین تابع شما نیازی به بررسی این حالت در زمان اجرا ندارد. مثال دیگر استفاده از یک نوع عددی بدون علامت مانند <code>u32</code> است که تضمین می‌کند پارامتر هرگز منفی نخواهد بود.</p>
<h3 id="ایجاد-انواع-سفارشی-برای-اعتبارسنجی"><a class="header" href="#ایجاد-انواع-سفارشی-برای-اعتبارسنجی">ایجاد انواع سفارشی برای اعتبارسنجی</a></h3>
<p>بیایید ایده استفاده از سیستم نوع Rust برای اطمینان از داشتن یک مقدار معتبر را یک قدم فراتر ببریم و به ایجاد یک نوع سفارشی برای اعتبارسنجی نگاه کنیم. بازی حدس عدد در فصل ۲ را به یاد بیاورید که کد ما از کاربر خواست تا یک عدد بین ۱ تا ۱۰۰ حدس بزند. ما هرگز اعتبارسنجی نکردیم که حدس کاربر بین این اعداد باشد قبل از اینکه آن را با عدد مخفی مقایسه کنیم؛ فقط بررسی کردیم که حدس مثبت باشد. در این مورد، پیامدها چندان شدید نبودند: خروجی ما با پیام‌های “خیلی بزرگ” یا “خیلی کوچک” همچنان درست بود. اما این می‌تواند بهبودی مفید باشد که کاربر را به سمت حدس‌های معتبر هدایت کنیم و رفتار متفاوتی داشته باشیم وقتی کاربر عددی خارج از محدوده حدس می‌زند در مقابل زمانی که، برای مثال، حروف تایپ می‌کند.</p>
<p>یک راه برای انجام این کار این است که حدس را به جای فقط یک <code>u32</code>، به صورت یک <code>i32</code> تجزیه کنیم تا اجازه دهیم اعداد منفی نیز در نظر گرفته شوند، و سپس یک بررسی برای اینکه عدد در محدوده است یا نه اضافه کنیم، مانند زیر:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</figure>
<p>عبارت <code>if</code> بررسی می‌کند که آیا مقدار ما خارج از محدوده است، به کاربر درباره مشکل اطلاع می‌دهد و <code>continue</code> را فراخوانی می‌کند تا تکرار بعدی حلقه شروع شود و درخواست یک حدس دیگر شود. بعد از عبارت <code>if</code>، می‌توانیم با مقایسه بین <code>guess</code> و عدد مخفی ادامه دهیم، زیرا می‌دانیم که <code>guess</code> بین ۱ و ۱۰۰ است.</p>
<p>با این حال، این یک راه‌حل ایده‌آل نیست: اگر بسیار حیاتی باشد که برنامه فقط بر روی مقادیر بین ۱ و ۱۰۰ عمل کند، و برنامه توابع زیادی با این نیاز داشته باشد، داشتن چنین بررسی‌هایی در هر تابع خسته‌کننده خواهد بود (و ممکن است عملکرد را تحت تأثیر قرار دهد).</p>
<p>در عوض، می‌توانیم یک نوع جدید ایجاد کنیم و اعتبارسنجی‌ها را در یک تابع برای ایجاد یک نمونه از نوع جدید قرار دهیم به جای تکرار اعتبارسنجی‌ها در همه‌جا. به این ترتیب، استفاده از نوع جدید در امضاهای توابع ایمن است و می‌توان با اطمینان از مقادیری که دریافت می‌کنند استفاده کرد. لیست ۹-۱۳ یک روش برای تعریف یک نوع <code>Guess</code> را نشان می‌دهد که فقط یک نمونه از <code>Guess</code> ایجاد می‌کند اگر تابع <code>new</code> مقداری بین ۱ و ۱۰۰ دریافت کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 9-13: یک نوع <code>Guess</code> که فقط با مقادیر بین ۱ و ۱۰۰ ادامه می‌دهد</figcaption>
</figure>
<p>ابتدا یک ساختار داده به نام <code>Guess</code> تعریف می‌کنیم که دارای یک فیلد به نام <code>value</code> است که یک <code>i32</code> نگه می‌دارد. اینجا جایی است که عدد ذخیره خواهد شد.</p>
<p>سپس یک تابع وابسته به نام <code>new</code> روی <code>Guess</code> پیاده‌سازی می‌کنیم که نمونه‌هایی از مقادیر <code>Guess</code> ایجاد می‌کند. تابع <code>new</code> به گونه‌ای تعریف شده که یک پارامتر به نام <code>value</code> از نوع <code>i32</code> داشته باشد و یک <code>Guess</code> بازگرداند. کدی که در بدنه تابع <code>new</code> قرار دارد مقدار <code>value</code> را بررسی می‌کند تا مطمئن شود که بین ۱ و ۱۰۰ است. اگر مقدار <code>value</code> این آزمون را پاس نکند، یک فراخوانی به <code>panic!</code> انجام می‌دهیم، که به برنامه‌نویسی که کد فراخوانی‌کننده را می‌نویسد هشدار می‌دهد که باگی دارد که باید برطرف کند، زیرا ایجاد یک <code>Guess</code> با مقدار <code>value</code> خارج از این محدوده قرارداد تابع <code>Guess::new</code> را نقض می‌کند. شرایطی که ممکن است باعث <code>panic!</code> در <code>Guess::new</code> شود باید در مستندات عمومی API آن مورد بحث قرار گیرد؛ ما در فصل ۱۴ درباره قراردادهای مستندات که نشان‌دهنده احتمال وقوع <code>panic!</code> هستند صحبت خواهیم کرد. اگر مقدار <code>value</code> آزمون را پاس کند، یک <code>Guess</code> جدید با فیلد <code>value</code> تنظیم شده به پارامتر <code>value</code> ایجاد می‌کنیم و <code>Guess</code> را بازمی‌گردانیم.</p>
<p>سپس یک متد به نام <code>value</code> پیاده‌سازی می‌کنیم که <code>self</code> را قرض می‌گیرد، هیچ پارامتر دیگری ندارد و یک <code>i32</code> بازمی‌گرداند. این نوع متد گاهی اوقات <em>getter</em> نامیده می‌شود زیرا هدف آن دریافت داده‌ای از فیلدهای خود و بازگرداندن آن است. این متد عمومی ضروری است زیرا فیلد <code>value</code> ساختار داده <code>Guess</code> خصوصی است. مهم است که فیلد <code>value</code> خصوصی باشد تا کدی که از ساختار <code>Guess</code> استفاده می‌کند مجاز نباشد مقدار <code>value</code> را مستقیماً تنظیم کند: کدی که خارج از ماژول است <em>باید</em> از تابع <code>Guess::new</code> برای ایجاد یک نمونه از <code>Guess</code> استفاده کند، و بنابراین تضمین می‌شود که هیچ راهی برای ایجاد یک <code>Guess</code> با مقدار <code>value</code> وجود ندارد که توسط شرایط در تابع <code>Guess::new</code> بررسی نشده باشد.</p>
<p>تابعی که یک پارامتر می‌گیرد یا فقط اعدادی بین ۱ و ۱۰۰ بازمی‌گرداند می‌تواند در امضای خود اعلام کند که یک <code>Guess</code> می‌گیرد یا بازمی‌گرداند به جای یک <code>i32</code> و نیازی به انجام بررسی‌های اضافی در بدنه خود ندارد.</p>
<h2 id="خلاصه-8"><a class="header" href="#خلاصه-8">خلاصه</a></h2>
<p>ویژگی‌های مدیریت خطای Rust طراحی شده‌اند تا به شما کمک کنند کدی قدرتمندتر بنویسید. ماکروی <code>panic!</code> نشان می‌دهد که برنامه شما در حالتی قرار دارد که نمی‌تواند آن را مدیریت کند و به شما امکان می‌دهد فرآیند را متوقف کنید به جای اینکه سعی کنید با مقادیر نامعتبر یا نادرست ادامه دهید. Enum <code>Result</code> از سیستم نوع Rust استفاده می‌کند تا نشان دهد که عملیات ممکن است به روشی شکست بخورد که کد شما می‌تواند از آن بازیابی کند. می‌توانید از <code>Result</code> برای اطلاع دادن به کدی که کد شما را فراخوانی می‌کند استفاده کنید که باید موفقیت یا شکست احتمالی را نیز مدیریت کند. استفاده از <code>panic!</code> و <code>Result</code> در شرایط مناسب باعث می‌شود کد شما در برابر مشکلات اجتناب‌ناپذیر قابل اطمینان‌تر شود.</p>
<p>حالا که راه‌های مفید استفاده کتابخانه استاندارد از جنریک‌ها با Enums <code>Option</code> و <code>Result</code> را دیده‌اید، درباره نحوه عملکرد جنریک‌ها و نحوه استفاده از آن‌ها در کد خود صحبت خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="انواع-جنریک-ویژگیها-traits-و-طول-عمرها-lifetimes"><a class="header" href="#انواع-جنریک-ویژگیها-traits-و-طول-عمرها-lifetimes">انواع جنریک، ویژگی‌ها (Traits)، و طول عمرها (Lifetimes)</a></h1>
<p>هر زبان برنامه‌نویسی ابزارهایی برای مدیریت موثر تکرار مفاهیم دارد. در Rust، یکی از این ابزارها <em>جنریک‌ها</em> هستند: جایگزین‌های انتزاعی برای انواع مشخص یا ویژگی‌های دیگر. ما می‌توانیم رفتار جنریک‌ها یا نحوه ارتباط آن‌ها با جنریک‌های دیگر را بیان کنیم بدون اینکه بدانیم هنگام کامپایل و اجرای کد چه چیزی جایگزین آن‌ها خواهد شد.</p>
<p>توابع می‌توانند پارامترهایی از نوع جنریک بگیرند، به جای یک نوع مشخص مانند <code>i32</code> یا <code>String</code>، به همان روشی که پارامترهایی با مقادیر ناشناخته می‌گیرند تا بتوانند کد مشابهی را روی مقادیر مشخص مختلف اجرا کنند. در واقع، ما قبلاً در فصل ۶ با <code>Option&lt;T&gt;</code>، در فصل ۸ با <code>Vec&lt;T&gt;</code> و <code>HashMap&lt;K, V&gt;</code>، و در فصل ۹ با <code>Result&lt;T, E&gt;</code> از جنریک‌ها استفاده کرده‌ایم. در این فصل، یاد خواهید گرفت که چگونه انواع، توابع، و متدهای خود را با جنریک‌ها تعریف کنید!</p>
<p>ابتدا نحوه استخراج یک تابع برای کاهش تکرار کد را مرور می‌کنیم. سپس از همان تکنیک برای ایجاد یک تابع جنریک از دو تابع که تنها در نوع پارامترهایشان متفاوت هستند استفاده خواهیم کرد. همچنین توضیح خواهیم داد که چگونه می‌توان از انواع جنریک در تعریف ساختار داده‌ها (struct) و شمارش‌ها (enum) استفاده کرد.</p>
<p>سپس یاد می‌گیرید که چگونه از <em>ویژگی‌ها</em> (Traits) برای تعریف رفتار به صورت جنریک استفاده کنید. می‌توانید ویژگی‌ها را با انواع جنریک ترکیب کنید تا نوع جنریک را محدود کنید که فقط آن نوع‌هایی را بپذیرد که رفتار خاصی دارند، به جای هر نوعی.</p>
<p>در نهایت، درباره <em>طول عمر‌ها</em> (Lifetimes) صحبت خواهیم کرد: نوعی از جنریک‌ها که به کامپایلر اطلاعاتی درباره نحوه ارتباط مراجع با یکدیگر می‌دهند. طول عمرها به ما اجازه می‌دهند اطلاعات کافی درباره مقادیر قرض گرفته شده به کامپایلر بدهیم تا اطمینان حاصل کند که مراجع در شرایط بیشتری معتبر خواهند بود.</p>
<h2 id="حذف-تکرار-با-استخراج-یک-تابع"><a class="header" href="#حذف-تکرار-با-استخراج-یک-تابع">حذف تکرار با استخراج یک تابع</a></h2>
<p>جنریک‌ها به ما اجازه می‌دهند که نوع‌های مشخص را با یک جایگزین که نمایانگر چندین نوع است جایگزین کنیم تا تکرار کد را حذف کنیم. قبل از ورود به نحو جنریک‌ها، ابتدا به نحوه حذف تکرار به روشی که شامل انواع جنریک نمی‌شود، با استخراج یک تابع که مقادیر مشخص را با یک جایگزین که نمایانگر مقادیر چندگانه است جایگزین می‌کند، نگاه خواهیم کرد. سپس از همان تکنیک برای استخراج یک تابع جنریک استفاده خواهیم کرد! با بررسی نحوه تشخیص کد تکراری که می‌توانید به یک تابع استخراج کنید، شروع به تشخیص کد تکراری خواهید کرد که می‌تواند از جنریک‌ها استفاده کند.</p>
<p>با برنامه کوتاه در لیست ۱۰-۱ که بزرگ‌ترین عدد را در یک لیست پیدا می‌کند، شروع می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<figcaption>Listing 10-1: یافتن بزرگ‌ترین عدد در یک لیست اعداد</figcaption>
</figure>
<p>ما یک لیست از اعداد صحیح را در متغیر <code>number_list</code> ذخیره می‌کنیم و یک مرجع به اولین عدد در لیست را در متغیری به نام <code>largest</code> قرار می‌دهیم. سپس تمام اعداد لیست را پیمایش می‌کنیم و اگر عدد فعلی بزرگ‌تر از عدد ذخیره شده در <code>largest</code> باشد، مرجع در آن متغیر را جایگزین می‌کنیم. با این حال، اگر عدد فعلی کوچک‌تر یا مساوی با بزرگ‌ترین عدد دیده شده تاکنون باشد، متغیر تغییری نمی‌کند و کد به عدد بعدی در لیست می‌رود. پس از بررسی تمام اعداد در لیست، <code>largest</code> باید به بزرگ‌ترین عدد اشاره کند که در این مورد ۱۰۰ است.</p>
<p>اکنون از ما خواسته شده است که بزرگ‌ترین عدد را در دو لیست مختلف اعداد پیدا کنیم. برای انجام این کار، می‌توانیم انتخاب کنیم که کد در لیست ۱۰-۱ را تکرار کنیم و از همان منطق در دو مکان مختلف در برنامه استفاده کنیم، همانطور که در لیست ۱۰-۲ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}</code></pre></pre>
<figcaption>Listing 10-2: کدی برای یافتن بزرگ‌ترین عدد در <em>دو</em> لیست اعداد</figcaption>
</figure>
<p>اگرچه این کد کار می‌کند، تکرار کد خسته‌کننده و مستعد خطاست. همچنین وقتی بخواهیم کد را تغییر دهیم، باید به یاد داشته باشیم که آن را در مکان‌های مختلف به‌روزرسانی کنیم.</p>
<p>برای حذف این تکرار، یک انتزاع ایجاد خواهیم کرد با تعریف یک تابع که روی هر لیستی از اعداد صحیح که به عنوان پارامتر پاس داده می‌شود عمل می‌کند. این راه‌حل کد ما را واضح‌تر می‌کند و به ما اجازه می‌دهد مفهوم یافتن بزرگ‌ترین عدد در یک لیست را به صورت انتزاعی بیان کنیم.</p>
<p>در لیست ۱۰-۳، کدی که بزرگ‌ترین عدد را پیدا می‌کند در تابعی به نام <code>largest</code> استخراج می‌کنیم. سپس این تابع را فراخوانی می‌کنیم تا بزرگ‌ترین عدد را در دو لیست از لیست ۱۰-۲ پیدا کنیم. همچنین می‌توانیم از این تابع روی هر لیست دیگری از مقادیر <code>i32</code> که ممکن است در آینده داشته باشیم استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<figcaption>Listing 10-3: کد انتزاعی برای یافتن بزرگ‌ترین عدد در دو لیست</figcaption>
</figure>
<p>تابع <code>largest</code> یک پارامتر به نام <code>list</code> دارد که نمایانگر هر بخش مشخصی از مقادیر <code>i32</code> است که ممکن است به تابع پاس دهیم. در نتیجه، وقتی تابع را فراخوانی می‌کنیم، کد روی مقادیر مشخصی که پاس می‌دهیم اجرا می‌شود.</p>
<p>به طور خلاصه، مراحل زیر را برای تغییر کد از لیست ۱۰-۲ به لیست ۱۰-۳ طی کردیم:</p>
<ol>
<li>کد تکراری را شناسایی کنید.</li>
<li>کد تکراری را به بدنه یک تابع استخراج کرده و ورودی‌ها و مقادیر بازگشتی آن کد را در امضای تابع مشخص کنید.</li>
<li>دو نمونه از کد تکراری را به جای آن با فراخوانی تابع به‌روزرسانی کنید.</li>
</ol>
<p>در مرحله بعد، از همین مراحل با جنریک‌ها برای کاهش تکرار کد استفاده خواهیم کرد. همانطور که بدنه تابع می‌تواند روی یک <code>list</code> انتزاعی به جای مقادیر مشخص عمل کند، جنریک‌ها به کد اجازه می‌دهند که روی انواع انتزاعی عمل کند.</p>
<p>برای مثال، فرض کنید دو تابع داشتیم: یکی که بزرگ‌ترین مورد را در یک بخش از مقادیر <code>i32</code> پیدا می‌کند و دیگری که بزرگ‌ترین مورد را در یک بخش از مقادیر <code>char</code> پیدا می‌کند. چگونه می‌توانیم این تکرار را حذف کنیم؟ بیایید پیدا کنیم!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="انواع-داده-جنریک"><a class="header" href="#انواع-داده-جنریک">انواع داده جنریک</a></h2>
<p>ما از جنریک‌ها برای ایجاد تعریف‌هایی برای مواردی مانند امضای توابع یا ساختارها (struct) استفاده می‌کنیم، که سپس می‌توانیم با انواع داده مشخص مختلف از آن‌ها استفاده کنیم. بیایید ابتدا ببینیم چگونه می‌توان توابع، ساختارها، شمارش‌ها (enum)، و متدها را با استفاده از جنریک‌ها تعریف کرد. سپس درباره اینکه جنریک‌ها چگونه بر عملکرد کد تأثیر می‌گذارند صحبت خواهیم کرد.</p>
<h3 id="در-تعریف-توابع"><a class="header" href="#در-تعریف-توابع">در تعریف توابع</a></h3>
<p>هنگام تعریف یک تابع که از جنریک‌ها استفاده می‌کند، جنریک‌ها را در امضای تابع قرار می‌دهیم، جایی که معمولاً نوع داده پارامترها و مقدار بازگشتی را مشخص می‌کنیم. این کار کد ما را انعطاف‌پذیرتر می‌کند و به فراخوانی‌کنندگان تابع ما عملکرد بیشتری ارائه می‌دهد، در حالی که از تکرار کد جلوگیری می‌کند.</p>
<p>با ادامه تابع <code>largest</code>، لیست ۱۰-۴ دو تابع را نشان می‌دهد که هر دو بزرگ‌ترین مقدار را در یک بخش (slice) پیدا می‌کنند. سپس این‌ها را به یک تابع واحد که از جنریک‌ها استفاده می‌کند ترکیب خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("The largest char is {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<figcaption>Listing 10-4: دو تابع که فقط در نام‌ها و انواع موجود در امضاهایشان متفاوت هستند</figcaption>
</figure>
<p>تابع <code>largest_i32</code> همان تابعی است که در لیست ۱۰-۳ استخراج کردیم و بزرگ‌ترین مقدار <code>i32</code> را در یک بخش پیدا می‌کند. تابع <code>largest_char</code> بزرگ‌ترین مقدار <code>char</code> را در یک بخش پیدا می‌کند. بدنه توابع دارای کد یکسانی هستند، بنابراین با معرفی یک پارامتر نوع جنریک در یک تابع واحد، تکرار را حذف می‌کنیم.</p>
<p>برای پارامتری کردن نوع‌ها در یک تابع جدید، باید نام پارامتر نوع را مشخص کنیم، همانطور که برای پارامترهای مقداری در یک تابع انجام می‌دهیم. می‌توانید از هر شناسه‌ای به عنوان نام پارامتر نوع استفاده کنید. اما از آنجا که طبق قرارداد، نام‌های پارامتر نوع در Rust کوتاه هستند، اغلب فقط یک حرف، و قرارداد نام‌گذاری نوع در Rust UpperCamelCase است، ما از <code>T</code> استفاده می‌کنیم. کوتاه برای <em>type</em>، <code>T</code> انتخاب پیش‌فرض بیشتر برنامه‌نویسان Rust است.</p>
<p>وقتی از یک پارامتر در بدنه تابع استفاده می‌کنیم، باید نام پارامتر را در امضا اعلام کنیم تا کامپایلر بداند آن نام به چه معناست. به طور مشابه، وقتی از نام پارامتر نوع در امضای تابع استفاده می‌کنیم، باید نام پارامتر نوع را قبل از استفاده از آن اعلام کنیم. برای تعریف تابع جنریک <code>largest</code>، نام نوع‌ها را داخل پرانتزهای زاویه‌ای، <code>&lt;&gt;</code>، بین نام تابع و لیست پارامتر قرار می‌دهیم، مانند زیر:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>این تعریف را به این صورت می‌خوانیم: تابع <code>largest</code> بر روی یک نوع <code>T</code> جنریک است. این تابع یک پارامتر به نام <code>list</code> دارد، که یک بخش از مقادیر نوع <code>T</code> است. تابع <code>largest</code> یک مرجع به مقداری از همان نوع <code>T</code> بازمی‌گرداند.</p>
<p>لیست ۱۰-۵ تعریف تابع ترکیبی <code>largest</code> با استفاده از نوع داده جنریک در امضای آن را نشان می‌دهد. این لیست همچنین نشان می‌دهد که چگونه می‌توان تابع را با یک بخش از مقادیر <code>i32</code> یا مقادیر <code>char</code> فراخوانی کرد. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود، اما بعداً در این فصل آن را رفع خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {result}");
}</code></pre>
<figcaption>Listing 10-5: تابع <code>largest</code> با استفاده از پارامترهای نوع جنریک؛ این کد هنوز کامپایل نمی‌شود</figcaption>
</figure>
<p>اگر همین حالا این کد را کامپایل کنیم، این خطا را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>متن کمکی به <code>std::cmp::PartialOrd</code> اشاره می‌کند که یک <em>ویژگی</em> (trait) است، و ما در بخش بعدی درباره ویژگی‌ها صحبت خواهیم کرد. در حال حاضر، بدانید که این خطا بیان می‌کند که بدنه تابع <code>largest</code> برای همه نوع‌های ممکن که <code>T</code> می‌تواند باشد، کار نمی‌کند. از آنجا که می‌خواهیم مقادیر نوع <code>T</code> را در بدنه مقایسه کنیم، فقط می‌توانیم از نوع‌هایی استفاده کنیم که مقادیرشان قابل مرتب‌سازی باشد. برای فعال کردن مقایسه‌ها، کتابخانه استاندارد ویژگی <code>std::cmp::PartialOrd</code> را ارائه می‌دهد که می‌توانید روی نوع‌ها پیاده‌سازی کنید (برای اطلاعات بیشتر درباره این ویژگی به ضمیمه ج مراجعه کنید). با دنبال کردن پیشنهاد متن کمکی، نوع‌های معتبر برای <code>T</code> را به آن‌هایی که <code>PartialOrd</code> را پیاده‌سازی می‌کنند محدود می‌کنیم و این مثال کامپایل خواهد شد، زیرا کتابخانه استاندارد ویژگی <code>PartialOrd</code> را برای هر دو نوع <code>i32</code> و <code>char</code> پیاده‌سازی کرده است.</p>
<h3 id="در-تعریف-ساختارها-struct"><a class="header" href="#در-تعریف-ساختارها-struct">در تعریف ساختارها (Struct)</a></h3>
<p>ما می‌توانیم ساختارها را نیز به گونه‌ای تعریف کنیم که از یک پارامتر نوع جنریک در یک یا چند فیلد استفاده کنند، با استفاده از نحو <code>&lt;&gt;</code>. لیست ۱۰-۶ ساختار <code>Point&lt;T&gt;</code> را تعریف می‌کند که مقادیر مختصات <code>x</code> و <code>y</code> از هر نوعی را نگه می‌دارد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<figcaption>Listing 10-6: ساختار <code>Point&lt;T&gt;</code> که مقادیر <code>x</code> و <code>y</code> از نوع <code>T</code> را نگه می‌دارد</figcaption>
</figure>
<p>نحو استفاده از جنریک‌ها در تعریف ساختارها مشابه استفاده آن‌ها در تعریف توابع است. ابتدا نام پارامتر نوع را در داخل پرانتزهای زاویه‌ای بلافاصله پس از نام ساختار اعلام می‌کنیم. سپس نوع جنریک را در تعریف ساختار استفاده می‌کنیم، جایی که در غیر این صورت نوع داده مشخص را مشخص می‌کردیم.</p>
<p>توجه داشته باشید که از آنجا که فقط یک نوع جنریک برای تعریف <code>Point&lt;T&gt;</code> استفاده کرده‌ایم، این تعریف بیان می‌کند که ساختار <code>Point&lt;T&gt;</code> برای یک نوع <code>T</code> جنریک است و فیلدهای <code>x</code> و <code>y</code> <em>هر دو</em> از همان نوع هستند، هرچه که آن نوع باشد. اگر نمونه‌ای از <code>Point&lt;T&gt;</code> ایجاد کنیم که مقادیر آن انواع مختلف داشته باشند، همانطور که در لیست ۱۰-۷ آمده است، کد ما کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<figcaption>Listing 10-7: فیلدهای <code>x</code> و <code>y</code> باید از همان نوع باشند زیرا هر دو دارای نوع داده جنریک <code>T</code> هستند.</figcaption>
</figure>
<p>در این مثال، وقتی مقدار عدد صحیح <code>5</code> را به <code>x</code> اختصاص می‌دهیم، به کامپایلر اطلاع می‌دهیم که نوع جنریک <code>T</code> برای این نمونه از <code>Point&lt;T&gt;</code> یک عدد صحیح خواهد بود. سپس وقتی <code>4.0</code> را برای <code>y</code> مشخص می‌کنیم، که تعریف کرده‌ایم همان نوع <code>x</code> را داشته باشد، یک خطای عدم تطابق نوع دریافت می‌کنیم، مانند این:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>برای تعریف یک ساختار <code>Point</code> که در آن <code>x</code> و <code>y</code> هر دو جنریک هستند اما می‌توانند انواع مختلفی داشته باشند، می‌توانیم از پارامترهای نوع جنریک چندگانه استفاده کنیم. برای مثال، در لیست ۱۰-۸، تعریف <code>Point</code> را تغییر می‌دهیم تا برای نوع‌های <code>T</code> و <code>U</code> جنریک باشد، جایی که <code>x</code> از نوع <code>T</code> و <code>y</code> از نوع <code>U</code> است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<figcaption>Listing 10-8: یک ساختار <code>Point&lt;T, U&gt;</code> جنریک بر روی دو نوع، به طوری که <code>x</code> و <code>y</code> می‌توانند مقادیری از انواع مختلف باشند</figcaption>
</figure>
<p>حالا تمام نمونه‌های <code>Point</code> نشان داده شده معتبر هستند! شما می‌توانید به تعداد دلخواه پارامترهای نوع جنریک در یک تعریف استفاده کنید، اما استفاده از تعداد زیاد خوانایی کد شما را دشوار می‌کند. اگر می‌بینید که نیاز به انواع جنریک زیادی در کد خود دارید، ممکن است نشان‌دهنده این باشد که کد شما نیاز به ساختاربندی مجدد به بخش‌های کوچک‌تر دارد.</p>
<h3 id="در-تعریف-شمارشها-enum"><a class="header" href="#در-تعریف-شمارشها-enum">در تعریف شمارش‌ها (Enum)</a></h3>
<p>همانطور که با ساختارها انجام دادیم، می‌توانیم شمارش‌ها را به گونه‌ای تعریف کنیم که نوع داده‌های جنریک را در حالت‌های خود نگه دارند. بیایید دوباره به شمارش <code>Option&lt;T&gt;</code> که کتابخانه استاندارد ارائه می‌دهد و در فصل ۶ از آن استفاده کردیم نگاه کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>این تعریف اکنون باید برای شما بیشتر معنا پیدا کند. همانطور که می‌بینید، شمارش <code>Option&lt;T&gt;</code> بر روی نوع <code>T</code> جنریک است و دو حالت دارد: <code>Some</code> که یک مقدار از نوع <code>T</code> را نگه می‌دارد و حالت <code>None</code> که هیچ مقداری را نگه نمی‌دارد. با استفاده از شمارش <code>Option&lt;T&gt;</code>، می‌توانیم مفهوم انتزاعی یک مقدار اختیاری را بیان کنیم، و از آنجا که <code>Option&lt;T&gt;</code> جنریک است، می‌توانیم از این انتزاع بدون توجه به نوع مقدار اختیاری استفاده کنیم.</p>
<p>شمارش‌ها نیز می‌توانند از انواع جنریک چندگانه استفاده کنند. تعریف شمارش <code>Result</code> که در فصل ۹ استفاده کردیم یک مثال است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>شمارش <code>Result</code> بر روی دو نوع جنریک <code>T</code> و <code>E</code> است و دو حالت دارد: <code>Ok</code> که یک مقدار از نوع <code>T</code> نگه می‌دارد و <code>Err</code> که یک مقدار از نوع <code>E</code> نگه می‌دارد. این تعریف استفاده از شمارش <code>Result</code> را در هر جایی که یک عملیات ممکن است موفق شود (یک مقدار از نوع <code>T</code> بازگرداند) یا شکست بخورد (یک خطا از نوع <code>E</code> بازگرداند) آسان می‌کند. در واقع، این همان چیزی است که برای باز کردن یک فایل در لیست ۹-۳ استفاده کردیم، جایی که <code>T</code> با نوع <code>std::fs::File</code> پر شده بود وقتی فایل با موفقیت باز شد و <code>E</code> با نوع <code>std::io::Error</code> پر شده بود وقتی مشکلاتی در باز کردن فایل وجود داشت.</p>
<p>وقتی وضعیت‌هایی در کد خود را شناسایی کردید که چندین تعریف ساختار یا شمارش وجود دارد که فقط در نوع مقادیر نگهداری شده متفاوت هستند، می‌توانید با استفاده از نوع‌های جنریک از تکرار جلوگیری کنید.</p>
<h3 id="در-تعریف-متدها"><a class="header" href="#در-تعریف-متدها">در تعریف متدها</a></h3>
<p>ما می‌توانیم متدهایی را روی ساختارها و شمارش‌ها پیاده‌سازی کنیم (همانطور که در فصل ۵ انجام دادیم) و از انواع جنریک در تعریف آن‌ها نیز استفاده کنیم. لیست ۱۰-۹ ساختار <code>Point&lt;T&gt;</code> که در لیست ۱۰-۶ تعریف کردیم را نشان می‌دهد، با متدی به نام <code>x</code> که روی آن پیاده‌سازی شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
<figcaption>Listing 10-9: پیاده‌سازی متدی به نام <code>x</code> روی ساختار <code>Point&lt;T&gt;</code> که یک مرجع به فیلد <code>x</code> از نوع <code>T</code> بازمی‌گرداند</figcaption>
</figure>
<p>در اینجا، یک متد به نام <code>x</code> روی <code>Point&lt;T&gt;</code> تعریف کرده‌ایم که یک مرجع به داده موجود در فیلد <code>x</code> بازمی‌گرداند.</p>
<p>توجه داشته باشید که باید <code>T</code> را بلافاصله بعد از <code>impl</code> اعلام کنیم تا بتوانیم از <code>T</code> برای مشخص کردن اینکه داریم متدها را روی نوع <code>Point&lt;T&gt;</code> پیاده‌سازی می‌کنیم، استفاده کنیم. با اعلام <code>T</code> به عنوان یک نوع جنریک بعد از <code>impl</code>، Rust می‌تواند تشخیص دهد که نوع موجود در پرانتزهای زاویه‌ای در <code>Point</code> یک نوع جنریک است، نه یک نوع مشخص. می‌توانستیم نامی متفاوت از پارامتر جنریک اعلام‌شده در تعریف ساختار برای این پارامتر جنریک انتخاب کنیم، اما استفاده از همان نام یک عرف است. اگر یک متد را درون یک <code>impl</code> که یک نوع جنریک اعلام می‌کند بنویسید، آن متد روی هر نمونه‌ای از آن نوع تعریف می‌شود، بدون توجه به اینکه چه نوع مشخصی جایگزین نوع جنریک می‌شود.</p>
<p>همچنین می‌توانیم محدودیت‌هایی بر روی نوع‌های جنریک هنگام تعریف متدها روی یک نوع مشخص کنیم. می‌توانیم، برای مثال، متدهایی را فقط روی نمونه‌های <code>Point&lt;f32&gt;</code> پیاده‌سازی کنیم، نه روی نمونه‌های <code>Point&lt;T&gt;</code> با هر نوع جنریک. در لیست ۱۰-۱۰ از نوع مشخص <code>f32</code> استفاده کرده‌ایم، به این معنی که هیچ نوعی را بعد از <code>impl</code> اعلام نمی‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 10-10: یک بلوک <code>impl</code> که فقط برای یک ساختار با یک نوع مشخص برای پارامتر نوع جنریک <code>T</code> اعمال می‌شود</figcaption>
</figure>
<p>این کد به این معنی است که نوع <code>Point&lt;f32&gt;</code> دارای یک متد <code>distance_from_origin</code> خواهد بود؛ سایر نمونه‌های <code>Point&lt;T&gt;</code> که <code>T</code> از نوع <code>f32</code> نیستند، این متد را تعریف نخواهند کرد. این متد فاصله نقطه ما از نقطه‌ای با مختصات (0.0, 0.0) را اندازه‌گیری می‌کند و از عملیات ریاضی استفاده می‌کند که فقط برای نوع‌های اعداد اعشاری در دسترس هستند.</p>
<p>پارامترهای نوع جنریک در تعریف یک ساختار همیشه با آن‌هایی که در امضاهای متد همان ساختار استفاده می‌شوند یکسان نیستند. لیست ۱۰-۱۱ از نوع‌های جنریک <code>X1</code> و <code>Y1</code> برای ساختار <code>Point</code> و <code>X2</code> و <code>Y2</code> برای امضای متد <code>mixup</code> استفاده می‌کند تا مثال را واضح‌تر کند. این متد یک نمونه جدید از <code>Point</code> ایجاد می‌کند با مقدار <code>x</code> از <code>Point</code> <code>self</code> (از نوع <code>X1</code>) و مقدار <code>y</code> از <code>Point</code> پاس‌داده‌شده (از نوع <code>Y2</code>).</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
<figcaption>Listing 10-11: یک متد که از نوع‌های جنریک متفاوت از تعریف ساختار خود استفاده می‌کند</figcaption>
</figure>
<p>در تابع <code>main</code>، یک <code>Point</code> تعریف کرده‌ایم که <code>x</code> آن یک <code>i32</code> (با مقدار <code>5</code>) و <code>y</code> آن یک <code>f64</code> (با مقدار <code>10.4</code>) است. متغیر <code>p2</code> یک ساختار <code>Point</code> است که <code>x</code> آن یک قطعه رشته (با مقدار <code>"Hello"</code>) و <code>y</code> آن یک <code>char</code> (با مقدار <code>c</code>) است. فراخوانی <code>mixup</code> روی <code>p1</code> با آرگومان <code>p2</code> به ما <code>p3</code> را می‌دهد، که <code>x</code> آن یک <code>i32</code> خواهد بود زیرا <code>x</code> از <code>p1</code> آمده است. متغیر <code>p3</code> یک <code>char</code> برای <code>y</code> خواهد داشت زیرا <code>y</code> از <code>p2</code> آمده است. فراخوانی ماکرو <code>println!</code> مقدار <code>p3.x = 5, p3.y = c</code> را چاپ می‌کند.</p>
<p>هدف این مثال این است که وضعیتی را نشان دهد که در آن برخی پارامترهای جنریک با <code>impl</code> اعلام می‌شوند و برخی دیگر با تعریف متد اعلام می‌شوند. در اینجا، پارامترهای جنریک <code>X1</code> و <code>Y1</code> بعد از <code>impl</code> اعلام شده‌اند زیرا با تعریف ساختار همراه هستند. پارامترهای جنریک <code>X2</code> و <code>Y2</code> بعد از <code>fn mixup</code> اعلام شده‌اند زیرا فقط به متد مربوط هستند.</p>
<h3 id="عملکرد-کدی-که-از-جنریکها-استفاده-میکند"><a class="header" href="#عملکرد-کدی-که-از-جنریکها-استفاده-میکند">عملکرد کدی که از جنریک‌ها استفاده می‌کند</a></h3>
<p>ممکن است این سوال برای شما پیش بیاید که آیا هنگام استفاده از پارامترهای نوع جنریک، هزینه‌ای در زمان اجرا وجود دارد یا خیر. خبر خوب این است که استفاده از انواع جنریک برنامه شما را کندتر از حالتی که از انواع مشخص استفاده می‌کردید، نمی‌کند.</p>
<p>Rust این کار را با انجام فرآیندی به نام <em>تک‌ریخت‌سازی</em> (monomorphization) روی کدی که از جنریک‌ها استفاده می‌کند در زمان کامپایل انجام می‌دهد. <em>تک‌ریخت‌سازی</em> فرآیند تبدیل کد جنریک به کد مشخص است با پر کردن انواع مشخصی که هنگام کامپایل استفاده می‌شوند. در این فرآیند، کامپایلر برعکس مراحلی که برای ایجاد تابع جنریک در لیست ۱۰-۵ استفاده کردیم را انجام می‌دهد: کامپایلر به تمام جاهایی که کد جنریک فراخوانی شده نگاه می‌کند و کدی را برای انواع مشخصی که کد جنریک با آن‌ها فراخوانی شده ایجاد می‌کند.</p>
<p>بیایید ببینیم این کار چگونه انجام می‌شود با استفاده از شمارش جنریک <code>Option&lt;T&gt;</code> در کتابخانه استاندارد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>وقتی Rust این کد را کامپایل می‌کند، فرآیند تک‌ریخت‌سازی را انجام می‌دهد. در طول این فرآیند، کامپایلر مقادیر استفاده شده در نمونه‌های <code>Option&lt;T&gt;</code> را می‌خواند و دو نوع <code>Option&lt;T&gt;</code> را شناسایی می‌کند: یکی <code>i32</code> و دیگری <code>f64</code>. به این ترتیب، تعریف جنریک <code>Option&lt;T&gt;</code> را به دو تعریف ویژه برای <code>i32</code> و <code>f64</code> گسترش می‌دهد و بنابراین تعریف جنریک را با تعریف‌های مشخص جایگزین می‌کند.</p>
<p>نسخه تک‌ریخت‌سازی شده کد شبیه به چیزی به نظر می‌رسد (کامپایلر از نام‌های متفاوتی استفاده می‌کند، اما برای توضیح از این نام‌ها استفاده کرده‌ایم):</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</figure>
<p>شمارش جنریک <code>Option&lt;T&gt;</code> با تعریف‌های مشخص ایجاد شده توسط کامپایلر جایگزین شده است. از آنجا که Rust کد جنریک را به کدی که نوع را در هر نمونه مشخص می‌کند کامپایل می‌کند، هیچ هزینه‌ای در زمان اجرا برای استفاده از جنریک‌ها پرداخت نمی‌کنیم. وقتی کد اجرا می‌شود، دقیقاً همان‌طور عمل می‌کند که اگر هر تعریف را به صورت دستی تکرار کرده بودیم. فرآیند تک‌ریخت‌سازی جنریک‌های Rust را در زمان اجرا بسیار کارآمد می‌کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ویژگیها-traits-تعریف-رفتار-مشترک"><a class="header" href="#ویژگیها-traits-تعریف-رفتار-مشترک">ویژگی‌ها (Traits): تعریف رفتار مشترک</a></h2>
<p>یک <em>ویژگی</em> (trait) عملکردی را که یک نوع خاص دارد تعریف می‌کند و می‌تواند با انواع دیگر به اشتراک بگذارد. ما می‌توانیم از traitها برای تعریف رفتار مشترک به صورت انتزاعی استفاده کنیم. همچنین می‌توانیم از <em>محدودیت‌های ویژگی</em> (trait bounds) برای مشخص کردن اینکه یک نوع جنریک می‌تواند هر نوعی باشد که رفتار خاصی دارد، استفاده کنیم.</p>
<blockquote>
<p>توجه: ویژگی‌ها شبیه به مفهومی هستند که اغلب در زبان‌های دیگر به نام <em>interfaces</em> شناخته می‌شود، البته با برخی تفاوت‌ها.</p>
</blockquote>
<h3 id="تعریف-یک-trait"><a class="header" href="#تعریف-یک-trait">تعریف یک trait</a></h3>
<p>رفتار یک نوع شامل متدهایی است که می‌توانیم روی آن نوع فراخوانی کنیم. انواع مختلف یک رفتار مشترک دارند اگر بتوانیم همان متدها را روی تمام آن انواع فراخوانی کنیم. تعریف ویژگی‌ها راهی برای گروه‌بندی امضاهای متدها با هم است تا مجموعه‌ای از رفتارها را که برای دستیابی به یک هدف خاص ضروری است، تعریف کنیم.</p>
<p>برای مثال، فرض کنید چندین ساختار داده داریم که انواع و مقادیر مختلفی از متن را نگه می‌دارند: یک ساختار <code>NewsArticle</code> که یک خبر ذخیره شده در یک مکان خاص را نگه می‌دارد و یک ساختار <code>Tweet</code> که می‌تواند حداکثر ۲۸۰ کاراکتر به همراه متادیتایی که نشان می‌دهد آیا این یک توییت جدید، بازتوییت، یا پاسخ به توییت دیگری بوده است را نگه دارد.</p>
<p>ما می‌خواهیم یک کتابخانه گردآورنده رسانه به نام <code>aggregator</code> ایجاد کنیم که بتواند خلاصه‌هایی از داده‌هایی که ممکن است در یک نمونه از <code>NewsArticle</code> یا <code>Tweet</code> ذخیره شده باشند، نمایش دهد. برای این کار، نیاز به خلاصه‌ای از هر نوع داریم و این خلاصه را با فراخوانی متد <code>summarize</code> روی یک نمونه درخواست خواهیم کرد. لیست ۱۰-۱۲ تعریف یک ویژگی عمومی <code>Summary</code> را نشان می‌دهد که این رفتار را بیان می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
<figcaption>Listing 10-12: ویژگی <code>Summary</code> که شامل رفتار ارائه‌شده توسط یک متد <code>summarize</code> است</figcaption>
</figure>
<p>در اینجا، یک ویژگی با استفاده از کلیدواژه <code>trait</code> و سپس نام ویژگی، که در اینجا <code>Summary</code> است، اعلام می‌کنیم. همچنین ویژگی را به عنوان <code>pub</code> اعلام می‌کنیم تا کرایت‌هایی که به این کرایت وابسته هستند نیز بتوانند از این ویژگی استفاده کنند، همانطور که در چند مثال خواهیم دید. در داخل آکولادها، امضاهای متدی را اعلام می‌کنیم که رفتارهای نوع‌هایی که این ویژگی را پیاده‌سازی می‌کنند توصیف می‌کنند، که در این مورد <code>fn summarize(&amp;self) -&gt; String</code> است.</p>
<p>بعد از امضای متد، به جای ارائه یک پیاده‌سازی در داخل آکولادها، از یک نقطه‌ویرگول استفاده می‌کنیم. هر نوعی که این ویژگی را پیاده‌سازی می‌کند باید رفتار سفارشی خود را برای بدنه متد ارائه دهد. کامپایلر اطمینان خواهد داد که هر نوعی که ویژگی <code>Summary</code> را دارد، متد <code>summarize</code> را دقیقاً با این امضا تعریف خواهد کرد.</p>
<p>یک ویژگی می‌تواند چندین متد در بدنه خود داشته باشد: امضاهای متدها به صورت یک خط در هر خط فهرست می‌شوند و هر خط با یک نقطه‌ویرگول پایان می‌یابد.</p>
<h3 id="پیادهسازی-یک-ویژگی-trait-روی-یک-نوع"><a class="header" href="#پیادهسازی-یک-ویژگی-trait-روی-یک-نوع">پیاده‌سازی یک ویژگی (trait) روی یک نوع</a></h3>
<p>اکنون که امضاهای مورد نظر متدهای ویژگی <code>Summary</code> را تعریف کرده‌ایم، می‌توانیم آن را روی نوع‌های موجود در گردآورنده رسانه خود پیاده‌سازی کنیم. لیست ۱۰-۱۳ یک پیاده‌سازی از ویژگی <code>Summary</code> روی ساختار <code>NewsArticle</code> را نشان می‌دهد که از تیتر، نویسنده، و مکان برای ایجاد مقدار بازگشتی <code>summarize</code> استفاده می‌کند. برای ساختار <code>Tweet</code>، متد <code>summarize</code> را به صورت نام کاربری به همراه تمام متن توییت تعریف می‌کنیم، با فرض اینکه محتوای توییت قبلاً به ۲۸۰ کاراکتر محدود شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
<figcaption>Listing 10-13: پیاده‌سازی ویژگی <code>Summary</code> روی نوع‌های <code>NewsArticle</code> و <code>Tweet</code></figcaption>
</figure>
<p>پیاده‌سازی یک ویژگی روی یک نوع مشابه پیاده‌سازی متدهای معمولی است. تفاوت این است که بعد از <code>impl</code>، نام ویژگی‌ای که می‌خواهیم پیاده‌سازی کنیم را قرار می‌دهیم، سپس از کلمه کلیدی <code>for</code> استفاده می‌کنیم و سپس نام نوعی که می‌خواهیم ویژگی را برای آن پیاده‌سازی کنیم مشخص می‌کنیم. درون بلوک <code>impl</code>، امضاهای متدی که تعریف ویژگی مشخص کرده‌اند را قرار می‌دهیم. به جای اضافه کردن یک نقطه‌ویرگول بعد از هر امضا، از آکولادها استفاده می‌کنیم و بدنه متد را با رفتار خاصی که می‌خواهیم متدهای ویژگی برای نوع خاص داشته باشند پر می‌کنیم.</p>
<p>حالا که کتابخانه ویژگی <code>Summary</code> را روی <code>NewsArticle</code> و <code>Tweet</code> پیاده‌سازی کرده است، کاربران این کرایت می‌توانند متدهای ویژگی را روی نمونه‌های <code>NewsArticle</code> و <code>Tweet</code> فراخوانی کنند، به همان روشی که متدهای معمولی را فراخوانی می‌کنیم. تنها تفاوت این است که کاربر باید ویژگی را به همراه نوع‌ها به محدوده وارد کند. در اینجا مثالی از اینکه چگونه یک کرایت باینری می‌تواند از کرایت کتابخانه <code>aggregator</code> ما استفاده کند آورده شده است:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}</code></pre>
<p>این کد <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code> را چاپ می‌کند.</p>
<p>کرایت‌های دیگری که به کرایت <code>aggregator</code> وابسته هستند نیز می‌توانند ویژگی <code>Summary</code> را به محدوده وارد کنند تا <code>Summary</code> را روی نوع‌های خودشان پیاده‌سازی کنند. یکی از محدودیت‌هایی که باید به آن توجه داشت این است که ما فقط می‌توانیم یک ویژگی را روی یک نوع پیاده‌سازی کنیم اگر یا ویژگی یا نوع، یا هر دو، به کرایت ما محلی باشند. برای مثال، ما می‌توانیم ویژگی‌هایی از کتابخانه استاندارد مانند <code>Display</code> را روی یک نوع سفارشی مانند <code>Tweet</code> به عنوان بخشی از عملکرد کرایت <code>aggregator</code> پیاده‌سازی کنیم زیرا نوع <code>Tweet</code> به کرایت <code>aggregator</code> محلی است. همچنین می‌توانیم <code>Summary</code> را روی <code>Vec&lt;T&gt;</code> در کرایت <code>aggregator</code> پیاده‌سازی کنیم زیرا ویژگی <code>Summary</code> به کرایت <code>aggregator</code> محلی است.</p>
<p>اما نمی‌توانیم ویژگی‌های خارجی را روی نوع‌های خارجی پیاده‌سازی کنیم. برای مثال، نمی‌توانیم ویژگی <code>Display</code> را روی <code>Vec&lt;T&gt;</code> در کرایت <code>aggregator</code> پیاده‌سازی کنیم زیرا <code>Display</code> و <code>Vec&lt;T&gt;</code> هر دو در کتابخانه استاندارد تعریف شده‌اند و به کرایت <code>aggregator</code> محلی نیستند. این محدودیت بخشی از خاصیتی به نام <em>انسجام</em> (coherence) و به طور خاص‌تر <em>قانون یتیم</em> (orphan rule) است، که به این دلیل نامگذاری شده است که نوع والد وجود ندارد. این قانون اطمینان می‌دهد که کد دیگران نمی‌تواند کد شما را خراب کند و برعکس. بدون این قانون، دو کرایت می‌توانستند همان ویژگی را برای همان نوع پیاده‌سازی کنند و Rust نمی‌دانست کدام پیاده‌سازی را استفاده کند.</p>
<h3 id="پیادهسازیهای-پیشفرض"><a class="header" href="#پیادهسازیهای-پیشفرض">پیاده‌سازی‌های پیش‌فرض</a></h3>
<p>گاهی اوقات مفید است که رفتار پیش‌فرضی برای برخی یا همه متدهای یک ویژگی داشته باشید به جای اینکه پیاده‌سازی‌ها برای تمام متدها در هر نوع اجباری باشند. سپس، وقتی ویژگی را روی یک نوع خاص پیاده‌سازی می‌کنیم، می‌توانیم رفتار پیش‌فرض هر متد را نگه داریم یا جایگزین کنیم.</p>
<p>در لیست ۱۰-۱۴، یک رشته پیش‌فرض برای متد <code>summarize</code> ویژگی <code>Summary</code> مشخص می‌کنیم به جای اینکه فقط امضای متد را تعریف کنیم، همانطور که در لیست ۱۰-۱۲ انجام دادیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 10-14: تعریف ویژگی <code>Summary</code> با یک پیاده‌سازی پیش‌فرض برای متد <code>summarize</code></figcaption>
</figure>
<p>برای استفاده از یک پیاده‌سازی پیش‌فرض برای خلاصه کردن نمونه‌های <code>NewsArticle</code>، یک بلوک <code>impl</code> خالی با <code>impl Summary for NewsArticle {}</code> مشخص می‌کنیم.</p>
<p>اگرچه دیگر متد <code>summarize</code> را مستقیماً روی <code>NewsArticle</code> تعریف نمی‌کنیم، یک پیاده‌سازی پیش‌فرض ارائه داده‌ایم و مشخص کرده‌ایم که <code>NewsArticle</code> ویژگی <code>Summary</code> را پیاده‌سازی می‌کند. در نتیجه، همچنان می‌توانیم متد <code>summarize</code> را روی یک نمونه از <code>NewsArticle</code> فراخوانی کنیم، مانند این:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>این کد <code>New article available! (Read more...)</code> را چاپ می‌کند.</p>
<p>ایجاد یک پیاده‌سازی پیش‌فرض نیازی به تغییر چیزی در پیاده‌سازی ویژگی <code>Summary</code> روی <code>Tweet</code> در لیست ۱۰-۱۳ ندارد. دلیل آن این است که نحو برای بازنویسی یک پیاده‌سازی پیش‌فرض همانند نحو برای پیاده‌سازی یک متد ویژگی است که پیاده‌سازی پیش‌فرض ندارد.</p>
<p>پیاده‌سازی‌های پیش‌فرض می‌توانند متدهای دیگر را در همان ویژگی فراخوانی کنند، حتی اگر آن متدهای دیگر پیاده‌سازی پیش‌فرض نداشته باشند. به این روش، یک ویژگی می‌تواند مقدار زیادی عملکرد مفید ارائه دهد و فقط از پیاده‌سازان بخواهد که بخشی از آن را مشخص کنند. برای مثال، می‌توانیم ویژگی <code>Summary</code> را به گونه‌ای تعریف کنیم که یک متد <code>summarize_author</code> داشته باشد که پیاده‌سازی آن الزامی است و سپس یک متد <code>summarize</code> تعریف کنیم که یک پیاده‌سازی پیش‌فرض دارد و متد <code>summarize_author</code> را فراخوانی می‌کند:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>برای استفاده از این نسخه از <code>Summary</code>، فقط باید <code>summarize_author</code> را هنگامی که ویژگی را روی یک نوع پیاده‌سازی می‌کنیم، تعریف کنیم:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Read more from {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>بعد از اینکه <code>summarize_author</code> را تعریف کردیم، می‌توانیم متد <code>summarize</code> را روی نمونه‌های ساختار <code>Tweet</code> فراخوانی کنیم، و پیاده‌سازی پیش‌فرض <code>summarize</code>، تعریف متد <code>summarize_author</code> که ارائه داده‌ایم را فراخوانی خواهد کرد. از آنجا که ما <code>summarize_author</code> را پیاده‌سازی کرده‌ایم، ویژگی <code>Summary</code> رفتار متد <code>summarize</code> را بدون نیاز به نوشتن کد اضافی به ما داده است. به این شکل عمل می‌کند:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
<span class="boring">}</span></code></pre>
<p>این کد <code>1 new tweet: (Read more from @horse_ebooks...)</code> را چاپ می‌کند.</p>
<p>توجه داشته باشید که امکان فراخوانی پیاده‌سازی پیش‌فرض از یک پیاده‌سازی بازنویسی شده از همان متد وجود ندارد.</p>
<h3 id="ویژگیها-traits-به-عنوان-پارامترها"><a class="header" href="#ویژگیها-traits-به-عنوان-پارامترها">ویژگی‌ها (traits) به عنوان پارامترها</a></h3>
<p>اکنون که می‌دانید چگونه ویژگی‌ها را تعریف و پیاده‌سازی کنید، می‌توانیم بررسی کنیم که چگونه از ویژگی‌ها برای تعریف توابعی که انواع مختلفی را می‌پذیرند استفاده کنیم. ما از ویژگی <code>Summary</code> که روی نوع‌های <code>NewsArticle</code> و <code>Tweet</code> در لیست ۱۰-۱۳ پیاده‌سازی کردیم استفاده خواهیم کرد تا تابعی به نام <code>notify</code> تعریف کنیم که متد <code>summarize</code> را روی پارامتر <code>item</code> خود فراخوانی می‌کند، که از نوعی است که ویژگی <code>Summary</code> را پیاده‌سازی می‌کند. برای این کار، از نحو <code>impl Trait</code> استفاده می‌کنیم، مانند این:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>به جای یک نوع مشخص برای پارامتر <code>item</code>، کلمه کلیدی <code>impl</code> و نام ویژگی را مشخص می‌کنیم. این پارامتر هر نوعی را که ویژگی مشخص‌شده را پیاده‌سازی می‌کند می‌پذیرد. در بدنه <code>notify</code>، می‌توانیم هر متدی روی <code>item</code> که از ویژگی <code>Summary</code> آمده باشد، مانند <code>summarize</code> را فراخوانی کنیم. می‌توانیم <code>notify</code> را فراخوانی کرده و هر نمونه‌ای از <code>NewsArticle</code> یا <code>Tweet</code> را به آن پاس دهیم. کدی که تابع را با هر نوع دیگری، مانند یک <code>String</code> یا یک <code>i32</code> فراخوانی کند، کامپایل نمی‌شود زیرا آن نوع‌ها ویژگی <code>Summary</code> را پیاده‌سازی نمی‌کنند.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="نحو-محدودیت-ویژگی-trait-bound-syntax"><a class="header" href="#نحو-محدودیت-ویژگی-trait-bound-syntax">نحو محدودیت ویژگی (Trait Bound Syntax)</a></h4>
<p>نحو <code>impl Trait</code> برای موارد ساده مناسب است اما در واقع یک شکل کوتاه‌شده از یک فرم طولانی‌تر به نام <em>محدودیت ویژگی</em> (trait bound) است؛ به این صورت:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>این فرم طولانی معادل مثال بخش قبلی است اما مفصل‌تر است. ما محدودیت‌های ویژگی را با اعلام پارامتر نوع جنریک بعد از یک دو‌نقطه و داخل پرانتزهای زاویه‌ای قرار می‌دهیم.</p>
<p>نحو <code>impl Trait</code> در موارد ساده مناسب است و کد را مختصرتر می‌کند، در حالی که نحو کامل‌تر محدودیت ویژگی می‌تواند پیچیدگی بیشتری را در موارد دیگر بیان کند. برای مثال، می‌توانیم دو پارامتر داشته باشیم که ویژگی <code>Summary</code> را پیاده‌سازی می‌کنند. انجام این کار با نحو <code>impl Trait</code> به این صورت است:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>استفاده از <code>impl Trait</code> مناسب است اگر بخواهیم این تابع اجازه دهد <code>item1</code> و <code>item2</code> انواع مختلفی داشته باشند (به شرطی که هر دو نوع ویژگی <code>Summary</code> را پیاده‌سازی کنند). اما اگر بخواهیم هر دو پارامتر یک نوع یکسان داشته باشند، باید از محدودیت ویژگی استفاده کنیم، مانند این:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>نوع جنریک <code>T</code> که به عنوان نوع پارامترهای <code>item1</code> و <code>item2</code> مشخص شده است، تابع را محدود می‌کند به این صورت که نوع مشخص مقدار پاس‌داده‌شده به عنوان آرگومان برای <code>item1</code> و <code>item2</code> باید یکسان باشد.</p>
<h4 id="مشخص-کردن-محدودیتهای-ویژگی-چندگانه-با-نحو-"><a class="header" href="#مشخص-کردن-محدودیتهای-ویژگی-چندگانه-با-نحو-">مشخص کردن محدودیت‌های ویژگی چندگانه با نحو <code>+</code></a></h4>
<p>ما همچنین می‌توانیم بیش از یک محدودیت ویژگی مشخص کنیم. فرض کنید می‌خواهیم <code>notify</code> از فرمت‌بندی نمایش (display formatting) و همچنین <code>summarize</code> روی <code>item</code> استفاده کند: در تعریف <code>notify</code> مشخص می‌کنیم که <code>item</code> باید هر دو ویژگی <code>Display</code> و <code>Summary</code> را پیاده‌سازی کند. این کار را می‌توانیم با نحو <code>+</code> انجام دهیم:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>نحو <code>+</code> همچنین با محدودیت ویژگی روی انواع جنریک معتبر است:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>با مشخص کردن این دو محدودیت ویژگی، بدنه <code>notify</code> می‌تواند متد <code>summarize</code> را فراخوانی کند و از <code>{}</code> برای فرمت‌بندی <code>item</code> استفاده کند.</p>
<h4 id="محدودیتهای-ویژگی-واضحتر-با-بندهای-where"><a class="header" href="#محدودیتهای-ویژگی-واضحتر-با-بندهای-where">محدودیت‌های ویژگی واضح‌تر با بندهای <code>where</code></a></h4>
<p>استفاده از تعداد زیادی محدودیت ویژگی معایب خود را دارد. هر جنریک محدودیت‌های ویژگی مخصوص به خود را دارد، بنابراین توابعی با چندین پارامتر نوع جنریک می‌توانند شامل اطلاعات زیادی درباره محدودیت‌های ویژگی بین نام تابع و لیست پارامترهای آن باشند، که باعث سخت شدن خواندن امضای تابع می‌شود. به همین دلیل، Rust نحو جایگزینی برای مشخص کردن محدودیت‌های ویژگی در داخل یک بند <code>where</code> پس از امضای تابع ارائه می‌دهد. بنابراین، به جای نوشتن این:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>می‌توانیم از یک بند <code>where</code> به این صورت استفاده کنیم:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>امضای این تابع کمتر شلوغ است: نام تابع، لیست پارامترها، و نوع بازگشتی به هم نزدیک‌تر هستند، مشابه یک تابع بدون محدودیت‌های ویژگی زیاد.</p>
<h3 id="بازگرداندن-نوعهایی-که-ویژگیها-را-پیادهسازی-میکنند"><a class="header" href="#بازگرداندن-نوعهایی-که-ویژگیها-را-پیادهسازی-میکنند">بازگرداندن نوع‌هایی که ویژگی‌ها را پیاده‌سازی می‌کنند</a></h3>
<p>ما همچنین می‌توانیم از نحو <code>impl Trait</code> در موقعیت بازگشتی استفاده کنیم تا مقداری از نوعی که یک ویژگی را پیاده‌سازی می‌کند بازگردانیم، همانطور که در اینجا نشان داده شده است:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>با استفاده از <code>impl Summary</code> برای نوع بازگشتی، مشخص می‌کنیم که تابع <code>returns_summarizable</code> مقداری از نوعی که ویژگی <code>Summary</code> را پیاده‌سازی می‌کند بازمی‌گرداند، بدون نیاز به نام بردن از نوع مشخص. در این مورد، <code>returns_summarizable</code> یک <code>Tweet</code> بازمی‌گرداند، اما کدی که این تابع را فراخوانی می‌کند نیازی به دانستن این موضوع ندارد.</p>
<p>توانایی مشخص کردن یک نوع بازگشتی تنها بر اساس ویژگی‌ای که پیاده‌سازی می‌کند، به ویژه در زمینه closures و iterators مفید است، که در فصل ۱۳ به آن‌ها می‌پردازیم. closures و iterators نوع‌هایی ایجاد می‌کنند که تنها کامپایلر آن‌ها را می‌شناسد یا نوع‌هایی که بسیار طولانی هستند تا مشخص شوند. نحو <code>impl Trait</code> به شما اجازه می‌دهد که به طور مختصر مشخص کنید یک تابع نوعی که ویژگی <code>Iterator</code> را پیاده‌سازی می‌کند بازمی‌گرداند، بدون نیاز به نوشتن یک نوع بسیار طولانی.</p>
<p>با این حال، فقط زمانی می‌توانید از <code>impl Trait</code> استفاده کنید که یک نوع بازگردانده شود. برای مثال، این کد که یا یک <code>NewsArticle</code> یا یک <code>Tweet</code> بازمی‌گرداند و نوع بازگشتی به عنوان <code>impl Summary</code> مشخص شده، کار نخواهد کرد:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p>بازگرداندن یا یک <code>NewsArticle</code> یا یک <code>Tweet</code> مجاز نیست به دلیل محدودیت‌هایی در نحوه پیاده‌سازی نحو <code>impl Trait</code> در کامپایلر. ما نحوه نوشتن یک تابع با این رفتار را در بخش <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“استفاده از اشیاء ویژگی که مقادیر از نوع‌های مختلف را مجاز می‌سازد”</a><!-- ignore --> در فصل ۱۸ بررسی خواهیم کرد.</p>
<h3 id="استفاده-از-محدودیتهای-ویژگی-برای-پیادهسازی-شرطی-متدها"><a class="header" href="#استفاده-از-محدودیتهای-ویژگی-برای-پیادهسازی-شرطی-متدها">استفاده از محدودیت‌های ویژگی برای پیاده‌سازی شرطی متدها</a></h3>
<p>با استفاده از یک محدودیت ویژگی در یک بلوک <code>impl</code> که از پارامترهای نوع جنریک استفاده می‌کند، می‌توانیم متدها را به طور شرطی برای نوع‌هایی که ویژگی‌های مشخص‌شده را پیاده‌سازی می‌کنند پیاده‌سازی کنیم. برای مثال، نوع <code>Pair&lt;T&gt;</code> در لیست ۱۰-۱۵ همیشه تابع <code>new</code> را پیاده‌سازی می‌کند تا یک نمونه جدید از <code>Pair&lt;T&gt;</code> بازگرداند (به یاد داشته باشید از بخش <a href="ch05-03-method-syntax.html#defining-methods">“تعریف متدها”</a><!-- ignore --> در فصل ۵ که <code>Self</code> یک نام مستعار برای نوع بلوک <code>impl</code> است که در اینجا <code>Pair&lt;T&gt;</code> است). اما در بلوک <code>impl</code> بعدی، <code>Pair&lt;T&gt;</code> فقط متد <code>cmp_display</code> را پیاده‌سازی می‌کند اگر نوع داخلی <code>T</code> ویژگی <code>PartialOrd</code> که مقایسه را ممکن می‌کند <em>و</em> ویژگی <code>Display</code> که چاپ را ممکن می‌کند، پیاده‌سازی کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}</code></pre>
<figcaption>Listing 10-15: پیاده‌سازی شرطی متدها روی یک نوع جنریک بر اساس محدودیت‌های ویژگی</figcaption>
</figure>
<p>ما همچنین می‌توانیم یک ویژگی را به طور شرطی برای هر نوعی که ویژگی دیگری را پیاده‌سازی می‌کند، پیاده‌سازی کنیم. پیاده‌سازی‌های یک ویژگی روی هر نوعی که محدودیت‌های ویژگی را برآورده می‌کند <em>پیاده‌سازی‌های کلی</em> (blanket implementations) نامیده می‌شوند و به طور گسترده در کتابخانه استاندارد Rust استفاده می‌شوند. برای مثال، کتابخانه استاندارد ویژگی <code>ToString</code> را روی هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی می‌کند، پیاده‌سازی می‌کند. بلوک <code>impl</code> در کتابخانه استاندارد شبیه به این کد است:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>از آنجا که کتابخانه استاندارد این پیاده‌سازی کلی را دارد، می‌توانیم متد <code>to_string</code> تعریف‌شده توسط ویژگی <code>ToString</code> را روی هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی می‌کند، فراخوانی کنیم. برای مثال، می‌توانیم اعداد صحیح را به مقادیر <code>String</code> متناظرشان تبدیل کنیم مانند این:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>پیاده‌سازی‌های کلی در مستندات ویژگی در بخش “Implementors” ظاهر می‌شوند.</p>
<p>ویژگی‌ها و محدودیت‌های ویژگی به ما امکان می‌دهند که کدی بنویسیم که از پارامترهای نوع جنریک برای کاهش تکرار استفاده کند اما همچنین به کامپایلر مشخص کند که می‌خواهیم نوع جنریک رفتار خاصی داشته باشد. سپس کامپایلر می‌تواند از اطلاعات محدودیت ویژگی استفاده کند تا بررسی کند که تمام نوع‌های مشخص استفاده‌شده با کد ما رفتار صحیح را ارائه می‌دهند. در زبان‌های تایپ‌گذاری پویا، ما هنگام اجرا خطا دریافت می‌کنیم اگر یک متد روی یک نوع که آن متد را تعریف نکرده فراخوانی کنیم. اما Rust این خطاها را به زمان کامپایل منتقل می‌کند تا ما مجبور شویم مشکلات را قبل از اینکه کد ما اجرا شود برطرف کنیم. علاوه بر این، نیازی به نوشتن کدی نداریم که رفتار را در زمان اجرا بررسی کند زیرا قبلاً آن را در زمان کامپایل بررسی کرده‌ایم. این کار عملکرد را بهبود می‌بخشد بدون اینکه انعطاف‌پذیری جنریک‌ها را قربانی کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="اعتبارسنجی-مراجع-با-طول-عمرها"><a class="header" href="#اعتبارسنجی-مراجع-با-طول-عمرها">اعتبارسنجی مراجع با طول عمرها</a></h2>
<p>طول عمرها نوع دیگری از جنریک‌ها هستند که ما قبلاً از آن‌ها استفاده کرده‌ایم. به جای اطمینان از اینکه یک نوع رفتار مورد نظر ما را دارد، طول عمرها تضمین می‌کنند که مراجع به اندازه‌ای که نیاز داریم معتبر باقی می‌مانند.</p>
<p>یکی از جزئیاتی که در بخش <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">“مراجع و قرض گرفتن”</a><!-- ignore --> در فصل ۴ بررسی نکردیم این است که هر مرجع در Rust دارای یک <em>طول عمر</em> است، که محدوده‌ای است که آن مرجع در آن معتبر است. بیشتر اوقات، طول عمرها ضمنی و استنتاج‌شده هستند، دقیقاً مانند انواع. ما فقط زمانی نیاز داریم که نوع‌ها را حاشیه‌نویسی کنیم که چندین نوع ممکن باشند. به طور مشابه، ما فقط زمانی نیاز داریم که طول عمرها را حاشیه‌نویسی کنیم که طول عمر مراجع بتوانند به چند روش مختلف مرتبط باشند. Rust ما را ملزم می‌کند تا روابط را با استفاده از پارامترهای جنریک طول عمر حاشیه‌نویسی کنیم تا اطمینان حاصل کنیم که مراجع واقعی استفاده‌شده در زمان اجرا قطعاً معتبر خواهند بود.</p>
<p>حاشیه‌نویسی طول عمر مفهومی نیست که بیشتر زبان‌های برنامه‌نویسی داشته باشند، بنابراین ممکن است این موضوع برای شما ناآشنا باشد. اگرچه در این فصل طول عمرها را به طور کامل پوشش نمی‌دهیم، اما روش‌های رایجی که ممکن است با نحو طول عمر مواجه شوید را بررسی می‌کنیم تا بتوانید با این مفهوم آشنا شوید.</p>
<h3 id="جلوگیری-از-مراجع-آویزان-dangling-references-با-طول-عمرها"><a class="header" href="#جلوگیری-از-مراجع-آویزان-dangling-references-با-طول-عمرها">جلوگیری از مراجع آویزان (Dangling References) با طول عمرها</a></h3>
<p>هدف اصلی طول عمرها جلوگیری از <em>مراجع آویزان</em> است، که باعث می‌شوند یک برنامه به داده‌هایی غیر از داده‌هایی که قرار بوده مراجعه کند اشاره کند. برنامه‌ای را در نظر بگیرید که در لیست ۱۰-۱۶ نشان داده شده است و دارای یک محدوده خارجی و یک محدوده داخلی است.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
<figcaption>Listing 10-16: تلاشی برای استفاده از مرجعی که مقدار آن از محدوده خارج شده است</figcaption>
</figure>
<blockquote>
<p>توجه: مثال‌های لیست ۱۰-۱۶، ۱۰-۱۷، و ۱۰-۲۳ متغیرهایی را بدون مقدار اولیه اعلام می‌کنند، بنابراین نام متغیر در محدوده خارجی وجود دارد. در نگاه اول، این ممکن است در تضاد با عدم وجود مقادیر null در Rust به نظر برسد. با این حال، اگر سعی کنیم از متغیری قبل از مقداردهی آن استفاده کنیم، یک خطای زمان کامپایل دریافت خواهیم کرد، که نشان می‌دهد Rust واقعاً مقادیر null را مجاز نمی‌داند.</p>
</blockquote>
<p>محدوده خارجی یک متغیر به نام <code>r</code> را بدون مقدار اولیه اعلام می‌کند، و محدوده داخلی یک متغیر به نام <code>x</code> را با مقدار اولیه <code>5</code> اعلام می‌کند. در داخل محدوده داخلی، تلاش می‌کنیم مقدار <code>r</code> را به عنوان یک مرجع به <code>x</code> تنظیم کنیم. سپس محدوده داخلی به پایان می‌رسد و سعی می‌کنیم مقدار موجود در <code>r</code> را چاپ کنیم. این کد کامپایل نخواهد شد زیرا مقداری که <code>r</code> به آن اشاره می‌کند قبل از اینکه سعی کنیم از آن استفاده کنیم از محدوده خارج شده است. پیام خطای زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>پیام خطا می‌گوید که متغیر <code>x</code> “به اندازه کافی طول عمر ندارد.” دلیل این است که <code>x</code> وقتی محدوده داخلی در خط ۷ پایان می‌یابد، از محدوده خارج می‌شود. اما <code>r</code> همچنان برای محدوده خارجی معتبر است؛ زیرا محدوده آن بزرگ‌تر است، می‌گوییم که “طول عمر بیشتری دارد.” اگر Rust به این کد اجازه کار کردن می‌داد، <code>r</code> به حافظه‌ای اشاره می‌کرد که وقتی <code>x</code> از محدوده خارج شد آزاد شده است، و هر کاری که سعی می‌کردیم با <code>r</code> انجام دهیم به درستی کار نمی‌کرد. پس چگونه Rust تشخیص می‌دهد که این کد نامعتبر است؟ از یک بررسی‌کننده قرض (borrow checker) استفاده می‌کند.</p>
<h3 id="بررسیکننده-قرض-borrow-checker"><a class="header" href="#بررسیکننده-قرض-borrow-checker">بررسی‌کننده قرض (Borrow Checker)</a></h3>
<p>کامپایلر Rust دارای یک <em>بررسی‌کننده قرض</em> است که محدوده‌ها را مقایسه می‌کند تا تعیین کند که آیا تمام قرض‌ها معتبر هستند یا خیر. لیست ۱۰-۱۷ همان کد لیست ۱۰-۱۶ را نشان می‌دهد اما با حاشیه‌نویسی‌هایی که طول عمر متغیرها را نشان می‌دهد.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
<figcaption>Listing 10-17: حاشیه‌نویسی طول عمرهای <code>r</code> و <code>x</code> که به ترتیب به نام‌های <code>'a</code> و <code>'b</code> نام‌گذاری شده‌اند</figcaption>
</figure>
<p>در اینجا، طول عمر <code>r</code> را با <code>'a</code> و طول عمر <code>x</code> را با <code>'b</code> حاشیه‌نویسی کرده‌ایم. همانطور که می‌بینید، بلوک داخلی <code>'b</code> بسیار کوچک‌تر از بلوک طول عمر خارجی <code>'a</code> است. در زمان کامپایل، Rust اندازه دو طول عمر را مقایسه می‌کند و می‌بیند که <code>r</code> دارای طول عمر <code>'a</code> است اما به حافظه‌ای اشاره می‌کند که طول عمر آن <code>'b</code> است. برنامه رد می‌شود زیرا <code>'b</code> کوتاه‌تر از <code>'a</code> است: موضوع مرجع به اندازه مرجع زنده نیست.</p>
<p>لیست ۱۰-۱۸ کد را اصلاح می‌کند تا یک مرجع آویزان نداشته باشد و بدون هیچ خطایی کامپایل شود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<figcaption>Listing 10-18: یک مرجع معتبر زیرا داده‌ها طول عمری طولانی‌تر از مرجع دارند</figcaption>
</figure>
<p>در اینجا، <code>x</code> دارای طول عمر <code>'b</code> است که در این مورد بزرگ‌تر از <code>'a</code> است. این بدان معناست که <code>r</code> می‌تواند به <code>x</code> اشاره کند زیرا Rust می‌داند که مرجع در <code>r</code> همیشه در حالی که <code>x</code> معتبر است، معتبر خواهد بود.</p>
<p>حالا که می‌دانید طول عمر مراجع چیست و چگونه Rust طول عمرها را تحلیل می‌کند تا اطمینان حاصل کند که مراجع همیشه معتبر خواهند بود، بیایید طول عمرهای جنریک پارامترها و مقادیر بازگشتی را در زمینه توابع بررسی کنیم.</p>
<h3 id="طول-عمرهای-جنریک-در-توابع"><a class="header" href="#طول-عمرهای-جنریک-در-توابع">طول عمرهای جنریک در توابع</a></h3>
<p>ما تابعی خواهیم نوشت که طولانی‌ترین قطعه رشته (string slice) را بازمی‌گرداند. این تابع دو قطعه رشته می‌گیرد و یک قطعه رشته بازمی‌گرداند. پس از پیاده‌سازی تابع <code>longest</code>، کد در لیست ۱۰-۱۹ باید <code>The longest string is abcd</code> را چاپ کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
<figcaption>Listing 10-19: یک تابع <code>main</code> که تابع <code>longest</code> را فراخوانی می‌کند تا طولانی‌ترین قطعه رشته را پیدا کند</figcaption>
</figure>
<p>توجه داشته باشید که می‌خواهیم تابع قطعه رشته‌ها، که مراجع هستند، بگیرد نه رشته‌ها، زیرا نمی‌خواهیم تابع <code>longest</code> مالکیت پارامترهای خود را بگیرد. برای بحث بیشتر درباره اینکه چرا پارامترهایی که در لیست ۱۰-۱۹ استفاده می‌کنیم همان‌هایی هستند که می‌خواهیم، به بخش <a href="ch04-03-slices.html#string-slices-as-parameters">“قطعه رشته‌ها به عنوان پارامترها”</a><!-- ignore --> در فصل ۴ مراجعه کنید.</p>
<p>اگر سعی کنیم تابع <code>longest</code> را همانطور که در لیست ۱۰-۲۰ نشان داده شده است پیاده‌سازی کنیم، کامپایل نمی‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<figcaption>Listing 10-20: پیاده‌سازی تابع <code>longest</code> که طولانی‌ترین قطعه رشته را بازمی‌گرداند اما هنوز کامپایل نمی‌شود</figcaption>
</figure>
<p>به جای آن، خطای زیر را دریافت می‌کنیم که درباره طول عمرها صحبت می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>متن کمکی نشان می‌دهد که نوع بازگشتی نیاز به یک پارامتر طول عمر جنریک دارد زیرا Rust نمی‌تواند تشخیص دهد که مرجع بازگردانده‌شده به <code>x</code> اشاره می‌کند یا به <code>y</code>. در واقع، ما هم نمی‌دانیم، زیرا بلوک <code>if</code> در بدنه این تابع یک مرجع به <code>x</code> بازمی‌گرداند و بلوک <code>else</code> یک مرجع به <code>y</code> بازمی‌گرداند!</p>
<p>وقتی این تابع را تعریف می‌کنیم، مقادیر مشخصی که به این تابع پاس داده می‌شوند را نمی‌دانیم، بنابراین نمی‌دانیم که آیا حالت <code>if</code> یا حالت <code>else</code> اجرا خواهد شد. همچنین طول عمرهای مشخص مراجع پاس‌داده‌شده را نمی‌دانیم، بنابراین نمی‌توانیم به محدوده‌ها مانند لیست‌های ۱۰-۱۷ و ۱۰-۱۸ نگاه کنیم تا تعیین کنیم که مرجعی که بازمی‌گردانیم همیشه معتبر خواهد بود. بررسی‌کننده قرض هم نمی‌تواند این موضوع را تعیین کند زیرا نمی‌داند چگونه طول عمرهای <code>x</code> و <code>y</code> به طول عمر مقدار بازگشتی مرتبط هستند. برای رفع این خطا، پارامترهای طول عمر جنریک اضافه می‌کنیم که رابطه بین مراجع را تعریف می‌کنند تا بررسی‌کننده قرض بتواند تحلیل خود را انجام دهد.</p>
<h3 id="نحو-حاشیهنویسی-طول-عمر"><a class="header" href="#نحو-حاشیهنویسی-طول-عمر">نحو حاشیه‌نویسی طول عمر</a></h3>
<p>حاشیه‌نویسی طول عمر طول عمر هیچ‌یک از مراجع را تغییر نمی‌دهد. بلکه، آن‌ها روابط طول عمرهای چندین مرجع را بدون تأثیر بر طول عمرها توصیف می‌کنند. همانطور که توابع می‌توانند هر نوعی را بپذیرند وقتی امضا یک پارامتر نوع جنریک را مشخص می‌کند، توابع می‌توانند مراجع با هر طول عمری را بپذیرند با مشخص کردن یک پارامتر طول عمر جنریک.</p>
<p>حاشیه‌نویسی طول عمر دارای نحو کمی غیرمعمول است: نام‌های پارامتر طول عمر باید با یک آپاستروف (<code>'</code>) شروع شوند و معمولاً همه حروف کوچک و بسیار کوتاه هستند، مانند نوع‌های جنریک. بیشتر افراد از نام <code>'a</code> برای اولین حاشیه‌نویسی طول عمر استفاده می‌کنند. ما حاشیه‌نویسی‌های پارامتر طول عمر را بعد از <code>&amp;</code> یک مرجع قرار می‌دهیم و از یک فاصله برای جدا کردن حاشیه‌نویسی از نوع مرجع استفاده می‌کنیم.</p>
<p>در اینجا چند مثال آورده شده است: یک مرجع به یک <code>i32</code> بدون پارامتر طول عمر، یک مرجع به یک <code>i32</code> که یک پارامتر طول عمر به نام <code>'a</code> دارد، و یک مرجع قابل تغییر به یک <code>i32</code> که همچنین طول عمر <code>'a</code> دارد:</p>
<pre><code class="language-rust ignore">&amp;i32        // یک مرجع
&amp;'a i32     // یک مرجع با طول عمر صریح
&amp;'a mut i32 // یک مرجع قابل تغییر با طول عمر صریح</code></pre>
<p>یک حاشیه‌نویسی طول عمر به تنهایی معنای زیادی ندارد زیرا حاشیه‌نویسی‌ها برای توضیح دادن به Rust هستند که پارامترهای طول عمر جنریک چندین مرجع چگونه به یکدیگر مرتبط هستند. بیایید بررسی کنیم که حاشیه‌نویسی‌های طول عمر چگونه در زمینه تابع <code>longest</code> به یکدیگر مرتبط هستند.</p>
<h3 id="حاشیهنویسی-طول-عمر-در-امضاهای-توابع"><a class="header" href="#حاشیهنویسی-طول-عمر-در-امضاهای-توابع">حاشیه‌نویسی طول عمر در امضاهای توابع</a></h3>
<p>برای استفاده از حاشیه‌نویسی‌های طول عمر در امضاهای توابع، باید پارامترهای طول عمر جنریک را در داخل پرانتزهای زاویه‌ای بین نام تابع و لیست پارامتر اعلام کنیم، همانطور که با پارامترهای نوع جنریک انجام دادیم.</p>
<p>ما می‌خواهیم امضا محدودیت زیر را بیان کند: مرجع بازگردانده‌شده تا زمانی که هر دو پارامتر معتبر هستند معتبر خواهد بود. این رابطه بین طول عمرهای پارامترها و مقدار بازگشتی است. طول عمر را به نام <code>'a</code> می‌نامیم و سپس آن را به هر مرجع اضافه می‌کنیم، همانطور که در لیست ۱۰-۲۱ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<figcaption>Listing 10-21: تعریف تابع <code>longest</code> که مشخص می‌کند تمام مراجع در امضا باید طول عمر یکسانی به نام <code>'a</code> داشته باشند</figcaption>
</figure>
<p>این کد باید کامپایل شود و نتیجه مورد نظر ما را زمانی که با تابع <code>main</code> در لیست ۱۰-۱۹ استفاده می‌کنیم تولید کند.</p>
<p>امضای تابع اکنون به Rust می‌گوید که برای برخی طول عمر <code>'a</code>، تابع دو پارامتر می‌گیرد که هر دو قطعه رشته‌هایی هستند که حداقل به مدت طول عمر <code>'a</code> زندگی می‌کنند. امضای تابع همچنین به Rust می‌گوید که قطعه رشته‌ای که از تابع بازگردانده می‌شود حداقل به مدت طول عمر <code>'a</code> زندگی می‌کند. در عمل، این بدان معناست که طول عمر مرجعی که توسط تابع <code>longest</code> بازگردانده می‌شود همان طول عمر کوچکتر مقادیر اشاره‌شده توسط آرگومان‌های تابع است. این روابط چیزی است که ما می‌خواهیم Rust هنگام تحلیل این کد از آن‌ها استفاده کند.</p>
<p>به یاد داشته باشید، وقتی پارامترهای طول عمر را در این امضای تابع مشخص می‌کنیم، طول عمر هیچ‌یک از مقادیر پاس‌داده‌شده یا بازگردانده‌شده را تغییر نمی‌دهیم. بلکه، مشخص می‌کنیم که بررسی‌کننده قرض باید هر مقداری را که به این محدودیت‌ها پایبند نیست رد کند. توجه داشته باشید که تابع <code>longest</code> نیازی به دانستن دقیق اینکه <code>x</code> و <code>y</code> چقدر زنده خواهند ماند ندارد، تنها اینکه برخی محدوده‌ها می‌توانند جایگزین <code>'a</code> شوند که این امضا را برآورده کنند.</p>
<p>هنگام حاشیه‌نویسی طول عمرها در توابع، حاشیه‌نویسی‌ها در امضای تابع قرار می‌گیرند، نه در بدنه تابع. حاشیه‌نویسی‌های طول عمر بخشی از قرارداد تابع می‌شوند، مشابه انواع موجود در امضا. داشتن امضای تابع که شامل قرارداد طول عمر است به این معنی است که تحلیلی که کامپایلر Rust انجام می‌دهد می‌تواند ساده‌تر باشد. اگر مشکلی در نحوه حاشیه‌نویسی یک تابع یا نحوه فراخوانی آن وجود داشته باشد، خطاهای کامپایلر می‌توانند به بخش مشخصی از کد ما و محدودیت‌ها اشاره کنند. اگر، به جای آن، کامپایلر Rust استنتاج بیشتری درباره آنچه که قصد داریم روابط طول عمرها باشند انجام دهد، کامپایلر ممکن است فقط بتواند به استفاده‌ای از کد ما اشاره کند که چندین مرحله دور از علت مشکل باشد.</p>
<p>وقتی مراجع مشخصی را به <code>longest</code> پاس می‌دهیم، طول عمر مشخصی که برای <code>'a</code> جایگزین می‌شود بخشی از محدوده <code>x</code> است که با محدوده <code>y</code> هم‌پوشانی دارد. به عبارت دیگر، طول عمر جنریک <code>'a</code> طول عمر مشخصی را می‌گیرد که برابر با کوچک‌ترین طول عمرهای <code>x</code> و <code>y</code> است. از آنجا که مرجع بازگردانده‌شده را با همان پارامتر طول عمر <code>'a</code> حاشیه‌نویسی کرده‌ایم، مرجع بازگردانده‌شده نیز برای مدت کوچک‌ترین طول عمرهای <code>x</code> و <code>y</code> معتبر خواهد بود.</p>
<p>بیایید ببینیم حاشیه‌نویسی طول عمرها چگونه تابع <code>longest</code> را محدود می‌کند با پاس دادن مراجع که طول عمرهای مشخص مختلفی دارند. لیست ۱۰-۲۲ یک مثال ساده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 10-22: استفاده از تابع <code>longest</code> با مراجع به مقادیر <code>String</code> که طول عمرهای مشخص مختلفی دارند</figcaption>
</figure>
<p>در این مثال، <code>string1</code> تا پایان محدوده خارجی معتبر است، <code>string2</code> تا پایان محدوده داخلی معتبر است، و <code>result</code> به چیزی اشاره می‌کند که تا پایان محدوده داخلی معتبر است. این کد را اجرا کنید و خواهید دید که بررسی‌کننده قرض آن را تأیید می‌کند؛ کد کامپایل می‌شود و <code>The longest string is long string is long</code> را چاپ می‌کند.</p>
<p>حال، بیایید مثالی را امتحان کنیم که نشان دهد طول عمر مرجع در <code>result</code> باید کوچک‌ترین طول عمر دو آرگومان باشد. اعلام متغیر <code>result</code> را به بیرون از محدوده داخلی منتقل می‌کنیم، اما مقداردهی به متغیر <code>result</code> را درون محدوده با <code>string2</code> نگه می‌داریم. سپس <code>println!</code> که از <code>result</code> استفاده می‌کند را به بیرون از محدوده داخلی، پس از پایان محدوده داخلی منتقل می‌کنیم. کد در لیست ۱۰-۲۳ کامپایل نمی‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 10-23: تلاش برای استفاده از <code>result</code> پس از اینکه <code>string2</code> از محدوده خارج شده است</figcaption>
</figure>
<p>وقتی تلاش می‌کنیم این کد را کامپایل کنیم، خطای زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>این خطا نشان می‌دهد که برای اینکه <code>result</code> برای دستور <code>println!</code> معتبر باشد، <code>string2</code> باید تا پایان محدوده خارجی معتبر باشد. Rust این را می‌داند زیرا طول عمرهای پارامترهای تابع و مقادیر بازگشتی را با استفاده از همان پارامتر طول عمر <code>'a</code> حاشیه‌نویسی کرده‌ایم.</p>
<p>به عنوان انسان، می‌توانیم به این کد نگاه کنیم و ببینیم که <code>string1</code> طولانی‌تر از <code>string2</code> است، و بنابراین، <code>result</code> یک مرجع به <code>string1</code> خواهد داشت. زیرا <code>string1</code> هنوز از محدوده خارج نشده است، یک مرجع به <code>string1</code> برای دستور <code>println!</code> همچنان معتبر خواهد بود. با این حال، کامپایلر نمی‌تواند ببیند که این مرجع در این مورد معتبر است. ما به Rust گفته‌ایم که طول عمر مرجع بازگردانده‌شده توسط تابع <code>longest</code> همان طول عمر کوچک‌ترین مرجع‌های پاس‌داده‌شده است. بنابراین، بررسی‌کننده قرض کد در لیست ۱۰-۲۳ را به عنوان داشتن یک مرجع نامعتبر احتمالی رد می‌کند.</p>
<p>سعی کنید آزمایش‌های بیشتری طراحی کنید که مقادیر و طول عمر مراجع پاس‌داده‌شده به تابع <code>longest</code> و نحوه استفاده از مرجع بازگردانده‌شده را تغییر دهند. فرضیاتی درباره اینکه آیا آزمایش‌های شما بررسی‌کننده قرض را پاس می‌کنند یا نه ایجاد کنید؛ سپس بررسی کنید که آیا درست می‌گویید!</p>
<h3 id="تفکر-بر-اساس-طول-عمرها"><a class="header" href="#تفکر-بر-اساس-طول-عمرها">تفکر بر اساس طول عمرها</a></h3>
<p>نحوه نیاز شما به مشخص کردن پارامترهای طول عمر به آنچه که تابع شما انجام می‌دهد بستگی دارد. برای مثال، اگر پیاده‌سازی تابع <code>longest</code> را تغییر دهیم تا همیشه اولین پارامتر را به جای طولانی‌ترین قطعه رشته بازگرداند، نیازی به مشخص کردن طول عمر برای پارامتر <code>y</code> نخواهیم داشت. کد زیر کامپایل می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</figure>
<p>ما یک پارامتر طول عمر <code>'a</code> برای پارامتر <code>x</code> و نوع بازگشتی مشخص کرده‌ایم، اما برای پارامتر <code>y</code> نه، زیرا طول عمر <code>y</code> هیچ رابطه‌ای با طول عمر <code>x</code> یا مقدار بازگشتی ندارد.</p>
<p>هنگام بازگرداندن یک مرجع از یک تابع، پارامتر طول عمر برای نوع بازگشتی باید با پارامتر طول عمر یکی از پارامترها مطابقت داشته باشد. اگر مرجع بازگردانده‌شده به یکی از پارامترها اشاره نکند، باید به مقداری که در این تابع ایجاد شده است اشاره کند. با این حال، این یک مرجع آویزان خواهد بود زیرا مقدار در پایان تابع از محدوده خارج می‌شود. به این پیاده‌سازی ناموفق تابع <code>longest</code> که کامپایل نمی‌شود توجه کنید:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</figure>
<p>در اینجا، حتی اگر یک پارامتر طول عمر <code>'a</code> برای نوع بازگشتی مشخص کرده باشیم، این پیاده‌سازی کامپایل نمی‌شود زیرا طول عمر مقدار بازگشتی به هیچ وجه به طول عمر پارامترها مرتبط نیست. پیام خطایی که دریافت می‌کنیم به این شکل است:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>مشکل این است که <code>result</code> از محدوده خارج می‌شود و در پایان تابع <code>longest</code> پاک می‌شود. همچنین سعی می‌کنیم یک مرجع به <code>result</code> را از تابع بازگردانیم. هیچ راهی وجود ندارد که بتوانیم پارامترهای طول عمری مشخص کنیم که مرجع آویزان را تغییر دهد، و Rust به ما اجازه نمی‌دهد یک مرجع آویزان ایجاد کنیم. در این مورد، بهترین راه حل این است که یک نوع داده مالک (owned) به جای یک مرجع بازگردانیم تا تابع فراخوانی‌کننده مسئول پاک‌سازی مقدار باشد.</p>
<p>در نهایت، نحو طول عمرها درباره ارتباط دادن طول عمرهای پارامترها و مقادیر بازگشتی توابع است. وقتی این ارتباط برقرار شد، Rust اطلاعات کافی برای اجازه دادن به عملیات‌های ایمن از نظر حافظه و منع عملیات‌هایی که باعث ایجاد اشاره‌گر (Pointer)های آویزان یا نقض ایمنی حافظه می‌شوند، دارد.</p>
<h3 id="حاشیهنویسی-طول-عمر-در-تعریف-ساختارها"><a class="header" href="#حاشیهنویسی-طول-عمر-در-تعریف-ساختارها">حاشیه‌نویسی طول عمر در تعریف ساختارها</a></h3>
<p>تا کنون، ساختارهایی که تعریف کرده‌ایم همه دارای نوع‌های مالک بوده‌اند. می‌توانیم ساختارهایی را تعریف کنیم که مراجع نگه می‌دارند، اما در این صورت باید برای هر مرجعی در تعریف ساختار یک حاشیه‌نویسی طول عمر اضافه کنیم. لیست ۱۰-۲۴ یک ساختار به نام <code>ImportantExcerpt</code> دارد که یک قطعه رشته نگه می‌دارد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<figcaption>Listing 10-24: یک ساختار که یک مرجع نگه می‌دارد و نیاز به یک حاشیه‌نویسی طول عمر دارد</figcaption>
</figure>
<p>این ساختار دارای یک فیلد به نام <code>part</code> است که یک قطعه رشته نگه می‌دارد، که یک مرجع است. همانند نوع‌های داده جنریک، ما نام پارامتر طول عمر جنریک را در داخل پرانتزهای زاویه‌ای بعد از نام ساختار اعلام می‌کنیم تا بتوانیم پارامتر طول عمر را در بدنه تعریف ساختار استفاده کنیم. این حاشیه‌نویسی به این معنی است که یک نمونه از <code>ImportantExcerpt</code> نمی‌تواند بیشتر از مرجعی که در فیلد <code>part</code> خود نگه می‌دارد زنده بماند.</p>
<p>تابع <code>main</code> در اینجا یک نمونه از ساختار <code>ImportantExcerpt</code> ایجاد می‌کند که یک مرجع به اولین جمله از <code>String</code> که توسط متغیر <code>novel</code> نگه داشته می‌شود، نگه می‌دارد. داده‌های <code>novel</code> قبل از ایجاد نمونه <code>ImportantExcerpt</code> وجود دارند. علاوه بر این، <code>novel</code> تا بعد از خروج <code>ImportantExcerpt</code> از محدوده از محدوده خارج نمی‌شود، بنابراین مرجع در نمونه <code>ImportantExcerpt</code> معتبر است.</p>
<h3 id="حذف-طول-عمر-lifetime-elision"><a class="header" href="#حذف-طول-عمر-lifetime-elision">حذف طول عمر (Lifetime Elision)</a></h3>
<p>آموختید که هر مرجع دارای یک طول عمر است و شما باید برای توابع یا ساختارهایی که از مراجع استفاده می‌کنند پارامترهای طول عمر مشخص کنید. با این حال، ما تابعی در لیست ۴-۹ داشتیم که دوباره در لیست ۱۰-۲۵ نشان داده شده است، که بدون حاشیه‌نویسی طول عمر کامپایل شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 10-25: یک تابع که در لیست ۴-۹ تعریف کردیم و بدون حاشیه‌نویسی طول عمر کامپایل شد، حتی با اینکه پارامتر و نوع بازگشتی مراجع هستند</figcaption>
</figure>
<p>دلیل اینکه این تابع بدون حاشیه‌نویسی طول عمر کامپایل می‌شود تاریخی است: در نسخه‌های اولیه (قبل از 1.0) از Rust، این کد کامپایل نمی‌شد زیرا هر مرجع نیاز به یک طول عمر صریح داشت. در آن زمان، امضای تابع به این صورت نوشته می‌شد:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>پس از نوشتن مقدار زیادی کد Rust، تیم Rust متوجه شد که برنامه‌نویسان Rust در موقعیت‌های خاصی حاشیه‌نویسی‌های طول عمر یکسانی را بارها و بارها وارد می‌کردند. این موقعیت‌ها قابل پیش‌بینی بودند و از چند الگوی تعیین‌کننده پیروی می‌کردند. توسعه‌دهندگان این الگوها را در کد کامپایلر برنامه‌ریزی کردند تا بررسی‌کننده قرض بتواند طول عمرها را در این موقعیت‌ها استنتاج کند و نیازی به حاشیه‌نویسی صریح نباشد.</p>
<p>این بخش از تاریخ Rust مرتبط است زیرا ممکن است الگوهای تعیین‌کننده بیشتری ظاهر شوند و به کامپایلر اضافه شوند. در آینده، حتی حاشیه‌نویسی‌های طول عمر کمتری ممکن است لازم باشد.</p>
<p>الگوهایی که در تحلیل مراجع Rust برنامه‌ریزی شده‌اند <em>قوانین حذف طول عمر</em> (lifetime elision rules) نامیده می‌شوند. این‌ها قوانینی نیستند که برنامه‌نویسان باید رعایت کنند؛ بلکه مجموعه‌ای از موارد خاص هستند که کامپایلر آن‌ها را در نظر می‌گیرد و اگر کد شما با این موارد مطابقت داشته باشد، نیازی به نوشتن طول عمرها به صورت صریح نخواهید داشت.</p>
<p>قوانین حذف طول عمر استنتاج کامل ارائه نمی‌دهند. اگر پس از اعمال قوانین توسط Rust همچنان ابهامی در مورد طول عمر مراجع وجود داشته باشد، کامپایلر حدس نمی‌زند که طول عمر باقی‌مانده چه باید باشد. به جای حدس زدن، کامپایلر به شما خطایی می‌دهد که می‌توانید با افزودن حاشیه‌نویسی‌های طول عمر آن را برطرف کنید.</p>
<p>طول عمرهای روی پارامترهای تابع یا متد <em>طول عمر ورودی</em> (input lifetimes) نامیده می‌شوند، و طول عمرهای روی مقادیر بازگشتی <em>طول عمر خروجی</em> (output lifetimes) نامیده می‌شوند.</p>
<p>کامپایلر از سه قانون برای تشخیص طول عمر مراجع استفاده می‌کند وقتی که حاشیه‌نویسی‌های صریح وجود ندارند. قانون اول برای طول عمرهای ورودی اعمال می‌شود، و قانون دوم و سوم برای طول عمرهای خروجی. اگر کامپایلر به انتهای این سه قانون برسد و هنوز مراجع وجود داشته باشند که نتواند طول عمرهای آن‌ها را تشخیص دهد، کامپایلر با یک خطا متوقف می‌شود. این قوانین به تعاریف <code>fn</code> و همچنین بلوک‌های <code>impl</code> اعمال می‌شوند.</p>
<ul>
<li><strong>قانون اول</strong>: کامپایلر یک پارامتر طول عمر به هر پارامتر که یک مرجع است اختصاص می‌دهد. به عبارت دیگر، یک تابع با یک پارامتر یک پارامتر طول عمر می‌گیرد: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>؛ یک تابع با دو پارامتر دو پارامتر طول عمر جداگانه می‌گیرد: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>؛ و به همین ترتیب.</li>
<li><strong>قانون دوم</strong>: اگر دقیقاً یک پارامتر طول عمر ورودی وجود داشته باشد، آن طول عمر به تمام پارامترهای طول عمر خروجی اختصاص داده می‌شود: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</li>
<li><strong>قانون سوم</strong>: اگر چندین پارامتر طول عمر ورودی وجود داشته باشد، اما یکی از آن‌ها <code>&amp;self</code> یا <code>&amp;mut self</code> باشد زیرا این یک متد است، طول عمر <code>self</code> به تمام پارامترهای طول عمر خروجی اختصاص داده می‌شود. این قانون سوم خواندن و نوشتن متدها را بسیار آسان‌تر می‌کند زیرا نمادهای کمتری لازم است.</li>
</ul>
<p>بیایید وانمود کنیم که ما کامپایلر هستیم. این قوانین را برای تشخیص طول عمر مراجع در امضای تابع <code>first_word</code> در لیست ۱۰-۲۵ اعمال می‌کنیم. امضا بدون هیچ طول عمری که با مراجع مرتبط باشد شروع می‌شود:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>سپس کامپایلر قانون اول را اعمال می‌کند که مشخص می‌کند هر پارامتر طول عمر خاص خود را دریافت می‌کند. ما آن را طبق معمول <code>'a</code> می‌نامیم، بنابراین امضا اکنون به این صورت است:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>قانون دوم اعمال می‌شود زیرا دقیقاً یک طول عمر ورودی وجود دارد. قانون دوم مشخص می‌کند که طول عمر یک پارامتر ورودی به طول عمر خروجی اختصاص داده می‌شود، بنابراین امضا اکنون به این صورت است:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>حالا تمام مراجع در این امضای تابع طول عمر دارند و کامپایلر می‌تواند تحلیل خود را بدون نیاز به برنامه‌نویس برای حاشیه‌نویسی طول عمرها در این امضای تابع ادامه دهد.</p>
<p>بیایید به یک مثال دیگر نگاه کنیم، این بار با استفاده از تابع <code>longest</code> که در ابتدا هیچ پارامتر طول عمری نداشت، همانطور که در لیست ۱۰-۲۰ کار خود را با آن شروع کردیم:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>بیایید قانون اول را اعمال کنیم: هر پارامتر طول عمر خاص خود را دریافت می‌کند. این بار دو پارامتر داریم، بنابراین دو طول عمر داریم:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>می‌بینید که قانون دوم اعمال نمی‌شود زیرا بیش از یک طول عمر ورودی وجود دارد. قانون سوم نیز اعمال نمی‌شود زیرا <code>longest</code> یک تابع است و نه یک متد، بنابراین هیچ یک از پارامترها <code>self</code> نیستند. پس از عبور از تمام سه قانون، هنوز طول عمر نوع بازگشتی را تعیین نکرده‌ایم. به همین دلیل است که هنگام تلاش برای کامپایل کد در لیست ۱۰-۲۰ خطا گرفتیم: کامپایلر قوانین حذف طول عمر را مرور کرد اما همچنان نتوانست تمام طول عمرهای مراجع در امضا را تعیین کند.</p>
<p>از آنجا که قانون سوم واقعاً فقط در امضاهای متد اعمال می‌شود، به بررسی طول عمرها در آن زمینه می‌پردازیم تا ببینیم چرا قانون سوم باعث می‌شود که اغلب نیازی به حاشیه‌نویسی طول عمر در امضاهای متد نداشته باشیم.</p>
<h3 id="حاشیهنویسی-طول-عمر-در-تعریف-متدها"><a class="header" href="#حاشیهنویسی-طول-عمر-در-تعریف-متدها">حاشیه‌نویسی طول عمر در تعریف متدها</a></h3>
<p>وقتی متدهایی را روی یک ساختار با طول عمرها پیاده‌سازی می‌کنیم، از همان نحوی که برای پارامترهای نوع جنریک در لیست ۱۰-۱۱ استفاده شده است، بهره می‌بریم. جایی که پارامترهای طول عمر را اعلام و استفاده می‌کنیم به این بستگی دارد که آیا آن‌ها به فیلدهای ساختار یا به پارامترها و مقادیر بازگشتی متد مربوط هستند یا خیر.</p>
<p>نام‌های طول عمر برای فیلدهای ساختار همیشه باید بعد از کلمه کلیدی <code>impl</code> اعلام شوند و سپس بعد از نام ساختار استفاده شوند، زیرا این طول عمرها بخشی از نوع ساختار هستند.</p>
<p>در امضاهای متد در داخل بلوک <code>impl</code>، مراجع ممکن است به طول عمر مراجع در فیلدهای ساختار مرتبط باشند، یا ممکن است مستقل باشند. علاوه بر این، قوانین حذف طول عمر اغلب باعث می‌شوند که حاشیه‌نویسی طول عمر در امضاهای متد ضروری نباشد. بیایید به چند مثال با استفاده از ساختار <code>ImportantExcerpt</code> که در لیست ۱۰-۲۴ تعریف کردیم، نگاه کنیم.</p>
<p>ابتدا از متدی به نام <code>level</code> استفاده می‌کنیم که تنها پارامتر آن مرجعی به <code>self</code> است و مقدار بازگشتی آن یک <code>i32</code> است که به چیزی اشاره نمی‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>اعلام پارامتر طول عمر بعد از <code>impl</code> و استفاده از آن بعد از نام نوع الزامی است، اما ما نیازی به حاشیه‌نویسی طول عمر مرجع به <code>self</code> نداریم زیرا قانون اول حذف اعمال می‌شود.</p>
<p>در اینجا مثالی است که قانون سوم حذف طول عمر اعمال می‌شود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>دو طول عمر ورودی وجود دارد، بنابراین Rust قانون اول حذف طول عمر را اعمال می‌کند و طول عمرهای جداگانه‌ای به <code>&amp;self</code> و <code>announcement</code> می‌دهد. سپس، چون یکی از پارامترها <code>&amp;self</code> است، نوع بازگشتی طول عمر <code>&amp;self</code> را دریافت می‌کند، و تمام طول عمرها در نظر گرفته شده‌اند.</p>
<h3 id="طول-عمر-استاتیک"><a class="header" href="#طول-عمر-استاتیک">طول عمر استاتیک</a></h3>
<p>یک طول عمر خاص که باید درباره آن صحبت کنیم <code>'static</code> است، که نشان می‌دهد مرجع مورد نظر <em>می‌تواند</em> برای کل مدت اجرای برنامه زنده بماند. تمام رشته‌های لیتری دارای طول عمر <code>'static</code> هستند، که می‌توانیم آن را به این صورت حاشیه‌نویسی کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>متن این رشته مستقیماً در باینری برنامه ذخیره می‌شود، که همیشه در دسترس است. بنابراین، طول عمر تمام رشته‌های لیتری <code>'static</code> است.</p>
<p>ممکن است در پیام‌های خطا پیشنهادهایی برای استفاده از طول عمر <code>'static</code> ببینید. اما قبل از مشخص کردن طول عمر <code>'static</code> برای یک مرجع، فکر کنید که آیا مرجعی که دارید واقعاً برای کل مدت اجرای برنامه زنده است یا خیر، و آیا می‌خواهید چنین باشد. بیشتر اوقات، یک پیام خطا که طول عمر <code>'static</code> را پیشنهاد می‌دهد نتیجه تلاش برای ایجاد یک مرجع آویزان یا ناسازگاری طول عمرهای موجود است. در چنین مواردی، راه حل این است که این مشکلات را برطرف کنید، نه اینکه طول عمر <code>'static</code> را مشخص کنید.</p>
<h2 id="پارامترهای-نوع-جنریک-محدودیت-ویژگی-و-طول-عمرها-با-هم"><a class="header" href="#پارامترهای-نوع-جنریک-محدودیت-ویژگی-و-طول-عمرها-با-هم">پارامترهای نوع جنریک، محدودیت ویژگی، و طول عمرها با هم</a></h2>
<p>بیایید به طور مختصر به نحو مشخص کردن پارامترهای نوع جنریک، محدودیت ویژگی، و طول عمرها در یک تابع نگاه کنیم!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>این تابع <code>longest</code> از لیست ۱۰-۲۱ است که طولانی‌ترین قطعه رشته را بازمی‌گرداند. اما اکنون یک پارامتر اضافی به نام <code>ann</code> دارد که از نوع جنریک <code>T</code> است، که می‌تواند با هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی می‌کند، پر شود، همانطور که توسط بند <code>where</code> مشخص شده است. این پارامتر اضافی با استفاده از <code>{}</code> چاپ خواهد شد، به همین دلیل محدودیت ویژگی <code>Display</code> ضروری است. از آنجا که طول عمرها نوعی جنریک هستند، اعلام طول عمر <code>'a</code> و پارامتر نوع جنریک <code>T</code> در همان لیست داخل پرانتزهای زاویه‌ای بعد از نام تابع قرار می‌گیرند.</p>
<h2 id="خلاصه-9"><a class="header" href="#خلاصه-9">خلاصه</a></h2>
<p>در این فصل مطالب زیادی را پوشش دادیم! حالا که با پارامترهای نوع جنریک، ویژگی‌ها و محدودیت‌های ویژگی، و پارامترهای طول عمر جنریک آشنا شدید، آماده هستید تا کدی بدون تکرار بنویسید که در بسیاری از موقعیت‌های مختلف کار کند. پارامترهای نوع جنریک به شما اجازه می‌دهند که کد را روی انواع مختلف اعمال کنید. ویژگی‌ها و محدودیت‌های ویژگی اطمینان حاصل می‌کنند که حتی با اینکه نوع‌ها جنریک هستند، رفتار مورد نیاز کد را خواهند داشت. شما یاد گرفتید چگونه از حاشیه‌نویسی طول عمر استفاده کنید تا اطمینان حاصل شود که این کد انعطاف‌پذیر هیچ مرجع آویزانی نخواهد داشت. و تمام این تحلیل‌ها در زمان کامپایل انجام می‌شود، که بر عملکرد زمان اجرا تأثیری ندارد!</p>
<p>باور کنید یا نه، مطالب بیشتری برای یادگیری در مورد موضوعاتی که در این فصل بحث شد وجود دارد: فصل ۱۸ به اشیاء ویژگی (trait objects) می‌پردازد، که راه دیگری برای استفاده از ویژگی‌ها است. همچنین سناریوهای پیچیده‌تری وجود دارد که شامل حاشیه‌نویسی طول عمر هستند و فقط در سناریوهای بسیار پیشرفته به آن‌ها نیاز خواهید داشت. برای این موارد، باید <a href="../reference/index.html">مرجع Rust</a> را مطالعه کنید. اما بعد از این، یاد خواهید گرفت که چگونه تست‌هایی در Rust بنویسید تا مطمئن شوید کد شما همانطور که باید کار می‌کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="نوشتن-تستهای-خودکار"><a class="header" href="#نوشتن-تستهای-خودکار">نوشتن تست‌های خودکار</a></h1>
<p>در مقاله‌ای در سال ۱۹۷۲ به نام “The Humble Programmer”، Edsger W. Dijkstra گفت:<br />
«آزمایش برنامه می‌تواند راهی بسیار مؤثر برای نشان دادن وجود باگ‌ها باشد، اما برای نشان دادن عدم وجود آن‌ها کاملاً ناکافی است.»<br />
این به این معنی نیست که نباید تلاش کنیم تا جایی که ممکن است آزمایش کنیم!</p>
<p>درستی در برنامه‌های ما میزان انطباق کد ما با آنچه که قصد انجامش را داریم، است. Rust با نگرانی بالایی درباره درستی برنامه‌ها طراحی شده است، اما درستی پیچیده و اثبات آن آسان نیست. سیستم نوع Rust بخش عظیمی از این بار را به دوش می‌کشد، اما سیستم نوع نمی‌تواند همه چیز را پوشش دهد. به همین دلیل، Rust شامل پشتیبانی برای نوشتن تست‌های خودکار نرم‌افزار است.</p>
<p>فرض کنید یک تابع به نام <code>add_two</code> می‌نویسیم که ۲ را به هر عددی که به آن پاس داده شود اضافه می‌کند. امضای این تابع یک عدد صحیح به عنوان پارامتر می‌پذیرد و یک عدد صحیح به عنوان نتیجه بازمی‌گرداند. هنگامی که این تابع را پیاده‌سازی و کامپایل می‌کنیم، Rust تمام بررسی‌های نوع و قرض‌گیری را که تا کنون آموخته‌اید انجام می‌دهد تا اطمینان حاصل شود که، به عنوان مثال، ما یک مقدار <code>String</code> یا یک مرجع نامعتبر را به این تابع پاس نمی‌دهیم. اما Rust <em>نمی‌تواند</em> بررسی کند که این تابع دقیقاً همان کاری را که ما قصد داریم انجام دهد، که بازگرداندن پارامتر به علاوه ۲ است نه مثلاً پارامتر به علاوه ۱۰ یا پارامتر منهای ۵۰! اینجا جایی است که تست‌ها وارد می‌شوند.</p>
<p>ما می‌توانیم تست‌هایی بنویسیم که، به عنوان مثال، تأیید می‌کنند که وقتی <code>3</code> را به تابع <code>add_two</code> پاس می‌دهیم، مقدار بازگردانده شده <code>5</code> است. می‌توانیم این تست‌ها را هر زمان که تغییری در کد خود ایجاد می‌کنیم اجرا کنیم تا مطمئن شویم که هر رفتار درستی که وجود داشته تغییر نکرده است.</p>
<p>تست‌نویسی یک مهارت پیچیده است: اگرچه نمی‌توانیم در یک فصل تمام جزئیات مربوط به نحوه نوشتن تست‌های خوب را پوشش دهیم، در این فصل درباره مکانیک تسهیلات تست Rust بحث خواهیم کرد. درباره حاشیه‌نویسی‌ها و ماکروهایی که هنگام نوشتن تست‌ها در اختیار دارید صحبت خواهیم کرد، رفتار پیش‌فرض و گزینه‌های ارائه‌شده برای اجرای تست‌ها را بررسی خواهیم کرد، و نحوه سازماندهی تست‌ها به تست‌های واحد و تست‌های یکپارچه را یاد خواهیم گرفت.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="چگونه-تست-بنویسیم"><a class="header" href="#چگونه-تست-بنویسیم">چگونه تست بنویسیم</a></h2>
<p>تست‌ها توابعی در Rust هستند که بررسی می‌کنند کد غیرتستی به شکل مورد انتظار کار می‌کند. بدنه توابع تست معمولاً این سه عمل را انجام می‌دهد:</p>
<ul>
<li>تنظیم هر داده یا وضعیت مورد نیاز.</li>
<li>اجرای کدی که می‌خواهید تست کنید.</li>
<li>تأیید اینکه نتایج همان چیزی است که انتظار دارید.</li>
</ul>
<p>بیایید به ویژگی‌هایی که Rust به طور خاص برای نوشتن تست‌هایی که این اقدامات را انجام می‌دهند فراهم کرده است نگاهی بیندازیم. این ویژگی‌ها شامل ویژگی <code>test</code>، چند ماکرو و ویژگی <code>should_panic</code> هستند.</p>
<h3 id="آناتومی-یک-تابع-تست"><a class="header" href="#آناتومی-یک-تابع-تست">آناتومی یک تابع تست</a></h3>
<p>در ساده‌ترین حالت، یک تست در Rust یک تابع است که با ویژگی <code>test</code> حاشیه‌نویسی شده است. ویژگی‌ها متاداده‌هایی درباره بخش‌های کد Rust هستند؛ یک مثال ویژگی <code>derive</code> است که در فصل ۵ با ساختارها استفاده کردیم. برای تغییر یک تابع به یک تابع تست، <code>#[test]</code> را به خط قبل از <code>fn</code> اضافه کنید. وقتی تست‌های خود را با فرمان <code>cargo test</code> اجرا می‌کنید، Rust یک باینری تست رانر ایجاد می‌کند که توابع حاشیه‌نویسی‌شده را اجرا می‌کند و گزارش می‌دهد که آیا هر تابع تست موفق یا ناموفق بوده است.</p>
<p>هر زمان که یک پروژه کتابخانه‌ای جدید با Cargo ایجاد می‌کنیم، یک ماژول تست با یک تابع تست در آن به صورت خودکار برای ما تولید می‌شود. این ماژول یک قالب برای نوشتن تست‌های شما فراهم می‌کند تا نیازی به جستجوی ساختار و نحو دقیق هر بار که یک پروژه جدید شروع می‌کنید نداشته باشید. می‌توانید هر تعداد تابع تست اضافی و هر تعداد ماژول تست اضافی که می‌خواهید اضافه کنید!</p>
<p>ما برخی از جنبه‌های نحوه عملکرد تست‌ها را با آزمایش قالب تست قبل از اینکه واقعاً کدی را تست کنیم بررسی خواهیم کرد. سپس تست‌هایی در دنیای واقعی می‌نویسیم که برخی کدهایی که نوشته‌ایم را فراخوانی می‌کنند و تأیید می‌کنند که رفتار آن صحیح است.</p>
<p>بیایید یک پروژه کتابخانه‌ای جدید به نام <code>adder</code> ایجاد کنیم که دو عدد را با هم جمع کند:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>محتویات فایل <em>src/lib.rs</em> در کتابخانه <code>adder</code> شما باید شبیه به لیست ۱۱-۱ باشد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption>Listing 11-1: کدی که به طور خودکار توسط <code>cargo new</code> تولید می‌شود</figcaption>
</figure>
<p>این فایل با یک تابع نمونه به نام <code>add</code> شروع می‌شود تا چیزی برای تست کردن داشته باشیم.</p>
<p>فعلاً روی تابع <code>it_works</code> تمرکز می‌کنیم. به حاشیه‌نویسی <code>#[test]</code> توجه کنید: این ویژگی نشان می‌دهد که این یک تابع تست است، بنابراین تست رانر می‌داند که این تابع را به عنوان یک تست در نظر بگیرد. ممکن است توابع غیرتستی نیز در ماژول <code>tests</code> داشته باشیم که به تنظیم سناریوهای مشترک یا انجام عملیات‌های مشترک کمک می‌کنند، بنابراین همیشه باید مشخص کنیم کدام توابع تست هستند.</p>
<p>بدنه تابع نمونه از ماکرو <code>assert_eq!</code> استفاده می‌کند تا اطمینان حاصل کند که <code>result</code>، که حاوی نتیجه فراخوانی <code>add</code> با مقادیر ۲ و ۲ است، برابر با ۴ باشد. این اطمینان به عنوان یک مثال از فرمت یک تست معمولی عمل می‌کند. بیایید آن را اجرا کنیم تا ببینیم این تست پاس می‌شود.</p>
<p>فرمان <code>cargo test</code> تمام تست‌های پروژه ما را اجرا می‌کند، همانطور که در لیست ۱۱-۲ نشان داده شده است.</p>
<figure class="listing">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<figcaption>Listing 11-2: خروجی اجرای تستی که به طور خودکار تولید شده است</figcaption>
</figure>
<p>Cargo تست را کامپایل و اجرا کرد. خط <code>running 1 test</code> را می‌بینیم. خط بعدی نام تابع تست تولیدشده را نشان می‌دهد، که <code>tests::it_works</code> نام دارد، و نتیجه اجرای آن تست <code>ok</code> است. خلاصه کلی <code>test result: ok.</code> نشان می‌دهد که تمام تست‌ها پاس شده‌اند، و بخشی که <code>1 passed; 0 failed</code> را می‌خواند تعداد تست‌هایی که پاس شده‌اند یا ناموفق بوده‌اند را نشان می‌دهد.</p>
<p>این امکان وجود دارد که یک تست را به عنوان نادیده‌گرفته‌شده علامت‌گذاری کنیم تا در یک نمونه خاص اجرا نشود؛ ما این مورد را در بخش <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“نادیده‌گرفتن برخی تست‌ها مگر اینکه صریحاً درخواست شوند”</a><!-- ignore --> در ادامه این فصل پوشش خواهیم داد. چون اینجا این کار را انجام نداده‌ایم، خلاصه <code>0 ignored</code> را نشان می‌دهد.</p>
<p>آمار <code>0 measured</code> برای تست‌های بنچمارک است که عملکرد را اندازه‌گیری می‌کنند. تست‌های بنچمارک، در زمان نوشتن این متن، فقط در نسخه شبانه Rust موجود هستند. برای اطلاعات بیشتر مستندات مربوط به <a href="../unstable-book/library-features/test.html">تست‌های بنچمارک</a> را ببینید.</p>
<p>ما می‌توانیم یک آرگومان به فرمان <code>cargo test</code> بدهیم تا فقط تست‌هایی که نام آن‌ها با یک رشته مطابقت دارد اجرا شوند؛ این به <em>فیلتر کردن</em> معروف است و ما آن را در بخش <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“اجرای زیرمجموعه‌ای از تست‌ها با نام”</a><!-- ignore --> پوشش خواهیم داد. اینجا ما تست‌های در حال اجرا را فیلتر نکرده‌ایم، بنابراین پایان خلاصه <code>0 filtered out</code> را نشان می‌دهد.</p>
<p>قسمت بعدی خروجی تست که با <code>Doc-tests adder</code> شروع می‌شود، نتایج هر تست مستنداتی را نشان می‌دهد. هنوز هیچ تست مستنداتی نداریم، اما Rust می‌تواند هر نمونه کدی که در مستندات API ما ظاهر می‌شود را کامپایل کند. این ویژگی به همگام نگه داشتن مستندات و کد شما کمک می‌کند! ما نحوه نوشتن تست‌های مستنداتی را در بخش <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“توضیحات مستندات به عنوان تست‌ها”</a><!-- ignore --> از فصل ۱۴ بررسی خواهیم کرد. فعلاً خروجی <code>Doc-tests</code> را نادیده می‌گیریم.</p>
<p>بیایید تست را مطابق نیازهای خود شخصی‌سازی کنیم. ابتدا نام تابع <code>it_works</code> را به یک نام دیگر، مانند <code>exploration</code> تغییر دهید، به این صورت:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>سپس دوباره <code>cargo test</code> را اجرا کنید. خروجی اکنون به جای <code>it_works</code> نام <code>exploration</code> را نشان می‌دهد:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>حالا یک تست دیگر اضافه می‌کنیم، اما این بار تستی می‌نویسیم که شکست بخورد! تست‌ها زمانی شکست می‌خورند که چیزی در تابع تست باعث ایجاد panic شود. هر تست در یک نخ (thread) جدید اجرا می‌شود، و وقتی نخ اصلی می‌بیند که یک نخ تست متوقف شده است، تست به عنوان شکست‌خورده علامت‌گذاری می‌شود. در فصل ۹، درباره اینکه ساده‌ترین راه برای panic کردن فراخوانی ماکروی <code>panic!</code> است صحبت کردیم. تابع جدیدی به نام <code>another</code> وارد کنید تا فایل <em>src/lib.rs</em> شما شبیه به لیست ۱۱-۳ شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
<figcaption>Listing 11-3: اضافه کردن یک تست دوم که به دلیل فراخوانی ماکروی <code>panic!</code> شکست می‌خورد</figcaption>
</figure>
<p>دوباره تست‌ها را با استفاده از <code>cargo test</code> اجرا کنید. خروجی باید شبیه به لیست ۱۱-۴ باشد، که نشان می‌دهد تست <code>exploration</code> موفق شده است و <code>another</code> شکست خورده است.</p>
<figure class="listing">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<figcaption>Listing 11-4: نتایج تست زمانی که یک تست موفق می‌شود و یک تست شکست می‌خورد</figcaption>
</figure>
<p>به جای <code>ok</code>، خط <code>test tests::another</code> نشان می‌دهد <code>FAILED</code>. دو بخش جدید بین نتایج فردی و خلاصه ظاهر می‌شود: بخش اول دلیل دقیق شکست هر تست را نشان می‌دهد. در این مورد، ما جزئیات را دریافت می‌کنیم که <code>another</code> به دلیل <code>panicked at 'Make this test fail'</code> در خط ۱۷ فایل <em>src/lib.rs</em> شکست خورده است. بخش بعدی فقط نام تمام تست‌های شکست‌خورده را لیست می‌کند، که وقتی تعداد زیادی تست و خروجی‌های شکست‌خورده زیاد هستند مفید است. ما می‌توانیم نام یک تست شکست‌خورده را برای اجرای فقط همان تست استفاده کنیم تا راحت‌تر آن را اشکال‌زدایی کنیم؛ ما در بخش <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“کنترل نحوه اجرای تست‌ها”</a><!-- ignore --> بیشتر در مورد روش‌های اجرای تست‌ها صحبت خواهیم کرد.</p>
<p>خط خلاصه در انتها نمایش داده می‌شود: به طور کلی، نتیجه تست ما <code>FAILED</code> است. یک تست موفق شد و یک تست شکست خورد.</p>
<p>حالا که دیدید نتایج تست در سناریوهای مختلف چگونه به نظر می‌رسند، بیایید به برخی از ماکروهای دیگر به جز <code>panic!</code> که در تست‌ها مفید هستند نگاهی بیندازیم.</p>
<h3 id="بررسی-نتایج-با-ماکروی-assert"><a class="header" href="#بررسی-نتایج-با-ماکروی-assert">بررسی نتایج با ماکروی <code>assert!</code></a></h3>
<p>ماکروی <code>assert!</code> که توسط کتابخانه استاندارد ارائه شده است، زمانی مفید است که بخواهید اطمینان حاصل کنید که یک شرط در یک تست به <code>true</code> ارزیابی می‌شود. ماکروی <code>assert!</code> یک آرگومان می‌گیرد که به یک مقدار بولی ارزیابی می‌شود. اگر مقدار <code>true</code> باشد، هیچ اتفاقی نمی‌افتد و تست پاس می‌شود. اگر مقدار <code>false</code> باشد، ماکروی <code>assert!</code> فراخوانی <code>panic!</code> را انجام می‌دهد تا باعث شکست تست شود. استفاده از ماکروی <code>assert!</code> به ما کمک می‌کند تا بررسی کنیم که کد ما همانطور که قصد داریم عمل می‌کند.</p>
<p>در فصل ۵، لیست ۵-۱۵، از یک ساختار <code>Rectangle</code> و یک متد <code>can_hold</code> استفاده کردیم، که در لیست ۱۱-۵ دوباره تکرار شده است. این کد را در فایل <em>src/lib.rs</em> قرار دهید، سپس با استفاده از ماکروی <code>assert!</code> چند تست برای آن بنویسید.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<figcaption>Listing 11-5: ساختار <code>Rectangle</code> و متد <code>can_hold</code> آن از فصل ۵</figcaption>
</figure>
<p>متد <code>can_hold</code> یک مقدار بولی بازمی‌گرداند، که به این معنی است که یک مورد استفاده عالی برای ماکروی <code>assert!</code> است. در لیست ۱۱-۶، ما تستی می‌نویسیم که متد <code>can_hold</code> را با ایجاد یک نمونه از <code>Rectangle</code> که عرض ۸ و ارتفاع ۷ دارد آزمایش می‌کند و تأیید می‌کند که می‌تواند نمونه دیگری از <code>Rectangle</code> که عرض ۵ و ارتفاع ۱ دارد را در خود جای دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<figcaption>Listing 11-6: تستی برای <code>can_hold</code> که بررسی می‌کند آیا یک مستطیل بزرگ‌تر می‌تواند واقعاً یک مستطیل کوچک‌تر را در خود جای دهد</figcaption>
</figure>
<p>به خط <code>use super::*;</code> در داخل ماژول <code>tests</code> توجه کنید. ماژول <code>tests</code> یک ماژول معمولی است که از قوانین دیدپذیری معمولی که در فصل ۷ در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“مسیرها برای اشاره به یک مورد در درخت ماژول”</a><!-- ignore --> پوشش دادیم پیروی می‌کند. از آنجا که ماژول <code>tests</code> یک ماژول داخلی است، باید کدی که در ماژول خارجی است را به دامنه ماژول داخلی بیاوریم. در اینجا از یک glob استفاده می‌کنیم، بنابراین هر چیزی که در ماژول خارجی تعریف کنیم برای این ماژول <code>tests</code> در دسترس است.</p>
<p>تست خود را <code>larger_can_hold_smaller</code> نام‌گذاری کرده‌ایم، و دو نمونه <code>Rectangle</code> که نیاز داشتیم را ایجاد کرده‌ایم. سپس ماکروی <code>assert!</code> را فراخوانی کردیم و نتیجه فراخوانی <code>larger.can_hold(&amp;smaller)</code> را به آن پاس دادیم. این عبارت قرار است <code>true</code> بازگرداند، بنابراین تست ما باید پاس شود. بیایید ببینیم چه اتفاقی می‌افتد!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>پاس شد! حالا یک تست دیگر اضافه کنیم، این بار تأیید می‌کنیم که یک مستطیل کوچک‌تر نمی‌تواند یک مستطیل بزرگ‌تر را در خود جای دهد:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>از آنجا که نتیجه صحیح تابع <code>can_hold</code> در این مورد <code>false</code> است، باید آن نتیجه را قبل از پاس دادن به ماکروی <code>assert!</code> منفی کنیم. به این ترتیب، تست ما زمانی پاس می‌شود که <code>can_hold</code> مقدار <code>false</code> را بازگرداند:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>دو تست که پاس می‌شوند! حالا بیایید ببینیم وقتی باگی به کد خود وارد می‌کنیم چه اتفاقی برای نتایج تست ما می‌افتد. پیاده‌سازی متد <code>can_hold</code> را با جایگزینی علامت بزرگتر (<code>&gt;</code>) با علامت کوچکتر (<code>&lt;</code>) هنگام مقایسه عرض‌ها تغییر می‌دهیم:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>اجرای تست‌ها اکنون خروجی زیر را تولید می‌کند:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>تست‌های ما باگ را پیدا کردند! از آنجا که <code>larger.width</code> مقدار <code>8</code> و <code>smaller.width</code> مقدار <code>5</code> دارد، مقایسه عرض‌ها در <code>can_hold</code> اکنون <code>false</code> بازمی‌گرداند: ۸ کمتر از ۵ نیست.</p>
<h3 id="تست-برابری-با-ماکروهای-assert_eq-و-assert_ne"><a class="header" href="#تست-برابری-با-ماکروهای-assert_eq-و-assert_ne">تست برابری با ماکروهای <code>assert_eq!</code> و <code>assert_ne!</code></a></h3>
<p>یک روش معمول برای بررسی عملکرد، تست برابری بین نتیجه کد تحت تست و مقدار مورد انتظار است. می‌توانید این کار را با استفاده از ماکروی <code>assert!</code> و پاس دادن یک عبارت با استفاده از عملگر <code>==</code> انجام دهید. با این حال، این یک تست بسیار معمول است که کتابخانه استاندارد یک جفت ماکرو—<code>assert_eq!</code> و <code>assert_ne!</code>—برای انجام این تست به صورت راحت‌تر فراهم کرده است. این ماکروها به ترتیب دو آرگومان را برای برابری یا نابرابری مقایسه می‌کنند. اگر ادعا شکست بخورد، این ماکروها دو مقدار را نیز چاپ می‌کنند، که مشاهده دلیل شکست تست را آسان‌تر می‌کند. در مقابل، ماکروی <code>assert!</code> فقط نشان می‌دهد که یک مقدار <code>false</code> برای عبارت <code>==</code> دریافت کرده است، بدون چاپ مقادیری که منجر به مقدار <code>false</code> شده‌اند.</p>
<p>در لیست ۱۱-۷، تابعی به نام <code>add_two</code> می‌نویسیم که <code>۲</code> را به پارامتر خود اضافه می‌کند، سپس این تابع را با استفاده از ماکروی <code>assert_eq!</code> تست می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption>Listing 11-7: تست تابع <code>add_two</code> با استفاده از ماکروی <code>assert_eq!</code></figcaption>
</figure>
<p>بیایید بررسی کنیم که آیا پاس می‌شود!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>یک متغیر به نام <code>result</code> ایجاد می‌کنیم که نتیجه فراخوانی <code>add_two(2)</code> را نگه می‌دارد. سپس <code>result</code> و <code>4</code> را به عنوان آرگومان‌ها به <code>assert_eq!</code> پاس می‌دهیم. خط خروجی برای این تست <code>test tests::it_adds_two ... ok</code> است، و متن <code>ok</code> نشان می‌دهد که تست ما پاس شده است!</p>
<p>بیایید یک باگ به کد خود وارد کنیم تا ببینیم ماکروی <code>assert_eq!</code> وقتی شکست می‌خورد چگونه به نظر می‌رسد. پیاده‌سازی تابع <code>add_two</code> را تغییر می‌دهیم تا به جای <code>۲</code> مقدار <code>۳</code> را اضافه کند:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>تست‌ها را دوباره اجرا کنید:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>تست ما باگ را پیدا کرد! تست <code>it_adds_two</code> شکست خورد، و پیام به ما می‌گوید <code>assertion `left == right` failed</code> و مقادیر <code>left</code> و <code>right</code> چیستند. این پیام به ما کمک می‌کند اشکال‌زدایی را شروع کنیم: آرگومان <code>left</code>، جایی که نتیجه فراخوانی <code>add_two(2)</code> را داشتیم، مقدار <code>5</code> بود، اما آرگومان <code>right</code> مقدار <code>4</code> بود. می‌توانید تصور کنید که این موضوع وقتی تعداد زیادی تست داشته باشیم بسیار مفید خواهد بود.</p>
<p>توجه داشته باشید که در برخی زبان‌ها و چارچوب‌های تست، پارامترهای توابع بررسی برابری <code>expected</code> و <code>actual</code> نامیده می‌شوند و ترتیب مشخص کردن آرگومان‌ها مهم است. اما در Rust، آن‌ها <code>left</code> و <code>right</code> نامیده می‌شوند، و ترتیب مشخص کردن مقداری که انتظار داریم و مقداری که کد تولید می‌کند مهم نیست. می‌توانیم ادعا را در این تست به صورت <code>assert_eq!(4, result)</code> بنویسیم، که همان پیام شکست را که <code>assertion failed: `(left == right)`</code> نمایش می‌دهد، تولید می‌کند.</p>
<p>ماکروی <code>assert_ne!</code> زمانی پاس می‌شود که دو مقداری که به آن می‌دهیم برابر نباشند و شکست می‌خورد اگر برابر باشند. این ماکرو برای مواردی مفید است که مطمئن نیستیم یک مقدار <em>چه خواهد بود</em>، اما می‌دانیم که مقدار به طور قطع <em>چه نباید باشد</em>. برای مثال، اگر تابعی را تست می‌کنیم که تضمین شده است ورودی خود را به نوعی تغییر دهد، اما نحوه تغییر ورودی به روز هفته‌ای که تست‌های خود را اجرا می‌کنیم بستگی دارد، بهترین چیزی که می‌توانیم تأیید کنیم این است که خروجی تابع برابر با ورودی نیست.</p>
<p>در پس‌زمینه، ماکروهای <code>assert_eq!</code> و <code>assert_ne!</code> به ترتیب از عملگرهای <code>==</code> و <code>!=</code> استفاده می‌کنند. وقتی ادعا شکست می‌خورد، این ماکروها آرگومان‌های خود را با استفاده از قالب‌بندی دیباگ چاپ می‌کنند، که به این معنی است که مقادیر مقایسه‌شده باید ویژگی‌های <code>PartialEq</code> و <code>Debug</code> را پیاده‌سازی کنند. تمام نوع‌های اولیه و بیشتر نوع‌های کتابخانه استاندارد این ویژگی‌ها را پیاده‌سازی می‌کنند. برای ساختارها و انوم‌هایی که خودتان تعریف می‌کنید، باید <code>PartialEq</code> را برای تأیید برابری این نوع‌ها پیاده‌سازی کنید. همچنین باید <code>Debug</code> را برای چاپ مقادیر زمانی که ادعا شکست می‌خورد پیاده‌سازی کنید. از آنجا که هر دو ویژگی قابل اشتقاق هستند، همانطور که در لیست ۵-۱۲ فصل ۵ اشاره شد، این معمولاً به سادگی افزودن حاشیه‌نویسی <code>#[derive(PartialEq, Debug)]</code> به تعریف ساختار یا انوم شما است. برای جزئیات بیشتر در مورد این ویژگی‌ها و سایر ویژگی‌های قابل اشتقاق، به ضمیمه ج، <a href="appendix-03-derivable-traits.html">“ویژگی‌های قابل اشتقاق”</a><!-- ignore --> مراجعه کنید.</p>
<h3 id="افزودن-پیامهای-شکست-سفارشی"><a class="header" href="#افزودن-پیامهای-شکست-سفارشی">افزودن پیام‌های شکست سفارشی</a></h3>
<p>همچنین می‌توانید یک پیام سفارشی برای چاپ همراه با پیام شکست به عنوان آرگومان‌های اختیاری به ماکروهای <code>assert!</code>، <code>assert_eq!</code> و <code>assert_ne!</code> اضافه کنید. هر آرگومانی که بعد از آرگومان‌های اجباری مشخص شده باشد به ماکروی <code>format!</code> (که در فصل ۸ در بخش <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“ادغام با عملگر <code>+</code> یا ماکروی <code>format!</code>”</a><!-- ignore --> بحث شد) پاس داده می‌شود، بنابراین می‌توانید یک رشته قالب که شامل نگهدارنده‌های <code>{}</code> است و مقادیری که در آن نگهدارنده‌ها قرار می‌گیرند را پاس دهید. پیام‌های سفارشی برای مستندسازی معنای یک ادعا مفید هستند؛ وقتی یک تست شکست می‌خورد، ایده بهتری از مشکل کد خواهید داشت.</p>
<p>برای مثال، فرض کنید تابعی داریم که افراد را با نامشان خوشامد می‌گوید و می‌خواهیم تست کنیم که نامی که به تابع پاس می‌دهیم در خروجی ظاهر می‌شود:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>نیازمندی‌های این برنامه هنوز مورد توافق قرار نگرفته‌اند، و ما تقریباً مطمئن هستیم که متن <code>Hello</code> در ابتدای پیام خوشامد تغییر خواهد کرد. تصمیم گرفتیم که نمی‌خواهیم وقتی نیازمندی‌ها تغییر می‌کنند، تست را به‌روزرسانی کنیم، بنابراین به جای بررسی برابری دقیق با مقدار بازگشتی از تابع <code>greeting</code>، فقط تأیید می‌کنیم که خروجی شامل متن پارامتر ورودی است.</p>
<p>حالا بیایید یک باگ به این کد وارد کنیم با تغییر <code>greeting</code> به‌طوری که <code>name</code> را شامل نشود تا ببینیم پیام شکست تست پیش‌فرض چگونه است:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>اجرای این تست خروجی زیر را تولید می‌کند:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>این نتیجه فقط نشان می‌دهد که ادعا شکست خورده است و خطی که ادعا در آن قرار دارد کدام است. یک پیام شکست مفیدتر مقدار بازگشتی از تابع <code>greeting</code> را چاپ می‌کرد. بیایید یک پیام شکست سفارشی اضافه کنیم که از یک رشته قالب با یک نگهدارنده که با مقدار واقعی بازگشتی از تابع <code>greeting</code> پر شده است، تشکیل شده باشد:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>حالا وقتی تست را اجرا می‌کنیم، یک پیام خطای اطلاع‌رسان‌تر دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>ما می‌توانیم مقدار واقعی‌ای که در خروجی تست دریافت کردیم را ببینیم، که به ما کمک می‌کند تا اشکال‌زدایی کنیم که چه اتفاقی افتاد به جای آنچه که انتظار داشتیم اتفاق بیفتد.</p>
<h3 id="بررسی-پانیک-با-should_panic"><a class="header" href="#بررسی-پانیک-با-should_panic">بررسی پانیک با <code>should_panic</code></a></h3>
<p>علاوه بر بررسی مقادیر بازگشتی، مهم است که بررسی کنیم کد ما شرایط خطا را همانطور که انتظار داریم مدیریت می‌کند. برای مثال، نوع <code>Guess</code> را که در فصل ۹، لیست ۹-۱۳ ایجاد کردیم در نظر بگیرید. سایر کدهایی که از <code>Guess</code> استفاده می‌کنند به این تضمین وابسته هستند که نمونه‌های <code>Guess</code> فقط مقادیر بین ۱ و ۱۰۰ را شامل می‌شوند. می‌توانیم تستی بنویسیم که اطمینان حاصل کند که تلاش برای ایجاد یک نمونه <code>Guess</code> با مقداری خارج از این بازه منجر به پانیک می‌شود.</p>
<p>این کار را با افزودن ویژگی <code>should_panic</code> به تابع تست خود انجام می‌دهیم. اگر کد داخل تابع پانیک کند، تست پاس می‌شود؛ اگر کد داخل تابع پانیک نکند، تست شکست می‌خورد.</p>
<p>لیست ۱۱-۸ یک تست را نشان می‌دهد که بررسی می‌کند شرایط خطای <code>Guess::new</code> زمانی که انتظار داریم رخ می‌دهند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption>Listing 11-8: تست کردن اینکه آیا یک شرط باعث یک <code>panic!</code> می‌شود</figcaption>
</figure>
<p>ما ویژگی <code>#[should_panic]</code> را بعد از ویژگی <code>#[test]</code> و قبل از تابع تستی که به آن اعمال می‌شود قرار می‌دهیم. بیایید به نتیجه‌ای که وقتی این تست پاس می‌شود نگاه کنیم:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>به نظر خوب می‌آید! حالا بیایید یک باگ در کد خود وارد کنیم با حذف شرطی که تابع <code>new</code> را مجبور می‌کند اگر مقدار بیشتر از ۱۰۰ باشد پانیک کند:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>وقتی تست در لیست ۱۱-۸ را اجرا می‌کنیم، شکست می‌خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>در این مورد پیام خیلی مفیدی دریافت نمی‌کنیم، اما وقتی به تابع تست نگاه می‌کنیم، می‌بینیم که با <code>#[should_panic]</code> حاشیه‌نویسی شده است. شکست به این معناست که کدی که در تابع تست قرار دارد باعث یک پانیک نشده است.</p>
<p>تست‌هایی که از <code>should_panic</code> استفاده می‌کنند می‌توانند دقیق نباشند. یک تست <code>should_panic</code> حتی اگر تست برای دلیلی غیر از آنچه انتظار داشتیم پانیک کند، پاس می‌شود. برای دقیق‌تر کردن تست‌های <code>should_panic</code>، می‌توانیم یک پارامتر اختیاری <code>expected</code> به ویژگی <code>should_panic</code> اضافه کنیم. تست رانر اطمینان حاصل می‌کند که پیام شکست شامل متن ارائه‌شده است. برای مثال، کد تغییر داده‌شده برای <code>Guess</code> در لیست ۱۱-۹ را در نظر بگیرید که تابع <code>new</code> با پیام‌های مختلف بسته به اینکه مقدار خیلی کوچک یا خیلی بزرگ باشد پانیک می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption>Listing 11-9: تست کردن یک <code>panic!</code> با یک پیام پانیک که حاوی یک زیررشته مشخص است</figcaption>
</figure>
<p>این تست پاس می‌شود زیرا مقداری که در پارامتر <code>expected</code> ویژگی <code>should_panic</code> قرار داده‌ایم یک زیررشته از پیامی است که تابع <code>Guess::new</code> با آن پانیک می‌کند. می‌توانستیم کل پیام پانیکی که انتظار داریم را مشخص کنیم، که در این مورد می‌شد <code>Guess value must be less than or equal to 100, got 200</code>. آنچه انتخاب می‌کنید بستگی به این دارد که چه مقدار از پیام پانیک منحصر به فرد یا پویا است و چقدر می‌خواهید تست شما دقیق باشد. در این مورد، یک زیررشته از پیام پانیک کافی است تا اطمینان حاصل شود که کد در تابع تست مورد <code>else if value &gt; 100</code> را اجرا می‌کند.</p>
<p>برای دیدن اینکه وقتی یک تست <code>should_panic</code> با یک پیام <code>expected</code> شکست می‌خورد چه اتفاقی می‌افتد، بیایید دوباره یک باگ به کد خود وارد کنیم با جابه‌جا کردن بدنه‌های بلوک‌های <code>if value &lt; 1</code> و <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>این بار وقتی تست <code>should_panic</code> را اجرا می‌کنیم، شکست خواهد خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>پیام شکست نشان می‌دهد که این تست همانطور که انتظار داشتیم پانیک کرد، اما پیام پانیک شامل رشته مورد انتظار <code>less than or equal to 100</code> نبود. پیام پانیکی که در این مورد دریافت کردیم <code>Guess value must be greater than or equal to 1, got 200.</code> بود. حالا می‌توانیم شروع به پیدا کردن محل باگ کنیم!</p>
<h3 id="استفاده-از-resultt-e-در-تستها"><a class="header" href="#استفاده-از-resultt-e-در-تستها">استفاده از <code>Result&lt;T, E&gt;</code> در تست‌ها</a></h3>
<p>تست‌های ما تا اینجا همه زمانی که شکست می‌خورند پانیک می‌کنند. همچنین می‌توانیم تست‌هایی بنویسیم که از <code>Result&lt;T, E&gt;</code> استفاده کنند! در اینجا تست لیست ۱۱-۱ را بازنویسی کرده‌ایم تا از <code>Result&lt;T, E&gt;</code> استفاده کند و به جای پانیک کردن، یک <code>Err</code> بازگرداند:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>تابع <code>it_works</code> اکنون نوع بازگشتی <code>Result&lt;(), String&gt;</code> دارد. در بدنه تابع، به جای فراخوانی ماکروی <code>assert_eq!</code>، وقتی تست پاس می‌شود <code>Ok(())</code> و وقتی تست شکست می‌خورد یک <code>Err</code> با یک <code>String</code> داخل آن بازمی‌گردانیم.</p>
<p>نوشتن تست‌هایی که یک <code>Result&lt;T, E&gt;</code> بازمی‌گردانند به شما اجازه می‌دهد از عملگر سوالی <code>?</code> در بدنه تست‌ها استفاده کنید، که می‌تواند راهی راحت برای نوشتن تست‌هایی باشد که اگر هر عملیاتی در آن‌ها یک واریانت <code>Err</code> بازگرداند، شکست بخورند.</p>
<p>شما نمی‌توانید از حاشیه‌نویسی <code>#[should_panic]</code> در تست‌هایی که از <code>Result&lt;T, E&gt;</code> استفاده می‌کنند استفاده کنید. برای تأیید اینکه یک عملیات یک واریانت <code>Err</code> بازمی‌گرداند، <em>از</em> عملگر سوالی روی مقدار <code>Result&lt;T, E&gt;</code> استفاده نکنید. در عوض، از <code>assert!(value.is_err())</code> استفاده کنید.</p>
<p>حالا که چندین روش برای نوشتن تست‌ها را یاد گرفتید، بیایید نگاهی به آنچه هنگام اجرای تست‌ها اتفاق می‌افتد بیندازیم و گزینه‌های مختلفی را که می‌توانیم با <code>cargo test</code> استفاده کنیم بررسی کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="کنترل-نحوه-اجرای-تستها"><a class="header" href="#کنترل-نحوه-اجرای-تستها">کنترل نحوه اجرای تست‌ها</a></h2>
<p>دقیقاً همانطور که <code>cargo run</code> کد شما را کامپایل کرده و باینری حاصل را اجرا می‌کند، <code>cargo test</code> کد شما را در حالت تست کامپایل کرده و باینری تست حاصل را اجرا می‌کند. رفتار پیش‌فرض باینری تولیدشده توسط <code>cargo test</code> این است که تمام تست‌ها را به صورت موازی اجرا کرده و خروجی تولید شده در طول اجرای تست‌ها را ضبط کند. این کار از نمایش خروجی جلوگیری کرده و خواندن خروجی مرتبط با نتایج تست را آسان‌تر می‌کند. با این حال، می‌توانید با مشخص کردن گزینه‌های خط فرمان این رفتار پیش‌فرض را تغییر دهید.</p>
<p>برخی گزینه‌های خط فرمان به <code>cargo test</code> می‌روند و برخی دیگر به باینری تست حاصل ارسال می‌شوند. برای جدا کردن این دو نوع آرگومان، آرگومان‌هایی که به <code>cargo test</code> می‌روند را ذکر کنید و سپس جداکننده <code>--</code> و آرگومان‌هایی که به باینری تست می‌روند را بیاورید. اجرای <code>cargo test --help</code> گزینه‌هایی را نمایش می‌دهد که می‌توانید با <code>cargo test</code> استفاده کنید، و اجرای <code>cargo test -- --help</code> گزینه‌هایی را که می‌توانید پس از جداکننده استفاده کنید نمایش می‌دهد. این گزینه‌ها همچنین در <a href="https://doc.rust-lang.org/rustc/tests/index.html">بخش “تست‌ها”</a> از <a href="https://doc.rust-lang.org/rustc/index.html">کتاب rustc</a> مستند شده‌اند.</p>
<h3 id="اجرای-تستها-به-صورت-موازی-یا-متوالی"><a class="header" href="#اجرای-تستها-به-صورت-موازی-یا-متوالی">اجرای تست‌ها به صورت موازی یا متوالی</a></h3>
<p>وقتی چندین تست را اجرا می‌کنید، به طور پیش‌فرض این تست‌ها به صورت موازی با استفاده از نخ‌ها (threads) اجرا می‌شوند، به این معنی که سریع‌تر به پایان می‌رسند و بازخورد سریع‌تری دریافت می‌کنید. از آنجا که تست‌ها به صورت هم‌زمان اجرا می‌شوند، باید اطمینان حاصل کنید که تست‌های شما به یکدیگر یا به هیچ حالت مشترکی، از جمله یک محیط مشترک مانند دایرکتوری کاری جاری یا متغیرهای محیطی، وابسته نیستند.</p>
<p>برای مثال، فرض کنید هر یک از تست‌های شما کدی را اجرا می‌کند که یک فایل به نام <em>test-output.txt</em> روی دیسک ایجاد کرده و داده‌هایی در آن فایل می‌نویسد. سپس هر تست داده‌های موجود در آن فایل را خوانده و تأیید می‌کند که فایل شامل یک مقدار خاص است، که در هر تست متفاوت است. چون تست‌ها به طور هم‌زمان اجرا می‌شوند، ممکن است یک تست فایل را در زمانی که تست دیگری در حال نوشتن و خواندن فایل است، بازنویسی کند. در این صورت، تست دوم شکست خواهد خورد، نه به این دلیل که کد اشتباه است بلکه به این دلیل که تست‌ها در هنگام اجرای موازی با یکدیگر تداخل پیدا کرده‌اند. یک راه‌حل این است که مطمئن شوید هر تست به یک فایل متفاوت می‌نویسد؛ راه‌حل دیگر این است که تست‌ها را یکی یکی اجرا کنید.</p>
<p>اگر نمی‌خواهید تست‌ها به صورت موازی اجرا شوند یا اگر می‌خواهید کنترل بیشتری بر تعداد نخ‌های استفاده‌شده داشته باشید، می‌توانید فلگ <code>--test-threads</code> و تعداد نخ‌هایی که می‌خواهید استفاده کنید را به باینری تست ارسال کنید. به مثال زیر توجه کنید:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>ما تعداد نخ‌های تست را به <code>1</code> تنظیم کردیم، به برنامه می‌گوییم از هیچ موازی‌سازی استفاده نکند. اجرای تست‌ها با یک نخ بیشتر از اجرای آن‌ها به صورت موازی طول می‌کشد، اما تست‌ها در صورتی که حالت مشترکی داشته باشند با یکدیگر تداخل پیدا نمی‌کنند.</p>
<h3 id="نمایش-خروجی-توابع"><a class="header" href="#نمایش-خروجی-توابع">نمایش خروجی توابع</a></h3>
<p>به طور پیش‌فرض، اگر یک تست پاس شود، کتابخانه تست Rust هر چیزی که به خروجی استاندارد چاپ شده را ضبط می‌کند. برای مثال، اگر در یک تست از <code>println!</code> استفاده کنیم و تست پاس شود، خروجی <code>println!</code> را در ترمینال نخواهیم دید؛ فقط خطی که نشان می‌دهد تست پاس شده است را خواهیم دید. اگر یک تست شکست بخورد، هر چیزی که به خروجی استاندارد چاپ شده باشد را همراه با پیام شکست خواهیم دید.</p>
<p>برای مثال، لیست ۱۱-۱۰ یک تابع ساده دارد که مقدار پارامتر خود را چاپ کرده و مقدار ۱۰ را بازمی‌گرداند، همچنین یک تست که پاس می‌شود و یک تست که شکست می‌خورد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
<figcaption>Listing 11-10: تست‌هایی برای یک تابع که از <code>println!</code> استفاده می‌کند</figcaption>
</figure>
<p>وقتی این تست‌ها را با <code>cargo test</code> اجرا می‌کنیم، خروجی زیر را خواهیم دید:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>توجه کنید که در هیچ جای این خروجی <code>I got the value 4</code> که هنگام اجرای تست پاس‌شده چاپ می‌شود، نمی‌بینیم. این خروجی ضبط شده است. خروجی تست شکست‌خورده، <code>I got the value 8</code>، در بخش خلاصه خروجی تست ظاهر می‌شود که علت شکست تست را نیز نشان می‌دهد.</p>
<p>اگر بخواهیم مقادیر چاپ‌شده برای تست‌های پاس‌شده را نیز ببینیم، می‌توانیم به Rust بگوییم که خروجی تست‌های موفق را با استفاده از <code>--show-output</code> نیز نمایش دهد:</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>وقتی تست‌های لیست ۱۱-۱۰ را دوباره با فلگ <code>--show-output</code> اجرا می‌کنیم، خروجی زیر را خواهیم دید:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="اجرای-زیرمجموعهای-از-تستها-با-نام"><a class="header" href="#اجرای-زیرمجموعهای-از-تستها-با-نام">اجرای زیرمجموعه‌ای از تست‌ها با نام</a></h3>
<p>گاهی اوقات، اجرای یک مجموعه کامل از تست‌ها می‌تواند زمان زیادی ببرد. اگر در حال کار روی کدی در یک بخش خاص هستید، ممکن است بخواهید فقط تست‌های مربوط به آن کد را اجرا کنید. می‌توانید با پاس دادن نام یا نام‌های تست‌هایی که می‌خواهید اجرا کنید به <code>cargo test</code>، انتخاب کنید که کدام تست‌ها اجرا شوند.</p>
<p>برای نشان دادن نحوه اجرای یک زیرمجموعه از تست‌ها، ابتدا سه تست برای تابع <code>add_two</code> خود ایجاد می‌کنیم، همانطور که در لیست ۱۱-۱۱ نشان داده شده است، و انتخاب می‌کنیم کدام‌یک را اجرا کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
<figcaption>Listing 11-11: سه تست با سه نام مختلف</figcaption>
</figure>
<p>اگر تست‌ها را بدون پاس دادن هیچ آرگومانی اجرا کنیم، همانطور که قبلاً دیدیم، تمام تست‌ها به صورت موازی اجرا می‌شوند:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="اجرای-تستهای-منفرد"><a class="header" href="#اجرای-تستهای-منفرد">اجرای تست‌های منفرد</a></h4>
<p>می‌توانیم نام هر تابع تست را به <code>cargo test</code> پاس دهیم تا فقط همان تست اجرا شود:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>فقط تستی با نام <code>one_hundred</code> اجرا شد؛ دو تست دیگر با این نام مطابقت نداشتند. خروجی تست به ما اطلاع می‌دهد که تست‌های بیشتری وجود داشته‌اند که اجرا نشده‌اند و در انتها <code>2 filtered out</code> را نمایش می‌دهد.</p>
<p>نمی‌توانیم به این روش نام چندین تست را مشخص کنیم؛ فقط اولین مقداری که به <code>cargo test</code> داده می‌شود استفاده خواهد شد. اما راهی برای اجرای چندین تست وجود دارد.</p>
<h4 id="فیلتر-کردن-برای-اجرای-چندین-تست"><a class="header" href="#فیلتر-کردن-برای-اجرای-چندین-تست">فیلتر کردن برای اجرای چندین تست</a></h4>
<p>می‌توانیم بخشی از یک نام تست را مشخص کنیم، و هر تستی که نامش با آن مقدار مطابقت داشته باشد اجرا خواهد شد. برای مثال، چون دو تا از نام‌های تست‌های ما شامل <code>add</code> هستند، می‌توانیم آن دو را با اجرای <code>cargo test add</code> اجرا کنیم:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>این فرمان تمام تست‌هایی که <code>add</code> در نامشان دارند را اجرا کرد و تستی با نام <code>one_hundred</code> را فیلتر کرد. همچنین توجه داشته باشید که ماژولی که یک تست در آن ظاهر می‌شود بخشی از نام تست می‌شود، بنابراین می‌توانیم تمام تست‌های یک ماژول را با فیلتر کردن روی نام ماژول اجرا کنیم.</p>
<h3 id="نادیده-گرفتن-برخی-تستها-مگر-اینکه-صریحاً-درخواست-شوند"><a class="header" href="#نادیده-گرفتن-برخی-تستها-مگر-اینکه-صریحاً-درخواست-شوند">نادیده گرفتن برخی تست‌ها مگر اینکه صریحاً درخواست شوند</a></h3>
<p>گاهی اوقات چند تست خاص می‌توانند بسیار وقت‌گیر باشند، بنابراین ممکن است بخواهید آن‌ها را در اکثر اجراهای <code>cargo test</code> حذف کنید. به جای لیست کردن تمام تست‌هایی که می‌خواهید اجرا کنید، می‌توانید تست‌های وقت‌گیر را با استفاده از ویژگی <code>ignore</code> حاشیه‌نویسی کنید تا آن‌ها را حذف کنید، همانطور که در اینجا نشان داده شده است:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>بعد از <code>#[test]</code>، خط <code>#[ignore]</code> را به تستی که می‌خواهیم حذف کنیم اضافه می‌کنیم. حالا وقتی تست‌های خود را اجرا می‌کنیم، <code>it_works</code> اجرا می‌شود، اما <code>expensive_test</code> اجرا نمی‌شود:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>تابع <code>expensive_test</code> به عنوان <code>ignored</code> فهرست شده است. اگر بخواهیم فقط تست‌های نادیده‌گرفته‌شده را اجرا کنیم، می‌توانیم از <code>cargo test -- --ignored</code> استفاده کنیم:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>با کنترل اینکه کدام تست‌ها اجرا می‌شوند، می‌توانید مطمئن شوید که نتایج <code>cargo test</code> شما به سرعت بازگردانده می‌شوند. وقتی در نقطه‌ای هستید که منطقی است نتایج تست‌های <code>ignored</code> را بررسی کنید و زمان برای انتظار نتایج دارید، می‌توانید به جای آن <code>cargo test -- --ignored</code> را اجرا کنید. اگر می‌خواهید تمام تست‌ها را اجرا کنید، چه نادیده‌گرفته‌شده و چه نشده، می‌توانید <code>cargo test -- --include-ignored</code> را اجرا کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="سازماندهی-تستها"><a class="header" href="#سازماندهی-تستها">سازماندهی تست‌ها</a></h2>
<p>همانطور که در ابتدای فصل ذکر شد، تست‌نویسی یک رشته پیچیده است، و افراد مختلف از اصطلاحات و سازماندهی متفاوتی استفاده می‌کنند. جامعه Rust تست‌ها را به دو دسته اصلی تقسیم می‌کند: تست‌های واحد و تست‌های یکپارچه. <em>تست‌های واحد</em> کوچک و متمرکزتر هستند، یک ماژول را به طور جداگانه در یک زمان تست می‌کنند و می‌توانند رابط‌های خصوصی را تست کنند. <em>تست‌های یکپارچه</em> کاملاً خارجی نسبت به کتابخانه شما هستند و از کد شما همانطور که هر کد خارجی دیگری استفاده می‌کند، تنها از طریق رابط عمومی استفاده می‌کنند و ممکن است چندین ماژول را در هر تست بررسی کنند.</p>
<p>نوشتن هر دو نوع تست برای اطمینان از اینکه قطعات کتابخانه شما به صورت جداگانه و با هم کار می‌کنند، مهم است.</p>
<h3 id="تستهای-واحد"><a class="header" href="#تستهای-واحد">تست‌های واحد</a></h3>
<p>هدف تست‌های واحد این است که هر واحد کد را به طور جداگانه از سایر کدها تست کنند تا به سرعت مشخص شود که کد کجا به درستی کار می‌کند و کجا نه. تست‌های واحد را در دایرکتوری <em>src</em> در هر فایل با کدی که تست می‌کنند قرار می‌دهید. کنوانسیون این است که یک ماژول به نام <code>tests</code> در هر فایل ایجاد کنید تا توابع تست را در آن قرار دهید و ماژول را با <code>cfg(test)</code> حاشیه‌نویسی کنید.</p>
<h4 id="ماژول-تستها-و-cfgtest"><a class="header" href="#ماژول-تستها-و-cfgtest">ماژول تست‌ها و <code>#[cfg(test)]</code></a></h4>
<p>حاشیه‌نویسی <code>#[cfg(test)]</code> روی ماژول <code>tests</code> به Rust می‌گوید که کد تست فقط وقتی که <code>cargo test</code> اجرا شود کامپایل و اجرا شود، نه وقتی که <code>cargo build</code> اجرا شود. این باعث صرفه‌جویی در زمان کامپایل وقتی فقط می‌خواهید کتابخانه را بسازید می‌شود و فضای کمتری در نتیجه کامپایل‌شده می‌گیرد زیرا تست‌ها شامل نمی‌شوند. مشاهده خواهید کرد که چون تست‌های یکپارچه در یک دایرکتوری جداگانه قرار می‌گیرند، نیازی به حاشیه‌نویسی <code>#[cfg(test)]</code> ندارند. با این حال، چون تست‌های واحد در همان فایل‌هایی که کد قرار دارد قرار می‌گیرند، از <code>#[cfg(test)]</code> استفاده می‌کنید تا مشخص کنید که نباید در نتیجه کامپایل‌شده قرار گیرند.</p>
<p>به یاد بیاورید وقتی پروژه جدید <code>adder</code> را در بخش اول این فصل تولید کردیم، Cargo این کد را برای ما تولید کرد:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>روی ماژول <code>tests</code> که به طور خودکار تولید شده است، ویژگی <code>cfg</code> مخفف <em>پیکربندی</em> است و به Rust می‌گوید که آیتم زیر فقط در صورت وجود یک گزینه پیکربندی مشخص گنجانده شود. در این مورد، گزینه پیکربندی <code>test</code> است، که توسط Rust برای کامپایل و اجرای تست‌ها ارائه می‌شود. با استفاده از ویژگی <code>cfg</code>، Cargo کد تست ما را فقط در صورتی که تست‌ها را به طور فعال با <code>cargo test</code> اجرا کنیم، کامپایل می‌کند. این شامل هر تابع کمکی که ممکن است در این ماژول باشد نیز می‌شود، علاوه بر توابعی که با <code>#[test]</code> حاشیه‌نویسی شده‌اند.</p>
<h4 id="تست-توابع-خصوصی"><a class="header" href="#تست-توابع-خصوصی">تست توابع خصوصی</a></h4>
<p>در جامعه تست‌نویسی بحث‌هایی درباره اینکه آیا توابع خصوصی باید مستقیماً تست شوند یا نه وجود دارد، و برخی زبان‌ها تست کردن توابع خصوصی را دشوار یا غیرممکن می‌کنند. صرف نظر از اینکه از کدام ایدئولوژی تست‌نویسی پیروی می‌کنید، قوانین خصوصی‌سازی Rust به شما اجازه می‌دهند توابع خصوصی را تست کنید. کدی که در لیست ۱۱-۱۲ با تابع خصوصی <code>internal_adder</code> ارائه شده است را در نظر بگیرید.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption>Listing 11-12: تست یک تابع خصوصی</figcaption>
</figure>
<p>توجه داشته باشید که تابع <code>internal_adder</code> با <code>pub</code> علامت‌گذاری نشده است. تست‌ها فقط کد Rust هستند، و ماژول <code>tests</code> فقط یک ماژول دیگر است. همانطور که در بخش <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“مسیرها برای اشاره به یک مورد در درخت ماژول”</a><!-- ignore --> بحث شد، آیتم‌های موجود در ماژول‌های فرزند می‌توانند از آیتم‌های موجود در ماژول‌های والد خود استفاده کنند. در این تست، تمام آیتم‌های والد ماژول <code>tests</code> را با <code>use super::*</code> به دامنه وارد می‌کنیم، و سپس تست می‌تواند <code>internal_adder</code> را فراخوانی کند. اگر فکر می‌کنید توابع خصوصی نباید تست شوند، هیچ چیزی در Rust وجود ندارد که شما را مجبور به انجام این کار کند.</p>
<h3 id="تستهای-یکپارچه"><a class="header" href="#تستهای-یکپارچه">تست‌های یکپارچه</a></h3>
<p>در Rust، تست‌های یکپارچه کاملاً خارجی نسبت به کتابخانه شما هستند. آن‌ها از کتابخانه شما همانطور که هر کد دیگری استفاده می‌کند استفاده می‌کنند، که به این معنی است که فقط می‌توانند توابعی را که بخشی از رابط عمومی کتابخانه شما هستند فراخوانی کنند. هدف آن‌ها این است که بررسی کنند آیا قسمت‌های مختلف کتابخانه شما با یکدیگر به درستی کار می‌کنند یا نه. واحدهای کدی که به تنهایی به درستی کار می‌کنند می‌توانند هنگام یکپارچه‌سازی مشکل داشته باشند، بنابراین پوشش تست کد یکپارچه نیز مهم است. برای ایجاد تست‌های یکپارچه، ابتدا به یک دایرکتوری به نام <em>tests</em> نیاز دارید.</p>
<h4 id="دایرکتوری-tests"><a class="header" href="#دایرکتوری-tests">دایرکتوری <em>tests</em></a></h4>
<p>ما یک دایرکتوری به نام <em>tests</em> در سطح بالای دایرکتوری پروژه خود، در کنار <em>src</em> ایجاد می‌کنیم. Cargo می‌داند که باید به دنبال فایل‌های تست یکپارچه در این دایرکتوری بگردد. سپس می‌توانیم به هر تعداد فایل تست که می‌خواهیم ایجاد کنیم، و Cargo هر یک از فایل‌ها را به عنوان یک crate جداگانه کامپایل می‌کند.</p>
<p>بیایید یک تست یکپارچه ایجاد کنیم. با کدی که هنوز در فایل <em>src/lib.rs</em> از لیست ۱۱-۱۲ قرار دارد، یک دایرکتوری <em>tests</em> ایجاد کنید و یک فایل جدید به نام <em>tests/integration_test.rs</em> بسازید. ساختار دایرکتوری شما باید به این صورت باشد:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>کد موجود در لیست ۱۱-۱۳ را در فایل <em>tests/integration_test.rs</em> وارد کنید.</p>
<figure class="listing">
<span class="file-name">Filename: tests/integration_test.rs</span>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<figcaption>Listing 11-13: یک تست یکپارچه برای تابعی در crate <code>adder</code></figcaption>
</figure>
<p>هر فایل در دایرکتوری <em>tests</em> یک crate جداگانه است، بنابراین باید کتابخانه خود را به دامنه هر crate تست وارد کنیم. به همین دلیل، در بالای کد <code>use adder::add_two;</code> را اضافه می‌کنیم، که در تست‌های واحد نیازی به آن نداشتیم.</p>
<p>نیازی نیست هیچ کدی در فایل <em>tests/integration_test.rs</em> را با <code>#[cfg(test)]</code> علامت‌گذاری کنیم. Cargo دایرکتوری <em>tests</em> را به طور خاص مدیریت می‌کند و فایل‌های موجود در این دایرکتوری را فقط زمانی که <code>cargo test</code> اجرا کنیم کامپایل می‌کند. اکنون <code>cargo test</code> را اجرا کنید:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>سه بخش خروجی شامل تست‌های واحد، تست یکپارچه، و تست‌های مستندات هستند. توجه داشته باشید که اگر هر تستی در یک بخش شکست بخورد، بخش‌های بعدی اجرا نخواهند شد. برای مثال، اگر یک تست واحد شکست بخورد، هیچ خروجی‌ای برای تست‌های یکپارچه و مستندات وجود نخواهد داشت زیرا آن تست‌ها فقط در صورتی اجرا می‌شوند که تمام تست‌های واحد پاس شوند.</p>
<p>بخش اول برای تست‌های واحد همان چیزی است که قبلاً دیده‌ایم: یک خط برای هر تست واحد (یکی به نام <code>internal</code> که در لیست ۱۱-۱۲ اضافه کردیم) و سپس یک خط خلاصه برای تست‌های واحد.</p>
<p>بخش تست‌های یکپارچه با خط <code>Running tests/integration_test.rs</code> شروع می‌شود. سپس یک خط برای هر تابع تست در آن تست یکپارچه و یک خط خلاصه برای نتایج تست یکپارچه دقیقاً قبل از شروع بخش <code>Doc-tests adder</code> وجود دارد.</p>
<p>هر فایل تست یکپارچه بخش خاص خود را دارد، بنابراین اگر فایل‌های بیشتری در دایرکتوری <em>tests</em> اضافه کنیم، بخش‌های بیشتری برای تست‌های یکپارچه خواهیم داشت.</p>
<p>ما هنوز می‌توانیم یک تابع تست خاص در یکپارچه را با مشخص کردن نام تابع تست به عنوان یک آرگومان برای <code>cargo test</code> اجرا کنیم. برای اجرای تمام تست‌های یک فایل تست یکپارچه خاص، از آرگومان <code>--test</code> برای <code>cargo test</code> به همراه نام فایل استفاده کنید:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>این فرمان فقط تست‌های موجود در فایل <em>tests/integration_test.rs</em> را اجرا می‌کند.</p>
<h4 id="زیرماژولها-در-تستهای-یکپارچه"><a class="header" href="#زیرماژولها-در-تستهای-یکپارچه">زیرماژول‌ها در تست‌های یکپارچه</a></h4>
<p>با اضافه کردن تست‌های یکپارچه بیشتر، ممکن است بخواهید فایل‌های بیشتری در دایرکتوری <em>tests</em> برای کمک به سازماندهی آن‌ها ایجاد کنید؛ برای مثال، می‌توانید توابع تست را بر اساس عملکردی که تست می‌کنند گروه‌بندی کنید. همانطور که قبلاً ذکر شد، هر فایل در دایرکتوری <em>tests</em> به عنوان یک crate جداگانه کامپایل می‌شود، که برای ایجاد دامنه‌های جداگانه مفید است تا بیشتر شبیه نحوه استفاده کاربران نهایی از crate شما باشد. با این حال، این به این معنی است که فایل‌های موجود در دایرکتوری <em>tests</em> رفتار یکسانی با فایل‌های موجود در <em>src</em> ندارند، همانطور که در فصل ۷ درباره جدا کردن کد به ماژول‌ها و فایل‌ها آموختید.</p>
<p>این رفتار متفاوت فایل‌های دایرکتوری <em>tests</em> بیشترین توجه را زمانی جلب می‌کند که مجموعه‌ای از توابع کمکی برای استفاده در چندین فایل تست یکپارچه دارید و سعی می‌کنید مراحل بخش <a href="ch07-05-separating-modules-into-different-files.html">“جدا کردن ماژول‌ها به فایل‌های مختلف”</a><!-- ignore --> در فصل ۷ را برای استخراج آن‌ها به یک ماژول مشترک دنبال کنید. برای مثال، اگر <em>tests/common.rs</em> ایجاد کنیم و یک تابع به نام <code>setup</code> در آن قرار دهیم، می‌توانیم کدی به <code>setup</code> اضافه کنیم که می‌خواهیم از چندین تابع تست در چندین فایل تست فراخوانی کنیم:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>وقتی دوباره تست‌ها را اجرا می‌کنیم، یک بخش جدید در خروجی تست برای فایل <em>common.rs</em> خواهیم دید، حتی اگر این فایل هیچ تابع تستی ندارد و تابع <code>setup</code> را از هیچ جایی فراخوانی نکرده‌ایم:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>داشتن <code>common</code> در نتایج تست با <code>running 0 tests</code> نمایش داده شده برای آن، چیزی نبود که می‌خواستیم. ما فقط می‌خواستیم برخی کدها را با دیگر فایل‌های تست یکپارچه به اشتراک بگذاریم. برای جلوگیری از نمایش <code>common</code> در خروجی تست، به جای ایجاد <em>tests/common.rs</em>، فایل <em>tests/common/mod.rs</em> را ایجاد می‌کنیم. اکنون ساختار دایرکتوری پروژه به این شکل است:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>این یک نام‌گذاری قدیمی است که Rust نیز آن را درک می‌کند، همانطور که در بخش <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“مسیرهای جایگزین فایل”</a><!-- ignore --> فصل ۷ ذکر شد. نام‌گذاری فایل به این شکل به Rust می‌گوید که ماژول <code>common</code> را به عنوان یک فایل تست یکپارچه در نظر نگیرد. وقتی کد تابع <code>setup</code> را به <em>tests/common/mod.rs</em> منتقل می‌کنیم و فایل <em>tests/common.rs</em> را حذف می‌کنیم، دیگر بخش مربوطه در خروجی تست ظاهر نخواهد شد. فایل‌های موجود در زیرشاخه‌های دایرکتوری <em>tests</em> به عنوان crate‌های جداگانه کامپایل نمی‌شوند یا بخش‌هایی در خروجی تست ندارند.</p>
<p>پس از ایجاد <em>tests/common/mod.rs</em>، می‌توانیم از آن به عنوان یک ماژول در هر یک از فایل‌های تست یکپارچه استفاده کنیم. در اینجا یک مثال از فراخوانی تابع <code>setup</code> از تست <code>it_adds_two</code> در <em>tests/integration_test.rs</em> آمده است:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>توجه داشته باشید که اعلان <code>mod common;</code> مشابه اعلان ماژولی است که در لیست ۷-۲۱ نشان دادیم. سپس، در تابع تست، می‌توانیم تابع <code>common::setup()</code> را فراخوانی کنیم.</p>
<h4 id="تستهای-یکپارچه-برای-crateهای-دودویی"><a class="header" href="#تستهای-یکپارچه-برای-crateهای-دودویی">تست‌های یکپارچه برای crate‌های دودویی</a></h4>
<p>اگر پروژه ما یک crate دودویی باشد که فقط شامل یک فایل <em>src/main.rs</em> است و فایل <em>src/lib.rs</em> ندارد، نمی‌توانیم تست‌های یکپارچه را در دایرکتوری <em>tests</em> ایجاد کنیم و توابع تعریف‌شده در فایل <em>src/main.rs</em> را با یک عبارت <code>use</code> به دامنه وارد کنیم. فقط crate‌های کتابخانه‌ای توابعی را که سایر crate‌ها می‌توانند استفاده کنند در معرض قرار می‌دهند؛ crate‌های دودویی برای اجرای مستقل طراحی شده‌اند.</p>
<p>این یکی از دلایلی است که پروژه‌های Rust که یک دودویی ارائه می‌دهند، معمولاً یک فایل <em>src/main.rs</em> ساده دارند که به منطق موجود در فایل <em>src/lib.rs</em> فراخوانی می‌کند. با استفاده از این ساختار، تست‌های یکپارچه می‌توانند crate کتابخانه‌ای را با <code>use</code> تست کنند تا قابلیت مهم را در دسترس قرار دهند. اگر قابلیت مهم کار کند، مقدار کمی کد در فایل <em>src/main.rs</em> نیز کار خواهد کرد، و نیازی به تست آن مقدار کم از کد نیست.</p>
<h2 id="خلاصه-10"><a class="header" href="#خلاصه-10">خلاصه</a></h2>
<p>ویژگی‌های تست‌نویسی در Rust راهی برای مشخص کردن نحوه عملکرد کد فراهم می‌کنند تا اطمینان حاصل شود که کد همانطور که انتظار می‌رود کار می‌کند، حتی زمانی که تغییراتی در آن ایجاد می‌کنید. تست‌های واحد بخش‌های مختلف یک کتابخانه را به طور جداگانه آزمایش می‌کنند و می‌توانند جزئیات پیاده‌سازی خصوصی را تست کنند. تست‌های یکپارچه بررسی می‌کنند که آیا بخش‌های مختلف کتابخانه به درستی با یکدیگر کار می‌کنند یا نه، و از رابط عمومی کتابخانه برای تست کد به همان روشی که کد خارجی از آن استفاده می‌کند، استفاده می‌کنند. حتی با وجود اینکه سیستم نوع‌ها و قوانین مالکیت در Rust به جلوگیری از برخی انواع باگ‌ها کمک می‌کند، تست‌ها همچنان برای کاهش باگ‌های منطقی که به نحوه عملکرد مورد انتظار کد مربوط می‌شوند، مهم هستند.</p>
<p>بیایید دانش خود را که در این فصل و فصل‌های قبلی یاد گرفتید، ترکیب کرده و روی یک پروژه کار کنیم!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="یک-پروژه-ورودیخروجی-ساخت-یک-برنامه-خط-فرمان"><a class="header" href="#یک-پروژه-ورودیخروجی-ساخت-یک-برنامه-خط-فرمان">یک پروژه ورودی/خروجی: ساخت یک برنامه خط فرمان</a></h1>
<p>این فصل مروری بر بسیاری از مهارت‌هایی است که تا کنون آموخته‌اید و همچنین بررسی چند ویژگی دیگر از کتابخانه استاندارد. ما یک ابزار خط فرمان خواهیم ساخت که با ورودی/خروجی فایل و خط فرمان تعامل می‌کند تا برخی از مفاهیم Rust را که اکنون در اختیار دارید تمرین کنیم.</p>
<p>سرعت، ایمنی، خروجی تک‌باینری و پشتیبانی چند‌پلتفرمی Rust، آن را به زبانی ایده‌آل برای ایجاد ابزارهای خط فرمان تبدیل می‌کند. بنابراین برای پروژه خود، نسخه‌ای از ابزار جستجوی خط فرمان کلاسیک <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) را خواهیم ساخت. در ساده‌ترین حالت، <code>grep</code> یک فایل مشخص را برای یک رشته مشخص جستجو می‌کند. برای انجام این کار، <code>grep</code> به عنوان آرگومان‌های خود مسیر فایل و یک رشته را دریافت می‌کند. سپس فایل را می‌خواند، خطوطی که شامل آرگومان رشته هستند را پیدا می‌کند و آن خطوط را چاپ می‌کند.</p>
<p>در طول مسیر، نشان خواهیم داد که چگونه ابزار خط فرمان ما از ویژگی‌های ترمینال استفاده کند که بسیاری از ابزارهای خط فرمان دیگر از آن‌ها استفاده می‌کنند. مقدار یک متغیر محیطی را برای اجازه به کاربر برای پیکربندی رفتار ابزار خود می‌خوانیم. همچنین پیام‌های خطا را به جریان کنسول خطای استاندارد (<code>stderr</code>) به جای خروجی استاندارد (<code>stdout</code>) چاپ می‌کنیم تا مثلاً کاربر بتواند خروجی موفقیت‌آمیز را به یک فایل هدایت کند در حالی که هنوز پیام‌های خطا را روی صفحه مشاهده می‌کند.</p>
<p>یکی از اعضای جامعه Rust، Andrew Gallant، نسخه‌ای کامل، بسیار سریع از <code>grep</code> به نام <code>ripgrep</code> ایجاد کرده است. در مقایسه، نسخه ما نسبتاً ساده خواهد بود، اما این فصل به شما برخی از دانش‌های پایه‌ای که برای درک پروژه‌های واقعی مانند <code>ripgrep</code> نیاز دارید را خواهد داد.</p>
<p>پروژه <code>grep</code> ما ترکیبی از تعدادی مفاهیمی است که تاکنون آموخته‌اید:</p>
<ul>
<li>سازماندهی کد (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">فصل ۷</a><!-- ignore -->)</li>
<li>استفاده از بردارها و رشته‌ها (<a href="ch08-00-common-collections.html">فصل ۸</a><!-- ignore -->)</li>
<li>مدیریت خطاها (<a href="ch09-00-error-handling.html">فصل ۹</a><!-- ignore -->)</li>
<li>استفاده از صفات و طول عمرها در موارد مناسب (<a href="ch10-00-generics.html">فصل ۱۰</a><!-- ignore -->)</li>
<li>نوشتن تست‌ها (<a href="ch11-00-testing.html">فصل ۱۱</a><!-- ignore -->)</li>
</ul>
<p>همچنین به طور مختصر به معرفی closures، iterators، و trait objects می‌پردازیم که به طور کامل در <a href="ch13-00-functional-features.html">فصل ۱۳</a><!-- ignore --> و <a href="ch18-00-oop.html">فصل ۱۸</a><!-- ignore --> پوشش داده خواهند شد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="پذیرش-آرگومانهای-خط-فرمان"><a class="header" href="#پذیرش-آرگومانهای-خط-فرمان">پذیرش آرگومان‌های خط فرمان</a></h2>
<p>بیایید با استفاده از <code>cargo new</code> یک پروژه جدید ایجاد کنیم. پروژه خود را <code>minigrep</code> می‌نامیم تا آن را از ابزار <code>grep</code> که ممکن است در سیستم شما وجود داشته باشد متمایز کنیم.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>اولین کار این است که <code>minigrep</code> آرگومان‌های خط فرمان خود، شامل مسیر فایل و رشته‌ای برای جستجو، را بپذیرد. به عبارت دیگر، می‌خواهیم بتوانیم برنامه خود را با <code>cargo run</code>، دو خط تیره برای نشان دادن اینکه آرگومان‌های بعدی برای برنامه ما هستند و نه برای <code>cargo</code>، یک رشته برای جستجو و یک مسیر فایل برای جستجو اجرا کنیم، مانند زیر:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>در حال حاضر، برنامه‌ای که توسط <code>cargo new</code> تولید شده است نمی‌تواند آرگومان‌هایی که به آن می‌دهیم را پردازش کند. برخی کتابخانه‌های موجود در <a href="https://crates.io/">crates.io</a> می‌توانند برای نوشتن برنامه‌ای که آرگومان‌های خط فرمان را بپذیرد کمک کنند، اما چون شما تازه با این مفهوم آشنا می‌شوید، بیایید این قابلیت را خودمان پیاده‌سازی کنیم.</p>
<h3 id="خواندن-مقادیر-آرگومانها"><a class="header" href="#خواندن-مقادیر-آرگومانها">خواندن مقادیر آرگومان‌ها</a></h3>
<p>برای اینکه <code>minigrep</code> بتواند مقادیر آرگومان‌های خط فرمان را که به آن می‌دهیم بخواند، به تابع <code>std::env::args</code> که در کتابخانه استاندارد Rust ارائه شده است نیاز خواهیم داشت. این تابع یک iterator از آرگومان‌های خط فرمانی که به <code>minigrep</code> داده شده است بازمی‌گرداند. ما در <a href="ch13-00-functional-features.html">فصل ۱۳</a><!-- ignore --> به طور کامل iteratorها را پوشش خواهیم داد. در حال حاضر، فقط باید دو نکته درباره iteratorها بدانید: iteratorها یک سری مقادیر تولید می‌کنند و ما می‌توانیم تابع <code>collect</code> را روی یک iterator فراخوانی کنیم تا آن را به یک collection، مانند یک بردار، که شامل تمام عناصر تولیدشده توسط iterator است، تبدیل کنیم.</p>
<p>کد موجود در لیست ۱۲-۱ به برنامه <code>minigrep</code> شما اجازه می‌دهد تا هر آرگومان خط فرمانی که به آن داده شده را بخواند و سپس مقادیر را به یک بردار جمع‌آوری کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<figcaption>Listing 12-1: جمع‌آوری آرگومان‌های خط فرمان به یک بردار و چاپ آن‌ها</figcaption>
</figure>
<p>ابتدا ماژول <code>std::env</code> را با یک دستور <code>use</code> به دامنه وارد می‌کنیم تا بتوانیم از تابع <code>args</code> آن استفاده کنیم. توجه کنید که تابع <code>std::env::args</code> در دو سطح ماژول تو در تو قرار دارد. همانطور که در <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">فصل ۷</a><!-- ignore --> بحث کردیم، در مواردی که تابع موردنظر در بیش از یک ماژول تو در تو قرار دارد، ترجیح می‌دهیم ماژول والد را به دامنه وارد کنیم نه تابع. با این کار، می‌توانیم به راحتی از توابع دیگر <code>std::env</code> استفاده کنیم. همچنین این روش کمتر مبهم است نسبت به اضافه کردن <code>use std::env::args</code> و سپس فراخوانی تابع با فقط <code>args</code>، چون <code>args</code> ممکن است به راحتی با یک تابع تعریف‌شده در ماژول جاری اشتباه گرفته شود.</p>
<section class="note" aria-role="note">
<h3 id="تابع-args-و-یونیکد-نامعتبر"><a class="header" href="#تابع-args-و-یونیکد-نامعتبر">تابع <code>args</code> و یونیکد نامعتبر</a></h3>
<p>توجه داشته باشید که <code>std::env::args</code> اگر هر آرگومانی شامل یونیکد نامعتبر باشد، پانیک خواهد کرد. اگر برنامه شما نیاز به پذیرش آرگومان‌هایی با یونیکد نامعتبر دارد، به جای آن از <code>std::env::args_os</code> استفاده کنید. این تابع یک iterator بازمی‌گرداند که مقادیر <code>OsString</code> به جای <code>String</code> تولید می‌کند. ما برای سادگی <code>std::env::args</code> را اینجا انتخاب کرده‌ایم زیرا مقادیر <code>OsString</code> بسته به پلتفرم متفاوت هستند و کار با آن‌ها پیچیده‌تر از مقادیر <code>String</code> است.</p>
</section>
<p>در اولین خط از تابع <code>main</code>، ما تابع <code>env::args</code> را فراخوانی می‌کنیم و بلافاصله از تابع <code>collect</code> استفاده می‌کنیم تا iterator را به یک بردار که شامل تمام مقادیر تولید‌شده توسط iterator است، تبدیل کنیم. می‌توانیم از تابع <code>collect</code> برای ایجاد انواع مختلفی از collectionها استفاده کنیم، بنابراین نوع <code>args</code> را به طور صریح با ذکر می‌کنیم که می‌خواهیم یک بردار از رشته‌ها داشته باشیم. با اینکه به ندرت نیاز به ذکر نوع‌ها در Rust دارید، تابع <code>collect</code> یکی از تابع‌هایی است که اغلب باید نوع آن را ذکر کنید، زیرا Rust نمی‌تواند نوع collection مورد نظر شما را استنباط کند.</p>
<p>در نهایت، بردار را با استفاده از ماکروی debug چاپ می‌کنیم. بیایید ابتدا کد را بدون آرگومان اجرا کنیم و سپس با دو آرگومان:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>توجه کنید که اولین مقدار در بردار <code>"target/debug/minigrep"</code> است، که نام باینری ما است. این رفتار با لیست آرگومان‌ها در زبان C مطابقت دارد و به برنامه‌ها اجازه می‌دهد از نامی که با آن اجرا شده‌اند، در اجرای خود استفاده کنند. دسترسی به نام برنامه اغلب مفید است، مثلاً برای چاپ آن در پیام‌ها یا تغییر رفتار برنامه بر اساس نام مستعار خط فرمانی که برای اجرای برنامه استفاده شده است. اما برای اهداف این فصل، آن را نادیده می‌گیریم و فقط دو آرگومان مورد نیاز را ذخیره می‌کنیم.</p>
<h3 id="ذخیره-مقادیر-آرگومانها-در-متغیرها"><a class="header" href="#ذخیره-مقادیر-آرگومانها-در-متغیرها">ذخیره مقادیر آرگومان‌ها در متغیرها</a></h3>
<p>در حال حاضر، برنامه قادر به دسترسی به مقادیر مشخص‌شده به عنوان آرگومان‌های خط فرمان است. اکنون نیاز داریم مقادیر دو آرگومان را در متغیرهایی ذخیره کنیم تا بتوانیم از آن‌ها در بقیه برنامه استفاده کنیم. این کار را در لیست ۱۲-۲ انجام می‌دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
<figcaption>Listing 12-2: ایجاد متغیرها برای نگه‌داری آرگومان جستجو و مسیر فایل</figcaption>
</figure>
<p>همانطور که هنگام چاپ بردار مشاهده کردیم، نام برنامه اولین مقدار در بردار را در <code>args[0]</code> اشغال می‌کند، بنابراین آرگومان‌ها را از اندیس (index)۱ شروع می‌کنیم. اولین آرگومان که <code>minigrep</code> دریافت می‌کند، رشته‌ای است که می‌خواهیم جستجو کنیم، بنابراین یک مرجع به اولین آرگومان را در متغیر <code>query</code> قرار می‌دهیم. آرگومان دوم مسیر فایل خواهد بود، بنابراین یک مرجع به آرگومان دوم را در متغیر <code>file_path</code> قرار می‌دهیم.</p>
<p>ما به طور موقت مقادیر این متغیرها را چاپ می‌کنیم تا اثبات کنیم که کد همانطور که می‌خواهیم کار می‌کند. بیایید دوباره این برنامه را با آرگومان‌های <code>test</code> و <code>sample.txt</code> اجرا کنیم:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>عالی است، برنامه کار می‌کند! مقادیر آرگومان‌های مورد نیاز ما در متغیرهای درست ذخیره می‌شوند. بعداً برخی از خطاها را مدیریت خواهیم کرد، مثل وقتی که کاربر هیچ آرگومانی ارائه نمی‌دهد؛ فعلاً، آن شرایط را نادیده می‌گیریم و روی افزودن قابلیت خواندن فایل تمرکز می‌کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="خواندن-یک-فایل"><a class="header" href="#خواندن-یک-فایل">خواندن یک فایل</a></h2>
<p>اکنون قابلیت خواندن فایل مشخص‌شده در آرگومان <code>file_path</code> را اضافه می‌کنیم. ابتدا به یک فایل نمونه برای تست نیاز داریم: از یک فایل با مقدار کمی متن در چندین خط که برخی کلمات در آن تکرار شده‌اند استفاده می‌کنیم. لیست ۱۲-۳ شامل شعری از امیلی دیکینسون است که به خوبی برای این منظور مناسب است! یک فایل به نام <em>poem.txt</em> در سطح اصلی پروژه خود ایجاد کنید و شعر “I’m Nobody! Who are you?” را وارد کنید.</p>
<figure class="listing">
<span class="file-name">Filename: poem.txt</span>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<figcaption>Listing 12-3: شعری از امیلی دیکینسون که مورد تست مناسبی است.</figcaption>
</figure>
<p>با متن در جای خود، فایل <em>src/main.rs</em> را ویرایش کرده و کدی برای خواندن فایل اضافه کنید، همانطور که در لیست ۱۲-۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}</code></pre>
<figcaption>Listing 12-4: خواندن محتوای فایل مشخص‌شده توسط آرگومان دوم</figcaption>
</figure>
<p>ابتدا بخشی مرتبط از کتابخانه استاندارد را با یک دستور <code>use</code> وارد می‌کنیم: برای مدیریت فایل‌ها به <code>std::fs</code> نیاز داریم.</p>
<p>در تابع <code>main</code>، دستور جدید <code>fs::read_to_string</code> مقدار <code>file_path</code> را می‌گیرد، آن فایل را باز می‌کند و مقداری از نوع <code>std::io::Result&lt;String&gt;</code> را که شامل محتوای فایل است، بازمی‌گرداند.</p>
<p>پس از آن، دوباره یک دستور موقت <code>println!</code> اضافه می‌کنیم که مقدار <code>contents</code> را پس از خواندن فایل چاپ می‌کند تا مطمئن شویم برنامه تا اینجا کار می‌کند.</p>
<p>بیایید این کد را با هر رشته‌ای به عنوان اولین آرگومان خط فرمان (چون هنوز بخش جستجو را پیاده‌سازی نکرده‌ایم) و فایل <em>poem.txt</em> به عنوان آرگومان دوم اجرا کنیم:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>عالی است! کد محتوای فایل را خواند و سپس چاپ کرد. اما کد چند نقص دارد. در حال حاضر، تابع <code>main</code> چندین مسئولیت دارد: به طور کلی، توابع واضح‌تر و آسان‌تر برای نگهداری هستند اگر هر تابع فقط مسئول یک ایده باشد. مشکل دیگر این است که ما خطاها را به خوبی مدیریت نمی‌کنیم. برنامه هنوز کوچک است، بنابراین این مشکلات مشکل بزرگی نیستند، اما با رشد برنامه، رفع آن‌ها به صورت تمیز سخت‌تر خواهد شد. بهتر است که زودتر در فرایند توسعه برنامه شروع به بازسازی کنیم، زیرا بازسازی کدهای کمتر بسیار آسان‌تر است. در مرحله بعد این کار را انجام خواهیم داد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="بازسازی-برای-بهبود-ماژولار-بودن-و-مدیریت-خطاها"><a class="header" href="#بازسازی-برای-بهبود-ماژولار-بودن-و-مدیریت-خطاها">بازسازی برای بهبود ماژولار بودن و مدیریت خطاها</a></h2>
<p>برای بهبود برنامه خود، چهار مشکلی که به ساختار برنامه و نحوه مدیریت خطاهای بالقوه مربوط می‌شوند را رفع خواهیم کرد.</p>
<ul dir="rtl">
  <li>
    <strong>تک‌مسئولیتی کردن تابع <code>main</code></strong>:  
    در حال حاضر، تابع <code>main</code> دو وظیفه را انجام می‌دهد: تجزیه آرگومان‌ها و خواندن فایل‌ها. با رشد برنامه، تعداد وظایف جداگانه‌ای که تابع <code>main</code> باید مدیریت کند افزایش خواهد یافت. هرچه یک تابع مسئولیت‌های بیشتری داشته باشد، درک آن سخت‌تر می‌شود، تست کردن آن پیچیده‌تر خواهد شد و تغییر آن بدون آسیب به بخش‌های دیگر دشوارتر می‌شود. بهتر است قابلیت‌ها را جدا کنیم تا هر تابع فقط مسئول یک وظیفه باشد.
  </li>
  <li>
    <strong>گروه‌بندی متغیرهای پیکربندی</strong>:  
    متغیرهایی مانند <code>query</code> و <code>file_path</code> متغیرهای پیکربندی برای برنامه ما هستند، در حالی که متغیرهایی مانند <code>contents</code> برای اجرای منطق برنامه استفاده می‌شوند. هرچه تابع <code>main</code> طولانی‌تر شود، به متغیرهای بیشتری نیاز خواهد داشت که وارد دامنه شوند؛ و هرچه تعداد متغیرها بیشتر شود، پیگیری هدف هر متغیر دشوارتر خواهد شد. بهتر است متغیرهای پیکربندی را در یک ساختار گروه‌بندی کنیم تا هدف آن‌ها واضح‌تر باشد.
  </li>
  <li>
    <strong>بهبود پیام‌های خطا</strong>:  
    هنگام شکست در خواندن فایل، از <code>expect</code> برای چاپ پیام خطا استفاده کرده‌ایم، اما پیام خطا فقط <code>Should have been able to read the file</code> را چاپ می‌کند. خواندن یک فایل می‌تواند به دلایل مختلفی شکست بخورد: مثلاً ممکن است فایل وجود نداشته باشد یا ممکن است اجازه دسترسی به آن را نداشته باشیم. در حال حاضر، بدون توجه به شرایط، همان پیام خطا برای همه چیز چاپ می‌شود که اطلاعاتی به کاربر نمی‌دهد.
  </li>
  <li>
    <strong>یکپارچه‌سازی مدیریت خطاها</strong>:  
    اگر کاربر برنامه ما را بدون مشخص کردن تعداد کافی آرگومان اجرا کند، یک خطای <code>index out of bounds</code> از Rust دریافت می‌کنند که به وضوح مشکل را توضیح نمی‌دهد. بهتر است تمام کد مدیریت خطاها در یک مکان قرار گیرد تا نگهداری‌کنندگان آینده تنها یک مکان را برای بررسی تغییرات در منطق مدیریت خطا داشته باشند. این کار همچنین اطمینان حاصل می‌کند که پیام‌هایی که چاپ می‌شوند برای کاربران نهایی معنادار هستند.
  </li>
</ul>
<h3 id="جداسازی-وظایف-برای-پروژههای-دودویی"><a class="header" href="#جداسازی-وظایف-برای-پروژههای-دودویی">جداسازی وظایف برای پروژه‌های دودویی</a></h3>
<p>مشکل تخصیص مسئولیت‌های چندگانه به تابع <code>main</code> در بسیاری از پروژه‌های دودویی رایج است. به همین دلیل، جامعه Rust دستورالعمل‌هایی برای تقسیم دغدغه‌های جداگانه یک برنامه دودویی ارائه داده است. این فرایند شامل مراحل زیر است:</p>
<ul dir="rtl">
<li> برنامه خود را به فایل‌های _main.rs_ و _lib.rs_ تقسیم کرده و منطق برنامه را به _lib.rs_ منتقل کنید. </li>
<li> تا زمانی که منطق تجزیه آرگومان‌های خط فرمان کوچک است، می‌تواند در _main.rs_ باقی بماند. </li>
<li> وقتی منطق تجزیه آرگومان‌ها پیچیده شد، آن را از _main.rs_ جدا کرده و به _lib.rs_ منتقل کنید. </li>
</ul>
<p>وظایفی که پس از این فرایند در تابع <code>main</code> باقی می‌مانند باید محدود به موارد زیر باشند:</p>
<ul dir="rtl">
<li> فراخوانی منطق تجزیه آرگومان‌های خط فرمان با مقادیر آرگومان‌ها </li>
<li> تنظیم هرگونه پیکربندی دیگر </li>
<li> فراخوانی یک تابع `run` در _lib.rs_ </li>
<li> مدیریت خطاها در صورت بازگرداندن خطا توسط `run` </li>
</ul>
<p>این الگو درباره جداسازی وظایف است: <em>main.rs</em> اجرای برنامه را مدیریت می‌کند و <em>lib.rs</em> تمام منطق مربوط به کار مورد نظر را مدیریت می‌کند. از آنجا که نمی‌توان تابع <code>main</code> را مستقیماً تست کرد، این ساختار به شما اجازه می‌دهد تمام منطق برنامه خود را با انتقال آن به توابع در <em>lib.rs</em> تست کنید. کدی که در <em>main.rs</em> باقی می‌ماند به اندازه کافی کوچک خواهد بود که با خواندن آن از صحت آن اطمینان حاصل کنید. بیایید برنامه خود را با پیروی از این فرایند بازسازی کنیم.</p>
<h4 id="استخراج-تجزیهکننده-آرگومانها"><a class="header" href="#استخراج-تجزیهکننده-آرگومانها">استخراج تجزیه‌کننده آرگومان‌ها</a></h4>
<p>ما قابلیت تجزیه آرگومان‌ها را به یک تابع جداگانه استخراج می‌کنیم که تابع <code>main</code> آن را فراخوانی خواهد کرد تا برای انتقال منطق تجزیه آرگومان خط فرمان به فایل <em>src/lib.rs</em> آماده شویم. لیست ۱۲-۵ شروع جدید تابع <code>main</code> را نشان می‌دهد که یک تابع جدید به نام <code>parse_config</code> را فراخوانی می‌کند، که در حال حاضر در <em>src/main.rs</em> تعریف خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption>Listing 12-5: استخراج تابع <code>parse_config</code> از <code>main</code></figcaption>
</figure>
<p>ما همچنان آرگومان‌های خط فرمان را به یک بردار جمع‌آوری می‌کنیم، اما به جای اینکه مقدار آرگومان در اندیس (index)۱ را به متغیر <code>query</code> و مقدار آرگومان در اندیس (index)۲ را به متغیر <code>file_path</code> در تابع <code>main</code> اختصاص دهیم، کل بردار را به تابع <code>parse_config</code> ارسال می‌کنیم. تابع <code>parse_config</code> سپس منطق مشخص می‌کند که کدام آرگومان در کدام متغیر قرار می‌گیرد و مقادیر را به تابع <code>main</code> بازمی‌گرداند. ما همچنان متغیرهای <code>query</code> و <code>file_path</code> را در <code>main</code> ایجاد می‌کنیم، اما <code>main</code> دیگر مسئول تعیین ارتباط آرگومان‌های خط فرمان و متغیرها نیست.</p>
<p>این تغییر ممکن است برای برنامه کوچک ما زیاده‌روی به نظر برسد، اما ما در حال بازسازی کد به صورت گام‌های کوچک و تدریجی هستیم. پس از اعمال این تغییر، دوباره برنامه را اجرا کنید تا اطمینان حاصل کنید که تجزیه آرگومان همچنان کار می‌کند. بررسی مداوم پیشرفت کد کمک می‌کند تا در صورت بروز مشکلات، علت آن‌ها را سریع‌تر شناسایی کنید.</p>
<h4 id="گروهبندی-مقادیر-پیکربندی"><a class="header" href="#گروهبندی-مقادیر-پیکربندی">گروه‌بندی مقادیر پیکربندی</a></h4>
<p>می‌توانیم یک گام کوچک دیگر برای بهبود بیشتر تابع <code>parse_config</code> برداریم. در حال حاضر، ما یک tuple بازمی‌گردانیم، اما بلافاصله آن tuple را به قسمت‌های جداگانه تقسیم می‌کنیم. این نشانه‌ای است که شاید هنوز انتزاع درستی نداریم.</p>
<p>نشانه دیگری که نشان می‌دهد جا برای بهبود وجود دارد، قسمت <code>config</code> در <code>parse_config</code> است، که نشان می‌دهد دو مقداری که بازمی‌گردانیم به هم مرتبط هستند و هر دو بخشی از یک مقدار پیکربندی هستند. ما در حال حاضر این معنا را در ساختار داده‌ها به جز با گروه‌بندی دو مقدار در یک tuple منتقل نمی‌کنیم؛ در عوض، این دو مقدار را در یک struct قرار می‌دهیم و به هر یک از فیلدهای struct نامی معنادار می‌دهیم. انجام این کار درک نحوه ارتباط مقادیر مختلف و هدف آن‌ها را برای نگهداری‌کنندگان آینده این کد آسان‌تر می‌کند.</p>
<p>لیست ۱۲-۶ بهبودهای تابع <code>parse_config</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption>Listing 12-6: بازسازی <code>parse_config</code> برای بازگرداندن یک نمونه از struct <code>Config</code></figcaption>
</figure>
<p>ما یک ساختار جدید به نام <code>Config</code> تعریف کرده‌ایم که دارای فیلدهایی با نام‌های <code>query</code> و <code>file_path</code> است. امضای تابع <code>parse_config</code> اکنون نشان می‌دهد که این تابع یک مقدار <code>Config</code> را بازمی‌گرداند. در بدنه تابع <code>parse_config</code>، جایی که قبلاً اسلایس‌های رشته‌ای را که به مقادیر <code>String</code> در <code>args</code> اشاره می‌کردند بازمی‌گرداندیم، اکنون <code>Config</code> را طوری تعریف می‌کنیم که دارای مقادیر <code>String</code> متعلق به خود باشد.</p>
<p>متغیر <code>args</code> در تابع <code>main</code> مالک مقادیر آرگومان است و فقط به تابع <code>parse_config</code> اجازه قرض گرفتن آن‌ها را می‌دهد، به این معنی که اگر <code>Config</code> بخواهد مالک مقادیر در <code>args</code> شود، قوانین قرض‌گیری Rust را نقض می‌کنیم.</p>
<p>چندین روش برای مدیریت داده‌های <code>String</code> وجود دارد؛ ساده‌ترین و شاید ناکارآمدترین روش، فراخوانی متد <code>clone</code> روی مقادیر است. این کار یک کپی کامل از داده‌ها برای نمونه <code>Config</code> ایجاد می‌کند که مالک آن است. این روش زمان و حافظه بیشتری نسبت به ذخیره یک مرجع به داده‌ها نیاز دارد. با این حال، کپی کردن داده‌ها باعث می‌شود که کد ما بسیار ساده شود زیرا نیازی به مدیریت طول عمر مراجع نداریم؛ در این شرایط، از دست دادن کمی کارایی برای دستیابی به سادگی ارزشمند است.</p>
<section class="note" aria-role="note">
<h3 id="هزینهها-و-مزایای-استفاده-از-clone"><a class="header" href="#هزینهها-و-مزایای-استفاده-از-clone">هزینه‌ها و مزایای استفاده از <code>clone</code></a></h3>
<p>در بین بسیاری از برنامه‌نویسان Rust، تمایلی به استفاده از <code>clone</code> برای رفع مشکلات مالکیت به دلیل هزینه اجرای آن وجود دارد. در <a href="ch13-00-functional-features.html">فصل ۱۳</a><!-- ignore -->، یاد خواهید گرفت که چگونه در این نوع موقعیت‌ها از روش‌های کارآمدتر استفاده کنید. اما در حال حاضر، کپی کردن چند رشته برای ادامه پیشرفت اشکالی ندارد زیرا این کپی‌ها فقط یک‌بار انجام می‌شوند و مسیر فایل و رشته جستجوی شما بسیار کوچک هستند. بهتر است یک برنامه کارا که کمی ناکارآمد است داشته باشید تا اینکه در اولین تلاش خود برای نوشتن کد، بهینه‌سازی بیش از حد انجام دهید. با تجربه بیشتر در Rust، شروع با راه‌حل کارآمدتر آسان‌تر خواهد بود، اما در حال حاضر استفاده از <code>clone</code> کاملاً قابل قبول است.</p>
</section>
<p>ما تابع <code>main</code> را به‌روزرسانی کردیم تا نمونه‌ای از <code>Config</code> که توسط <code>parse_config</code> بازگردانده می‌شود را در یک متغیر به نام <code>config</code> قرار دهد، و کدی که قبلاً از متغیرهای جداگانه <code>query</code> و <code>file_path</code> استفاده می‌کرد، اکنون از فیلدهای موجود در struct <code>Config</code> استفاده می‌کند.</p>
<p>اکنون کد ما به‌وضوح نشان می‌دهد که <code>query</code> و <code>file_path</code> به هم مرتبط هستند و هدف آن‌ها تنظیم نحوه کار برنامه است. هر کدی که از این مقادیر استفاده می‌کند می‌داند که باید آن‌ها را در نمونه <code>config</code> در فیلدهایی که نام آن‌ها برای هدفشان انتخاب شده است، پیدا کند.</p>
<h4 id="ایجاد-سازنده-برای-config"><a class="header" href="#ایجاد-سازنده-برای-config">ایجاد سازنده برای <code>Config</code></a></h4>
<p>تا اینجا، منطق مسئول تجزیه آرگومان‌های خط فرمان را از <code>main</code> استخراج کرده و در تابع <code>parse_config</code> قرار داده‌ایم. این کار به ما کمک کرد ببینیم که مقادیر <code>query</code> و <code>file_path</code> به هم مرتبط هستند و این رابطه باید در کد ما منتقل شود. سپس یک struct به نام <code>Config</code> اضافه کردیم تا هدف مشترک <code>query</code> و <code>file_path</code> را نام‌گذاری کنیم و بتوانیم نام مقادیر را به‌عنوان فیلدهای struct از تابع <code>parse_config</code> بازگردانیم.</p>
<p>حالا که هدف تابع <code>parse_config</code> ایجاد یک نمونه از <code>Config</code> است، می‌توانیم <code>parse_config</code> را از یک تابع معمولی به یک تابع با نام <code>new</code> تغییر دهیم که به struct <code>Config</code> مرتبط است. این تغییر کد را به‌صورت idiomatic‌تر می‌کند. ما می‌توانیم نمونه‌هایی از انواع موجود در کتابخانه استاندارد، مانند <code>String</code>، را با فراخوانی <code>String::new</code> ایجاد کنیم. به همین ترتیب، با تغییر <code>parse_config</code> به تابع <code>new</code> مرتبط با <code>Config</code>، می‌توانیم نمونه‌هایی از <code>Config</code> را با فراخوانی <code>Config::new</code> ایجاد کنیم. لیست ۱۲-۷ تغییرات لازم را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption>Listing 12-7: تغییر <code>parse_config</code> به <code>Config::new</code></figcaption>
</figure>
<p>ما تابع <code>main</code> را که در آن <code>parse_config</code> را فراخوانی می‌کردیم به‌روزرسانی کرده‌ایم تا به‌جای آن <code>Config::new</code> را فراخوانی کند. نام <code>parse_config</code> را به <code>new</code> تغییر داده و آن را در یک بلوک <code>impl</code> قرار داده‌ایم که تابع <code>new</code> را به <code>Config</code> مرتبط می‌کند. کد را دوباره کامپایل کنید تا مطمئن شوید که کار می‌کند.</p>
<h3 id="رفع-مشکلات-مدیریت-خطا"><a class="header" href="#رفع-مشکلات-مدیریت-خطا">رفع مشکلات مدیریت خطا</a></h3>
<p>حالا روی رفع مشکلات مدیریت خطا کار می‌کنیم. به خاطر بیاورید که تلاش برای دسترسی به مقادیر موجود در بردار <code>args</code> در اندیس (index)۱ یا ۲ باعث می‌شود برنامه در صورت داشتن کمتر از سه آیتم، دچار وحشت شود. برنامه را بدون هیچ آرگومانی اجرا کنید؛ این حالت به شکل زیر خواهد بود:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>خط <code>index out of bounds: the len is 1 but the index is 1</code> یک پیام خطا است که برای برنامه‌نویسان در نظر گرفته شده است. این پیام به کاربران نهایی کمکی نمی‌کند تا بفهمند باید چه کار کنند. حالا این مشکل را رفع می‌کنیم.</p>
<h4 id="بهبود-پیام-خطا"><a class="header" href="#بهبود-پیام-خطا">بهبود پیام خطا</a></h4>
<p>در لیست ۱۲-۸، یک بررسی در تابع <code>new</code> اضافه می‌کنیم که بررسی می‌کند آیا آرایه به‌اندازه کافی طولانی است تا بتوان به اندیس‌های ۱ و ۲ دسترسی داشت. اگر طول آرایه کافی نباشد، برنامه دچار وحشت می‌شود و یک پیام خطای بهتر نمایش می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-8: افزودن بررسی برای تعداد آرگومان‌ها</figcaption>
</figure>
<p>این کد شبیه به <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">تابع <code>Guess::new</code> که در لیست ۹-۱۳ نوشتیم</a><!-- ignore --> است، جایی که وقتی آرگومان <code>value</code> خارج از محدوده مقادیر معتبر بود، <code>panic!</code> فراخوانی کردیم. به جای بررسی محدوده مقادیر، در اینجا بررسی می‌کنیم که طول <code>args</code> حداقل برابر با <code>3</code> باشد و بقیه تابع می‌تواند با فرض اینکه این شرط برقرار شده است، عمل کند. اگر <code>args</code> کمتر از سه آیتم داشته باشد، این شرط <code>true</code> خواهد بود و ما ماکرو <code>panic!</code> را برای خاتمه برنامه بلافاصله فراخوانی می‌کنیم.</p>
<p>با این چند خط اضافی در <code>new</code>، بیایید دوباره برنامه را بدون هیچ آرگومانی اجرا کنیم تا ببینیم اکنون پیام خطا چگونه است:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>این خروجی بهتر است: اکنون یک پیام خطای منطقی داریم. با این حال، هنوز اطلاعات اضافی داریم که نمی‌خواهیم به کاربران خود ارائه دهیم. شاید تکنیکی که در لیست ۹-۱۳ استفاده کردیم بهترین گزینه برای اینجا نباشد: یک فراخوانی به <code>panic!</code> برای مشکل برنامه‌نویسی مناسب‌تر است تا یک مشکل استفاده، <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">همان‌طور که در فصل ۹ بحث شد</a><!-- ignore -->. در عوض، از تکنیک دیگری که در فصل ۹ یاد گرفتید استفاده می‌کنیم—<a href="ch09-02-recoverable-errors-with-result.html">بازگرداندن یک <code>Result</code></a><!-- ignore --> که نشان‌دهنده موفقیت یا خطا است.</p>
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="بازگرداندن-یک-result-به-جای-فراخوانی-panic"><a class="header" href="#بازگرداندن-یک-result-به-جای-فراخوانی-panic">بازگرداندن یک <code>Result</code> به جای فراخوانی <code>panic!</code></a></h4>
<p>ما می‌توانیم به جای آن، یک مقدار <code>Result</code> بازگردانیم که در صورت موفقیت شامل یک نمونه از <code>Config</code> باشد و در صورت خطا مشکل را توصیف کند. همچنین قصد داریم نام تابع را از <code>new</code> به <code>build</code> تغییر دهیم زیرا بسیاری از برنامه‌نویسان انتظار دارند که توابع <code>new</code> هرگز شکست نخورند. وقتی <code>Config::build</code> با <code>main</code> ارتباط برقرار می‌کند، می‌توانیم از نوع <code>Result</code> برای اعلام مشکل استفاده کنیم. سپس می‌توانیم <code>main</code> را تغییر دهیم تا یک واریانت <code>Err</code> را به یک پیام خطای عملی‌تر برای کاربران خود تبدیل کنیم، بدون متن‌های اضافی مربوط به <code>thread 'main'</code> و <code>RUST_BACKTRACE</code> که یک فراخوانی به <code>panic!</code> ایجاد می‌کند.</p>
<p>لیست ۱۲-۹ تغییراتی را که باید در مقدار بازگشتی تابع که اکنون آن را <code>Config::build</code> می‌نامیم و بدنه تابع برای بازگرداندن یک <code>Result</code> ایجاد کنیم، نشان می‌دهد. توجه داشته باشید که این کد تا زمانی که <code>main</code> را نیز به‌روزرسانی نکنیم کامپایل نمی‌شود، که این کار را در لیست بعدی انجام خواهیم داد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption>Listing 12-9: بازگرداندن یک <code>Result</code> از <code>Config::build</code></figcaption>
</figure>
<h4 id="تابع-build-و-بازگشت-مقدار-result"><a class="header" href="#تابع-build-و-بازگشت-مقدار-result">تابع <code>build</code> و بازگشت مقدار <code>Result</code></a></h4>
<p>تابع <code>build</code> ما اکنون یک مقدار <code>Result</code> را بازمی‌گرداند که در صورت موفقیت شامل یک نمونه از <code>Config</code> و در صورت خطا یک مقدار رشته‌ای ثابت (<code>string literal</code>) است. مقادیر خطای ما همیشه رشته‌های ثابت با طول عمر <code>'static</code> خواهند بود.</p>
<p>ما دو تغییر در بدنه تابع ایجاد کرده‌ایم: به جای فراخوانی <code>panic!</code> زمانی که کاربر آرگومان‌های کافی ارائه نمی‌دهد، اکنون یک مقدار <code>Err</code> بازمی‌گردانیم و مقدار بازگشتی <code>Config</code> را در یک <code>Ok</code> قرار داده‌ایم. این تغییرات باعث می‌شوند تابع با امضای نوع جدید خود سازگار باشد.</p>
<p>بازگرداندن مقدار <code>Err</code> از <code>Config::build</code> به تابع <code>main</code> اجازه می‌دهد که مقدار <code>Result</code> بازگشتی از تابع <code>build</code> را مدیریت کرده و در صورت بروز خطا، فرآیند را به شکلی تمیزتر خاتمه دهد.</p>
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="فراخوانی-configbuild-و-مدیریت-خطاها"><a class="header" href="#فراخوانی-configbuild-و-مدیریت-خطاها">فراخوانی <code>Config::build</code> و مدیریت خطاها</a></h4>
<p>برای مدیریت حالت خطا و چاپ یک پیام دوستانه برای کاربر، باید تابع <code>main</code> را به‌روزرسانی کنیم تا مقدار <code>Result</code> بازگردانده‌شده توسط <code>Config::build</code> را مدیریت کند. این کار در لیست ۱۲-۱۰ نشان داده شده است. همچنین مسئولیت خاتمه دادن ابزار خط فرمان با کد خطای غیر صفر را از <code>panic!</code> گرفته و به صورت دستی پیاده‌سازی خواهیم کرد. کد خروجی غیر صفر به عنوان یک قرارداد برای اعلام وضعیت خطا به فرآیندی که برنامه ما را فراخوانده است، استفاده می‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-10: خروج با کد خطا در صورت شکست در ساخت یک <code>Config</code></figcaption>
</figure>
<p>در این لیستینگ، ما از متدی استفاده کرده‌ایم که هنوز جزئیات آن را به‌طور کامل پوشش نداده‌ایم: <code>unwrap_or_else</code>. این متد که در استاندارد کتابخانه Rust برای <code>Result&lt;T, E&gt;</code> تعریف شده است، به ما امکان می‌دهد مدیریت خطاهای سفارشی و بدون استفاده از <code>panic!</code> را تعریف کنیم. اگر مقدار <code>Result</code> از نوع <code>Ok</code> باشد، رفتار این متد مشابه <code>unwrap</code> است: مقدار داخلی که <code>Ok</code> در خود قرار داده را بازمی‌گرداند. با این حال، اگر مقدار از نوع <code>Err</code> باشد، این متد کدی را که در <em>closure</em> تعریف کرده‌ایم اجرا می‌کند. <em>Closure</em> یک تابع ناشناس است که آن را تعریف کرده و به‌عنوان آرگومان به <code>unwrap_or_else</code> ارسال می‌کنیم.</p>
<p>ما closures را به تفصیل در <a href="ch13-00-functional-features.html">فصل ۱۳</a> توضیح خواهیم داد. فعلاً کافی است بدانید که <code>unwrap_or_else</code> مقدار داخلی <code>Err</code> را به <em>closure</em> می‌دهد. در اینجا، مقدار استاتیک <code>"not enough arguments"</code> که در لیستینگ 12-9 اضافه کردیم، به <em>closure</em> ارسال شده و به آرگومان <code>err</code> تخصیص داده می‌شود، که بین خط عمودی‌ها قرار دارد. کد درون <em>closure</em> سپس می‌تواند از مقدار <code>err</code> استفاده کند.</p>
<p>ما همچنین یک خط جدید <code>use</code> اضافه کرده‌ایم تا <code>process</code> را از کتابخانه استاندارد به محدوده بیاوریم. کدی که در حالت خطا اجرا می‌شود تنها شامل دو خط است: ابتدا مقدار <code>err</code> را چاپ می‌کنیم و سپس <code>process::exit</code> را فراخوانی می‌کنیم. تابع <code>process::exit</code> بلافاصله برنامه را متوقف کرده و عددی که به‌عنوان کد وضعیت خروج ارسال شده است را بازمی‌گرداند. این روش شبیه مدیریت مبتنی بر <code>panic!</code> است که در لیستینگ 12-8 استفاده کردیم، اما دیگر خروجی اضافی تولید نمی‌شود. حالا آن را آزمایش کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>عالی! این خروجی برای کاربران ما بسیار دوستانه‌تر است.</p>
<h3 id="جداسازی-منطق-از-main"><a class="header" href="#جداسازی-منطق-از-main">جداسازی منطق از <code>main</code></a></h3>
<p>اکنون که بازآرایی برای تجزیه تنظیمات را به پایان رسانده‌ایم، بیایید به منطق برنامه بپردازیم. همان‌طور که در <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">«تفکیک نگرانی‌ها برای پروژه‌های باینری»</a><!-- ignore --> بیان کردیم، تابعی به نام <code>run</code> استخراج خواهیم کرد که تمام منطقی که در حال حاضر در تابع <code>main</code> وجود دارد و مربوط به تنظیمات یا مدیریت خطا نیست را نگه می‌دارد. هنگامی که کار ما تمام شود، <code>main</code> مختصر و آسان برای بررسی خواهد بود و می‌توانیم تست‌هایی برای سایر منطق‌ها بنویسیم.</p>
<p>لیست ۱۲-۱۱ تابع استخراج‌شده <code>run</code> را نشان می‌دهد. فعلاً فقط بهبود کوچکی انجام می‌دهیم که تابع را استخراج کنیم. همچنان تابع را در فایل <em>src/main.rs</em> تعریف می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-11: استخراج تابع <code>run</code> از <code>main</code></figcaption>
</figure>
<p>با این تغییرات، <code>main</code> اکنون تابع <code>run</code> را فراخوانی می‌کند و مسئولیت اجرای منطق اصلی برنامه را به آن واگذار می‌کند. این جداسازی باعث می‌شود تابع <code>main</code> ساده‌تر شود و ما بتوانیم تست‌های دقیقی برای بخش‌های مختلف کد بنویسیم. این روش به بهبود قابلیت نگهداری و خوانایی کد کمک شایانی می‌کند.</p>
<h3 id="بازگرداندن-خطاها-از-تابع-run"><a class="header" href="#بازگرداندن-خطاها-از-تابع-run">بازگرداندن خطاها از تابع <code>run</code></a></h3>
<p>اکنون که منطق باقی‌مانده برنامه را در تابع <code>run</code> جدا کرده‌ایم، می‌توانیم مانند <code>Config::build</code> در لیستینگ 12-9، مدیریت خطا را بهبود بخشیم. به جای اجازه دادن به برنامه برای اجرای <code>panic</code> با فراخوانی <code>expect</code>، تابع <code>run</code> در صورت بروز مشکل یک <code>Result&lt;T, E&gt;</code> بازمی‌گرداند. این رویکرد به ما امکان می‌دهد منطق مرتبط با مدیریت خطا را به صورت کاربرپسندانه‌ای در تابع <code>main</code> متمرکز کنیم. تغییرات لازم برای امضا و بدنه تابع <code>run</code> در لیستینگ 12-12 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-12: تغییر تابع <code>run</code> برای بازگرداندن <code>Result</code></figcaption>
</figure>
<h3 id="تغییرات-مهم"><a class="header" href="#تغییرات-مهم">تغییرات مهم</a></h3>
<ul dir="rtl">
  <li>
    <strong>تغییر نوع بازگشتی:</strong>  
    نوع بازگشتی تابع <code>run</code> به <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> تغییر داده شده است. این تابع قبلاً نوع واحد (<code>()</code>) را بازمی‌گرداند، که همچنان برای حالت موفقیت حفظ شده است.  
    برای نوع خطا از یک <strong>شیء صفات</strong> به نام <code>Box&lt;dyn Error&gt;</code> استفاده کرده‌ایم (و با استفاده از <code>use</code>، <code>std::error::Error</code> را به محدوده آورده‌ایم). در فصل 18 بیشتر درباره شیء صفات صحبت خواهیم کرد. فعلاً کافی است بدانید که <code>Box&lt;dyn Error&gt;</code> به این معنا است که تابع می‌تواند نوعی از مقدار را که صفت <code>Error</code> را پیاده‌سازی کرده بازگرداند، بدون اینکه نوع خاصی را مشخص کند. کلمه کلیدی <code>dyn</code> به معنای <strong>دینامیک</strong> است.
  </li>
  <li>
    <strong>حذف <code>expect</code> و استفاده از عملگر <code>?</code>:</strong>  
    به جای استفاده از <code>panic!</code> در صورت بروز خطا، عملگر <code>?</code> مقدار خطا را از تابع جاری بازمی‌گرداند تا فراخوانی‌کننده بتواند آن را مدیریت کند.
  </li>
  <li>
    <strong>بازگرداندن مقدار <code>Ok</code> در حالت موفقیت:</strong>  
    تابع <code>run</code> اکنون در حالت موفقیت مقدار <code>Ok</code> را بازمی‌گرداند. ما نوع موفقیت تابع را به عنوان <code>()</code> در امضا تعریف کرده‌ایم، که به این معنا است که باید مقدار نوع واحد را در مقدار <code>Ok</code> قرار دهیم. نحو <code>Ok(())</code> ممکن است در ابتدا کمی عجیب به نظر برسد، اما استفاده از <code>()</code> به این صورت روش استاندارد برای نشان دادن این است که تابع <code>run</code> تنها برای تأثیرات جانبی فراخوانی شده و مقداری بازنمی‌گرداند که به آن نیاز داشته باشیم.
  </li>
</ul>
```
<h3 id="بررسی-کد"><a class="header" href="#بررسی-کد">بررسی کد</a></h3>
<p>اجرای این کد باعث می‌شود که کد کامپایل شود اما یک هشدار نمایش دهد:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust به ما یادآوری می‌کند که کد ما مقدار <code>Result</code> را نادیده گرفته است و این مقدار ممکن است نشان‌دهنده بروز خطا باشد. اما ما بررسی نمی‌کنیم که آیا خطایی رخ داده است یا خیر، و کامپایلر به ما یادآوری می‌کند که احتمالاً نیاز به مدیریت خطا در این بخش داریم. اکنون این مشکل را اصلاح خواهیم کرد.</p>
<h4 id="مدیریت-خطاهای-بازگرداندهشده-از-run-در-main"><a class="header" href="#مدیریت-خطاهای-بازگرداندهشده-از-run-در-main">مدیریت خطاهای بازگردانده‌شده از <code>run</code> در <code>main</code></a></h4>
<p>ما خطاها را بررسی کرده و با استفاده از تکنیکی مشابه آنچه در <code>Config::build</code> در لیست ۱۲-۱۰ استفاده کردیم مدیریت می‌کنیم، اما با یک تفاوت کوچک:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ما به جای <code>unwrap_or_else</code> از <code>if let</code> استفاده می‌کنیم تا بررسی کنیم آیا <code>run</code> یک مقدار <code>Err</code> بازمی‌گرداند یا خیر و در صورت وقوع، <code>process::exit(1)</code> را فراخوانی کنیم. تابع <code>run</code> مقداری بازنمی‌گرداند که بخواهیم به همان شیوه‌ای که <code>Config::build</code> نمونه <code>Config</code> را بازمی‌گرداند آن را <code>unwrap</code> کنیم. از آنجایی که <code>run</code> در صورت موفقیت مقدار <code>()</code> بازمی‌گرداند، ما فقط به شناسایی یک خطا اهمیت می‌دهیم، بنابراین نیازی به <code>unwrap_or_else</code> برای بازگرداندن مقدار آن نداریم، که تنها <code>()</code> خواهد بود.</p>
<p>بدنه‌های <code>if let</code> و <code>unwrap_or_else</code> در هر دو حالت یکسان هستند: ما خطا را چاپ کرده و خارج می‌شویم.</p>
<h3 id="تقسیم-کد-به-یک-کتابخانه"><a class="header" href="#تقسیم-کد-به-یک-کتابخانه">تقسیم کد به یک کتابخانه</a></h3>
<p>پروژه <code>minigrep</code> ما تا اینجا خوب پیش می‌رود! اکنون کد فایل <em>src/main.rs</em> را تقسیم کرده و برخی از کد را به فایل <em>src/lib.rs</em> منتقل می‌کنیم. به این ترتیب، می‌توانیم کد را تست کنیم و فایل <em>src/main.rs</em> مسئولیت‌های کمتری داشته باشد.</p>
<p>بیایید تمام کدی که در تابع <code>main</code> نیست از <em>src/main.rs</em> به <em>src/lib.rs</em> منتقل کنیم:</p>
<ul dir="rtl">
<li> تعریف تابع `run` </li>
<li> دستورات `use` مرتبط </li>
<li> تعریف `Config` </li>
<li> تعریف تابع `Config::build` </li>
</ul>
<p>محتویات فایل <em>src/lib.rs</em> باید امضاهایی که در لیست ۱۲-۱۳ آمده است را داشته باشد (بدنه توابع برای اختصار حذف شده است). توجه داشته باشید که این کد تا زمانی که <em>src/main.rs</em> را همانطور که در لیست ۱۲-۱۴ نشان داده شده است تغییر ندهیم کامپایل نمی‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<figcaption>Listing 12-13: انتقال <code>Config</code> و <code>run</code> به <em>src/lib.rs</em></figcaption>
</figure>
<p>ما به طور گسترده از کلمه کلیدی <code>pub</code> استفاده کرده‌ایم: در <code>Config</code>، فیلدهای آن، متد <code>build</code> و همچنین تابع <code>run</code>. اکنون یک crate کتابخانه‌ای داریم که یک API عمومی دارد و می‌توانیم آن را تست کنیم!</p>
<p>حالا باید کدی که به <em>src/lib.rs</em> منتقل کرده‌ایم را به محدوده crate باینری در <em>src/main.rs</em> بیاوریم، همانطور که در لیست ۱۲-۱۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<figcaption>Listing 12-14: استفاده از crate کتابخانه‌ای <code>minigrep</code> در <em>src/main.rs</em></figcaption>
</figure>
<p>ما خط <code>use minigrep::Config</code> را اضافه کرده‌ایم تا نوع <code>Config</code> را از crate کتابخانه‌ای به محدوده crate باینری بیاوریم، و تابع <code>run</code> را با پیشوند نام crate فراخوانی کرده‌ایم. اکنون همه قابلیت‌ها باید متصل شوند و کار کنند. برنامه را با <code>cargo run</code> اجرا کنید و مطمئن شوید که همه چیز به درستی کار می‌کند.</p>
<p>وای! این یک کار سخت بود، اما ما خودمان را برای موفقیت در آینده آماده کردیم. اکنون مدیریت خطاها بسیار آسان‌تر شده است و کد ما ماژولارتر شده است. از اینجا به بعد تقریباً تمام کارهای ما در فایل <em>src/lib.rs</em> انجام خواهد شد.</p>
<p>بیایید از این ماژولاریت جدید برای انجام کاری استفاده کنیم که با کد قبلی دشوار بود اما با کد جدید آسان است: نوشتن چند تست!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="توسعه-قابلیتهای-کتابخانه-با-توسعه-آزمونمحور-tdd-یا-همان-test-driven-development"><a class="header" href="#توسعه-قابلیتهای-کتابخانه-با-توسعه-آزمونمحور-tdd-یا-همان-test-driven-development">توسعه قابلیت‌های کتابخانه با توسعه آزمون‌محور (TDD) یا همان (Test-Driven Development)</a></h2>
<p>اکنون که منطق را به <em>src/lib.rs</em> استخراج کرده‌ایم و جمع‌آوری آرگومان‌ها و مدیریت خطاها را در <em>src/main.rs</em> باقی گذاشته‌ایم، نوشتن تست برای قابلیت‌های اصلی کد ما بسیار آسان‌تر شده است. می‌توانیم مستقیماً توابع را با آرگومان‌های مختلف فراخوانی کرده و مقادیر بازگشتی را بررسی کنیم، بدون اینکه نیاز باشد از باینری ما از خط فرمان استفاده کنیم.</p>
<p>در این بخش، منطق جستجو را با استفاده از فرآیند توسعه آزمون‌محور (TDD) به برنامه <code>minigrep</code> اضافه خواهیم کرد. مراحل این فرآیند به شرح زیر است:</p>
<ol dir="rtl">
  <li>نوشتن یک تست که شکست می‌خورد و اجرای آن برای اطمینان از اینکه به دلیلی که انتظار داشتید شکست می‌خورد.</li>
  <li>نوشتن یا تغییر کد به اندازه‌ای که تست جدید پاس شود.</li>
  <li>بازسازی کدی که به تازگی اضافه یا تغییر داده شده و اطمینان از اینکه تست‌ها همچنان پاس می‌شوند.</li>
  <li>تکرار از مرحله ۱!</li>
</ol>
<p>TDD تنها یکی از روش‌های نوشتن نرم‌افزار است، اما می‌تواند به طراحی بهتر کد کمک کند. نوشتن تست قبل از نوشتن کدی که تست را پاس می‌کند، کمک می‌کند تا پوشش تست بالا در طول فرآیند حفظ شود.</p>
<p>ما با استفاده از TDD پیاده‌سازی قابلیت جستجوی رشته کوئری در محتوای فایل و تولید لیستی از خطوط مطابق با کوئری را توسعه خواهیم داد. این قابلیت را در تابعی به نام <code>search</code> اضافه خواهیم کرد.</p>
<h3 id="نوشتن-یک-تست-که-شکست-میخورد"><a class="header" href="#نوشتن-یک-تست-که-شکست-میخورد">نوشتن یک تست که شکست می‌خورد</a></h3>
<p>از آنجا که دیگر به آن‌ها نیاز نداریم، بیایید عبارت‌های <code>println!</code> را از <em>src/lib.rs</em> و <em>src/main.rs</em> که برای بررسی رفتار برنامه استفاده می‌کردیم حذف کنیم. سپس، در <em>src/lib.rs</em>، یک ماژول <code>tests</code> با یک تابع تست اضافه خواهیم کرد، همانطور که در <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">فصل ۱۱</a> انجام دادیم. تابع تست، رفتاری که می‌خواهیم تابع <code>search</code> داشته باشد را مشخص می‌کند: این تابع یک کوئری و متن برای جستجو دریافت می‌کند و تنها خطوطی از متن که شامل کوئری هستند را بازمی‌گرداند. لیست ۱۲-۱۵ این تست را نشان می‌دهد که هنوز کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
<figcaption>Listing 12-15: ایجاد یک تست شکست‌خورده برای تابع <code>search</code> که آرزو می‌کنیم داشته باشیم</figcaption>
</figure>
<p>این تست به دنبال رشته <code>"duct"</code> می‌گردد. متنی که در آن جستجو می‌کنیم شامل سه خط است که تنها یکی از آن‌ها شامل <code>"duct"</code> است (توجه داشته باشید که بک‌اسلش بعد از علامت نقل قول بازکننده به Rust می‌گوید که کاراکتر newline در ابتدای محتویات این literal رشته قرار ندهد). ما تأیید می‌کنیم که مقدار بازگردانده شده از تابع <code>search</code> تنها شامل خطی است که انتظار داریم.</p>
<p>هنوز قادر به اجرای این تست و مشاهده شکست آن نیستیم زیرا تست حتی کامپایل نمی‌شود: تابع <code>search</code> هنوز وجود ندارد! بر اساس اصول TDD، ما تنها به اندازه‌ای کد اضافه می‌کنیم که تست کامپایل و اجرا شود، با اضافه کردن یک تعریف از تابع <code>search</code> که همیشه یک بردار خالی بازمی‌گرداند، همانطور که در لیست ۱۲-۱۶ نشان داده شده است. سپس تست باید کامپایل و شکست بخورد زیرا یک بردار خالی با یک بردار شامل خط <code>"safe, fast, productive."</code> مطابقت ندارد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-16: تعریف حداقل کد برای تابع <code>search</code> تا تست ما کامپایل شود</figcaption>
</figure>
<p>متوجه می‌شوید که ما نیاز داریم یک طول عمر صریح <code>'a</code> در امضای تابع <code>search</code> تعریف کنیم و از آن طول عمر با آرگومان <code>contents</code> و مقدار بازگشتی استفاده کنیم. به یاد داشته باشید که در <a href="ch10-03-lifetime-syntax.html">فصل ۱۰</a> توضیح دادیم که پارامترهای طول عمر مشخص می‌کنند کدام طول عمر آرگومان به طول عمر مقدار بازگشتی متصل است. در این مورد، ما مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌های رشته‌ای باشد که به برش‌های آرگومان <code>contents</code> اشاره دارند (نه آرگومان <code>query</code>).</p>
<p>به عبارت دیگر، به Rust می‌گوییم داده‌ای که توسط تابع <code>search</code> بازگردانده می‌شود به اندازه داده‌ای که به تابع <code>search</code> در آرگومان <code>contents</code> منتقل می‌شود زنده خواهد بود. این مهم است! داده‌ای که توسط یک برش مرجع داده می‌شود باید معتبر باشد تا مرجع نیز معتبر باشد؛ اگر کامپایلر فرض کند که ما در حال ساختن برش‌های رشته‌ای از <code>query</code> هستیم به جای <code>contents</code>، بررسی‌های ایمنی را به اشتباه انجام خواهد داد.</p>
<p>اگر طول عمرها را فراموش کنیم و سعی کنیم این تابع را کامپایل کنیم، این خطا را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust به هیچ وجه نمی‌تواند بداند کدام یک از دو آرگومان مورد نیاز است، بنابراین ما باید به صورت صریح به آن بگوییم. از آنجایی که <code>contents</code> آرگومانی است که شامل تمام متن ما است و ما می‌خواهیم قسمت‌هایی از آن متن که مطابقت دارند را بازگردانیم، می‌دانیم که <code>contents</code> آرگومانی است که باید با استفاده از نحو طول عمر به مقدار بازگشتی متصل شود.</p>
<p>دیگر زبان‌های برنامه‌نویسی نیازی ندارند آرگومان‌ها را به مقادیر بازگشتی در امضا متصل کنید، اما این تمرین با گذشت زمان آسان‌تر می‌شود. ممکن است بخواهید این مثال را با مثال‌های موجود در بخش <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“اعتبارسنجی مراجع با طول عمر”</a> از فصل ۱۰ مقایسه کنید.</p>
<p>اکنون بیایید تست را اجرا کنیم:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: ["safe, fast, productive."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>عالی است، تست دقیقا همانطور که انتظار داشتیم شکست می‌خورد. بیایید تست را پاس کنیم!</p>
<h3 id="نوشتن-کدی-برای-پاس-کردن-تست"><a class="header" href="#نوشتن-کدی-برای-پاس-کردن-تست">نوشتن کدی برای پاس کردن تست</a></h3>
<p>در حال حاضر، تست ما به دلیل اینکه همیشه یک بردار خالی بازمی‌گرداند، شکست می‌خورد. برای رفع این مشکل و پیاده‌سازی <code>search</code>، برنامه ما باید این مراحل را دنبال کند:</p>
<ol dir="rtl">
  <li>تکرار از طریق هر خط از محتوای فایل.</li>
  <li>بررسی اینکه آیا خط شامل رشته کوئری ما هست یا نه.</li>
  <li>اگر خط شامل کوئری بود، آن را به لیست مقادیر بازگشتی اضافه کنیم.</li>
  <li>اگر نبود، کاری انجام ندهیم.</li>
  <li>لیست نتایجی که مطابقت دارند را بازگردانیم.</li>
</ol>
<p>بیایید هر مرحله را یکی‌یکی اجرا کنیم، با تکرار از طریق خطوط شروع می‌کنیم.</p>
<h4 id="تکرار-از-طریق-خطوط-با-متد-lines"><a class="header" href="#تکرار-از-طریق-خطوط-با-متد-lines">تکرار از طریق خطوط با متد <code>lines</code></a></h4>
<p>Rust یک متد مفید برای مدیریت تکرار خط به خط در رشته‌ها ارائه می‌دهد که به طور مناسبی <code>lines</code> نامیده شده است و همانطور که در لیست ۱۲-۱۷ نشان داده شده کار می‌کند. توجه داشته باشید که این کد هنوز کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-17: تکرار از طریق هر خط در <code>contents</code></figcaption>
</figure>
<p>متد <code>lines</code> یک iterator برمی‌گرداند. ما در <a href="ch13-02-iterators.html">فصل ۱۳</a> عمیقاً در مورد iteratorها صحبت خواهیم کرد، اما به یاد داشته باشید که قبلاً این روش استفاده از یک iterator را در <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">لیست ۳-۵</a> دیدید، جایی که از یک حلقه <code>for</code> با یک iterator برای اجرای کدی روی هر آیتم در یک مجموعه استفاده کردیم.</p>
<h4 id="جستجو-در-هر-خط-برای-کوئری"><a class="header" href="#جستجو-در-هر-خط-برای-کوئری">جستجو در هر خط برای کوئری</a></h4>
<p>اکنون، بررسی خواهیم کرد که آیا خط فعلی شامل رشته کوئری ما هست یا نه. خوشبختانه، رشته‌ها یک متد مفید به نام <code>contains</code> دارند که این کار را برای ما انجام می‌دهد! یک فراخوانی به متد <code>contains</code> را در تابع <code>search</code> اضافه کنید، همانطور که در لیست ۱۲-۱۸ نشان داده شده است. توجه داشته باشید که این کد همچنان کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-18: اضافه کردن قابلیت بررسی اینکه آیا خط شامل رشته موجود در <code>query</code> هست یا نه</figcaption>
</figure>
<p>در حال حاضر، ما در حال ایجاد قابلیت‌های بیشتر هستیم. برای اینکه کد کامپایل شود، نیاز داریم مقداری را از بدنه تابع بازگردانیم همانطور که در امضای تابع اشاره کردیم.</p>
<h4 id="ذخیره-خطوط-مطابق"><a class="header" href="#ذخیره-خطوط-مطابق">ذخیره خطوط مطابق</a></h4>
<p>برای تکمیل این تابع، نیاز داریم روشی برای ذخیره خطوط مطابق که می‌خواهیم بازگردانیم داشته باشیم. برای این کار، می‌توانیم یک بردار mutable قبل از حلقه <code>for</code> ایجاد کنیم و با استفاده از متد <code>push</code> یک خط را در بردار ذخیره کنیم. بعد از حلقه <code>for</code>، بردار را بازمی‌گردانیم، همانطور که در لیست ۱۲-۱۹ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-19: ذخیره خطوط مطابق برای بازگرداندن آن‌ها</figcaption>
</figure>
<p>اکنون تابع <code>search</code> باید فقط خطوطی را که شامل <code>query</code> هستند بازگرداند، و تست ما باید پاس شود. بیایید تست را اجرا کنیم:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>تست ما پاس شد، بنابراین می‌دانیم که کار می‌کند!</p>
<p>در این مرحله، می‌توانیم فرصت‌هایی برای بازسازی پیاده‌سازی تابع جستجو در نظر بگیریم و در عین حال تست‌ها را پاس نگه داریم تا همان قابلیت را حفظ کنیم. کد در تابع جستجو چندان بد نیست، اما از برخی ویژگی‌های مفید iteratorها استفاده نمی‌کند. ما در <a href="ch13-02-iterators.html">فصل ۱۳</a> به این مثال بازخواهیم گشت، جایی که iteratorها را با جزئیات بررسی می‌کنیم و به نحوه بهبود آن می‌پردازیم.</p>
<h4 id="استفاده-از-تابع-search-در-تابع-run"><a class="header" href="#استفاده-از-تابع-search-در-تابع-run">استفاده از تابع <code>search</code> در تابع <code>run</code></a></h4>
<p>اکنون که تابع <code>search</code> کار می‌کند و تست شده است، باید تابع <code>search</code> را از تابع <code>run</code> فراخوانی کنیم. ما باید مقدار <code>config.query</code> و <code>contents</code> که <code>run</code> از فایل می‌خواند را به تابع <code>search</code> بدهیم. سپس <code>run</code> هر خطی که از <code>search</code> برگردانده شده را چاپ خواهد کرد:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ما هنوز از یک حلقه <code>for</code> برای بازگرداندن هر خط از <code>search</code> و چاپ آن استفاده می‌کنیم.</p>
<p>اکنون کل برنامه باید کار کند! بیایید آن را امتحان کنیم، ابتدا با کلمه‌ای که باید دقیقاً یک خط از شعر امیلی دیکینسون را برگرداند: <em>frog</em>.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>عالی! حالا بیایید کلمه‌ای را امتحان کنیم که چندین خط را مطابقت دهد، مثل <em>body</em>:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>و در نهایت، مطمئن شویم که وقتی کلمه‌ای را جستجو می‌کنیم که در هیچ جای شعر وجود ندارد، مثل <em>monomorphization</em>، هیچ خطی دریافت نخواهیم کرد:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>عالی! ما نسخه کوچکی از یک ابزار کلاسیک ساختیم و چیزهای زیادی درباره نحوه ساختاردهی برنامه‌ها آموختیم. همچنین کمی درباره ورودی و خروجی فایل، طول عمر‌ها، تست کردن و تجزیه دستورات خط فرمان یاد گرفتیم.</p>
<p>برای تکمیل این پروژه، به طور مختصر نشان خواهیم داد که چگونه با متغیرهای محیطی کار کنیم و چگونه به خطای استاندارد (standard error) چاپ کنیم، که هر دو در هنگام نوشتن برنامه‌های خط فرمان مفید هستند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="کار-با-متغیرهای-محیطی"><a class="header" href="#کار-با-متغیرهای-محیطی">کار با متغیرهای محیطی</a></h2>
<p>ما قصد داریم برنامه <code>minigrep</code> را با افزودن یک ویژگی جدید بهبود دهیم: گزینه‌ای برای جستجوی
حساس به حروف کوچک و بزرگ که کاربر می‌تواند آن را از طریق یک متغیر محیطی فعال کند. ما می‌توانیم
این ویژگی را به عنوان یک گزینه خط فرمان قرار دهیم و کاربران را ملزم کنیم که هر بار که می‌خواهند
این ویژگی اعمال شود آن را وارد کنند، اما با استفاده از یک متغیر محیطی به جای آن، به کاربران
اجازه می‌دهیم که فقط یک بار متغیر محیطی را تنظیم کنند و همه جستجوهایشان در همان نشست ترمینال
به صورت غیرحساس به حروف کوچک و بزرگ باشد.</p>
<h3 id="نوشتن-یک-تست-شکستخورده-برای-تابع-search_case_insensitive"><a class="header" href="#نوشتن-یک-تست-شکستخورده-برای-تابع-search_case_insensitive">نوشتن یک تست شکست‌خورده برای تابع <code>search_case_insensitive</code></a></h3>
<p>ابتدا یک تابع جدید به نام <code>search_case_insensitive</code> اضافه می‌کنیم که زمانی که متغیر محیطی دارای
مقدار باشد، فراخوانی خواهد شد. ما همچنان از فرآیند TDD پیروی می‌کنیم، بنابراین اولین گام،
نوشتن یک تست شکست‌خورده است. یک تست جدید برای تابع <code>search_case_insensitive</code> اضافه می‌کنیم و
تست قدیمی خود را از <code>one_result</code> به <code>case_sensitive</code> تغییر نام می‌دهیم تا تفاوت بین این دو
تست مشخص شود، همان‌طور که در لیستینگ 12-20 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<figcaption>Listing 12-20: افزودن یک تست شکست‌خورده جدید برای تابع غیرحساس به حروف کوچک و بزرگ که قصد داریم اضافه کنیم</figcaption>
</figure>
<p>توجه کنید که ما متن تست قدیمی را نیز ویرایش کرده‌ایم. ما یک خط جدید با متن <code>"Duct tape."</code> با
حرف بزرگ <em>D</em> اضافه کرده‌ایم که نباید با عبارت جستجو <code>"duct"</code> در حالت حساس به حروف کوچک و
بزرگ مطابقت داشته باشد. تغییر دادن تست قدیمی به این صورت کمک می‌کند که مطمئن شویم عملکرد
جستجوی حساس به حروف کوچک و بزرگ که قبلاً پیاده‌سازی کرده‌ایم به طور تصادفی شکسته نمی‌شود.
این تست باید اکنون عبور کند و همچنان باید عبور کند در حالی که ما روی جستجوی غیرحساس به حروف
کار می‌کنیم.</p>
<p>تست جدید برای جستجوی غیرحساس به حروف کوچک و بزرگ از <code>"rUsT"</code> به عنوان عبارت جستجو استفاده
می‌کند. در تابع <code>search_case_insensitive</code> که قصد داریم اضافه کنیم، عبارت جستجوی <code>"rUsT"</code>
باید با خط حاوی <code>"Rust:"</code> با حرف بزرگ <em>R</em> و خط <code>"Trust me."</code> مطابقت داشته باشد، حتی اگر هر
دو حالت متفاوتی نسبت به عبارت جستجو داشته باشند. این تست شکست‌خورده ما است و به دلیل اینکه
هنوز تابع <code>search_case_insensitive</code> تعریف نشده است، کامپایل نخواهد شد. می‌توانید یک
پیاده‌سازی موقتی که همیشه یک وکتور خالی برمی‌گرداند اضافه کنید، مشابه کاری که برای تابع
<code>search</code> در لیستینگ 12-16 انجام دادیم تا تست کامپایل شده و شکست بخورد.</p>
<h3 id="پیادهسازی-تابع-search_case_insensitive"><a class="header" href="#پیادهسازی-تابع-search_case_insensitive">پیاده‌سازی تابع <code>search_case_insensitive</code></a></h3>
<p>تابع <code>search_case_insensitive</code> که در لیستینگ 12-21 نشان داده شده است، تقریباً مشابه تابع
<code>search</code> خواهد بود. تنها تفاوت این است که ما عبارت جستجو و هر خط را کوچک‌حرف می‌کنیم تا
صرف‌نظر از مورد ورودی‌ها، هنگام بررسی اینکه آیا خط شامل عبارت جستجو است، هر دو به یک مورد
تبدیل شوند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-21: تعریف تابع <code>search_case_insensitive</code> برای کوچک‌حرف کردن عبارت جستجو و خط قبل از مقایسه آنها</figcaption>
</figure>
<p>ابتدا عبارت جستجوی <code>query</code> را کوچک‌حرف می‌کنیم و آن را در یک متغیر جدید با همان نام ذخیره می‌کنیم،
جایگزین متغیر اصلی می‌شود. فراخوانی <code>to_lowercase</code> بر روی عبارت جستجو ضروری است تا صرف‌نظر از
اینکه عبارت جستجو <code>"rust"</code>، <code>"RUST"</code>، <code>"Rust"</code> یا <code>"rUsT"</code> باشد، به گونه‌ای عمل کنیم که انگار
عبارت جستجو <code>"rust"</code> است و به حروف کوچک و بزرگ حساس نباشد. در حالی که <code>to_lowercase</code> یونیکد
پایه‌ای را مدیریت می‌کند، اما 100٪ دقیق نخواهد بود. اگر ما یک برنامه واقعی می‌نوشتیم،
می‌خواستیم در اینجا کمی بیشتر کار کنیم، اما این بخش درباره متغیرهای محیطی است، نه یونیکد،
بنابراین در اینجا به همین میزان بسنده می‌کنیم.</p>
<p>توجه کنید که اکنون <code>query</code> یک رشته (<code>String</code>) به جای برش رشته (<code>string slice</code>) است، زیرا
فراخوانی <code>to_lowercase</code> داده‌های جدید ایجاد می‌کند به جای اینکه به داده‌های موجود اشاره کند.
به عنوان مثال، بگویید عبارت جستجو <code>"rUsT"</code> است: آن رشته شامل یک <code>u</code> یا <code>t</code> کوچک نیست که بتوانیم
استفاده کنیم، بنابراین باید یک <code>String</code> جدید شامل <code>"rust"</code> تخصیص دهیم. وقتی اکنون <code>query</code> را
به عنوان یک آرگومان به متد <code>contains</code> منتقل می‌کنیم، نیاز داریم که یک علامت <code>&amp;</code> اضافه کنیم
چون امضای <code>contains</code> به گونه‌ای تعریف شده است که یک برش رشته دریافت می‌کند.</p>
<p>بعداً یک فراخوانی به <code>to_lowercase</code> بر روی هر <code>line</code> اضافه می‌کنیم تا همه کاراکترها کوچک‌حرف
شوند. اکنون که <code>line</code> و <code>query</code> را به کوچک‌حرف تبدیل کرده‌ایم، مطمئن می‌شویم که مطابقت‌ها
صرف‌نظر از مورد عبارت جستجو پیدا شوند.</p>
<p>بیایید ببینیم آیا این پیاده‌سازی تست‌ها را پاس می‌کند یا خیر:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>عالی! تست‌ها پاس شدند. حالا بیایید تابع جدید <code>search_case_insensitive</code> را از تابع <code>run</code>
فراخوانی کنیم. ابتدا یک گزینه پیکربندی به ساختار <code>Config</code> اضافه می‌کنیم تا بین جستجوی حساس
به حروف کوچک و بزرگ و غیرحساس به حروف کوچک و بزرگ سوئیچ کنیم. افزودن این فیلد باعث ایجاد
خطاهای کامپایل می‌شود زیرا هنوز این فیلد را در هیچ جا مقداردهی نکرده‌ایم:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We added the <code>ignore_case</code> field that holds a Boolean. Next, we need the <code>run</code>
function to check the <code>ignore_case</code> field’s value and use that to decide
whether to call the <code>search</code> function or the <code>search_case_insensitive</code>
function, as shown in Listing 12-22. This still won’t compile yet.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-22: Calling either <code>search</code> or <code>search_case_insensitive</code> based on the value in <code>config.ignore_case</code></figcaption>
</figure>
<p>توابع مربوط به کار با متغیرهای محیطی در ماژول <code>env</code> در کتابخانه استاندارد قرار دارند. بنابراین در
بالای فایل <em>src/lib.rs</em> این ماژول را وارد محدوده (scope) می‌کنیم. سپس از تابع <code>var</code> از ماژول
<code>env</code> استفاده خواهیم کرد تا بررسی کنیم آیا مقدار خاصی برای یک متغیر محیطی به نام
<code>IGNORE_CASE</code> تنظیم شده است یا خیر، همان‌طور که در لیستینگ 12-23 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 12-23: بررسی مقدار متغیر محیطی با نام <code>IGNORE_CASE</code></figcaption>
</figure>
<p>اینجا یک متغیر جدید به نام <code>ignore_case</code> ایجاد می‌کنیم. برای مقداردهی آن، تابع <code>env::var</code> را
فراخوانی کرده و نام متغیر محیطی <code>IGNORE_CASE</code> را به آن می‌دهیم. تابع <code>env::var</code> یک <code>Result</code>
برمی‌گرداند که در صورت تنظیم بودن متغیر محیطی به هر مقداری، مقدار <code>Ok</code> با مقدار متغیر محیطی را
دارد. اگر متغیر محیطی تنظیم نشده باشد، مقدار <code>Err</code> برگردانده می‌شود.</p>
<p>ما از متد <code>is_ok</code> روی <code>Result</code> استفاده می‌کنیم تا بررسی کنیم که آیا متغیر محیطی تنظیم شده است،
که نشان می‌دهد برنامه باید جستجو را به صورت غیرحساس به حروف کوچک و بزرگ انجام دهد. اگر متغیر
محیطی <code>IGNORE_CASE</code> به هیچ مقداری تنظیم نشده باشد، <code>is_ok</code> مقدار <code>false</code> برمی‌گرداند و برنامه
جستجو را به صورت حساس به حروف کوچک و بزرگ انجام می‌دهد. ما به مقدار متغیر محیطی نیازی نداریم، فقط
می‌خواهیم بررسی کنیم که آیا تنظیم شده است یا نه. بنابراین از <code>is_ok</code> به جای متدهایی مانند
<code>unwrap</code>، <code>expect</code> یا دیگر متدهای مرتبط با <code>Result</code> استفاده می‌کنیم.</p>
<p>ما مقدار متغیر <code>ignore_case</code> را به نمونه <code>Config</code> منتقل می‌کنیم تا تابع <code>run</code> بتواند این مقدار
را بخواند و تصمیم بگیرد که آیا باید تابع <code>search_case_insensitive</code> یا <code>search</code> را فراخوانی کند.</p>
<h3 id="امتحان-کردن-برنامه"><a class="header" href="#امتحان-کردن-برنامه">امتحان کردن برنامه</a></h3>
<p>حالا بیایید برنامه را امتحان کنیم! ابتدا برنامه را بدون تنظیم متغیر محیطی و با عبارت جستجوی
<code>to</code> اجرا می‌کنیم. این عبارت باید با هر خطی که شامل کلمه <em>to</em> به صورت تمام حروف کوچک باشد،
مطابقت داشته باشد:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
</code></pre>
<p>برنامه همچنان باید به درستی کار کند و تنها خطوطی که کاملاً با عبارت مطابقت دارند را برگرداند.
حالا برنامه را با متغیر محیطی <code>IGNORE_CASE</code> که به مقدار <code>1</code> تنظیم شده است اجرا می‌کنیم و
همان عبارت جستجو <em>to</em> را امتحان می‌کنیم:</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>در صورت استفاده از PowerShell، نیاز است که متغیر محیطی را تنظیم کنید و سپس برنامه را به صورت
دستورات جداگانه اجرا کنید:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>این دستور باعث می‌شود که <code>IGNORE_CASE</code> برای مدت زمان نشست ترمینال شما تنظیم باقی بماند. می‌توانید
آن را با دستور <code>Remove-Item</code> حذف کنید:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>برنامه باید خطوطی که شامل <em>to</em> هستند و ممکن است حروف بزرگ داشته باشند را برگرداند:</p>
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>عالی! حالا برنامه <code>minigrep</code> ما می‌تواند جستجوهای غیرحساس به حروف کوچک و بزرگ را انجام دهد که
با یک متغیر محیطی کنترل می‌شود. حالا شما می‌دانید چگونه گزینه‌هایی را که از طریق آرگومان‌های
خط فرمان یا متغیرهای محیطی تنظیم می‌شوند مدیریت کنید.</p>
<p>برخی برنامه‌ها اجازه می‌دهند که آرگومان‌ها و متغیرهای محیطی برای یک پیکربندی واحد استفاده شوند.
در این موارد، برنامه‌ها تصمیم می‌گیرند که یکی از آن‌ها اولویت داشته باشد. برای تمرین بیشتر،
سعی کنید حساسیت به حروف کوچک و بزرگ را از طریق یک آرگومان خط فرمان یا یک متغیر محیطی کنترل کنید.
تصمیم بگیرید که در صورت تنظیم یکی به حساس و دیگری به غیرحساس بودن، آرگومان خط فرمان یا متغیر
محیطی باید اولویت داشته باشد.</p>
<p>ماژول <code>std::env</code> ویژگی‌های مفید بسیاری برای کار با متغیرهای محیطی دارد: مستندات آن را بررسی کنید
تا ببینید چه امکاناتی در دسترس است.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="نوشتن-پیامهای-خطا-به-خروجی-خطای-استاندارد-به-جای-خروجی-استاندارد"><a class="header" href="#نوشتن-پیامهای-خطا-به-خروجی-خطای-استاندارد-به-جای-خروجی-استاندارد">نوشتن پیام‌های خطا به خروجی خطای استاندارد به جای خروجی استاندارد</a></h2>
<p>در حال حاضر، ما تمام خروجی‌های خود را با استفاده از ماکروی <code>println!</code> به ترمینال می‌نویسیم. در بیشتر ترمینال‌ها، دو نوع خروجی وجود دارد: <em>خروجی استاندارد</em> (<code>stdout</code>) برای اطلاعات عمومی و <em>خروجی خطای استاندارد</em> (<code>stderr</code>) برای پیام‌های خطا. این تمایز به کاربران امکان می‌دهد که خروجی موفقیت‌آمیز یک برنامه را به یک فایل هدایت کنند اما همچنان پیام‌های خطا را روی صفحه ببینند.</p>
<p>ماکروی <code>println!</code> فقط قادر به نوشتن در خروجی استاندارد است، بنابراین برای نوشتن به خروجی خطای استاندارد باید از چیزی دیگر استفاده کنیم.</p>
<h3 id="بررسی-محل-نوشتن-خطاها"><a class="header" href="#بررسی-محل-نوشتن-خطاها">بررسی محل نوشتن خطاها</a></h3>
<p>ابتدا بررسی می‌کنیم که محتوای چاپ‌شده توسط <code>minigrep</code> در حال حاضر به خروجی استاندارد نوشته می‌شود، از جمله پیام‌های خطایی که می‌خواهیم به جای آن‌ها در خروجی خطای استاندارد نوشته شوند. این کار را با هدایت جریان خروجی استاندارد به یک فایل و عمداً ایجاد یک خطا انجام خواهیم داد. ما جریان خروجی خطای استاندارد را هدایت نمی‌کنیم، بنابراین هر محتوایی که به خروجی خطای استاندارد ارسال شود همچنان روی صفحه نمایش داده خواهد شد.</p>
<p>برنامه‌های خط فرمان انتظار می‌رود که پیام‌های خطای خود را به جریان خروجی خطای استاندارد ارسال کنند تا در صورت هدایت جریان خروجی استاندارد به یک فایل، پیام‌های خطا همچنان روی صفحه نمایش داده شوند. برنامه ما در حال حاضر به درستی عمل نمی‌کند: ما به زودی خواهیم دید که پیام خطا به جای صفحه نمایش به فایل ذخیره می‌شود!</p>
<p>برای نشان دادن این رفتار، برنامه را با استفاده از دستور <code>&gt;</code> و مسیر فایل <em>output.txt</em> که می‌خواهیم جریان خروجی استاندارد را به آن هدایت کنیم، اجرا می‌کنیم. هیچ آرگومانی ارائه نخواهیم کرد، که باید منجر به یک خطا شود:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>دستور <code>&gt;</code> به شل می‌گوید که محتوای جریان خروجی استاندارد را به <em>output.txt</em> بنویسد به جای اینکه آن را روی صفحه نمایش دهد. ما پیام خطایی که انتظار داشتیم روی صفحه ببینیم را ندیدیم، بنابراین به این معنی است که باید در فایل ذخیره شده باشد. این همان چیزی است که <em>output.txt</em> شامل می‌شود:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>بله، پیام خطای ما به خروجی استاندارد چاپ می‌شود. برای پیام‌های خطایی مانند این بهتر است که به خروجی خطای استاندارد چاپ شوند تا فقط داده‌های حاصل از اجرای موفقیت‌آمیز در فایل قرار گیرند. ما این موضوع را تغییر خواهیم داد.</p>
<h3 id="نوشتن-خطاها-به-خروجی-خطای-استاندارد"><a class="header" href="#نوشتن-خطاها-به-خروجی-خطای-استاندارد">نوشتن خطاها به خروجی خطای استاندارد</a></h3>
<p>ما از کدی که در لیستینگ 12-24 نشان داده شده است برای تغییر نحوه چاپ پیام‌های خطا استفاده می‌کنیم. به دلیل بازسازی‌ای که قبلاً در این فصل انجام دادیم، تمام کدی که پیام‌های خطا را چاپ می‌کند در یک تابع به نام <code>main</code> قرار دارد. کتابخانه استاندارد ماکروی <code>eprintln!</code> را ارائه می‌دهد که به جریان خروجی خطای استاندارد چاپ می‌کند، بنابراین دو جایی که ما <code>println!</code> را برای چاپ خطاها فراخوانی کرده‌ایم را به <code>eprintln!</code> تغییر می‌دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}</code></pre>
<figcaption>Listing 12-24: نوشتن پیام‌های خطا به خروجی خطای استاندارد به جای خروجی استاندارد با استفاده از <code>eprintln!</code></figcaption>
</figure>
<p>حالا برنامه را دوباره اجرا می‌کنیم به همان روش، بدون هیچ آرگومانی و با هدایت خروجی استاندارد با استفاده از <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>حالا خطا را روی صفحه می‌بینیم و <em>output.txt</em> خالی است، که همان رفتاری است که از برنامه‌های خط فرمان انتظار داریم.</p>
<p>برنامه را دوباره اجرا می‌کنیم با آرگومان‌هایی که خطایی ایجاد نمی‌کنند اما همچنان خروجی استاندارد را به یک فایل هدایت می‌کنند، مانند این:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>هیچ خروجی روی ترمینال نخواهیم دید و <em>output.txt</em> شامل نتایج ما خواهد بود:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>این نشان می‌دهد که اکنون از خروجی استاندارد برای خروجی‌های موفقیت‌آمیز و از خروجی خطای استاندارد برای خروجی‌های خطا استفاده می‌کنیم، همان‌طور که مناسب است.</p>
<h2 id="خلاصه-11"><a class="header" href="#خلاصه-11">خلاصه</a></h2>
<p>این فصل به طور خلاصه برخی از مفاهیم اصلی که تاکنون آموخته‌اید را مرور کرد و توضیح داد که چگونه عملیات ورودی/خروجی معمول را در Rust انجام دهید. با استفاده از آرگومان‌های خط فرمان، فایل‌ها، متغیرهای محیطی و ماکروی <code>eprintln!</code> برای چاپ خطاها، شما اکنون آماده‌اید تا برنامه‌های خط فرمان بنویسید. همراه با مفاهیم فصل‌های قبلی، کد شما سازماندهی خوبی خواهد داشت، داده‌ها را به طور مؤثر در ساختارهای داده مناسب ذخیره می‌کند، خطاها را به خوبی مدیریت می‌کند و به خوبی تست شده است.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ویژگیهای-زبانهای-تابعی-تکرارگرها-و-closureها"><a class="header" href="#ویژگیهای-زبانهای-تابعی-تکرارگرها-و-closureها">ویژگی‌های زبان‌های تابعی: تکرارگرها و closureها</a></h1>
<p>طراحی زبان Rust از بسیاری از زبان‌ها و تکنیک‌های موجود الهام گرفته است و یکی از تأثیرات مهم آن
<em>برنامه‌نویسی تابعی</em> است. برنامه‌نویسی به سبک تابعی اغلب شامل استفاده از توابع به عنوان مقادیر
است، از طریق ارسال آن‌ها به عنوان آرگومان، بازگرداندن آن‌ها از دیگر توابع، اختصاص آن‌ها به
متغیرها برای اجرای بعدی و موارد دیگر.</p>
<p>در این فصل، ما بحث نخواهیم کرد که برنامه‌نویسی تابعی چیست یا چه نیست، بلکه به جای آن درباره
برخی از ویژگی‌های Rust که مشابه ویژگی‌های بسیاری از زبان‌هایی است که اغلب به آن‌ها تابعی گفته
می‌شود، صحبت خواهیم کرد.</p>
<p>به طور خاص، ما پوشش خواهیم داد:</p>
<ul dir="rtl">
<li> _closureها_، یک ساختار شبیه به تابع که می‌توان آن را در یک متغیر ذخیره کرد. </li>
<li> _تکرارگرها_، روشی برای پردازش یک سری عناصر. </li>
<li> نحوه استفاده از closureها و تکرارگرها برای بهبود پروژه I/O در فصل 12. </li>
<li> عملکرد closureها و تکرارگرها (هشدار: آن‌ها سریع‌تر از چیزی هستند که ممکن است تصور کنید!) </li>
</ul>
<p>ما قبلاً برخی از ویژگی‌های دیگر Rust، مانند الگوها و enums را پوشش داده‌ایم که همچنین از
سبک تابعی تأثیر گرفته‌اند. از آنجایی که تسلط بر closureها و تکرارگرها بخش مهمی از نوشتن کد
ایدوماکتیک و سریع در Rust است، ما کل این فصل را به آن‌ها اختصاص خواهیم داد.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closureها-توابع-ناشناسی-که-محیط-خود-را-میگیرند"><a class="header" href="#closureها-توابع-ناشناسی-که-محیط-خود-را-میگیرند"> closureها: توابع ناشناسی که محیط خود را می‌گیرند</a></h2>
</div>
<p>closureهای Rust توابع ناشناسی هستند که می‌توانید آن‌ها را در یک متغیر ذخیره کنید یا به عنوان آرگومان به توابع دیگر ارسال کنید. شما می‌توانید closure را در یک مکان ایجاد کنید و سپس آن را در جای دیگری فراخوانی کنید تا در یک زمینه متفاوت ارزیابی شود. برخلاف توابع، closureها می‌توانند مقادیر را از محیطی که در آن تعریف شده‌اند، بگیرند. ما نشان خواهیم داد که چگونه این ویژگی‌های closure امکان استفاده مجدد از کد و سفارشی‌سازی رفتار را فراهم می‌کند.</p>
<!-- عناوین قدیمی. حذف نکنید تا لینک‌ها خراب نشوند. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="گرفتن-محیط-با-closureها"><a class="header" href="#گرفتن-محیط-با-closureها">گرفتن محیط با closureها</a></h3>
<p>ابتدا بررسی خواهیم کرد که چگونه می‌توان از closureها برای گرفتن مقادیر از محیطی که در آن تعریف شده‌اند، برای استفاده در آینده استفاده کرد. سناریوی زیر را در نظر بگیرید: هر چند وقت یک بار، شرکت تی‌شرت ما یک تی‌شرت انحصاری و نسخه محدود به شخصی از لیست پستی خود به عنوان تبلیغ هدیه می‌دهد. افرادی که در لیست پستی هستند می‌توانند به صورت اختیاری رنگ مورد علاقه خود را به پروفایل خود اضافه کنند. اگر شخصی که برای تی‌شرت رایگان انتخاب شده است رنگ مورد علاقه خود را تنظیم کرده باشد، آن رنگ را دریافت می‌کند. اگر شخص رنگ مورد علاقه‌ای مشخص نکرده باشد، رنگی که شرکت بیشترین تعداد آن را دارد، به او داده می‌شود.</p>
<p>راه‌های زیادی برای پیاده‌سازی این سناریو وجود دارد. در این مثال، ما از یک <code>enum</code> به نام <code>ShirtColor</code> استفاده می‌کنیم که شامل مقادیر <code>Red</code> و <code>Blue</code> است (برای سادگی تعداد رنگ‌های موجود را محدود کرده‌ایم). موجودی شرکت را با یک ساختار <code>Inventory</code> نشان می‌دهیم که یک فیلد به نام <code>shirts</code> دارد که یک <code>Vec&lt;ShirtColor&gt;</code> از رنگ‌های تی‌شرت موجود را نشان می‌دهد. متدی به نام <code>giveaway</code> که در <code>Inventory</code> تعریف شده است، اولویت رنگ تی‌شرت کاربر برنده را دریافت کرده و رنگ تی‌شرتی که به آن فرد داده می‌شود را برمی‌گرداند. این تنظیمات در لیستینگ 13-1 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
<figcaption>Listing 13-1: سناریوی هدیه شرکت تی‌شرت</figcaption>
</figure>
<p>در این کد، <code>store</code> تعریف‌شده در <code>main</code> دو تی‌شرت آبی و یک تی‌شرت قرمز باقی‌مانده برای توزیع در این تبلیغ نسخه محدود دارد. ما متد <code>giveaway</code> را برای یک کاربر با ترجیح یک تی‌شرت قرمز و یک کاربر بدون هیچ ترجیحی فراخوانی می‌کنیم.</p>
<p>دوباره تأکید می‌کنیم که این کد را می‌توان به روش‌های مختلفی پیاده‌سازی کرد. در اینجا، برای تمرکز بر closureها، به مفاهیمی که قبلاً آموخته‌اید پایبند مانده‌ایم، به جز بخش بدنه متد <code>giveaway</code> که از یک closure استفاده می‌کند. در متد <code>giveaway</code>، ما اولویت کاربر را به عنوان یک آرگومان از نوع <code>Option&lt;ShirtColor&gt;</code> دریافت می‌کنیم و متد <code>unwrap_or_else</code> را روی <code>user_preference</code> فراخوانی می‌کنیم.</p>
<p>متد <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> روی <code>Option&lt;T&gt;</code></a><!-- ignore --> توسط کتابخانه استاندارد تعریف شده است. این متد یک آرگومان می‌گیرد: یک closure بدون هیچ آرگومانی که یک مقدار <code>T</code> را بازمی‌گرداند (همان نوعی که در متغیر <code>Some</code> از <code>Option&lt;T&gt;</code> ذخیره شده است، در این مورد <code>ShirtColor</code>). اگر <code>Option&lt;T&gt;</code> مقدار <code>Some</code> داشته باشد، <code>unwrap_or_else</code> مقدار داخل <code>Some</code> را بازمی‌گرداند. اگر <code>Option&lt;T&gt;</code> مقدار <code>None</code> باشد، <code>unwrap_or_else</code> closure را فراخوانی کرده و مقداری که closure بازمی‌گرداند را بازمی‌گرداند.</p>
<p>ما عبارت closure <code>|| self.most_stocked()</code> را به عنوان آرگومان به <code>unwrap_or_else</code> ارسال می‌کنیم. این یک closure است که خود هیچ آرگومانی نمی‌گیرد (اگر closure آرگومان‌هایی داشت، آن‌ها بین دو خط عمودی قرار می‌گرفتند). بدنه closure متد <code>self.most_stocked()</code> را فراخوانی می‌کند. ما closure را اینجا تعریف می‌کنیم و پیاده‌سازی <code>unwrap_or_else</code> در صورت نیاز، closure را ارزیابی می‌کند.</p>
<p>اجرای این کد موارد زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>یکی از جنبه‌های جالب در اینجا این است که ما یک closure ارسال کرده‌ایم که متد <code>self.most_stocked()</code> را روی نمونه فعلی <code>Inventory</code> فراخوانی می‌کند. کتابخانه استاندارد نیازی به دانستن چیزی درباره انواع <code>Inventory</code> یا <code>ShirtColor</code> که تعریف کرده‌ایم یا منطقی که می‌خواهیم در این سناریو استفاده کنیم، ندارد. closure یک ارجاع غیرقابل تغییر به نمونه <code>self</code> از <code>Inventory</code> را می‌گیرد و آن را همراه با کدی که مشخص کرده‌ایم به متد <code>unwrap_or_else</code> ارسال می‌کند. از طرف دیگر، توابع قادر به گرفتن محیط خود به این صورت نیستند.</p>
<h3 id="استنباط-نوع-closure-و-حاشیهنویسی"><a class="header" href="#استنباط-نوع-closure-و-حاشیهنویسی">استنباط نوع closure و حاشیه‌نویسی</a></h3>
<p>تفاوت‌های بیشتری بین توابع و closureها وجود دارد. closureها معمولاً نیازی به حاشیه‌نویسی انواع آرگومان‌ها یا مقدار بازگشتی ندارند، برخلاف توابع <code>fn</code> که به این حاشیه‌نویسی نیاز دارند. حاشیه‌نویسی انواع در توابع ضروری است زیرا این انواع بخشی از رابط کاربری صریحی هستند که برای کاربران شما ارائه می‌شود. تعریف این رابط به صورت سختگیرانه برای اطمینان از توافق همه در مورد انواع مقادیر استفاده شده و بازگشتی یک تابع مهم است. از طرف دیگر، closureها به این صورت در یک رابط کاربری صریح استفاده نمی‌شوند: آن‌ها در متغیرها ذخیره می‌شوند و بدون نام‌گذاری و افشای آن‌ها به کاربران کتابخانه ما استفاده می‌شوند.</p>
<div dir="rtl">
closureها معمولاً کوتاه هستند و فقط در یک زمینه محدود مرتبط هستند، نه در هر سناریوی دلخواه. در این زمینه‌های محدود، کامپایلر می‌تواند انواع پارامترها و مقدار بازگشتی را استنباط کند، مشابه آنچه که می‌تواند انواع اکثر متغیرها را استنباط کند (موارد نادری وجود دارند که کامپایلر به حاشیه‌نویسی نوع closure نیز نیاز دارد).
</div>
<br>
همانند متغیرها، ما می‌توانیم حاشیه‌نویسی نوع اضافه کنیم اگر بخواهیم وضوح و شفافیت را افزایش دهیم، به قیمت پرحرف‌تر شدن از آنچه که به طور دقیق ضروری است. افزودن حاشیه‌نویسی نوع برای یک closure به این صورت است که در لیستینگ 13-2 نشان داده شده است. در این مثال، ما یک closure تعریف کرده و آن را در یک متغیر ذخیره می‌کنیم، به جای اینکه closure را در مکانی که به عنوان آرگومان ارسال می‌کنیم تعریف کنیم، همانطور که در لیستینگ 13-1 انجام دادیم.
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 13-2: افزودن حاشیه‌نویسی‌های اختیاری برای انواع آرگومان‌ها و مقدار بازگشتی در closure</figcaption>
</figure>
<p>با اضافه کردن حاشیه‌نویسی نوع، نحوه نوشتن closureها بیشتر شبیه به نوشتن توابع می‌شود. در اینجا، ما یک تابع تعریف کرده‌ایم که 1 به آرگومان خود اضافه می‌کند و یک closure که همان رفتار را دارد، برای مقایسه. ما فضاهایی اضافه کرده‌ایم تا بخش‌های مرتبط را هم‌ردیف کنیم. این نشان می‌دهد که نحو closure چقدر شبیه به نحو توابع است، به جز استفاده از خطوط عمودی و میزان نحوی که اختیاری است.</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>خط اول تعریف یک تابع را نشان می‌دهد، و خط دوم تعریف یک closure با حاشیه‌نویسی کامل را نمایش می‌دهد. در خط سوم، حاشیه‌نویسی انواع از تعریف closure حذف شده است. در خط چهارم، براکت‌ها را حذف می‌کنیم، که اختیاری هستند زیرا بدنه closure فقط یک عبارت دارد. همه این‌ها تعاریف معتبری هستند که هنگام فراخوانی رفتار یکسانی تولید می‌کنند. خطوط <code>add_one_v3</code> و <code>add_one_v4</code> نیاز دارند که closureها ارزیابی شوند تا کامپایل شوند زیرا انواع از نحوه استفاده آن‌ها استنباط خواهند شد. این مشابه با <code>let v = Vec::new();</code> است که نیاز دارد یا حاشیه‌نویسی نوع داشته باشد یا مقادیر از نوعی در <code>Vec</code> وارد شوند تا Rust بتواند نوع را استنباط کند.</p>
<p>برای تعریف closureها، کامپایلر یک نوع مشخص برای هر یک از پارامترها و مقدار بازگشتی آن‌ها استنباط می‌کند. برای مثال، لیستینگ 13-3 تعریف یک closure کوتاه را نشان می‌دهد که فقط مقداری که به عنوان پارامتر دریافت می‌کند را بازمی‌گرداند. این closure برای اهداف این مثال استفاده چندانی ندارد. توجه کنید که هیچ حاشیه‌نویسی نوعی به تعریف اضافه نکرده‌ایم. چون هیچ حاشیه‌نویسی وجود ندارد، می‌توانیم closure را با هر نوعی فراخوانی کنیم، همان‌طور که اولین بار این کار را با <code>String</code> انجام دادیم. اگر سپس سعی کنیم <code>example_closure</code> را با یک عدد صحیح فراخوانی کنیم، خطایی دریافت خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<figcaption>Listing 13-3: تلاش برای فراخوانی یک closure که انواع آن با استفاده از دو نوع مختلف استنباط شده است</figcaption>
</figure>
<p>کامپایلر این خطا را می‌دهد:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>اولین باری که <code>example_closure</code> را با مقدار <code>String</code> فراخوانی می‌کنیم، کامپایلر نوع <code>x</code> و مقدار بازگشتی closure را به عنوان <code>String</code> استنباط می‌کند. سپس این انواع در closure <code>example_closure</code> قفل می‌شوند و هنگام تلاش برای استفاده از یک نوع دیگر با همان closure، یک خطای نوع دریافت می‌کنیم.</p>
<h3 id="گرفتن-ارجاعات-یا-انتقال-مالکیت"><a class="header" href="#گرفتن-ارجاعات-یا-انتقال-مالکیت">گرفتن ارجاعات یا انتقال مالکیت</a></h3>
<p>closureها می‌توانند مقادیر را از محیط خود به سه روش بگیرند که مستقیماً به سه روشی که یک تابع می‌تواند یک پارامتر بگیرد، نگاشت می‌شوند: قرض‌گیری غیرقابل تغییر، قرض‌گیری قابل تغییر، و گرفتن مالکیت. closure تصمیم می‌گیرد که کدام یک از این‌ها را بر اساس کاری که بدنه تابع با مقادیر گرفته شده انجام می‌دهد، استفاده کند.</p>
<p>در لیستینگ 13-4، یک closure تعریف می‌کنیم که یک ارجاع غیرقابل تغییر به بردار با نام <code>list</code> را می‌گیرد زیرا فقط به یک ارجاع غیرقابل تغییر نیاز دارد تا مقدار را چاپ کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption>Listing 13-4: تعریف و فراخوانی یک closure که یک ارجاع غیرقابل تغییر می‌گیرد</figcaption>
</figure>
<p>این مثال همچنین نشان می‌دهد که یک متغیر می‌تواند به تعریف یک closure متصل شود و بعداً می‌توان closure را با استفاده از نام متغیر و پرانتزها فراخوانی کرد، گویی که نام متغیر یک نام تابع است.</p>
<p>از آنجا که می‌توانیم چندین ارجاع غیرقابل تغییر به <code>list</code> به طور همزمان داشته باشیم، <code>list</code> همچنان از کدی که قبل از تعریف closure، بعد از تعریف closure اما قبل از فراخوانی closure و بعد از فراخوانی closure وجود دارد، قابل دسترسی است. این کد کامپایل شده، اجرا می‌شود و نتیجه زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-04)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>در ادامه، در لیستینگ 13-5، بدنه closure را تغییر می‌دهیم تا یک عنصر به بردار <code>list</code> اضافه کند. closure اکنون یک ارجاع قابل تغییر می‌گیرد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption>Listing 13-5: تعریف و فراخوانی یک closure که یک ارجاع قابل تغییر می‌گیرد</figcaption>
</figure>
<p>این کد کامپایل شده، اجرا می‌شود و نتیجه زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-05)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>توجه داشته باشید که دیگر <code>println!</code> بین تعریف و فراخوانی closure <code>borrows_mutably</code> وجود ندارد: زمانی که <code>borrows_mutably</code> تعریف می‌شود، یک ارجاع قابل تغییر به <code>list</code> می‌گیرد. ما بعد از فراخوانی closure دوباره از آن استفاده نمی‌کنیم، بنابراین قرض‌گیری قابل تغییر پایان می‌یابد. بین تعریف closure و فراخوانی آن، قرض‌گیری غیرقابل تغییر برای چاپ مجاز نیست، زیرا هیچ قرض دیگری هنگام وجود یک قرض قابل تغییر مجاز نیست. سعی کنید یک <code>println!</code> در آنجا اضافه کنید تا ببینید چه پیام خطایی دریافت می‌کنید!</p>
<p>اگر بخواهید closure را مجبور کنید که مالکیت مقادیر استفاده‌شده در محیط را بگیرد، حتی اگر بدنه closure به طور دقیق به مالکیت نیاز نداشته باشد، می‌توانید از کلیدواژه <code>move</code> قبل از لیست پارامترها استفاده کنید.</p>
<p>این تکنیک بیشتر زمانی مفید است که یک closure را به یک نخ جدید ارسال می‌کنید تا داده‌ها به گونه‌ای انتقال داده شوند که توسط نخ جدید مالکیت پیدا کنند. ما موضوع نخ‌ها و دلایلی که ممکن است بخواهید از آن‌ها استفاده کنید را به تفصیل در فصل 16 زمانی که در مورد هم‌زمانی صحبت می‌کنیم، بررسی خواهیم کرد. اما برای حالا، بیایید به صورت مختصر ایجاد یک نخ جدید با استفاده از یک closure که به کلیدواژه <code>move</code> نیاز دارد را بررسی کنیم. لیستینگ 13-6 لیستینگ 13-4 را اصلاح می‌کند تا بردار را در یک نخ جدید چاپ کند به جای اینکه در نخ اصلی این کار را انجام دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<figcaption>Listing 13-6: استفاده از <code>move</code> برای مجبور کردن closure به گرفتن مالکیت <code>list</code> برای نخ</figcaption>
</figure>
<p>ما یک نخ جدید ایجاد می‌کنیم و به نخ یک closure می‌دهیم تا به عنوان آرگومان اجرا شود. بدنه closure لیست را چاپ می‌کند. در لیستینگ 13-4، closure فقط با استفاده از یک ارجاع غیرقابل تغییر <code>list</code> را گرفت زیرا این کمترین دسترسی مورد نیاز برای چاپ <code>list</code> بود. در این مثال، اگرچه بدنه closure هنوز فقط به یک ارجاع غیرقابل تغییر نیاز دارد، باید مشخص کنیم که <code>list</code> باید به داخل closure منتقل شود. این کار را با قرار دادن کلمه کلیدی <code>move</code> در ابتدای تعریف closure انجام می‌دهیم.</p>
<p>نخ جدید ممکن است قبل از تکمیل نخ اصلی تمام شود، یا نخ اصلی ممکن است زودتر تمام شود. اگر نخ اصلی مالکیت <code>list</code> را حفظ می‌کرد اما قبل از نخ جدید به پایان می‌رسید و <code>list</code> را حذف می‌کرد، ارجاع غیرقابل تغییر در نخ دیگر معتبر نبود. بنابراین، کامپایلر نیاز دارد که <code>list</code> به داخل closure داده‌شده به نخ جدید منتقل شود تا ارجاع معتبر باقی بماند. سعی کنید کلمه کلیدی <code>move</code> را حذف کنید یا از <code>list</code> در نخ اصلی پس از تعریف closure استفاده کنید تا ببینید چه خطاهای کامپایلری دریافت می‌کنید!</p>
<!-- عناوین قدیمی. حذف نکنید تا لینک‌ها خراب نشوند. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="انتقال-مقادیر-گرفتهشده-به-خارج-از-closureها-و-صفات-fn"><a class="header" href="#انتقال-مقادیر-گرفتهشده-به-خارج-از-closureها-و-صفات-fn">انتقال مقادیر گرفته‌شده به خارج از closureها و صفات <code>Fn</code></a></h3>
<p>پس از اینکه یک closure ارجاعی را گرفت یا مالکیت مقداری را از محیطی که closure در آن تعریف شده است دریافت کرد (و به این ترتیب تعیین کرد چه چیزی، اگر وجود داشته باشد، به <em>داخل</em> closure منتقل شود)، کد در بدنه closure مشخص می‌کند که چه اتفاقی برای ارجاعات یا مقادیر هنگام ارزیابی closure در آینده می‌افتد (و به این ترتیب تعیین می‌کند چه چیزی، اگر وجود داشته باشد، به <em>خارج از</em> closure منتقل شود). بدنه یک closure می‌تواند هر یک از موارد زیر را انجام دهد:</p>
<ul dir="rtl">
  <li>انتقال یک مقدار گرفته‌شده به خارج از closure،</li>
  <li>تغییر مقدار گرفته‌شده،</li>
  <li>نه انتقال و نه تغییر مقدار،</li>
  <li>یا از ابتدا هیچ چیزی از محیط نگرفتن.</li>
</ul>
<p>نحوه گرفتن و مدیریت مقادیر توسط closure از محیط مشخص می‌کند که closure کدام صفات را پیاده‌سازی می‌کند. صفات روشی هستند که توابع و ساختارها می‌توانند مشخص کنند از چه نوع closureهایی می‌توانند استفاده کنند. closureها به صورت خودکار یکی، دو یا هر سه این صفات <code>Fn</code> را پیاده‌سازی می‌کنند، به صورت افزایشی، بسته به نحوه مدیریت مقادیر توسط بدنه closure:</p>
<ol dir="rtl">
  <li>
    <code>FnOnce</code>: برای closureهایی که می‌توانند فقط یک بار فراخوانی شوند اعمال می‌شود. همه closureها حداقل این صفت را پیاده‌سازی می‌کنند، زیرا همه closureها قابل فراخوانی هستند. closureی که مقادیر گرفته‌شده را از بدنه خود انتقال می‌دهد فقط صفت <code>FnOnce</code> را پیاده‌سازی می‌کند و هیچ‌یک از دیگر صفات <code>Fn</code> را پیاده‌سازی نمی‌کند، زیرا فقط یک بار قابل فراخوانی است.
  </li>
  <li>
    <code>FnMut</code>: برای closureهایی که مقادیر گرفته‌شده را از بدنه خود انتقال نمی‌دهند اما ممکن است مقادیر گرفته‌شده را تغییر دهند اعمال می‌شود. این closureها می‌توانند بیش از یک بار فراخوانی شوند.
  </li>
  <li>
    <code>Fn</code>: برای closureهایی که مقادیر گرفته‌شده را از بدنه خود انتقال نمی‌دهند و مقادیر گرفته‌شده را تغییر نمی‌دهند، همچنین closureهایی که هیچ چیزی از محیط نمی‌گیرند اعمال می‌شود. این closureها می‌توانند بیش از یک بار بدون تغییر محیط خود فراخوانی شوند، که در مواردی مانند فراخوانی یک closure به طور همزمان چندین بار مهم است.
  </li>
</ol>
<p>بیایید تعریف متد <code>unwrap_or_else</code> در <code>Option&lt;T&gt;</code> را که در لیستینگ 13-1 استفاده کردیم بررسی کنیم:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>به یاد داشته باشید که <code>T</code> نوع جنریک است که نوع مقدار موجود در واریانت <code>Some</code> از <code>Option</code> را نشان می‌دهد. این نوع <code>T</code> همچنین نوع بازگشتی تابع <code>unwrap_or_else</code> است: به عنوان مثال، کدی که <code>unwrap_or_else</code> را روی یک <code>Option&lt;String&gt;</code> فراخوانی می‌کند، یک <code>String</code> دریافت خواهد کرد.</p>
<p>بعدی، توجه داشته باشید که تابع <code>unwrap_or_else</code> پارامتر نوع جنریک اضافی <code>F</code> را دارد. نوع <code>F</code> نوع پارامتر نام‌گذاری‌شده <code>f</code> است، که closureی است که هنگام فراخوانی <code>unwrap_or_else</code> ارائه می‌دهیم.</p>
<p>محدودیت صفت مشخص‌شده روی نوع جنریک <code>F</code>، <code>FnOnce() -&gt; T</code> است، که به این معناست که <code>F</code> باید بتواند یک بار فراخوانی شود، هیچ آرگومانی نگیرد و یک <code>T</code> بازگرداند. استفاده از <code>FnOnce</code> در محدودیت صفت، محدودیت این موضوع را بیان می‌کند که <code>unwrap_or_else</code> حداکثر یک بار <code>f</code> را فراخوانی خواهد کرد. در بدنه <code>unwrap_or_else</code>، می‌بینیم که اگر <code>Option</code> برابر با <code>Some</code> باشد، <code>f</code> فراخوانی نمی‌شود. اگر <code>Option</code> برابر با <code>None</code> باشد، <code>f</code> یک بار فراخوانی خواهد شد. از آنجایی که تمام closureها <code>FnOnce</code> را پیاده‌سازی می‌کنند، <code>unwrap_or_else</code> همه انواع سه‌گانه closureها را می‌پذیرد و به اندازه کافی انعطاف‌پذیر است.</p>
<blockquote>
<p>نکته: اگر کاری که می‌خواهیم انجام دهیم نیاز به گرفتن مقداری از محیط نداشته باشد، می‌توانیم به جای closure از نام یک تابع استفاده کنیم. به عنوان مثال، می‌توانیم <code>unwrap_or_else(Vec::new)</code> را روی یک مقدار <code>Option&lt;Vec&lt;T&gt;&gt;</code> فراخوانی کنیم تا اگر مقدار <code>None</code> بود، یک وکتور جدید و خالی دریافت کنیم. کامپایلر به طور خودکار هر کدام از صفات <code>Fn</code> که برای تعریف تابع کاربرد دارد را پیاده‌سازی می‌کند.</p>
</blockquote>
<p>اکنون بیایید به متد استاندارد کتابخانه <code>sort_by_key</code> که روی برش‌ها (slices) تعریف شده است نگاهی بیندازیم تا ببینیم چگونه با <code>unwrap_or_else</code> متفاوت است و چرا <code>sort_by_key</code> به جای <code>FnOnce</code> از <code>FnMut</code> برای محدودیت صفت استفاده می‌کند. closure یک آرگومان به شکل یک ارجاع به آیتم جاری در برشی که در نظر گرفته می‌شود می‌گیرد و یک مقدار از نوع <code>K</code> را که قابل مرتب‌سازی است بازمی‌گرداند. این تابع زمانی مفید است که بخواهید یک برش را بر اساس ویژگی خاصی از هر آیتم مرتب کنید. در لیست 13-7، ما لیستی از نمونه‌های <code>Rectangle</code> داریم و از <code>sort_by_key</code> برای مرتب کردن آن‌ها بر اساس ویژگی <code>width</code> از کم به زیاد استفاده می‌کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<figcaption>Listing 13-7: استفاده از <code>sort_by_key</code> برای مرتب‌سازی مستطیل‌ها بر اساس عرض</figcaption>
</figure>
<p>این کد خروجی زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>دلیل اینکه <code>sort_by_key</code> به گونه‌ای تعریف شده که یک closure <code>FnMut</code> بگیرد این است که closure را چندین بار فراخوانی می‌کند: یک بار برای هر آیتم در برش. closure <code>|r| r.width</code> چیزی را از محیط خود نمی‌گیرد، تغییر نمی‌دهد یا منتقل نمی‌کند، بنابراین با الزامات محدودیت صفت مطابقت دارد.</p>
<p>در مقابل، لیست 13-8 مثالی از closureی را نشان می‌دهد که فقط صفت <code>FnOnce</code> را پیاده‌سازی می‌کند، زیرا مقداری را از محیط منتقل می‌کند. کامپایلر اجازه نمی‌دهد از این closure با <code>sort_by_key</code> استفاده کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
<figcaption>Listing 13-8: تلاش برای استفاده از closure <code>FnOnce</code> با <code>sort_by_key</code></figcaption>
</figure>
<p>این یک روش مصنوعی و پیچیده (که کار نمی‌کند) برای تلاش در شمارش تعداد دفعاتی است که <code>sort_by_key</code> closure را هنگام مرتب کردن <code>list</code> فراخوانی می‌کند. این کد سعی می‌کند این شمارش را با افزودن <code>value</code>—یک <code>String</code> از محیط closure—به وکتور <code>sort_operations</code> انجام دهد. closure، <code>value</code> را می‌گیرد و سپس با انتقال مالکیت <code>value</code> به وکتور <code>sort_operations</code>، <code>value</code> را از closure منتقل می‌کند. این closure فقط یک بار می‌تواند فراخوانی شود؛ تلاش برای فراخوانی آن برای بار دوم کار نمی‌کند زیرا <code>value</code> دیگر در محیط وجود ندارد که دوباره به <code>sort_operations</code> اضافه شود! بنابراین، این closure فقط صفت <code>FnOnce</code> را پیاده‌سازی می‌کند. وقتی سعی می‌کنیم این کد را کامپایل کنیم، این خطا دریافت می‌شود که <code>value</code> نمی‌تواند از closure منتقل شود، زیرا closure باید <code>FnMut</code> را پیاده‌سازی کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>این خطا به خطی در بدنه closure اشاره می‌کند که <code>value</code> را از محیط منتقل می‌کند. برای رفع این مشکل، باید بدنه closure را تغییر دهیم تا مقادیر را از محیط منتقل نکند. برای شمارش تعداد دفعاتی که closure فراخوانی می‌شود، نگه داشتن یک شمارنده در محیط و افزایش مقدار آن در بدنه closure روشی ساده‌تر برای محاسبه آن است. closure در لیست 13-9 با <code>sort_by_key</code> کار می‌کند زیرا فقط یک ارجاع قابل تغییر به شمارنده <code>num_sort_operations</code> را می‌گیرد و بنابراین می‌تواند بیش از یک بار فراخوانی شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
<figcaption>Listing 13-9: استفاده از یک closure <code>FnMut</code> با <code>sort_by_key</code> مجاز است</figcaption>
</figure>
<p>صفات <code>Fn</code> هنگام تعریف یا استفاده از توابع یا انواعی که از closureها استفاده می‌کنند، مهم هستند. در بخش بعدی، ما درباره iteratorها بحث خواهیم کرد. بسیاری از متدهای iterator آرگومان‌های closure می‌گیرند، بنابراین این جزئیات closure را هنگام ادامه مطالعه در نظر داشته باشید!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="پردازش-یک-سری-از-آیتمها-با-استفاده-از-iteratorها"><a class="header" href="#پردازش-یک-سری-از-آیتمها-با-استفاده-از-iteratorها">پردازش یک سری از آیتم‌ها با استفاده از Iteratorها</a></h2>
<p>الگوی iterator به شما اجازه می‌دهد تا به ترتیب روی یک دنباله از آیتم‌ها کاری انجام دهید. یک iterator مسئول منطق پیمایش هر آیتم و تعیین زمان پایان دنباله است. وقتی از iteratorها استفاده می‌کنید، نیازی به پیاده‌سازی مجدد آن منطق ندارید.</p>
<p>در Rust، iteratorها <em>تنبل</em> هستند، به این معنی که تا زمانی که متدهایی که iterator را مصرف می‌کنند فراخوانی نشوند، هیچ اثری ندارند. به عنوان مثال، کد در لیست 13-10 یک iterator را بر روی آیتم‌های وکتور <code>v1</code> با فراخوانی متد <code>iter</code> که روی <code>Vec&lt;T&gt;</code> تعریف شده است، ایجاد می‌کند. این کد به تنهایی هیچ کار مفیدی انجام نمی‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 13-10: ایجاد یک iterator</figcaption>
</figure>
<p>این iterator در متغیر <code>v1_iter</code> ذخیره شده است. پس از ایجاد یک iterator، می‌توانیم از آن به روش‌های مختلف استفاده کنیم. در لیست 3-5 از فصل 3، ما روی یک آرایه با استفاده از یک حلقه <code>for</code> تکرار کردیم تا کدی را روی هر یک از آیتم‌های آن اجرا کنیم. در پشت صحنه، این کار به طور ضمنی یک iterator ایجاد و سپس مصرف می‌کرد، اما تا کنون دقیقاً توضیح ندادیم که چگونه کار می‌کند.</p>
<p>در مثال لیست 13-11، ما ایجاد iterator را از استفاده از آن در حلقه <code>for</code> جدا می‌کنیم. وقتی حلقه <code>for</code> با استفاده از iterator در <code>v1_iter</code> فراخوانی می‌شود، هر عنصر در iterator در یک تکرار از حلقه استفاده می‌شود، که هر مقدار را چاپ می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 13-11: استفاده از یک iterator در حلقه <code>for</code></figcaption>
</figure>
<p>در زبان‌هایی که iteratorها توسط کتابخانه استاندارد آن‌ها ارائه نمی‌شوند، احتمالاً همین عملکرد را با شروع یک متغیر در شاخص 0، استفاده از آن متغیر برای شاخص‌گذاری در وکتور برای دریافت یک مقدار و افزایش مقدار متغیر در یک حلقه تا زمانی که به تعداد کل آیتم‌ها در وکتور برسد، می‌نوشتید.</p>
<p>iteratorها تمام این منطق را برای شما مدیریت می‌کنند و کدهای تکراری را که ممکن است اشتباه کنید کاهش می‌دهند. iteratorها به شما انعطاف بیشتری می‌دهند تا از همان منطق با انواع مختلف دنباله‌ها استفاده کنید، نه فقط ساختارهای داده‌ای که می‌توان به آن‌ها شاخص زد، مانند وکتورها. بیایید بررسی کنیم که iteratorها چگونه این کار را انجام می‌دهند.</p>
<h3 id="صفت-iterator-و-متد-next"><a class="header" href="#صفت-iterator-و-متد-next">صفت <code>Iterator</code> و متد <code>next</code></a></h3>
<p>همه iteratorها یک صفت به نام <code>Iterator</code> را پیاده‌سازی می‌کنند که در کتابخانه استاندارد تعریف شده است. تعریف این صفت به صورت زیر است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // متدهایی با پیاده‌سازی پیش‌فرض حذف شده‌اند
}
<span class="boring">}</span></code></pre></pre>
<p>توجه کنید که این تعریف از یک نحو جدید استفاده می‌کند: <code>type Item</code> و <code>Self::Item</code>، که یک <em>نوع مرتبط</em> را با این صفت تعریف می‌کنند. ما در فصل 20 به طور مفصل درباره انواع مرتبط صحبت خواهیم کرد. فعلاً فقط باید بدانید که این کد می‌گوید پیاده‌سازی صفت <code>Iterator</code> نیاز دارد که شما یک نوع <code>Item</code> نیز تعریف کنید، و این نوع <code>Item</code> در نوع بازگشتی متد <code>next</code> استفاده می‌شود. به عبارت دیگر، نوع <code>Item</code> همان نوعی خواهد بود که از iterator بازگردانده می‌شود.</p>
<p>صفت <code>Iterator</code> فقط از پیاده‌کنندگان می‌خواهد یک متد را تعریف کنند: متد <code>next</code>، که یک آیتم از iterator را در هر زمان بازمی‌گرداند، که در <code>Some</code> بسته‌بندی شده است، و وقتی پیمایش تمام شد، <code>None</code> بازمی‌گرداند.</p>
<p>ما می‌توانیم مستقیماً متد <code>next</code> را روی iteratorها فراخوانی کنیم؛ لیست 13-12 نشان می‌دهد چه مقادیری از فراخوانی‌های مکرر <code>next</code> روی iterator ایجادشده از وکتور بازگردانده می‌شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<figcaption>Listing 13-12: فراخوانی متد <code>next</code> روی یک iterator</figcaption>
</figure>
<p>توجه کنید که ما نیاز داشتیم <code>v1_iter</code> را قابل تغییر (mutable) کنیم: فراخوانی متد <code>next</code> روی یک iterator، وضعیت داخلی را تغییر می‌دهد که iterator از آن برای ردیابی موقعیت خود در دنباله استفاده می‌کند. به عبارت دیگر، این کد iterator را <em>مصرف</em> می‌کند یا از بین می‌برد. هر فراخوانی به <code>next</code> یک آیتم از iterator را مصرف می‌کند. نیازی نبود <code>v1_iter</code> را هنگام استفاده از یک حلقه <code>for</code> قابل تغییر کنیم، زیرا حلقه مالکیت <code>v1_iter</code> را به عهده گرفت و به طور پنهانی آن را قابل تغییر کرد.</p>
<p>همچنین توجه کنید که مقادیری که از فراخوانی‌های <code>next</code> دریافت می‌کنیم، ارجاعات غیرقابل تغییر به مقادیر موجود در وکتور هستند. متد <code>iter</code> یک iterator روی ارجاعات غیرقابل تغییر تولید می‌کند. اگر بخواهیم یک iterator ایجاد کنیم که مالکیت <code>v1</code> را بگیرد و مقادیر مالک‌شده را بازگرداند، می‌توانیم به جای <code>iter</code>، <code>into_iter</code> را فراخوانی کنیم. به همین ترتیب، اگر بخواهیم روی ارجاعات قابل تغییر پیمایش کنیم، می‌توانیم به جای <code>iter</code>، <code>iter_mut</code> را فراخوانی کنیم.</p>
<h3 id="متدهایی-که-iterator-را-مصرف-میکنند"><a class="header" href="#متدهایی-که-iterator-را-مصرف-میکنند">متدهایی که Iterator را مصرف می‌کنند</a></h3>
<p>صفت <code>Iterator</code> تعداد زیادی متد مختلف با پیاده‌سازی‌های پیش‌فرض ارائه‌شده توسط کتابخانه استاندارد دارد؛ می‌توانید درباره این متدها با نگاه کردن به مستندات API کتابخانه استاندارد برای صفت <code>Iterator</code> اطلاعات بیشتری کسب کنید. برخی از این متدها در تعریف خود متد <code>next</code> را فراخوانی می‌کنند، به همین دلیل است که شما باید متد <code>next</code> را هنگام پیاده‌سازی صفت <code>Iterator</code> تعریف کنید.</p>
<p>متدهایی که <code>next</code> را فراخوانی می‌کنند، <em>تطبیق‌دهنده‌های مصرفی</em> نامیده می‌شوند، زیرا فراخوانی آن‌ها iterator را مصرف می‌کند. یک مثال، متد <code>sum</code> است که مالکیت iterator را به عهده می‌گیرد و با فراخوانی مکرر <code>next</code>، از میان آیتم‌ها عبور می‌کند، بنابراین iterator را مصرف می‌کند. هنگام عبور، هر آیتم را به یک مجموع در حال اجرا اضافه می‌کند و وقتی پیمایش کامل شد، مجموع را بازمی‌گرداند. لیست 13-13 یک تست را نشان می‌دهد که استفاده از متد <code>sum</code> را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<figcaption>Listing 13-13: فراخوانی متد <code>sum</code> برای گرفتن مجموع همه آیتم‌ها در iterator</figcaption>
</figure>
<p>ما اجازه نداریم پس از فراخوانی متد <code>sum</code> از <code>v1_iter</code> استفاده کنیم، زیرا <code>sum</code> مالکیت iteratorی که روی آن فراخوانی می‌شود را به عهده می‌گیرد.</p>
<h3 id="متدهایی-که-iteratorهای-دیگری-تولید-میکنند"><a class="header" href="#متدهایی-که-iteratorهای-دیگری-تولید-میکنند">متدهایی که Iteratorهای دیگری تولید می‌کنند</a></h3>
<p><em>تطبیق‌دهنده‌های Iterator</em> متدهایی هستند که روی صفت <code>Iterator</code> تعریف شده‌اند و iterator را مصرف نمی‌کنند. در عوض، آن‌ها با تغییر برخی جنبه‌های iterator اصلی، iteratorهای متفاوتی تولید می‌کنند.</p>
<p>لیست 13-14 مثالی از فراخوانی متد تطبیق‌دهنده iterator به نام <code>map</code> را نشان می‌دهد که یک closure را برای فراخوانی روی هر آیتم هنگام پیمایش از میان آیتم‌ها می‌گیرد. متد <code>map</code> یک iterator جدید بازمی‌گرداند که آیتم‌های تغییر یافته را تولید می‌کند. closure در اینجا یک iterator جدید ایجاد می‌کند که در آن هر آیتم از وکتور ۱ واحد افزایش می‌یابد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 13-14: فراخوانی تطبیق‌دهنده iterator <code>map</code> برای ایجاد یک iterator جدید</figcaption>
</figure>
<p>با این حال، این کد یک هشدار تولید می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>کد در لیست 13-14 هیچ کاری انجام نمی‌دهد؛ closureی که مشخص کرده‌ایم هرگز فراخوانی نمی‌شود. این هشدار به ما یادآوری می‌کند چرا: تطبیق‌دهنده‌های iterator تنبل هستند و ما باید iterator را در اینجا مصرف کنیم.</p>
<p>برای رفع این هشدار و مصرف iterator، از متد <code>collect</code> استفاده می‌کنیم، که در فصل 12 با <code>env::args</code> در لیست 12-1 استفاده کردیم. این متد iterator را مصرف کرده و مقادیر حاصل را در یک نوع داده مجموعه جمع‌آوری می‌کند.</p>
<p>در لیست 13-15، نتایج پیمایش بر روی iterator بازگردانده‌شده از فراخوانی <code>map</code> را در یک وکتور جمع‌آوری می‌کنیم. این وکتور در نهایت شامل هر آیتم از وکتور اصلی با افزایش ۱ واحد خواهد بود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 13-15: فراخوانی متد <code>map</code> برای ایجاد یک iterator جدید و سپس فراخوانی متد <code>collect</code> برای مصرف iterator جدید و ایجاد یک وکتور</figcaption>
</figure>
<p>از آنجا که <code>map</code> یک closure می‌گیرد، می‌توانیم هر عملیاتی را که می‌خواهیم روی هر آیتم انجام دهیم مشخص کنیم. این مثال بسیار خوبی است از اینکه چگونه closureها به شما اجازه می‌دهند تا برخی رفتارها را سفارشی کنید در حالی که از رفتار پیمایشی که صفت <code>Iterator</code> فراهم می‌کند استفاده مجدد می‌کنید.</p>
<p>می‌توانید چندین فراخوانی به تطبیق‌دهنده‌های iterator را زنجیره کنید تا اقدامات پیچیده‌ای را به شکلی خوانا انجام دهید. اما از آنجا که همه iteratorها تنبل هستند، باید یکی از متدهای تطبیق‌دهنده مصرفی را برای گرفتن نتایج از فراخوانی تطبیق‌دهنده‌های iterator فراخوانی کنید.</p>
<h3 id="استفاده-از-closureهایی-که-محیط-خود-را-میگیرند"><a class="header" href="#استفاده-از-closureهایی-که-محیط-خود-را-میگیرند">استفاده از closureهایی که محیط خود را می‌گیرند</a></h3>
<p>بسیاری از تطبیق‌دهنده‌های iterator closureها را به عنوان آرگومان می‌پذیرند، و معمولاً closureهایی که به عنوان آرگومان به تطبیق‌دهنده‌های iterator مشخص می‌کنیم closureهایی هستند که محیط خود را می‌گیرند.</p>
<p>برای این مثال، از متد <code>filter</code> استفاده خواهیم کرد که یک closure می‌گیرد. closure یک آیتم از iterator دریافت کرده و یک مقدار <code>bool</code> بازمی‌گرداند. اگر closure مقدار <code>true</code> بازگرداند، مقدار در پیمایش تولید شده توسط <code>filter</code> گنجانده می‌شود. اگر closure مقدار <code>false</code> بازگرداند، مقدار گنجانده نخواهد شد.</p>
<p>در لیست 13-16، از <code>filter</code> با یک closure که متغیر <code>shoe_size</code> را از محیط خود می‌گیرد استفاده می‌کنیم تا روی مجموعه‌ای از نمونه‌های ساختار <code>Shoe</code> پیمایش کنیم. این متد فقط کفش‌هایی را که اندازه مشخص شده دارند بازمی‌گرداند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
<figcaption>Listing 13-16: استفاده از متد <code>filter</code> با یک closure که <code>shoe_size</code> را می‌گیرد</figcaption>
</figure>
<p>تابع <code>shoes_in_size</code> مالکیت یک وکتور از کفش‌ها و یک اندازه کفش را به عنوان پارامتر می‌گیرد. این تابع یک وکتور بازمی‌گرداند که فقط شامل کفش‌هایی با اندازه مشخص شده است.</p>
<p>در بدنه <code>shoes_in_size</code>، ما <code>into_iter</code> را فراخوانی می‌کنیم تا یک iterator ایجاد کنیم که مالکیت وکتور را می‌گیرد. سپس <code>filter</code> را فراخوانی می‌کنیم تا آن iterator را به یک iterator جدید تبدیل کنیم که فقط شامل عناصری است که closure برای آن‌ها مقدار <code>true</code> بازمی‌گرداند.</p>
<p>closure پارامتر <code>shoe_size</code> را از محیط می‌گیرد و مقدار آن را با اندازه هر کفش مقایسه می‌کند و فقط کفش‌هایی با اندازه مشخص شده را نگه می‌دارد. در نهایت، با فراخوانی <code>collect</code> مقادیر بازگردانده‌شده توسط iterator تطبیق‌یافته در یک وکتور جمع‌آوری می‌شوند که توسط تابع بازگردانده می‌شود.</p>
<p>تست نشان می‌دهد که وقتی <code>shoes_in_size</code> را فراخوانی می‌کنیم، فقط کفش‌هایی را دریافت می‌کنیم که اندازه آن‌ها با مقداری که مشخص کرده‌ایم یکسان است.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="بهبود-پروژه-io"><a class="header" href="#بهبود-پروژه-io">بهبود پروژه I/O</a></h2>
<p>با این دانش جدید درباره iteratorها، می‌توانیم پروژه I/O در فصل ۱۲ را با استفاده از iteratorها بهبود بخشیم تا بخش‌هایی از کد واضح‌تر و مختصرتر شوند. بیایید ببینیم چگونه iteratorها می‌توانند پیاده‌سازی تابع <code>Config::build</code> و تابع <code>search</code> را بهبود دهند.</p>
<h3 id="حذف-یک-clone-با-استفاده-از-یک-iterator"><a class="header" href="#حذف-یک-clone-با-استفاده-از-یک-iterator">حذف یک <code>clone</code> با استفاده از یک Iterator</a></h3>
<p>در لیست 12-6، کدی اضافه کردیم که یک برش از مقادیر <code>String</code> را گرفته و یک نمونه از ساختار <code>Config</code> ایجاد می‌کرد. این کار با شاخص‌گذاری در برش و کلون کردن مقادیر انجام شد تا ساختار <code>Config</code> مالک آن مقادیر شود. در لیست 13-17، پیاده‌سازی تابع <code>Config::build</code> را همانطور که در لیست 12-23 بود بازتولید کرده‌ایم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 13-17: بازتولید تابع <code>Config::build</code> از لیست 12-23</figcaption>
</figure>
<p>در آن زمان گفتیم که نگران تماس‌های ناکارآمد <code>clone</code> نباشید زیرا در آینده آن‌ها را حذف خواهیم کرد. خب، اکنون زمان آن فرا رسیده است!</p>
<p>ما در اینجا به <code>clone</code> نیاز داشتیم زیرا در پارامتر <code>args</code> یک برش با عناصر <code>String</code> داریم، اما تابع <code>build</code> مالک <code>args</code> نیست. برای بازگرداندن مالکیت یک نمونه <code>Config</code>، مجبور بودیم مقادیر فیلدهای <code>query</code> و <code>file_path</code> را از <code>Config</code> کلون کنیم تا نمونه <code>Config</code> بتواند مالک مقادیرش باشد.</p>
<p>با دانش جدیدمان درباره iteratorها، می‌توانیم تابع <code>build</code> را تغییر دهیم تا مالکیت یک iterator را به عنوان آرگومان خود بگیرد، به جای اینکه یک برش را قرض بگیرد. ما از قابلیت‌های iterator به جای کدی که طول برش را بررسی می‌کند و به مکان‌های خاص شاخص می‌زند، استفاده خواهیم کرد. این کار مشخص می‌کند که تابع <code>Config::build</code> چه کاری انجام می‌دهد زیرا iterator به مقادیر دسترسی پیدا خواهد کرد.</p>
<p>زمانی که <code>Config::build</code> مالکیت iterator را به دست آورد و استفاده از عملیات شاخص‌گذاری که قرض می‌گیرند را متوقف کرد، می‌توانیم مقادیر <code>String</code> را از iterator به <code>Config</code> منتقل کنیم به جای اینکه <code>clone</code> را فراخوانی کنیم و تخصیص جدیدی ایجاد کنیم.</p>
<h4 id="استفاده-مستقیم-از-iterator-بازگرداندهشده"><a class="header" href="#استفاده-مستقیم-از-iterator-بازگرداندهشده">استفاده مستقیم از Iterator بازگردانده‌شده</a></h4>
<p>فایل <em>src/main.rs</em> پروژه I/O خود را باز کنید، که باید به این شکل باشد:</p>
<p><span class="filename">نام فایل: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>ابتدا شروع تابع <code>main</code> که در لیست 12-24 داشتیم را به کدی که در لیست 13-18 است تغییر می‌دهیم، که این بار از یک iterator استفاده می‌کند. این کد تا زمانی که <code>Config::build</code> را نیز به‌روزرسانی کنیم، کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<figcaption>Listing 13-18: ارسال مقدار بازگردانده‌شده توسط <code>env::args</code> به <code>Config::build</code></figcaption>
</figure>
<p>تابع <code>env::args</code> یک iterator بازمی‌گرداند! به جای جمع‌آوری مقادیر iterator در یک وکتور و سپس ارسال یک برش به <code>Config::build</code>، اکنون ما مالکیت iterator بازگردانده‌شده از <code>env::args</code> را مستقیماً به <code>Config::build</code> ارسال می‌کنیم.</p>
<p>سپس باید تعریف تابع <code>Config::build</code> را به‌روزرسانی کنیم. در فایل <em>src/lib.rs</em> پروژه I/O خود، امضای تابع <code>Config::build</code> را به شکلی که در لیست 13-19 نشان داده شده تغییر دهید. این کد هنوز کامپایل نخواهد شد زیرا باید بدنه تابع را نیز به‌روزرسانی کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 13-19: به‌روزرسانی امضای <code>Config::build</code> برای انتظار یک iterator</figcaption>
</figure>
<p>مستندات کتابخانه استاندارد برای تابع <code>env::args</code> نشان می‌دهد که نوع iterator بازگردانده‌شده <code>std::env::Args</code> است، و این نوع صفت <code>Iterator</code> را پیاده‌سازی کرده و مقادیر <code>String</code> بازمی‌گرداند.</p>
<p>ما امضای تابع <code>Config::build</code> را به‌روزرسانی کرده‌ایم تا پارامتر <code>args</code> یک نوع جنریک با محدودیت‌های صفت <code>impl Iterator&lt;Item = String&gt;</code> باشد به جای <code>&amp;[String]</code>. این استفاده از نحو <code>impl Trait</code> که در بخش <a href="ch10-02-traits.html#traits-as-parameters">“Traits به عنوان پارامترها”</a><!-- ignore --> فصل 10 بحث شد، به این معناست که <code>args</code> می‌تواند هر نوعی باشد که صفت <code>Iterator</code> را پیاده‌سازی کرده و آیتم‌های <code>String</code> بازمی‌گرداند.</p>
<p>از آنجا که مالکیت <code>args</code> را به دست می‌آوریم و با پیمایش در آن، <code>args</code> را تغییر خواهیم داد، می‌توانیم کلمه کلیدی <code>mut</code> را به مشخصات پارامتر <code>args</code> اضافه کنیم تا آن را قابل تغییر کنیم.</p>
<h4 id="استفاده-از-متدهای-صفت-iterator-به-جای-شاخصگذاری"><a class="header" href="#استفاده-از-متدهای-صفت-iterator-به-جای-شاخصگذاری">استفاده از متدهای صفت <code>Iterator</code> به جای شاخص‌گذاری</a></h4>
<p>سپس بدنه تابع <code>Config::build</code> را اصلاح می‌کنیم. از آنجا که <code>args</code> صفت <code>Iterator</code> را پیاده‌سازی کرده است، می‌دانیم که می‌توانیم متد <code>next</code> را روی آن فراخوانی کنیم! لیست 13-20 کد لیست 12-23 را برای استفاده از متد <code>next</code> به‌روزرسانی می‌کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 13-20: تغییر بدنه <code>Config::build</code> برای استفاده از متدهای iterator</figcaption>
</figure>
<p>به یاد داشته باشید که اولین مقدار در مقدار بازگردانده‌شده از <code>env::args</code> نام برنامه است. ما می‌خواهیم آن را نادیده بگیریم و به مقدار بعدی برسیم، بنابراین ابتدا <code>next</code> را فراخوانی می‌کنیم و هیچ کاری با مقدار بازگشتی انجام نمی‌دهیم. سپس، <code>next</code> را فراخوانی می‌کنیم تا مقداری که می‌خواهیم در فیلد <code>query</code> از <code>Config</code> قرار دهیم را دریافت کنیم. اگر <code>next</code> یک <code>Some</code> بازگرداند، از یک <code>match</code> برای استخراج مقدار استفاده می‌کنیم. اگر <code>None</code> بازگرداند، به این معنی است که آرگومان‌های کافی ارائه نشده‌اند و با مقدار <code>Err</code> زودتر بازمی‌گردیم. همین کار را برای مقدار <code>file_path</code> انجام می‌دهیم.</p>
<h3 id="واضحتر-کردن-کد-با-تطبیقدهندههای-iterator"><a class="header" href="#واضحتر-کردن-کد-با-تطبیقدهندههای-iterator">واضح‌تر کردن کد با تطبیق‌دهنده‌های Iterator</a></h3>
<p>ما همچنین می‌توانیم از iteratorها در تابع <code>search</code> پروژه I/O خود بهره ببریم. این تابع در لیست 13-21 به همان شکلی که در لیست 12-19 بود بازتولید شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 13-21: پیاده‌سازی تابع <code>search</code> از لیست 12-19</figcaption>
</figure>
<p>ما می‌توانیم این کد را با استفاده از متدهای تطبیق‌دهنده iterator به شکلی مختصرتر بنویسیم. این کار همچنین به ما اجازه می‌دهد که از داشتن یک وکتور میانی قابل تغییر به نام <code>results</code> اجتناب کنیم. سبک برنامه‌نویسی تابعی ترجیح می‌دهد مقدار حالت‌های قابل تغییر را به حداقل برساند تا کد واضح‌تر شود. حذف حالت قابل تغییر ممکن است امکان ارتقاء آینده را فراهم کند تا جستجو به صورت موازی انجام شود، زیرا نیازی به مدیریت دسترسی همزمان به وکتور <code>results</code> نخواهیم داشت. لیست 13-22 این تغییر را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a query string"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a file path"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 13-22: استفاده از متدهای تطبیق‌دهنده iterator در پیاده‌سازی تابع <code>search</code></figcaption>
</figure>
<p>به یاد داشته باشید که هدف تابع <code>search</code> بازگرداندن تمام خطوط موجود در <code>contents</code> است که شامل <code>query</code> باشند. مشابه مثال <code>filter</code> در لیست 13-16، این کد از تطبیق‌دهنده <code>filter</code> برای نگه‌داشتن فقط خطوطی که برای آن‌ها <code>line.contains(query)</code> مقدار <code>true</code> بازمی‌گرداند، استفاده می‌کند. سپس خطوط مطابق را با <code>collect</code> در یک وکتور دیگر جمع‌آوری می‌کنیم. بسیار ساده‌تر! اگر تمایل دارید، می‌توانید همین تغییر را برای استفاده از متدهای iterator در تابع <code>search_case_insensitive</code> نیز انجام دهید.</p>
<h3 id="انتخاب-بین-حلقهها-یا-iteratorها"><a class="header" href="#انتخاب-بین-حلقهها-یا-iteratorها">انتخاب بین حلقه‌ها یا Iteratorها</a></h3>
<p>سؤال منطقی بعدی این است که کدام سبک را باید در کد خود انتخاب کنید و چرا: پیاده‌سازی اصلی در لیست 13-21 یا نسخه‌ای که از iteratorها در لیست 13-22 استفاده می‌کند. اکثر برنامه‌نویسان Rust ترجیح می‌دهند از سبک iterator استفاده کنند. یادگیری آن در ابتدا کمی سخت‌تر است، اما وقتی با تطبیق‌دهنده‌های مختلف iterator و کارهایی که انجام می‌دهند آشنا شوید، استفاده از iteratorها می‌تواند آسان‌تر شود. به جای دست‌و‌پنجه نرم کردن با بخش‌های مختلف حلقه‌ها و ساخت وکتورهای جدید، کد بر هدف سطح بالا حلقه تمرکز می‌کند. این کار برخی از کدهای عمومی را پنهان می‌کند، بنابراین مفاهیمی که مختص این کد هستند، مانند شرط فیلتر کردن که هر عنصر در iterator باید پاس کند، واضح‌تر دیده می‌شوند.</p>
<p>اما آیا این دو پیاده‌سازی واقعاً معادل هستند؟ فرضیه شهودی این است که حلقه سطح پایین‌تر سریع‌تر خواهد بود. بیایید درباره عملکرد صحبت کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="مقایسه-عملکرد-حلقهها-در-برابر-iteratorها"><a class="header" href="#مقایسه-عملکرد-حلقهها-در-برابر-iteratorها">مقایسه عملکرد: حلقه‌ها در برابر Iteratorها</a></h2>
<p>برای تعیین اینکه از حلقه‌ها یا iteratorها استفاده کنید، باید بدانید کدام پیاده‌سازی سریع‌تر است: نسخه تابع <code>search</code> با حلقه صریح <code>for</code> یا نسخه با iteratorها.</p>
<p>ما یک بنچمارک اجرا کردیم که در آن تمام محتوای کتاب <em>The Adventures of Sherlock Holmes</em> اثر سر آرتور کانن دویل را در یک <code>String</code> بارگذاری کردیم و به دنبال کلمه <em>the</em> در محتوا گشتیم. نتایج بنچمارک برای نسخه <code>search</code> با استفاده از حلقه <code>for</code> و نسخه با iteratorها به شرح زیر است:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>دو پیاده‌سازی عملکرد مشابهی دارند! ما کد بنچمارک (benchmark) را اینجا توضیح نمی‌دهیم، زیرا هدف این نیست که ثابت کنیم این دو نسخه معادل هستند، بلکه هدف این است که به یک درک کلی از نحوه مقایسه عملکردی این دو پیاده‌سازی برسیم.</p>
<p>برای یک بنچمارک جامع‌تر، باید از متن‌های مختلف با اندازه‌های گوناگون به‌عنوان <code>contents</code>، کلمات مختلف و کلماتی با طول‌های متفاوت به‌عنوان <code>query</code>، و انواع دیگری از تغییرات استفاده کنید. نکته این است: iteratorها، اگرچه یک انتزاع سطح بالا هستند، به کدی که تقریباً همان سطح پایینی دارد کامپایل می‌شوند، انگار خودتان کد سطح پایین را نوشته باشید. iteratorها یکی از <em>انتزاع‌های بدون هزینه</em> Rust هستند، به این معنی که استفاده از انتزاع هیچ هزینه اضافی زمان اجرای برنامه را تحمیل نمی‌کند. این موضوع مشابه تعریفی است که بیارنه استراس‌تروپ، طراح و پیاده‌ساز اصلی ++C، در مقاله “Foundations of C++” (2012) برای <em>بدون هزینه اضافی</em> ارائه می‌دهد:</p>
<blockquote>
<p>به طور کلی، پیاده‌سازی‌های ++C از اصل بدون هزینه اضافی پیروی می‌کنند: چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد. و علاوه بر این: چیزی که استفاده می‌کنید، نمی‌توانید بهتر از این دستی کدنویسی کنید.</p>
</blockquote>
<p>به‌عنوان یک مثال دیگر، کد زیر از یک دیکودر صوتی گرفته شده است. الگوریتم دیکودینگ از عملیات ریاضی پیش‌بینی خطی برای تخمین مقادیر آینده بر اساس یک تابع خطی از نمونه‌های قبلی استفاده می‌کند. این کد از یک زنجیره iterator برای انجام برخی محاسبات بر روی سه متغیر در محدوده استفاده می‌کند: یک برش داده‌ای <code>buffer</code>، یک آرایه از ۱۲ <code>coefficients</code>، و مقداری برای جابجایی داده‌ها در <code>qlp_shift</code>. ما متغیرها را در این مثال تعریف کرده‌ایم اما به آن‌ها مقداری نداده‌ایم؛ اگرچه این کد خارج از زمینه خود معنای زیادی ندارد، اما همچنان یک مثال مختصر و واقعی از نحوه تبدیل ایده‌های سطح بالا به کد سطح پایین در Rust است.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>برای محاسبه مقدار <code>prediction</code>، این کد از طریق هر یک از ۱۲ مقدار در <code>coefficients</code> پیمایش می‌کند و از متد <code>zip</code> برای جفت کردن مقادیر coefficients با ۱۲ مقدار قبلی در <code>buffer</code> استفاده می‌کند. سپس، برای هر جفت، مقادیر را در هم ضرب می‌کنیم، تمام نتایج را جمع می‌کنیم، و بیت‌های حاصل را به اندازه <code>qlp_shift</code> بیت به سمت راست جابجا می‌کنیم.</p>
<p>محاسبات در برنامه‌هایی مانند دیکودرهای صوتی اغلب عملکرد را در اولویت قرار می‌دهند. در اینجا، ما یک iterator ایجاد می‌کنیم، از دو تطبیق‌دهنده استفاده می‌کنیم، و سپس مقدار را مصرف می‌کنیم. کد اسمبلی که این کد Rust به آن کامپایل می‌شود چیست؟ خب، در زمان نگارش این متن، این کد به همان اسمبلی‌ای که ممکن است دستی بنویسید کامپایل می‌شود. هیچ حلقه‌ای وجود ندارد که با پیمایش روی مقادیر در <code>coefficients</code> مطابقت داشته باشد: Rust می‌داند که ۱۲ تکرار وجود دارد، بنابراین حلقه را “بازمی‌پیچد”. <em>بازپیچیدن</em> یک بهینه‌سازی است که سربار کد کنترل‌کننده حلقه را حذف می‌کند و به جای آن کد تکراری برای هر تکرار حلقه تولید می‌کند.</p>
<p>تمام مقادیر coefficients در ثبات‌ها ذخیره می‌شوند، به این معنی که دسترسی به مقادیر بسیار سریع است. در زمان اجرا هیچ بررسی حدودی برای دسترسی به آرایه انجام نمی‌شود. تمام این بهینه‌سازی‌هایی که Rust می‌تواند اعمال کند کد نهایی را به شدت کارآمد می‌سازد. حالا که این را می‌دانید، می‌توانید از iteratorها و closureها بدون ترس استفاده کنید! آن‌ها باعث می‌شوند کد سطح بالاتر به نظر برسد اما هیچ هزینه عملکردی در زمان اجرا اعمال نمی‌کنند.</p>
<h2 id="خلاصه-12"><a class="header" href="#خلاصه-12">خلاصه</a></h2>
<div dir="rtl">
closureها و iteratorها ویژگی‌های Rust هستند که از ایده‌های زبان‌های برنامه‌نویسی تابعی الهام گرفته‌اند. آن‌ها به توانایی Rust در بیان واضح ایده‌های سطح بالا با عملکرد سطح پایین کمک می‌کنند. پیاده‌سازی closureها و iteratorها به گونه‌ای است که عملکرد زمان اجرا تحت تأثیر قرار نمی‌گیرد. این بخشی از هدف Rust برای ارائه انتزاع‌های بدون هزینه است.
</div>
<p>اکنون که قابلیت بیان پروژه I/O خود را بهبود داده‌ایم، بیایید نگاهی به برخی ویژگی‌های بیشتر <code>cargo</code> بیندازیم که به ما کمک می‌کنند پروژه را با دنیا به اشتراک بگذاریم.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="اطلاعات-بیشتر-درباره-cargo-و-cratesio"><a class="header" href="#اطلاعات-بیشتر-درباره-cargo-و-cratesio">اطلاعات بیشتر درباره Cargo و Crates.io</a></h1>
<p>تا کنون ما فقط از ویژگی‌های ابتدایی Cargo برای ساخت، اجرا و تست کد خود استفاده کرده‌ایم، اما Cargo قابلیت‌های بیشتری دارد. در این فصل، برخی از ویژگی‌های پیشرفته‌تر آن را بررسی می‌کنیم تا نشان دهیم چگونه می‌توانید کارهای زیر را انجام دهید:</p>
<div dir="rtl">
    <ul>
        <li>شخصی‌سازی فرآیند ساخت از طریق پروفایل‌های نسخه انتشار</li>
        <li>انتشار کتابخانه‌ها در <a href="https://crates.io/" target="_blank">crates.io</a></li>
        <li>سازماندهی پروژه‌های بزرگ با استفاده از Workspaces</li>
        <li>نصب باینری‌ها از <a href="https://crates.io/" target="_blank">crates.io</a></li>
        <li>گسترش قابلیت‌های Cargo با استفاده از دستورات سفارشی</li>
    </ul>
</div>
<p>Cargo می‌تواند بسیار بیشتر از آنچه در این فصل پوشش می‌دهیم انجام دهد، بنابراین برای توضیحات کامل درباره تمام قابلیت‌های آن، به <a href="https://doc.rust-lang.org/cargo/">مستندات آن</a> مراجعه کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="شخصیسازی-فرآیند-ساخت-با-استفاده-از-پروفایلهای-نسخه-انتشار"><a class="header" href="#شخصیسازی-فرآیند-ساخت-با-استفاده-از-پروفایلهای-نسخه-انتشار">شخصی‌سازی فرآیند ساخت با استفاده از پروفایل‌های نسخه انتشار</a></h2>
<p>در Rust، <em>پروفایل‌های نسخه انتشار</em> پروفایل‌هایی از پیش تعریف‌شده و قابل شخصی‌سازی هستند که با پیکربندی‌های مختلف به برنامه‌نویس اجازه می‌دهند کنترل بیشتری روی گزینه‌های مختلف کامپایل کد داشته باشد. هر پروفایل به صورت مستقل از دیگران پیکربندی می‌شود.</p>
<p>Cargo دو پروفایل اصلی دارد: پروفایل <code>dev</code> که هنگام اجرای <code>cargo build</code> استفاده می‌شود و پروفایل <code>release</code> که هنگام اجرای <code>cargo build --release</code> استفاده می‌شود. پروفایل <code>dev</code> با تنظیمات پیش‌فرض مناسب برای توسعه و پروفایل <code>release</code> با تنظیمات پیش‌فرض مناسب برای ساخت نسخه‌های انتشار تعریف شده‌اند.</p>
<p>این نام‌های پروفایل ممکن است از خروجی‌های ساخت شما آشنا به نظر برسند:</p>
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
</code></pre>
<p><code>dev</code> و <code>release</code> پروفایل‌های متفاوتی هستند که توسط کامپایلر استفاده می‌شوند.</p>
<p>Cargo تنظیمات پیش‌فرضی برای هر یک از پروفایل‌ها دارد که زمانی اعمال می‌شوند که هیچ بخش <code>[profile.*]</code> در فایل <em>Cargo.toml</em> پروژه شما به طور صریح اضافه نشده باشد. با افزودن بخش‌های <code>[profile.*]</code> برای هر پروفایلی که می‌خواهید سفارشی کنید، می‌توانید هر بخشی از تنظیمات پیش‌فرض را بازنویسی کنید. به عنوان مثال، در اینجا مقادیر پیش‌فرض تنظیم <code>opt-level</code> برای پروفایل‌های <code>dev</code> و <code>release</code> آورده شده است:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>تنظیم <code>opt-level</code> تعداد بهینه‌سازی‌هایی که Rust روی کد شما اعمال می‌کند را کنترل می‌کند و محدوده‌ای از 0 تا 3 دارد. اعمال بهینه‌سازی‌های بیشتر زمان کامپایل را افزایش می‌دهد، بنابراین اگر در حال توسعه هستید و کد خود را اغلب کامپایل می‌کنید، بهینه‌سازی‌های کمتری می‌خواهید تا سریع‌تر کامپایل شود حتی اگر کد نهایی کندتر اجرا شود. بنابراین مقدار پیش‌فرض <code>opt-level</code> برای <code>dev</code> برابر <code>0</code> است. وقتی آماده انتشار کد خود هستید، بهتر است زمان بیشتری برای کامپایل صرف کنید. شما فقط یک بار در حالت انتشار کامپایل خواهید کرد، اما برنامه کامپایل‌شده را بارها اجرا خواهید کرد. بنابراین حالت انتشار زمان کامپایل طولانی‌تر را با اجرای سریع‌تر کد معامله می‌کند. به همین دلیل مقدار پیش‌فرض <code>opt-level</code> برای پروفایل <code>release</code> برابر <code>3</code> است.</p>
<p>شما می‌توانید یک تنظیم پیش‌فرض را با افزودن یک مقدار متفاوت برای آن در فایل <em>Cargo.toml</em> بازنویسی کنید. برای مثال، اگر بخواهیم از سطح بهینه‌سازی 1 در پروفایل توسعه استفاده کنیم، می‌توانیم این دو خط را به فایل <em>Cargo.toml</em> پروژه خود اضافه کنیم:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>این کد تنظیم پیش‌فرض <code>0</code> را بازنویسی می‌کند. اکنون، زمانی که <code>cargo build</code> را اجرا می‌کنیم، Cargo از تنظیمات پیش‌فرض برای پروفایل <code>dev</code> به همراه سفارشی‌سازی ما برای <code>opt-level</code> استفاده خواهد کرد. از آنجایی که ما مقدار <code>opt-level</code> را به <code>1</code> تنظیم کرده‌ایم، Cargo بهینه‌سازی‌های بیشتری نسبت به پیش‌فرض اعمال خواهد کرد، اما نه به اندازه یک ساخت در حالت <code>release</code>.</p>
<p>برای مشاهده لیست کامل گزینه‌های پیکربندی و تنظیمات پیش‌فرض برای هر پروفایل، به <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">مستندات Cargo</a> مراجعه کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="انتشار-یک-crate-در-cratesio"><a class="header" href="#انتشار-یک-crate-در-cratesio">انتشار یک Crate در Crates.io</a></h2>
<p>ما از پکیج‌های موجود در <a href="https://crates.io/">crates.io</a><!-- ignore --> به عنوان وابستگی‌های پروژه خود استفاده کرده‌ایم، اما شما همچنین می‌توانید کد خود را با دیگران به اشتراک بگذارید با انتشار پکیج‌های خودتان. رجیستری Crates.io کد منبع پکیج‌های شما را توزیع می‌کند، بنابراین به طور عمده میزبان کدهای منبع باز است.</p>
<p>Rust و Cargo ویژگی‌هایی دارند که باعث می‌شود پکیج منتشرشده شما برای دیگران راحت‌تر پیدا شده و استفاده شود. ما ابتدا درباره برخی از این ویژگی‌ها صحبت می‌کنیم و سپس توضیح می‌دهیم چگونه یک پکیج منتشر کنیم.</p>
<h3 id="ایجاد-نظرات-مستندات-مفید"><a class="header" href="#ایجاد-نظرات-مستندات-مفید">ایجاد نظرات مستندات مفید</a></h3>
<p>مستندسازی دقیق پکیج‌های شما به دیگر کاربران کمک می‌کند بدانند چگونه و چه زمانی از آن‌ها استفاده کنند، بنابراین ارزش دارد که وقت خود را برای نوشتن مستندات صرف کنید. در فصل 3، نحوه اضافه کردن نظرات به کد Rust با استفاده از دو اسلش <code>//</code> را بررسی کردیم. Rust همچنین نوع خاصی از نظرات برای مستندات دارد که به نام <em>نظرات مستندات</em> شناخته می‌شود و مستندات HTML تولید می‌کند. این مستندات HTML محتوای نظرات مستندات را برای آیتم‌های عمومی API نمایش می‌دهد که برای برنامه‌نویسانی که به دنبال دانستن چگونگی <em>استفاده از</em> crate شما هستند، طراحی شده است و نه چگونگی <em>پیاده‌سازی</em> crate شما.</p>
<p>نظرات مستندات به جای دو اسلش از سه اسلش <code>///</code> استفاده می‌کنند و از نشانه‌گذاری Markdown برای قالب‌بندی متن پشتیبانی می‌کنند. نظرات مستندات را درست قبل از آیتمی که قرار است مستندسازی شود قرار دهید. لیستینگ 14-1 نظرات مستندات برای یک تابع <code>add_one</code> در یک crate به نام <code>my_crate</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<figcaption>Listing 14-1: یک نظر مستند برای یک تابع</figcaption>
</figure>
<p>اینجا، ما توضیحی درباره عملکرد تابع <code>add_one</code> می‌دهیم، بخشی با عنوان <code>Examples</code> شروع می‌کنیم، و سپس کدی که نشان می‌دهد چگونه از تابع <code>add_one</code> استفاده کنیم ارائه می‌دهیم. می‌توانیم مستندات HTML را از این نظر مستند با اجرای دستور <code>cargo doc</code> تولید کنیم. این دستور ابزار <code>rustdoc</code> که با Rust توزیع شده را اجرا می‌کند و مستندات HTML تولیدشده را در دایرکتوری <em>target/doc</em> قرار می‌دهد.</p>
<p>برای راحتی، اجرای دستور <code>cargo doc --open</code> مستندات HTML را برای crate فعلی شما (و همچنین مستندات همه وابستگی‌های crate شما) می‌سازد و نتیجه را در مرورگر وب باز می‌کند. به تابع <code>add_one</code> بروید و خواهید دید که چگونه متن موجود در نظرات مستندات نمایش داده می‌شود، همانطور که در شکل 14-1 نشان داده شده است:</p>
<img alt="مستندات HTML تولیدشده برای تابع `add_one` از `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">شکل 14-1: مستندات HTML برای تابع <code>add_one</code></span></p>
<h4 id="بخشهای-متداول-مورد-استفاده"><a class="header" href="#بخشهای-متداول-مورد-استفاده">بخش‌های متداول مورد استفاده</a></h4>
<p>ما در لیستینگ 14-1 از عنوان Markdown <code># Examples</code> برای ایجاد یک بخش در HTML با عنوان “Examples” استفاده کردیم. در اینجا برخی دیگر از بخش‌هایی که نویسندگان crate معمولاً در مستندات خود استفاده می‌کنند آورده شده است:</p>
<ul>
<li><strong>Panics</strong>: سناریوهایی که در آن ممکن است تابع مستند شده باعث ایجاد panic شود. فراخوانان تابع که نمی‌خواهند برنامه‌هایشان panic کنند باید مطمئن شوند که تابع را در این شرایط فراخوانی نمی‌کنند.</li>
<li><strong>Errors</strong>: اگر تابع یک مقدار <code>Result</code> بازگرداند، توضیح انواع خطاهایی که ممکن است رخ دهد و شرایطی که ممکن است این خطاها را ایجاد کند، برای فراخوانان مفید است تا بتوانند کدهایی برای مدیریت انواع مختلف خطاها بنویسند.</li>
<li><strong>Safety</strong>: اگر تابع <code>unsafe</code> برای فراخوانی باشد (ما عدم ایمنی را در فصل 20 بررسی خواهیم کرد)، باید بخشی توضیح دهد که چرا تابع ناامن است و اصولی را که تابع از فراخوانان انتظار دارد رعایت کنند پوشش دهد.</li>
</ul>
<p>بیشتر نظرات مستندات به همه این بخش‌ها نیاز ندارند، اما این یک چک‌لیست خوب برای یادآوری جنبه‌هایی از کد شما است که کاربران علاقه‌مند به دانستن آن هستند.</p>
<h4 id="نظرات-مستندات-به-عنوان-تست"><a class="header" href="#نظرات-مستندات-به-عنوان-تست">نظرات مستندات به عنوان تست</a></h4>
<p>اضافه کردن بلوک‌های کد مثال به نظرات مستندات شما می‌تواند به نمایش نحوه استفاده از کتابخانه شما کمک کند، و انجام این کار یک مزیت اضافی دارد: اجرای دستور <code>cargo test</code>، مثال‌های کد در مستندات شما را به عنوان تست اجرا خواهد کرد! هیچ چیزی بهتر از مستندات با مثال نیست. اما هیچ چیزی بدتر از مثال‌هایی نیست که کار نمی‌کنند زیرا کد از زمان نوشته شدن مستندات تغییر کرده است. اگر <code>cargo test</code> را با مستندات تابع <code>add_one</code> از لیستینگ 14-1 اجرا کنیم، بخشی در نتایج تست مانند زیر خواهیم دید:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>اکنون، اگر تابع یا مثال را تغییر دهیم به طوری که <code>assert_eq!</code> در مثال باعث panic شود و دوباره <code>cargo test</code> را اجرا کنیم، خواهیم دید که تست‌های مستندات تشخیص می‌دهند که مثال و کد با یکدیگر همگام نیستند!</p>
<h4 id="مستندسازی-آیتمهای-شامل-شده"><a class="header" href="#مستندسازی-آیتمهای-شامل-شده">مستندسازی آیتم‌های شامل شده</a></h4>
<p>سبک نظر مستند <code>//!</code> مستندات را به آیتمی که نظرات را شامل می‌شود اضافه می‌کند، به جای آیتم‌هایی که بعد از نظرات قرار دارند. ما معمولاً از این نظرات مستند در فایل اصلی crate (<em>src/lib.rs</em> بر اساس قرارداد) یا در داخل یک ماژول برای مستندسازی کل crate یا ماژول استفاده می‌کنیم.</p>
<p>برای مثال، برای اضافه کردن مستنداتی که هدف crate <code>my_crate</code> را که شامل تابع <code>add_one</code> است توضیح می‌دهد، نظرات مستندی که با <code>//!</code> شروع می‌شوند را به ابتدای فایل <em>src/lib.rs</em> اضافه می‌کنیم، همان‌طور که در لیستینگ 14-2 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 14-2: مستندات برای کل crate <code>my_crate</code></figcaption>
</figure>
<p>توجه داشته باشید که هیچ کدی بعد از آخرین خطی که با <code>//!</code> شروع می‌شود وجود ندارد. چون ما نظرات را با <code>//!</code> شروع کرده‌ایم به جای <code>///</code>، ما در حال مستندسازی آیتمی هستیم که این نظر را شامل می‌شود به جای آیتمی که بعد از این نظر قرار دارد. در این مورد، آن آیتم فایل <em>src/lib.rs</em> است که ریشه crate است. این نظرات کل crate را توضیح می‌دهند.</p>
<p>وقتی <code>cargo doc --open</code> را اجرا می‌کنیم، این نظرات در صفحه اول مستندات crate <code>my_crate</code> بالای لیست آیتم‌های عمومی در crate نمایش داده می‌شوند، همان‌طور که در شکل 14-2 نشان داده شده است:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">شکل 14-2: مستندات تولید شده برای <code>my_crate</code>، شامل توضیحات در مورد کل crate</span></p>
<p>نظرات مستندات داخل آیتم‌ها به ویژه برای توصیف crates و ماژول‌ها مفید هستند. از آن‌ها برای توضیح هدف کلی container استفاده کنید تا به کاربران خود در درک سازمان‌دهی crate کمک کنید.</p>
<h3 id="صادرات-یک-api-عمومی-کارآمد-با-استفاده-از-pub-use"><a class="header" href="#صادرات-یک-api-عمومی-کارآمد-با-استفاده-از-pub-use">صادرات یک API عمومی کارآمد با استفاده از <code>pub use</code></a></h3>
<p>ساختار API عمومی شما یک موضوع مهم هنگام انتشار یک crate است. افرادی که از crate شما استفاده می‌کنند، کمتر از شما با ساختار آن آشنا هستند و ممکن است در یافتن قسمت‌هایی که می‌خواهند استفاده کنند، اگر crate شما دارای یک سلسله‌مراتب ماژول بزرگ باشد، دچار مشکل شوند.</p>
<p>در فصل 7، نحوه عمومی کردن آیتم‌ها با استفاده از کلمه کلیدی <code>pub</code> و آوردن آیتم‌ها به یک scope با استفاده از کلمه کلیدی <code>use</code> را پوشش دادیم. با این حال، ساختاری که هنگام توسعه یک crate برای شما منطقی به نظر می‌رسد ممکن است برای کاربران شما چندان مناسب نباشد. ممکن است بخواهید ساختارهای خود را در یک سلسله‌مراتب با چندین سطح سازماندهی کنید، اما سپس افرادی که می‌خواهند از یک نوع تعریف‌شده عمیق در سلسله‌مراتب استفاده کنند ممکن است در پیدا کردن آن نوع دچار مشکل شوند. همچنین ممکن است مجبور شوند به جای <code>use my_crate::UsefulType;</code>، چیزی مانند <code>use my_crate::some_module::another_module::UsefulType;</code> بنویسند که ناخوشایند است.</p>
<p>خبر خوب این است که اگر ساختار <em>برای دیگران راحت نیست</em>، نیازی نیست سازمان‌دهی داخلی خود را دوباره بچینید: به جای آن می‌توانید آیتم‌ها را با استفاده از <code>pub use</code> مجدداً صادر کنید تا یک ساختار عمومی متفاوت از ساختار خصوصی خود ایجاد کنید. صادرات مجدد یک آیتم عمومی در یک مکان را می‌گیرد و آن را در یک مکان دیگر عمومی می‌کند، گویی که در مکان دیگر تعریف شده است.</p>
<p>برای مثال، فرض کنید ما یک کتابخانه به نام <code>art</code> برای مدل‌سازی مفاهیم هنری ایجاد کرده‌ایم. در این کتابخانه دو ماژول وجود دارند: یک ماژول <code>kinds</code> که شامل دو enum به نام‌های <code>PrimaryColor</code> و <code>SecondaryColor</code> است و یک ماژول <code>utils</code> که شامل یک تابع به نام <code>mix</code> است، همان‌طور که در لیستینگ 14-3 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<figcaption>Listing 14-3: یک کتابخانه <code>art</code> با آیتم‌هایی که در ماژول‌های <code>kinds</code> و <code>utils</code> سازماندهی شده‌اند</figcaption>
</figure>
<p>شکل 14-3 نشان می‌دهد که صفحه اول مستندات این crate که توسط <code>cargo doc</code> تولید شده است چگونه به نظر می‌رسد:</p>
<img alt="مستندات تولید شده برای crate `art` که ماژول‌های `kinds` و `utils` را لیست می‌کند" src="img/trpl14-03.png" class="center" />
<p><span class="caption">شکل 14-3: صفحه اول مستندات crate <code>art</code> که ماژول‌های <code>kinds</code> و <code>utils</code> را لیست می‌کند</span></p>
<p>توجه کنید که انواع <code>PrimaryColor</code> و <code>SecondaryColor</code> در صفحه اول لیست نشده‌اند، و تابع <code>mix</code> نیز لیست نشده است. برای دیدن آن‌ها باید روی <code>kinds</code> و <code>utils</code> کلیک کنیم.</p>
<p>یک crate دیگر که به این کتابخانه وابسته است نیاز دارد که بیانیه‌های <code>use</code> مشخص کنند که آیتم‌ها را از <code>art</code> به scope می‌آورند، و ساختار ماژول تعریف‌شده کنونی را بیان کنند. لیستینگ 14-4 یک مثال از crate‌ای که آیتم‌های <code>PrimaryColor</code> و <code>mix</code> را از crate <code>art</code> استفاده می‌کند نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<figcaption>Listing 14-4: A crate using the <code>art</code> crate’s items with its internal structure exported</figcaption>
</figure>
<p>نویسنده کدی که در لیستینگ 14-4 نشان داده شده و از crate <code>art</code> استفاده می‌کند، مجبور بوده متوجه شود که <code>PrimaryColor</code> در ماژول <code>kinds</code> و <code>mix</code> در ماژول <code>utils</code> قرار دارد. ساختار ماژول crate <code>art</code> بیشتر برای توسعه‌دهندگانی که روی این crate کار می‌کنند مرتبط است تا کسانی که از آن استفاده می‌کنند. ساختار داخلی اطلاعات مفیدی برای کسی که می‌خواهد نحوه استفاده از crate <code>art</code> را بفهمد ارائه نمی‌دهد، بلکه بیشتر باعث سردرگمی می‌شود، زیرا توسعه‌دهندگانی که از آن استفاده می‌کنند باید بفهمند کجا را باید جستجو کنند و نام‌های ماژول را در بیانیه‌های <code>use</code> مشخص کنند.</p>
<p>برای حذف سازمان‌دهی داخلی از API عمومی، می‌توانیم کد crate <code>art</code> را در لیستینگ 14-3 تغییر دهیم تا بیانیه‌های <code>pub use</code> را برای صادرات مجدد آیتم‌ها در سطح بالا اضافه کنیم، همان‌طور که در لیستینگ 14-5 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<figcaption>Listing 14-5: افزودن بیانیه‌های <code>pub use</code> برای صادرات مجدد آیتم‌ها</figcaption>
</figure>
<p>مستندات API که <code>cargo doc</code> برای این crate تولید می‌کند اکنون صادرات‌های مجدد را در صفحه اول لیست کرده و به آن‌ها لینک می‌دهد، همان‌طور که در شکل 14-4 نشان داده شده است. این کار پیدا کردن انواع <code>PrimaryColor</code> و <code>SecondaryColor</code> و تابع <code>mix</code> را آسان‌تر می‌کند.</p>
<img alt="مستندات تولیدشده برای crate `art` با صادرات‌های مجدد در صفحه اول" src="img/trpl14-04.png" class="center" />
<p><span class="caption">شکل 14-4: صفحه اول مستندات برای crate <code>art</code> که صادرات‌های مجدد را لیست می‌کند</span></p>
<p>کاربران crate <code>art</code> همچنان می‌توانند ساختار داخلی را از لیستینگ 14-3 ببینند و استفاده کنند، همان‌طور که در لیستینگ 14-4 نشان داده شده است، یا می‌توانند از ساختار راحت‌تر در لیستینگ 14-5 استفاده کنند، همان‌طور که در لیستینگ 14-6 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<figcaption>Listing 14-6: یک برنامه که از آیتم‌های صادرات‌شده مجدد crate <code>art</code> استفاده می‌کند</figcaption>
</figure>
<p>در مواردی که ماژول‌های تو در تو زیادی وجود دارند، صادرات مجدد انواع در سطح بالا با <code>pub use</code> می‌تواند تفاوت بزرگی در تجربه افرادی که از crate استفاده می‌کنند ایجاد کند. یکی دیگر از استفاده‌های رایج <code>pub use</code>، صادرات مجدد تعاریف یک وابستگی در crate فعلی برای تبدیل تعاریف آن به بخشی از API عمومی crate شما است.</p>
<p>ایجاد یک ساختار API عمومی مفید بیشتر شبیه یک هنر است تا یک علم، و می‌توانید با آزمون و خطا API‌ای پیدا کنید که بهترین کارکرد را برای کاربران شما داشته باشد. انتخاب <code>pub use</code> به شما انعطاف می‌دهد که چگونه crate خود را به صورت داخلی ساختار دهید و آن ساختار داخلی را از چیزی که به کاربران خود ارائه می‌دهید جدا کنید. به برخی از کدهای crate‌هایی که نصب کرده‌اید نگاهی بیندازید تا ببینید آیا ساختار داخلی آن‌ها با API عمومی آن‌ها تفاوت دارد یا خیر.</p>
<h3 id="تنظیم-یک-حساب-در-cratesio"><a class="header" href="#تنظیم-یک-حساب-در-cratesio">تنظیم یک حساب در Crates.io</a></h3>
<p>قبل از اینکه بتوانید هر crate‌ای را منتشر کنید، نیاز دارید که یک حساب در <a href="https://crates.io/">crates.io</a><!-- ignore --> ایجاد کنید و یک توکن API دریافت کنید. برای این کار، به صفحه اصلی در <a href="https://crates.io/">crates.io</a><!-- ignore --> بروید و از طریق حساب GitHub وارد شوید. (در حال حاضر حساب GitHub یک نیاز است، اما ممکن است سایت در آینده از روش‌های دیگری برای ایجاد حساب پشتیبانی کند.) پس از ورود به سیستم، به تنظیمات حساب خود در <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> بروید و کلید API خود را دریافت کنید. سپس دستور <code>cargo login</code> را اجرا کرده و کلید API خود را وارد کنید، مانند این:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>این دستور Cargo را از توکن API شما مطلع کرده و آن را به صورت محلی در فایل <em>~/.cargo/credentials</em> ذخیره می‌کند. توجه داشته باشید که این توکن یک <em>راز</em> است: آن را با هیچ‌کس دیگری به اشتراک نگذارید. اگر به هر دلیلی این توکن را با کسی به اشتراک گذاشتید، باید آن را لغو کنید و یک توکن جدید در <a href="https://crates.io/">crates.io</a><!-- ignore --> ایجاد کنید.</p>
<h3 id="افزودن-متادیتا-به-یک-crate-جدید"><a class="header" href="#افزودن-متادیتا-به-یک-crate-جدید">افزودن متادیتا به یک Crate جدید</a></h3>
<p>فرض کنید یک crate دارید که می‌خواهید منتشر کنید. قبل از انتشار، نیاز دارید که برخی متادیتا را در بخش <code>[package]</code> فایل <em>Cargo.toml</em> crate خود اضافه کنید.</p>
<p>crate شما باید یک نام منحصر به فرد داشته باشد. در حالی که به صورت محلی روی یک crate کار می‌کنید، می‌توانید هر نامی که دوست دارید برای crate خود انتخاب کنید. با این حال، نام‌های crate در <a href="https://crates.io/">crates.io</a><!-- ignore --> به صورت اولین درخواست‌کننده تخصیص داده می‌شوند. هنگامی که یک نام برای یک crate گرفته شود، هیچ کس دیگری نمی‌تواند یک crate با آن نام منتشر کند. قبل از تلاش برای انتشار یک crate، جستجو کنید که نامی که می‌خواهید استفاده کنید در دسترس است یا خیر. اگر نام استفاده شده باشد، باید یک نام دیگر پیدا کنید و فیلد <code>name</code> را در فایل <em>Cargo.toml</em> در زیر بخش <code>[package]</code> ویرایش کنید تا از نام جدید برای انتشار استفاده کنید، مانند زیر:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>حتی اگر یک نام منحصر به فرد انتخاب کرده باشید، زمانی که <code>cargo publish</code> را برای انتشار crate در این مرحله اجرا کنید، یک هشدار و سپس یک خطا دریافت خواهید کرد:</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these field
</code></pre>
<p>این خطا به دلیل این است که شما برخی اطلاعات حیاتی را از دست داده‌اید: یک توضیح و یک مجوز مورد نیاز است تا افراد بدانند crate شما چه کاری انجام می‌دهد و تحت چه شرایطی می‌توانند از آن استفاده کنند. در فایل <em>Cargo.toml</em>، یک توضیح اضافه کنید که فقط یک یا دو جمله باشد، زیرا این توضیح همراه crate شما در نتایج جستجو ظاهر خواهد شد. برای فیلد <code>license</code>، باید یک <em>مقدار شناسگر مجوز</em> ارائه دهید. <a href="http://spdx.org/licenses/">پروژه Software Package Data Exchange (SPDX)</a> لیستی از شناسگرهایی که می‌توانید برای این مقدار استفاده کنید را ارائه می‌دهد. برای مثال، برای مشخص کردن اینکه crate خود را با استفاده از مجوز MIT منتشر کرده‌اید، شناسگر <code>MIT</code> را اضافه کنید:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>اگر می‌خواهید از مجوزی استفاده کنید که در لیست SPDX موجود نیست، باید متن آن مجوز را در یک فایل قرار دهید، فایل را در پروژه خود اضافه کنید و سپس از کلید <code>license-file</code> برای مشخص کردن نام آن فایل به جای استفاده از کلید <code>license</code> استفاده کنید.</p>
<p>راهنمایی درباره اینکه کدام مجوز برای پروژه شما مناسب است، فراتر از محدوده این کتاب است. بسیاری از افراد در جامعه Rust پروژه‌های خود را به همان روشی که Rust مجوز داده است، با استفاده از یک مجوز دوگانه <code>MIT OR Apache-2.0</code> مجوز می‌دهند. این روش نشان می‌دهد که شما می‌توانید چندین شناسه مجوز را با جدا کردن آن‌ها با <code>OR</code> مشخص کنید تا چندین مجوز برای پروژه خود داشته باشید.</p>
<p>با یک نام منحصر به فرد، نسخه، توضیحات، و یک مجوز اضافه شده، فایل <em>Cargo.toml</em> برای یک پروژه آماده انتشار ممکن است به این صورت باشد:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">مستندات Cargo</a> سایر متادیتاهایی که می‌توانید مشخص کنید تا دیگران بتوانند crate شما را راحت‌تر پیدا کرده و استفاده کنند توضیح می‌دهد.</p>
<h3 id="انتشار-در-cratesio"><a class="header" href="#انتشار-در-cratesio">انتشار در Crates.io</a></h3>
<p>اکنون که یک حساب ایجاد کرده‌اید، توکن API خود را ذخیره کرده‌اید، نامی برای crate خود انتخاب کرده‌اید، و متادیتای مورد نیاز را مشخص کرده‌اید، آماده انتشار هستید! انتشار یک crate نسخه‌ای خاص از آن را در <a href="https://crates.io/">crates.io</a><!-- ignore --> آپلود می‌کند تا دیگران بتوانند از آن استفاده کنند.</p>
<p>دقت کنید، زیرا انتشار <em>دائمی</em> است. نسخه هرگز نمی‌تواند بازنویسی شود، و کد نمی‌تواند حذف شود. یکی از اهداف اصلی <a href="https://crates.io/">crates.io</a><!-- ignore --> این است که به عنوان یک آرشیو دائمی از کد عمل کند، به طوری که ساخت‌های همه پروژه‌هایی که به crates از <a href="https://crates.io/">crates.io</a><!-- ignore --> وابسته هستند، همچنان کار کنند. اجازه حذف نسخه‌ها تحقق این هدف را غیرممکن می‌کند. با این حال، هیچ محدودیتی برای تعداد نسخه‌های crate که می‌توانید منتشر کنید وجود ندارد.</p>
<p>دستور <code>cargo publish</code> را دوباره اجرا کنید. اکنون باید موفق شود:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>تبریک می‌گویم! شما اکنون کد خود را با جامعه Rust به اشتراک گذاشته‌اید و هر کسی می‌تواند به راحتی crate شما را به عنوان یک وابستگی به پروژه خود اضافه کند.</p>
<h3 id="انتشار-نسخه-جدیدی-از-یک-crate-موجود"><a class="header" href="#انتشار-نسخه-جدیدی-از-یک-crate-موجود">انتشار نسخه جدیدی از یک Crate موجود</a></h3>
<p>وقتی تغییراتی در crate خود ایجاد کرده‌اید و آماده انتشار یک نسخه جدید هستید، مقدار <code>version</code> مشخص‌شده در فایل <em>Cargo.toml</em> خود را تغییر داده و دوباره منتشر کنید. از <a href="http://semver.org/">قوانین نسخه‌بندی معنایی (Semantic Versioning)</a> استفاده کنید تا تصمیم بگیرید که بر اساس نوع تغییراتی که ایجاد کرده‌اید، چه شماره نسخه‌ای مناسب است. سپس دستور <code>cargo publish</code> را اجرا کنید تا نسخه جدید آپلود شود.</p>
<!-- لینک قدیمی، حذف نکنید -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="از-رده-خارج-کردن-نسخهها-از-cratesio-با-استفاده-از-cargo-yank"><a class="header" href="#از-رده-خارج-کردن-نسخهها-از-cratesio-با-استفاده-از-cargo-yank">از رده خارج کردن نسخه‌ها از Crates.io با استفاده از <code>cargo yank</code></a></h3>
<p>اگرچه نمی‌توانید نسخه‌های قبلی یک crate را حذف کنید، می‌توانید از اضافه شدن آن‌ها به عنوان وابستگی جدید در پروژه‌های آینده جلوگیری کنید. این ویژگی زمانی مفید است که یک نسخه از crate به هر دلیلی خراب باشد. در چنین مواردی، Cargo از <em>یَنک کردن</em> (yanking) یک نسخه از crate پشتیبانی می‌کند.</p>
<p>یَنک کردن یک نسخه باعث می‌شود که پروژه‌های جدید نتوانند به آن نسخه وابسته شوند، در حالی که تمام پروژه‌های موجود که به آن نسخه وابسته هستند به کار خود ادامه می‌دهند. به طور خلاصه، یَنک به این معناست که تمام پروژه‌هایی که دارای فایل <em>Cargo.lock</em> هستند شکسته نخواهند شد و هر فایل <em>Cargo.lock</em> جدیدی که تولید شود از نسخه یَنک‌شده استفاده نخواهد کرد.</p>
<p>برای یَنک کردن یک نسخه از یک crate، در دایرکتوری crate‌ای که قبلاً منتشر کرده‌اید، دستور <code>cargo yank</code> را اجرا کرده و نسخه‌ای که می‌خواهید یَنک کنید را مشخص کنید. به عنوان مثال، اگر ما یک crate به نام <code>guessing_game</code> نسخه 1.0.1 منتشر کرده باشیم و بخواهیم آن را یَنک کنیم، در دایرکتوری پروژه <code>guessing_game</code> این دستور را اجرا می‌کنیم:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>با افزودن گزینه <code>--undo</code> به دستور، می‌توانید یَنک را لغو کرده و به پروژه‌ها اجازه دهید دوباره به آن نسخه وابسته شوند:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>یَنک <em>هیچ کدی را حذف نمی‌کند</em>. به عنوان مثال، نمی‌تواند اطلاعات حساسی که به طور تصادفی آپلود شده‌اند را حذف کند. اگر چنین اتفاقی افتاد، باید فوراً آن اطلاعات حساس را بازنشانی کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="workspaces-در-cargo"><a class="header" href="#workspaces-در-cargo">Workspaces در Cargo</a></h2>
<p>در فصل 12، ما یک پکیج ساختیم که شامل یک crate باینری و یک crate کتابخانه‌ای بود. همان‌طور که پروژه شما توسعه می‌یابد، ممکن است متوجه شوید که crate کتابخانه‌ای همچنان بزرگ‌تر می‌شود و بخواهید پکیج خود را بیشتر به crate‌های کتابخانه‌ای چندگانه تقسیم کنید. Cargo یک ویژگی به نام <em>workspaces</em> ارائه می‌دهد که می‌تواند به مدیریت پکیج‌های مرتبط که به صورت همزمان توسعه داده می‌شوند کمک کند.</p>
<h3 id="ایجاد-یک-workspace"><a class="header" href="#ایجاد-یک-workspace">ایجاد یک Workspace</a></h3>
<p>یک <em>workspace</em> مجموعه‌ای از پکیج‌ها است که یک فایل <em>Cargo.lock</em> و دایرکتوری خروجی مشترک دارند. بیایید یک پروژه با استفاده از workspace ایجاد کنیم—ما از کد ساده‌ای استفاده خواهیم کرد تا بتوانیم بر ساختار workspace تمرکز کنیم. راه‌های متعددی برای ساختن یک workspace وجود دارد، بنابراین فقط یک روش رایج را نشان خواهیم داد. ما یک workspace شامل یک باینری و دو کتابخانه خواهیم داشت. باینری که عملکرد اصلی را فراهم خواهد کرد، به دو کتابخانه وابسته خواهد بود. یک کتابخانه تابع <code>add_one</code> و کتابخانه دیگر تابع <code>add_two</code> ارائه خواهد داد. این سه crate بخشی از یک workspace خواهند بود. ابتدا با ایجاد یک دایرکتوری جدید برای workspace شروع می‌کنیم:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>سپس، در دایرکتوری <em>add</em>، فایل <em>Cargo.toml</em> را ایجاد می‌کنیم که کل workspace را پیکربندی می‌کند. این فایل بخش <code>[package]</code> نخواهد داشت. در عوض، با یک بخش <code>[workspace]</code> شروع می‌شود که به ما اجازه می‌دهد اعضا را به workspace اضافه کنیم. همچنین نسخه جدیدتر الگوریتم resolver Cargo را با تنظیم <code>resolver</code> به <code>"2"</code> استفاده می‌کنیم.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<p>سپس، crate باینری <code>adder</code> را با اجرای <code>cargo new</code> در دایرکتوری <em>add</em> ایجاد می‌کنیم:</p>
<pre><code class="language-console">$ cargo new adder
    Creating binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
</code></pre>
<p>اجرای <code>cargo new</code> داخل یک workspace به صورت خودکار پکیج تازه ایجاد شده را به کلید <code>members</code> در تعریف <code>[workspace]</code> در فایل <code>Cargo.toml</code> workspace اضافه می‌کند، به این صورت:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder"]
</code></pre>
<p>در این مرحله، می‌توانیم workspace را با اجرای دستور <code>cargo build</code> بسازیم. فایل‌های موجود در دایرکتوری <em>add</em> شما باید به این صورت باشند:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>Workspace یک دایرکتوری <em>target</em> در سطح بالا دارد که فایل‌های کامپایل‌شده در آن قرار خواهند گرفت. پکیج <code>adder</code> دایرکتوری <em>target</em> اختصاصی خود را ندارد. حتی اگر دستور <code>cargo build</code> را از داخل دایرکتوری <em>adder</em> اجرا کنیم، فایل‌های کامپایل‌شده همچنان در <em>add/target</em> قرار می‌گیرند نه در <em>add/adder/target</em>. Cargo دایرکتوری <em>target</em> را در یک workspace به این صورت ساختاردهی می‌کند زیرا crate‌های موجود در یک workspace برای وابستگی به یکدیگر طراحی شده‌اند. اگر هر crate دایرکتوری <em>target</em> اختصاصی خود را داشت، هر crate مجبور بود هر کدام از crate‌های دیگر را در workspace دوباره کامپایل کند تا فایل‌های کامپایل‌شده را در دایرکتوری <em>target</em> خود قرار دهد. با به اشتراک‌گذاری یک دایرکتوری <em>target</em>، crate‌ها می‌توانند از ساخت مجدد غیرضروری جلوگیری کنند.</p>
<h3 id="ایجاد-پکیج-دوم-در-workspace"><a class="header" href="#ایجاد-پکیج-دوم-در-workspace">ایجاد پکیج دوم در Workspace</a></h3>
<p>حالا، بیایید یک پکیج عضو دیگر در workspace ایجاد کنیم و آن را <code>add_one</code> بنامیم. فایل <em>Cargo.toml</em> در سطح بالا را تغییر دهید تا مسیر <em>add_one</em> را در لیست <code>members</code> مشخص کنید:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder", "add_one"]
</code></pre>
<p>سپس یک crate کتابخانه‌ای جدید به نام <code>add_one</code> ایجاد کنید:</p>
<pre><code class="language-console">$ cargo new add_one --lib
    Creating library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
</code></pre>
<p>دایرکتوری <em>add</em> شما اکنون باید شامل این دایرکتوری‌ها و فایل‌ها باشد:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>در فایل <em>add_one/src/lib.rs</em>، تابعی به نام <code>add_one</code> اضافه کنیم:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>حالا می‌توانیم پکیج <code>adder</code> که حاوی باینری ما است را وابسته به پکیج <code>add_one</code> که حاوی کتابخانه ما است کنیم. ابتدا باید یک وابستگی مسیر (path dependency) به <code>add_one</code> در فایل <em>adder/Cargo.toml</em> اضافه کنیم.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo فرض نمی‌کند که crate‌های موجود در یک workspace به یکدیگر وابسته هستند، بنابراین ما باید به صراحت روابط وابستگی را مشخص کنیم.</p>
<p>در ادامه، بیایید از تابع <code>add_one</code> (از crate به نام <code>add_one</code>) در crate به نام <code>adder</code> استفاده کنیم. فایل <em>adder/src/main.rs</em> را باز کنید و تابع <code>main</code> را تغییر دهید تا تابع <code>add_one</code> را فراخوانی کند، همان‌طور که در لیست ۱۴-۷ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: adder/src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}</code></pre>
<figcaption>Listing 14-7: Using the <code>add_one</code> library crate in the <code>adder</code> crate</figcaption>
</figure>
<p>بیایید workspace را با اجرای دستور <code>cargo build</code> در دایرکتوری سطح بالای <em>add</em> بسازیم!</p>
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>برای اجرای crate باینری از دایرکتوری <em>add</em>، می‌توانیم با استفاده از آرگومان <code>-p</code> و نام پکیج همراه با دستور <code>cargo run</code> مشخص کنیم کدام پکیج در workspace اجرا شود:</p>
<pre><code class="language-console">$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>این کد در فایل <em>adder/src/main.rs</em> را اجرا می‌کند که به crate <code>add_one</code> وابسته است.</p>
<h4 id="وابستگی-به-یک-پکیج-خارجی-در-یک-workspace"><a class="header" href="#وابستگی-به-یک-پکیج-خارجی-در-یک-workspace">وابستگی به یک پکیج خارجی در یک Workspace</a></h4>
<p>توجه کنید که workspace فقط یک فایل <em>Cargo.lock</em> در سطح بالا دارد، به جای اینکه هر crate دایرکتوری خود فایل <em>Cargo.lock</em> داشته باشد. این اطمینان حاصل می‌کند که تمام crate‌ها از همان نسخه تمام وابستگی‌ها استفاده می‌کنند. اگر پکیج <code>rand</code> را به فایل‌های <em>adder/Cargo.toml</em> و <em>add_one/Cargo.toml</em> اضافه کنیم، Cargo هر دو را به یک نسخه از <code>rand</code> تبدیل می‌کند و آن را در فایل <em>Cargo.lock</em> ثبت می‌کند. اطمینان از اینکه همه crate‌های موجود در workspace از همان وابستگی‌ها استفاده می‌کنند، به این معناست که crate‌ها همیشه با یکدیگر سازگار خواهند بود. بیایید پکیج <code>rand</code> را به بخش <code>[dependencies]</code> در فایل <em>add_one/Cargo.toml</em> اضافه کنیم تا بتوانیم از crate <code>rand</code> در crate <code>add_one</code> استفاده کنیم:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Filename: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>حالا می‌توانیم <code>use rand;</code> را به فایل <em>add_one/src/lib.rs</em> اضافه کنیم و با اجرای دستور <code>cargo build</code> در دایرکتوری <em>add</em> کل workspace را بسازیم، که crate <code>rand</code> را وارد کرده و کامپایل خواهد کرد. یک هشدار دریافت خواهیم کرد زیرا به <code>rand</code> که به محدوده وارد شده است اشاره‌ای نمی‌کنیم:</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s
</code></pre>
<p>فایل <em>Cargo.lock</em> در سطح بالا اکنون اطلاعاتی درباره وابستگی <code>add_one</code> به <code>rand</code> دارد. با این حال، حتی اگر <code>rand</code> در جایی از workspace استفاده شود، نمی‌توانیم از آن در crate‌های دیگر workspace استفاده کنیم مگر اینکه <code>rand</code> را به فایل‌های <em>Cargo.toml</em> آن‌ها نیز اضافه کنیم. برای مثال، اگر <code>use rand;</code> را به فایل <em>adder/src/main.rs</em> برای پکیج <code>adder</code> اضافه کنیم، با خطا مواجه خواهیم شد:</p>
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>برای رفع این مشکل، فایل <em>Cargo.toml</em> پکیج <code>adder</code> را ویرایش کرده و مشخص کنید که <code>rand</code> برای آن نیز یک وابستگی است. ساختن پکیج <code>adder</code>، <code>rand</code> را به لیست وابستگی‌های <code>adder</code> در فایل <em>Cargo.lock</em> اضافه می‌کند، اما هیچ نسخه اضافی از <code>rand</code> دانلود نخواهد شد. Cargo اطمینان حاصل می‌کند که هر crate در هر پکیجی از workspace که از پکیج <code>rand</code> استفاده می‌کند، از همان نسخه استفاده کند، به شرطی که نسخه‌های سازگار از <code>rand</code> را مشخص کنند. این کار فضای ما را ذخیره کرده و تضمین می‌کند که crate‌های workspace با یکدیگر سازگار خواهند بود.</p>
<p>اگر crate‌های workspace نسخه‌های ناسازگار از یک وابستگی را مشخص کنند، Cargo هر یک از آن‌ها را جداگانه حل خواهد کرد، اما همچنان تلاش می‌کند که تعداد نسخه‌های حل‌شده را به حداقل برساند.</p>
<h4 id="افزودن-یک-تست-به-یک-workspace"><a class="header" href="#افزودن-یک-تست-به-یک-workspace">افزودن یک تست به یک Workspace</a></h4>
<p>برای یک بهبود دیگر، بیایید یک تست برای تابع <code>add_one::add_one</code> در crate <code>add_one</code> اضافه کنیم:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>حالا دستور <code>cargo test</code> را در دایرکتوری سطح بالای <em>add</em> اجرا کنید. اجرای دستور <code>cargo test</code> در یک workspace با ساختاری مانند این، تست‌های تمام crate‌های موجود در workspace را اجرا خواهد کرد:</p>
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>بخش اول خروجی نشان می‌دهد که تست <code>it_works</code> در crate <code>add_one</code> پاس شده است. بخش بعدی نشان می‌دهد که هیچ تستی در crate <code>adder</code> پیدا نشده است، و سپس بخش آخر نشان می‌دهد که هیچ تست مستنداتی در crate <code>add_one</code> پیدا نشده است.</p>
<p>ما همچنین می‌توانیم تست‌های یک crate خاص در workspace را از دایرکتوری سطح بالا با استفاده از گزینه <code>-p</code> و مشخص کردن نام crate‌ای که می‌خواهیم تست کنیم، اجرا کنیم:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>این خروجی نشان می‌دهد که <code>cargo test</code> فقط تست‌های crate <code>add_one</code> را اجرا کرده و تست‌های crate <code>adder</code> را اجرا نکرده است.</p>
<p>اگر crate‌های موجود در workspace را در <a href="https://crates.io/">crates.io</a> منتشر کنید، هر crate در workspace باید به صورت جداگانه منتشر شود. مشابه با <code>cargo test</code>، می‌توانیم یک crate خاص را در workspace خود با استفاده از گزینه <code>-p</code> و مشخص کردن نام crate‌ای که می‌خواهیم منتشر کنیم، منتشر کنیم.</p>
<p>برای تمرین بیشتر، یک crate جدید به نام <code>add_two</code> به این workspace اضافه کنید، به شیوه‌ای مشابه crate <code>add_one</code>!</p>
<p>همان‌طور که پروژه شما رشد می‌کند، استفاده از یک workspace را در نظر بگیرید: فهمیدن اجزای کوچک‌تر و جداگانه آسان‌تر از کار کردن با یک کد بزرگ و یکپارچه است. علاوه بر این، نگه داشتن crate‌ها در یک workspace می‌تواند هماهنگی بین آن‌ها را آسان‌تر کند، به خصوص اگر crate‌ها اغلب به طور همزمان تغییر کنند.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- لینک قدیمی، حذف نکنید -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="نصب-باینریها-با-استفاده-از-cargo-install"><a class="header" href="#نصب-باینریها-با-استفاده-از-cargo-install">نصب باینری‌ها با استفاده از <code>cargo install</code></a></h2>
<p>دستور <code>cargo install</code> به شما این امکان را می‌دهد که crate‌های باینری را به صورت محلی نصب و استفاده کنید. این دستور به‌منظور جایگزینی بسته‌های سیستمی طراحی نشده است؛ بلکه یک راه آسان برای توسعه‌دهندگان Rust فراهم می‌کند تا ابزارهایی که دیگران در <a href="https://crates.io/">crates.io</a><!-- ignore --> به اشتراک گذاشته‌اند را نصب کنند. توجه داشته باشید که فقط پکیج‌هایی را که دارای هدف باینری هستند می‌توانید نصب کنید. <em>هدف باینری</em> برنامه قابل‌اجرا است که در صورتی ایجاد می‌شود که crate شامل یک فایل <em>src/main.rs</em> یا فایل دیگری باشد که به عنوان باینری مشخص شده است. این در مقابل هدف کتابخانه‌ای قرار دارد که به تنهایی قابل اجرا نیست، اما برای استفاده در سایر برنامه‌ها مناسب است. معمولاً crate‌ها در فایل <em>README</em> اطلاعاتی در مورد اینکه آیا یک crate کتابخانه است، دارای هدف باینری است یا هر دو، ارائه می‌دهند.</p>
<p>تمام باینری‌هایی که با <code>cargo install</code> نصب می‌شوند، در پوشه <em>bin</em> مسیر نصب ذخیره می‌شوند. اگر Rust را با استفاده از <em>rustup.rs</em> نصب کرده باشید و هیچ تنظیمات سفارشی نداشته باشید، این مسیر معمولاً <em>$HOME/.cargo/bin</em> خواهد بود. مطمئن شوید که این مسیر در متغیر محیطی <code>$PATH</code> شما قرار دارد تا بتوانید برنامه‌هایی که با <code>cargo install</code> نصب کرده‌اید اجرا کنید.</p>
<p>برای مثال، در فصل 12 اشاره کردیم که یک پیاده‌سازی Rust از ابزار <code>grep</code> به نام <code>ripgrep</code> وجود دارد که برای جستجوی فایل‌ها استفاده می‌شود. برای نصب <code>ripgrep</code> می‌توانیم دستور زیر را اجرا کنیم:</p>
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished `release` profile [optimized + debuginfo] target(s) in 10.64s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>خط دوم به آخر خروجی نشان می‌دهد که باینری نصب‌شده در کجا و با چه نامی قرار دارد؛ که در مورد <code>ripgrep</code> این باینری <code>rg</code> نام دارد. تا زمانی که مسیر نصب در متغیر <code>$PATH</code> شما باشد، همان‌طور که قبلاً ذکر شد، می‌توانید با اجرای <code>rg --help</code> استفاده از این ابزار سریع‌تر و مرتبط با Rust برای جستجوی فایل‌ها را شروع کنید!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="گسترش-cargo-با-دستورات-سفارشی"><a class="header" href="#گسترش-cargo-با-دستورات-سفارشی">گسترش Cargo با دستورات سفارشی</a></h2>
<div dir="rtl">
Cargo به گونه‌ای طراحی شده است که می‌توانید آن را با زیرفرمان‌های جدید گسترش دهید، بدون اینکه نیاز به تغییر در Cargo باشد. اگر یک باینری در مسیر `$PATH` شما با نام `cargo-something` وجود داشته باشد، می‌توانید آن را به گونه‌ای اجرا کنید که گویی یک زیرفرمان Cargo است، با اجرای `cargo something`. دستورات سفارشی مانند این نیز زمانی که `cargo --list` را اجرا می‌کنید، لیست می‌شوند. امکان استفاده از `cargo install` برای نصب افزونه‌ها و سپس اجرای آن‌ها مانند ابزارهای داخلی Cargo یکی از مزایای بسیار راحت طراحی Cargo است!
</div>
<h2 id="خلاصه-13"><a class="header" href="#خلاصه-13">خلاصه</a></h2>
<p>اشتراک‌گذاری کد با Cargo و <a href="https://crates.io/">crates.io</a><!-- ignore --> بخشی از عواملی است که اکوسیستم Rust را برای بسیاری از وظایف مختلف مفید می‌کند. کتابخانه استاندارد Rust کوچک و پایدار است، اما crate‌ها به راحتی قابل اشتراک‌گذاری، استفاده و بهبود هستند و با یک خط زمانی متفاوت از زبان توسعه می‌یابند. از اشتراک‌گذاری کدی که برای شما مفید است در <a href="https://crates.io/">crates.io</a><!-- ignore --> خجالت نکشید؛ احتمالاً برای دیگران نیز مفید خواهد بود!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="اشارهگر-pointerهای-هوشمند-smart-pointers"><a class="header" href="#اشارهگر-pointerهای-هوشمند-smart-pointers">اشاره‌گر (Pointer)های هوشمند (Smart Pointers)</a></h1>
<p><em>اشاره‌گر (Pointer)</em> یک مفهوم کلی برای یک متغیر است که شامل یک آدرس در حافظه می‌شود. این آدرس به برخی داده‌های دیگر
ارجاع می‌دهد یا به‌اصطلاح “اشاره می‌کند”. رایج‌ترین نوع اشاره‌گر (Pointer) در Rust یک ارجاع است که در فصل ۴ با آن آشنا شدید.
ارجاعات با نماد <code>&amp;</code> مشخص می‌شوند و مقدار مورد اشاره را قرض می‌گیرند. آن‌ها قابلیت‌های خاص دیگری به‌جز ارجاع به
داده ندارند و هیچ سرباری ندارند.</p>
<p>از سوی دیگر، <em>اشاره‌گر (Pointer)های هوشمند</em> ساختارهای داده‌ای هستند که مانند یک اشاره‌گر (Pointer) عمل می‌کنند، اما همچنین دارای
فرا داده و قابلیت‌های اضافی هستند. مفهوم اشاره‌گر (Pointer)های هوشمند منحصراً به Rust اختصاص ندارد: اشاره‌گر (Pointer)های هوشمند
در ابتدا در C++ معرفی شدند و در زبان‌های دیگر نیز وجود دارند. Rust مجموعه‌ای از اشاره‌گر (Pointer)های هوشمند در کتابخانه
استاندارد خود دارد که عملکردی فراتر از آنچه که ارجاعات فراهم می‌کنند، ارائه می‌دهند. برای بررسی مفهوم کلی، به چند
مثال مختلف از اشاره‌گر (Pointer)های هوشمند نگاهی خواهیم انداخت، از جمله نوع اشاره‌گر (Pointer) هوشمند <em>شمارش ارجاعات</em>. این اشاره‌گر (Pointer)
به شما امکان می‌دهد تا داده‌ها مالکیت‌های متعددی داشته باشند، با ردیابی تعداد مالکان و پاک کردن داده هنگامی که
هیچ مالکی باقی نماند.</p>
<p>Rust با مفهوم مالکیت و قرض گرفتن خود، تفاوت اضافی بین ارجاعات و اشاره‌گر (Pointer)های هوشمند دارد: در حالی که ارجاعات فقط
داده‌ها را قرض می‌گیرند، در بسیاری از موارد اشاره‌گر (Pointer)های هوشمند <em>مالک</em> داده‌ای هستند که به آن اشاره می‌کنند.</p>
<p>اگرچه در آن زمان آن‌ها را به این صورت نام نبردیم، اما قبلاً با چند اشاره‌گر (Pointer) هوشمند در این کتاب آشنا شده‌ایم، از
جمله <code>String</code> و <code>Vec&lt;T&gt;</code> در فصل ۸. هر دوی این نوع‌ها به‌عنوان اشاره‌گر (Pointer)های هوشمند در نظر گرفته می‌شوند زیرا آن‌ها
مقداری حافظه را مالک می‌شوند و به شما امکان می‌دهند آن را دست‌کاری کنید. آن‌ها همچنین دارای فرا داده و قابلیت‌ها
یا تضمین‌های اضافی هستند. برای مثال، <code>String</code> ظرفیت خود را به‌عنوان فرا داده ذخیره می‌کند و دارای قابلیت اضافی
برای اطمینان از این است که داده‌های آن همیشه یک UTF-8 معتبر خواهد بود.</p>
<p>اشاره‌گر (Pointer)های هوشمند معمولاً با استفاده از ساختارها (structs) پیاده‌سازی می‌شوند. برخلاف یک ساختار عادی، اشاره‌گر (Pointer)های
هوشمند ویژگی‌های <code>Deref</code> و <code>Drop</code> را پیاده‌سازی می‌کنند. ویژگی <code>Deref</code> به نمونه‌ای از ساختار اشاره‌گر (Pointer) هوشمند
امکان می‌دهد که مانند یک ارجاع عمل کند، بنابراین می‌توانید کد خود را بنویسید تا با ارجاعات یا اشاره‌گر (Pointer)های هوشمند
کار کند. ویژگی <code>Drop</code> به شما امکان می‌دهد کدی را که هنگام خارج شدن یک نمونه از اشاره‌گر (Pointer) هوشمند از محدوده اجرا
می‌شود، سفارشی‌سازی کنید. در این فصل، هر دو ویژگی را بررسی خواهیم کرد و نشان خواهیم داد که چرا برای اشاره‌گر (Pointer)های
هوشمند مهم هستند.</p>
<p>از آنجا که الگوی اشاره‌گر (Pointer) هوشمند یک الگوی طراحی کلی است که به‌طور مکرر در Rust استفاده می‌شود، این فصل تمام
اشاره‌گر (Pointer)های هوشمند موجود را پوشش نمی‌دهد. بسیاری از کتابخانه‌ها اشاره‌گر (Pointer)های هوشمند خاص خود را دارند و حتی می‌توانید
اشاره‌گر (Pointer) هوشمند خود را بنویسید. ما رایج‌ترین اشاره‌گر (Pointer)های هوشمند در کتابخانه استاندارد را پوشش خواهیم داد:</p>
<ul>
<li><code>Box&lt;T&gt;</code> برای تخصیص مقادیر در heap</li>
<li><code>Rc&lt;T&gt;</code>، یک نوع شمارش ارجاعات که امکان مالکیت چندگانه را فراهم می‌کند</li>
<li><code>Ref&lt;T&gt;</code> و <code>RefMut&lt;T&gt;</code>، که از طریق <code>RefCell&lt;T&gt;</code> قابل دسترسی هستند، نوعی که قوانین قرض گرفتن را در زمان اجرا
به‌جای زمان کامپایل اعمال می‌کند</li>
</ul>
<p>علاوه بر این، الگوی <em>تغییرپذیری داخلی</em> را پوشش خواهیم داد، جایی که یک نوع غیرقابل تغییر یک API برای تغییر یک مقدار
داخلی ارائه می‌دهد. ما همچنین در مورد <em>حلقه‌های ارجاع</em> بحث خواهیم کرد: چگونه می‌توانند حافظه را نشت دهند و چگونه
می‌توان از آن‌ها جلوگیری کرد.</p>
<p>بیایید شروع کنیم!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="استفاده-از-boxt-برای-اشاره-به-دادهها-در-heap"><a class="header" href="#استفاده-از-boxt-برای-اشاره-به-دادهها-در-heap">استفاده از <code>Box&lt;T&gt;</code> برای اشاره به داده‌ها در Heap</a></h2>
<p>ساده‌ترین اشاره‌گر (Pointer) هوشمند یک <em>جعبه</em> است که نوع آن به صورت <code>Box&lt;T&gt;</code> نوشته می‌شود. جعبه‌ها به شما امکان می‌دهند
داده‌ها را در heap ذخیره کنید به جای stack. چیزی که در stack باقی می‌ماند، اشاره‌گر (Pointer)ی به داده‌های heap است. برای
مرور تفاوت بین stack و heap به فصل ۴ مراجعه کنید.</p>
<p>جعبه‌ها هیچ سربار عملکردی ندارند، به‌جز ذخیره داده‌های خود در heap به جای stack. اما آن‌ها قابلیت‌های اضافی زیادی
ندارند. شما اغلب آن‌ها را در این موقعیت‌ها استفاده خواهید کرد:</p>
<ul>
<li>هنگامی که نوعی دارید که اندازه آن در زمان کامپایل مشخص نیست و می‌خواهید از مقداری از آن نوع در محیطی که نیاز
به اندازه دقیق دارد استفاده کنید.</li>
<li>هنگامی که مقدار زیادی داده دارید و می‌خواهید مالکیت را انتقال دهید، اما اطمینان حاصل کنید که داده‌ها هنگام انجام
این کار کپی نمی‌شوند.</li>
<li>هنگامی که می‌خواهید مالک یک مقدار باشید و فقط اهمیت می‌دهید که آن نوع، یک صفت خاص را پیاده‌سازی کرده باشد
نه اینکه از یک نوع خاص باشد.</li>
</ul>
<p>اولین حالت را در بخش <a href="ch15-01-box.html#enabling-recursive-types-with-boxes">“فعال‌سازی انواع بازگشتی با استفاده از جعبه‌ها”</a><!-- 
ignore --> بررسی خواهیم کرد. در حالت دوم، انتقال مالکیت مقدار زیادی داده می‌تواند زمان زیادی بگیرد زیرا داده‌ها
در stack کپی می‌شوند. برای بهبود عملکرد در این حالت، می‌توانیم مقدار زیادی داده را در heap و در یک جعبه ذخیره
کنیم. سپس، تنها مقدار کمی از داده‌های اشاره‌گر (Pointer) در stack کپی می‌شود، در حالی که داده‌هایی که به آن‌ها اشاره می‌کند
در یک مکان در heap باقی می‌مانند. حالت سوم به نام <em>شیء صفت</em> شناخته می‌شود و فصل ۱۸ بخشی کامل به نام <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“استفاده
از اشیای صفت که به شما اجازه می‌دهند مقادیر از انواع مختلف داشته باشید”</a><!-- ignore --> به این
موضوع اختصاص داده است. بنابراین چیزی که اینجا یاد می‌گیرید، دوباره در فصل ۱۸ استفاده خواهید کرد!</p>
<h3 id="استفاده-از-boxt-برای-ذخیره-دادهها-در-heap"><a class="header" href="#استفاده-از-boxt-برای-ذخیره-دادهها-در-heap">استفاده از <code>Box&lt;T&gt;</code> برای ذخیره داده‌ها در Heap</a></h3>
<p>قبل از اینکه مورد استفاده ذخیره در heap برای <code>Box&lt;T&gt;</code> را بحث کنیم، نحو و نحوه تعامل با مقادیر ذخیره‌شده در
یک <code>Box&lt;T&gt;</code> را پوشش خواهیم داد.</p>
<p>لیستینگ ۱۵-۱ نشان می‌دهد چگونه می‌توان از یک جعبه برای ذخیره مقدار <code>i32</code> در heap استفاده کرد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<figcaption>Listing 15-1: ذخیره مقدار <code>i32</code> در heap با استفاده از یک جعبه</figcaption>
</figure>
<p>ما متغیر <code>b</code> را تعریف می‌کنیم تا مقدار یک <code>Box</code> که به مقدار <code>5</code> اشاره می‌کند را داشته باشد، که در heap تخصیص
داده شده است. این برنامه <code>b = 5</code> را چاپ می‌کند؛ در این حالت، می‌توانیم به داده‌های موجود در جعبه دسترسی داشته
باشیم، مشابه حالتی که این داده‌ها در stack بودند. درست مثل هر مقدار مالک، وقتی یک جعبه از دامنه خارج می‌شود، همان
طور که <code>b</code> در پایان <code>main</code> این کار را می‌کند، آزاد می‌شود. آزادسازی هم برای جعبه (ذخیره‌شده در stack) و هم داده‌هایی
که به آن اشاره می‌کند (ذخیره‌شده در heap) اتفاق می‌افتد.</p>
<p>قرار دادن یک مقدار واحد در heap خیلی مفید نیست، بنابراین جعبه‌ها را به‌تنهایی به این شکل خیلی استفاده نخواهید
کرد. داشتن مقادیری مانند یک <code>i32</code> در stack، جایی که به‌طور پیش‌فرض ذخیره می‌شوند، در اکثر موارد مناسب‌تر است. بیایید
به حالتی نگاه کنیم که جعبه‌ها به ما امکان می‌دهند انواعی را تعریف کنیم که بدون آن‌ها نمی‌توانستیم.</p>
<h3 id="فعالسازی-انواع-بازگشتی-با-استفاده-از-جعبهها"><a class="header" href="#فعالسازی-انواع-بازگشتی-با-استفاده-از-جعبهها">فعال‌سازی انواع بازگشتی با استفاده از جعبه‌ها</a></h3>
<p>یک مقدار از نوع <em>بازگشتی</em> می‌تواند مقدار دیگری از همان نوع را به‌عنوان بخشی از خود داشته باشد. انواع بازگشتی
یک مسئله ایجاد می‌کنند زیرا در زمان کامپایل، Rust باید بداند یک نوع چقدر فضا اشغال می‌کند. با این حال، تودرتویی
مقادیر انواع بازگشتی می‌تواند به‌طور نظری بی‌نهایت ادامه یابد، بنابراین Rust نمی‌تواند بداند که مقدار چقدر فضا
نیاز دارد. چون جعبه‌ها یک اندازه مشخص دارند، می‌توانیم انواع بازگشتی را با قرار دادن یک جعبه در تعریف نوع بازگشتی
فعال کنیم.</p>
<p>به‌عنوان مثالی از یک نوع بازگشتی، بیایید به <em>لیست cons</em> نگاه کنیم. این یک نوع داده است که معمولاً در زبان‌های
برنامه‌نویسی تابعی یافت می‌شود. نوع لیست cons که تعریف خواهیم کرد ساده است به جز بازگشت؛ بنابراین، مفاهیم موجود
در مثالی که با آن کار خواهیم کرد، هر زمان که وارد موقعیت‌های پیچیده‌تری با انواع بازگشتی شوید مفید خواهند بود.</p>
<h4 id="اطلاعات-بیشتر-درباره-لیست-cons"><a class="header" href="#اطلاعات-بیشتر-درباره-لیست-cons">اطلاعات بیشتر درباره لیست Cons</a></h4>
<p>یک <em>لیست cons</em> یک ساختار داده‌ای است که از زبان برنامه‌نویسی Lisp و گویش‌های آن می‌آید و از جفت‌های تودرتو تشکیل
شده است و نسخه Lisp از یک لیست پیوندی است. نام آن از تابع <code>cons</code> (مخفف “تابع ساخت” یا Construct Function) در Lisp
گرفته شده است که یک جفت جدید را از دو آرگومان خود می‌سازد. با فراخوانی <code>cons</code> روی یک جفت که شامل یک مقدار و یک جفت
دیگر است، می‌توانیم لیست‌های cons ساخته‌شده از جفت‌های بازگشتی را ایجاد کنیم.</p>
<p>برای مثال، در اینجا یک نمایش شبه‌کد از یک لیست cons که شامل لیست ۱، ۲، ۳ است آورده شده است که هر جفت در داخل پرانتز
قرار دارد:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>هر آیتم در یک لیست cons شامل دو عنصر است: مقدار آیتم فعلی و آیتم بعدی. آخرین آیتم در لیست تنها شامل مقداری به نام
<code>Nil</code> است و آیتم بعدی ندارد. یک لیست cons با فراخوانی بازگشتی تابع <code>cons</code> تولید می‌شود. نام متعارف برای نشان دادن
حالت پایه بازگشت، <code>Nil</code> است. توجه داشته باشید که این با مفهوم “null” یا “nil” در فصل ۶ که یک مقدار نامعتبر یا غایب
است، متفاوت است.</p>
<p>لیست cons یک ساختار داده‌ای نیست که به‌طور معمول در Rust استفاده شود. در اکثر مواقع وقتی یک لیست از آیتم‌ها در
Rust دارید، استفاده از <code>Vec&lt;T&gt;</code> انتخاب بهتری است. سایر انواع بازگشتی پیچیده‌تر <em>در</em> موقعیت‌های مختلف مفید هستند،
اما با شروع از لیست cons در این فصل، می‌توانیم بررسی کنیم که چگونه جعبه‌ها به ما اجازه می‌دهند یک نوع داده بازگشتی
را بدون حواس‌پرتی زیاد تعریف کنیم.</p>
<p>لیستینگ ۱۵-۲ حاوی یک تعریف enum برای یک لیست cons است. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود زیرا نوع
<code>List</code> اندازه شناخته‌شده‌ای ندارد، که آن را توضیح خواهیم داد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption>Listing 15-2: اولین تلاش برای تعریف یک enum برای نمایش یک ساختار داده‌ای لیست cons از مقادیر <code>i32</code></figcaption>
</figure>
<blockquote>
<p>توجه: ما در حال پیاده‌سازی یک لیست cons هستیم که تنها مقادیر <code>i32</code> را نگه می‌دارد، برای اهداف این مثال. می‌توانستیم
آن را با استفاده از جنریک‌ها، همان‌طور که در فصل ۱۰ بحث کردیم، پیاده‌سازی کنیم تا یک نوع لیست cons تعریف کنیم
که بتواند مقادیر هر نوعی را ذخیره کند.</p>
</blockquote>
<p>استفاده از نوع <code>List</code> برای ذخیره لیست <code>1, 2, 3</code> شبیه به کدی خواهد بود که در لیستینگ ۱۵-۳ آورده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<figcaption>Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></figcaption>
</figure>
<p>اولین مقدار <code>Cons</code> مقدار <code>1</code> و یک مقدار دیگر از نوع <code>List</code> را نگه می‌دارد. این مقدار <code>List</code> یک مقدار دیگر از نوع
<code>Cons</code> است که مقدار <code>2</code> و یک مقدار دیگر از نوع <code>List</code> را نگه می‌دارد. این مقدار <code>List</code> یک مقدار دیگر از نوع <code>Cons</code>
را نگه می‌دارد که مقدار <code>3</code> و یک مقدار دیگر از نوع <code>List</code> را دارد که در نهایت <code>Nil</code>، متغیر غیر بازگشتی که پایان
لیست را نشان می‌دهد، است.</p>
<p>اگر سعی کنیم کد در لیستینگ ۱۵-۳ را کامپایل کنیم، خطایی را دریافت می‌کنیم که در لیستینگ ۱۵-۴ نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: output.txt</span>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<figcaption>Listing 15-4: خطایی که هنگام تلاش برای تعریف یک enum بازگشتی دریافت می‌کنیم</figcaption>
</figure>
<p>خطا نشان می‌دهد که این نوع “اندازه بی‌نهایت” دارد. دلیل این است که ما <code>List</code> را با یک متغیر تعریف کرده‌ایم که
بازگشتی است: به‌طور مستقیم یک مقدار دیگر از نوع خود را نگه می‌دارد. در نتیجه، Rust نمی‌تواند بفهمد چقدر فضا نیاز
دارد تا یک مقدار از نوع <code>List</code> را ذخیره کند. بیایید بررسی کنیم چرا این خطا را دریافت می‌کنیم. ابتدا، نگاهی به این
می‌اندازیم که Rust چگونه تصمیم می‌گیرد چه مقدار فضا برای ذخیره یک مقدار از نوع غیر بازگشتی نیاز دارد.</p>
<h4 id="محاسبه-اندازه-یک-نوع-غیر-بازگشتی"><a class="header" href="#محاسبه-اندازه-یک-نوع-غیر-بازگشتی">محاسبه اندازه یک نوع غیر بازگشتی</a></h4>
<p>ساختار <code>Message</code> را که در لیستینگ ۶-۲ تعریف کرده‌ایم، به‌خاطر بیاورید وقتی که در فصل ۶ در مورد تعریف‌های enum
بحث کردیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>برای تعیین اینکه چقدر فضا برای یک مقدار از نوع <code>Message</code> اختصاص داده شود، Rust هر یک از متغیرها را بررسی می‌کند
تا ببیند کدام متغیر بیشترین فضا را نیاز دارد. Rust می‌بیند که <code>Message::Quit</code> نیازی به فضا ندارد، <code>Message::Move</code>
نیاز به فضای کافی برای ذخیره دو مقدار <code>i32</code> دارد، و همین‌طور ادامه می‌دهد. چون تنها یک متغیر استفاده خواهد شد،
بیشترین فضای مورد نیاز برای یک مقدار <code>Message</code> فضایی است که بزرگ‌ترین متغیر آن اشغال می‌کند.</p>
<p>این را با حالتی مقایسه کنید که Rust سعی می‌کند تعیین کند چه مقدار فضا برای یک نوع بازگشتی مانند enum <code>List</code> در
لیستینگ ۱۵-۲ نیاز است. کامپایلر با نگاه کردن به متغیر <code>Cons</code> شروع می‌کند که یک مقدار از نوع <code>i32</code> و یک مقدار از نوع
<code>List</code> را نگه می‌دارد. بنابراین، <code>Cons</code> به فضایی معادل اندازه یک <code>i32</code> به‌علاوه اندازه یک <code>List</code> نیاز دارد. برای
فهمیدن اینکه نوع <code>List</code> به چه مقدار حافظه نیاز دارد، کامپایلر متغیرها را بررسی می‌کند و از متغیر <code>Cons</code> شروع می‌کند.
متغیر <code>Cons</code> یک مقدار از نوع <code>i32</code> و یک مقدار از نوع <code>List</code> را نگه می‌دارد، و این فرآیند به‌طور بی‌نهایت ادامه
می‌یابد، همان‌طور که در شکل ۱۵-۱ نشان داده شده است.</p>
<img alt="یک لیست Cons بی‌نهایت" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">شکل ۱۵-۱: یک <code>List</code> بی‌نهایت شامل متغیرهای <code>Cons</code> بی‌نهایت</span></p>
<h4 id="استفاده-از-boxt-برای-بهدست-آوردن-یک-نوع-بازگشتی-با-اندازه-شناختهشده"><a class="header" href="#استفاده-از-boxt-برای-بهدست-آوردن-یک-نوع-بازگشتی-با-اندازه-شناختهشده">استفاده از <code>Box&lt;T&gt;</code> برای به‌دست آوردن یک نوع بازگشتی با اندازه شناخته‌شده</a></h4>
<p>چون Rust نمی‌تواند بفهمد چه مقدار فضا باید برای انواع تعریف‌شده به‌صورت بازگشتی تخصیص دهد، کامپایلر با این پیشنهاد
کمکی خطا می‌دهد:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>در این پیشنهاد، “غیرمستقیم‌سازی” به این معنا است که به‌جای ذخیره مستقیم یک مقدار، باید ساختار داده را تغییر دهیم تا
مقدار را به‌صورت غیرمستقیم با ذخیره یک اشاره‌گر (Pointer) به مقدار ذخیره کند.</p>
<p>چون <code>Box&lt;T&gt;</code> یک اشاره‌گر (Pointer) است، Rust همیشه می‌داند که یک <code>Box&lt;T&gt;</code> به چه مقدار فضا نیاز دارد: اندازه یک اشاره‌گر (Pointer)
بر اساس مقدار داده‌ای که به آن اشاره می‌کند تغییر نمی‌کند. این بدان معنا است که می‌توانیم یک <code>Box&lt;T&gt;</code> را در
متغیر <code>Cons</code> قرار دهیم به‌جای یک مقدار دیگر از نوع <code>List</code>. <code>Box&lt;T&gt;</code> به مقدار بعدی <code>List</code> اشاره می‌کند که روی heap
خواهد بود به‌جای داخل متغیر <code>Cons</code>. به‌صورت مفهومی، ما همچنان یک لیست داریم که از لیست‌های دیگری تشکیل شده است، اما
این پیاده‌سازی اکنون بیشتر شبیه قرار دادن آیتم‌ها در کنار یکدیگر است تا داخل یکدیگر.</p>
<p>ما می‌توانیم تعریف enum <code>List</code> در لیستینگ ۱۵-۲ و استفاده از <code>List</code> در لیستینگ ۱۵-۳ را به کد موجود در لیستینگ ۱۵-۵
تغییر دهیم، که کامپایل خواهد شد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<figcaption>Listing 15-5: تعریف <code>List</code> که از <code>Box&lt;T&gt;</code> استفاده می‌کند تا اندازه مشخصی داشته باشد</figcaption>
</figure>
<p>متغیر <code>Cons</code> به اندازه یک <code>i32</code> به‌علاوه فضای مورد نیاز برای ذخیره داده‌های اشاره‌گر (Pointer) جعبه نیاز دارد. متغیر <code>Nil</code> هیچ
مقداری را ذخیره نمی‌کند، بنابراین به فضای کمتری نسبت به متغیر <code>Cons</code> نیاز دارد. اکنون می‌دانیم که هر مقدار <code>List</code>
به اندازه یک <code>i32</code> به‌علاوه اندازه داده‌های اشاره‌گر (Pointer) جعبه فضا نیاز دارد. با استفاده از جعبه، زنجیره بازگشتی بی‌نهایت
را شکسته‌ایم، بنابراین کامپایلر می‌تواند بفهمد چه مقدار فضا برای ذخیره یک مقدار <code>List</code> نیاز دارد. شکل ۱۵-۲ نشان
می‌دهد که متغیر <code>Cons</code> اکنون چگونه به نظر می‌رسد.</p>
<img alt="یک لیست Cons محدود" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">شکل ۱۵-۲: یک <code>List</code> که بی‌نهایت نیست زیرا <code>Cons</code> یک <code>Box</code> نگه می‌دارد</span></p>
<p>جعبه‌ها تنها غیرمستقیم‌سازی و تخصیص heap را فراهم می‌کنند؛ آن‌ها هیچ قابلیت خاص دیگری ندارند، مانند آنچه با دیگر انواع
اشاره‌گر (Pointer) هوشمند خواهیم دید. آن‌ها همچنین سربار عملکردی که این قابلیت‌های خاص ایجاد می‌کنند را ندارند، بنابراین می‌توانند
در مواردی مانند لیست cons مفید باشند که غیرمستقیم‌سازی تنها ویژگی مورد نیاز است. ما موارد استفاده بیشتری از جعبه‌ها را
نیز در فصل ۱۸ بررسی خواهیم کرد.</p>
<p>نوع <code>Box&lt;T&gt;</code> یک اشاره‌گر (Pointer) هوشمند است زیرا ویژگی <code>Deref</code> را پیاده‌سازی می‌کند، که به مقادیر <code>Box&lt;T&gt;</code> اجازه می‌دهد
مانند ارجاعات رفتار کنند. وقتی یک مقدار <code>Box&lt;T&gt;</code> از دامنه خارج می‌شود، داده‌های heap که جعبه به آن اشاره می‌کند
نیز به دلیل پیاده‌سازی ویژگی <code>Drop</code> پاک‌سازی می‌شود. این دو ویژگی برای عملکرد انواع دیگر اشاره‌گر (Pointer)های هوشمند که
در بقیه این فصل مورد بحث قرار می‌دهیم، اهمیت بیشتری خواهند داشت. بیایید این دو ویژگی را با جزئیات بیشتری بررسی کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="رفتار-اشارهگر-pointerهای-هوشمند-مانند-ارجاعات-معمولی-با-استفاده-از-ویژگی-deref"><a class="header" href="#رفتار-اشارهگر-pointerهای-هوشمند-مانند-ارجاعات-معمولی-با-استفاده-از-ویژگی-deref">رفتار اشاره‌گر (Pointer)های هوشمند مانند ارجاعات معمولی با استفاده از ویژگی <code>Deref</code></a></h2>
<p>پیاده‌سازی ویژگی <code>Deref</code> به شما امکان می‌دهد رفتار <em>عملگر اشاره‌گر (Pointer)‌زدایی</em> <code>*</code> را سفارشی کنید (این را با عملگر
ضرب یا glob اشتباه نگیرید). با پیاده‌سازی <code>Deref</code> به گونه‌ای که یک اشاره‌گر (Pointer) هوشمند بتواند مانند یک ارجاع معمولی
رفتار کند، می‌توانید کدی بنویسید که روی ارجاعات عمل می‌کند و از آن کد با اشاره‌گر (Pointer)های هوشمند نیز استفاده کنید.</p>
<p>ابتدا بیایید نگاهی به این بیندازیم که چگونه عملگر اشاره‌گر (Pointer)‌زدایی با ارجاعات معمولی کار می‌کند. سپس سعی می‌کنیم یک
نوع سفارشی تعریف کنیم که مانند <code>Box&lt;T&gt;</code> رفتار کند، و بررسی کنیم چرا عملگر اشاره‌گر (Pointer)‌زدایی مانند یک ارجاع روی نوع
جدید ما عمل نمی‌کند. ما بررسی می‌کنیم که چگونه پیاده‌سازی ویژگی <code>Deref</code> امکان‌پذیر می‌سازد که اشاره‌گر (Pointer)های هوشمند
به شیوه‌ای مشابه ارجاعات عمل کنند. سپس نگاهی به ویژگی <em>فشار اشاره‌گر (Pointer)‌زدایی</em> (deref coercion) در Rust می‌اندازیم و
اینکه چگونه به ما اجازه می‌دهد با ارجاعات یا اشاره‌گر (Pointer)های هوشمند کار کنیم.</p>
<blockquote>
<p>توجه: یک تفاوت بزرگ بین نوع <code>MyBox&lt;T&gt;</code> که قرار است بسازیم و <code>Box&lt;T&gt;</code> واقعی وجود دارد: نسخه ما داده‌های خود
را در heap ذخیره نمی‌کند. ما این مثال را بر روی <code>Deref</code> متمرکز کرده‌ایم، بنابراین مکانی که داده‌ها واقعاً در
آن ذخیره می‌شوند کمتر از رفتار اشاره‌گر (Pointer)گونه اهمیت دارد.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="دنبال-کردن-اشارهگر-pointer-به-مقدار"><a class="header" href="#دنبال-کردن-اشارهگر-pointer-به-مقدار">دنبال کردن اشاره‌گر (Pointer) به مقدار</a></h3>
<p>یک ارجاع معمولی نوعی اشاره‌گر (Pointer) است، و یکی از راه‌های فکر کردن به یک اشاره‌گر (Pointer) این است که به عنوان یک فلش به یک
مقدار ذخیره‌شده در جای دیگری در نظر گرفته شود. در لیستینگ ۱۵-۶، ما یک ارجاع به یک مقدار <code>i32</code> ایجاد می‌کنیم و
سپس از عملگر اشاره‌گر (Pointer)‌زدایی برای دنبال کردن ارجاع به مقدار استفاده می‌کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption>Listing 15-6: استفاده از عملگر اشاره‌گر (Pointer)‌زدایی برای دنبال کردن یک ارجاع به یک مقدار <code>i32</code></figcaption>
</figure>
<p>متغیر <code>x</code> مقدار <code>i32</code> برابر با <code>5</code> را نگه می‌دارد. ما <code>y</code> را برابر با یک ارجاع به <code>x</code> تنظیم می‌کنیم. می‌توانیم
تایید کنیم که <code>x</code> برابر با <code>5</code> است. با این حال، اگر بخواهیم یک تایید روی مقدار داخل <code>y</code> انجام دهیم، باید از
<code>*y</code> برای دنبال کردن ارجاع به مقداری که به آن اشاره می‌کند استفاده کنیم (بنابراین <em>اشاره‌گر (Pointer)‌زدایی</em>) تا کامپایلر
بتواند مقدار واقعی را مقایسه کند. وقتی <code>y</code> را اشاره‌گر (Pointer)‌زدایی می‌کنیم، به مقدار صحیحی که <code>y</code> به آن اشاره می‌کند
دسترسی داریم و می‌توانیم آن را با <code>5</code> مقایسه کنیم.</p>
<p>اگر بخواهیم <code>assert_eq!(5, y);</code> بنویسیم، خطای کامپایل زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>مقایسه یک عدد با یک ارجاع به عدد مجاز نیست زیرا آن‌ها انواع متفاوتی هستند. ما باید از عملگر اشاره‌گر (Pointer)‌زدایی برای
دنبال کردن ارجاع به مقداری که به آن اشاره می‌کند استفاده کنیم.</p>
<h3 id="استفاده-از-boxt-مانند-یک-ارجاع"><a class="header" href="#استفاده-از-boxt-مانند-یک-ارجاع">استفاده از <code>Box&lt;T&gt;</code> مانند یک ارجاع</a></h3>
<p>ما می‌توانیم کد لیستینگ ۱۵-۶ را برای استفاده از یک <code>Box&lt;T&gt;</code> به‌جای یک ارجاع بازنویسی کنیم؛ عملگر اشاره‌گر (Pointer)‌زدایی
که روی <code>Box&lt;T&gt;</code> در لیستینگ ۱۵-۷ استفاده شده است، به همان شیوه‌ای عمل می‌کند که روی ارجاع در لیستینگ ۱۵-۶ عمل
می‌کرد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption>Listing 15-7: استفاده از عملگر اشاره‌گر (Pointer)‌زدایی روی یک <code>Box&lt;i32&gt;</code></figcaption>
</figure>
<p>تفاوت اصلی بین لیستینگ ۱۵-۷ و لیستینگ ۱۵-۶ این است که در اینجا <code>y</code> را به‌عنوان یک نمونه از <code>Box&lt;T&gt;</code> تنظیم می‌کنیم
که به یک مقدار کپی‌شده از <code>x</code> اشاره می‌کند، به‌جای یک ارجاع که به مقدار <code>x</code> اشاره می‌کند. در تایید نهایی،
می‌توانیم از عملگر اشاره‌گر (Pointer)‌زدایی برای دنبال کردن اشاره‌گر (Pointer) <code>Box&lt;T&gt;</code> به همان شیوه‌ای که زمانی که <code>y</code> یک ارجاع
بود استفاده کردیم. در ادامه بررسی می‌کنیم چه چیزی در مورد <code>Box&lt;T&gt;</code> خاص است که به ما اجازه می‌دهد از عملگر
اشاره‌گر (Pointer)‌زدایی استفاده کنیم، با تعریف نوع خودمان.</p>
<h3 id="تعریف-اشارهگر-pointer-هوشمند-خودمان"><a class="header" href="#تعریف-اشارهگر-pointer-هوشمند-خودمان">تعریف اشاره‌گر (Pointer) هوشمند خودمان</a></h3>
<p>بیایید یک اشاره‌گر (Pointer) هوشمند مشابه نوع <code>Box&lt;T&gt;</code> که توسط کتابخانه استاندارد ارائه شده است بسازیم تا تجربه کنیم که
چگونه اشاره‌گر (Pointer)های هوشمند به طور پیش‌فرض متفاوت از ارجاعات رفتار می‌کنند. سپس به نحوه اضافه کردن قابلیت استفاده از
عملگر اشاره‌گر (Pointer)‌زدایی می‌پردازیم.</p>
<p>نوع <code>Box&lt;T&gt;</code> در نهایت به عنوان یک ساختار tuple با یک عنصر تعریف شده است، بنابراین لیستینگ ۱۵-۸ نوع <code>MyBox&lt;T&gt;</code>
را به همان روش تعریف می‌کند. همچنین یک تابع <code>new</code> تعریف می‌کنیم تا با تابع <code>new</code> تعریف‌شده روی <code>Box&lt;T&gt;</code>
مطابقت داشته باشد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 15-8: تعریف نوع <code>MyBox&lt;T&gt;</code></figcaption>
</figure>
<p>ما یک ساختار با نام <code>MyBox</code> تعریف می‌کنیم و یک پارامتر جنریک <code>T</code> اعلام می‌کنیم، زیرا می‌خواهیم نوع ما مقادیر
از هر نوعی را نگه دارد. نوع <code>MyBox</code> یک ساختار tuple با یک عنصر از نوع <code>T</code> است. تابع <code>MyBox::new</code> یک پارامتر از نوع
<code>T</code> می‌گیرد و یک نمونه از <code>MyBox</code> که مقدار ورودی را نگه می‌دارد برمی‌گرداند.</p>
<p>بیایید تابع <code>main</code> در لیستینگ ۱۵-۷ را به لیستینگ ۱۵-۸ اضافه کنیم و آن را برای استفاده از نوع <code>MyBox&lt;T&gt;</code> که
تعریف کرده‌ایم، به جای <code>Box&lt;T&gt;</code> تغییر دهیم. کد موجود در لیستینگ ۱۵-۹ کامپایل نخواهد شد، زیرا Rust نمی‌داند
چگونه <code>MyBox</code> را اشاره‌گر (Pointer)‌زدایی کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<figcaption>Listing 15-9: تلاش برای استفاده از <code>MyBox&lt;T&gt;</code> به همان شیوه‌ای که از ارجاعات و <code>Box&lt;T&gt;</code> استفاده کردیم</figcaption>
</figure>
<p>در اینجا خطای کامپایل که نتیجه می‌شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>نوع <code>MyBox&lt;T&gt;</code> ما نمی‌تواند اشاره‌گر (Pointer)‌زدایی شود زیرا ما این قابلیت را روی نوع خود پیاده‌سازی نکرده‌ایم. برای فعال
کردن اشاره‌گر (Pointer)‌زدایی با عملگر <code>*</code>، ما ویژگی <code>Deref</code> را پیاده‌سازی می‌کنیم.</p>
<h3 id="رفتار-دادن-به-یک-نوع-مانند-یک-ارجاع-با-پیادهسازی-ویژگی-deref"><a class="header" href="#رفتار-دادن-به-یک-نوع-مانند-یک-ارجاع-با-پیادهسازی-ویژگی-deref">رفتار دادن به یک نوع مانند یک ارجاع با پیاده‌سازی ویژگی <code>Deref</code></a></h3>
<p>همان‌طور که در بخش <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“پیاده‌سازی یک ویژگی روی یک نوع”</a><!-- ignore --> فصل ۱۰ بحث شد، برای پیاده‌سازی یک
ویژگی، باید پیاده‌سازی‌هایی برای متدهای مورد نیاز ویژگی ارائه دهیم. ویژگی <code>Deref</code> که توسط کتابخانه استاندارد
ارائه شده است، از ما می‌خواهد که یک متد به نام <code>deref</code> را پیاده‌سازی کنیم که <code>self</code> را قرض بگیرد و یک ارجاع به
داده داخلی بازگرداند. لیستینگ ۱۵-۱۰ شامل یک پیاده‌سازی از <code>Deref</code> است که به تعریف <code>MyBox</code> اضافه شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 15-10: پیاده‌سازی <code>Deref</code> روی <code>MyBox&lt;T&gt;</code></figcaption>
</figure>
<p>سینتکس <code>type Target = T;</code> یک نوع مرتبط برای ویژگی <code>Deref</code> تعریف می‌کند تا از آن استفاده کند. نوع‌های مرتبط
یک روش کمی متفاوت برای اعلام یک پارامتر جنریک هستند، اما نیازی نیست در حال حاضر نگران آن‌ها باشید؛ ما در فصل ۲۰
جزئیات بیشتری درباره آن‌ها ارائه خواهیم داد.</p>
<p>ما بدنه متد <code>deref</code> را با <code>&amp;self.0</code> پر می‌کنیم تا <code>deref</code> یک ارجاع به مقداری که می‌خواهیم با عملگر <code>*</code>
دسترسی پیدا کنیم بازگرداند. به یاد بیاورید از بخش <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“استفاده از ساختارهای tuple بدون فیلدهای نام‌گذاری‌شده برای
ایجاد انواع مختلف”</a><!-- ignore --> در فصل ۵ که <code>.0</code> به اولین مقدار در یک ساختار tuple دسترسی
پیدا می‌کند. تابع <code>main</code> در لیستینگ ۱۵-۹ که <code>*</code> را روی مقدار <code>MyBox&lt;T&gt;</code> فراخوانی می‌کند اکنون کامپایل می‌شود و
تاییدها موفق خواهند شد!</p>
<p>بدون ویژگی <code>Deref</code>، کامپایلر تنها می‌تواند ارجاعات <code>&amp;</code> را اشاره‌گر (Pointer)‌زدایی کند. متد <code>deref</code> به کامپایلر امکان می‌دهد
که یک مقدار از هر نوعی که <code>Deref</code> را پیاده‌سازی می‌کند بگیرد و متد <code>deref</code> را فراخوانی کند تا یک ارجاع <code>&amp;</code>
دریافت کند که می‌داند چگونه آن را اشاره‌گر (Pointer)‌زدایی کند.</p>
<p>وقتی که در لیستینگ ۱۵-۹ <code>*y</code> وارد کردیم، پشت صحنه Rust در واقع این کد را اجرا کرد:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust عملگر <code>*</code> را با یک فراخوانی به متد <code>deref</code> و سپس یک اشاره‌گر (Pointer)زدایی ساده جایگزین می‌کند، بنابراین لازم نیست
درباره این فکر کنیم که آیا نیاز به فراخوانی متد <code>deref</code> داریم یا نه. این ویژگی Rust به ما اجازه می‌دهد کدی بنویسیم که
خواه ارجاع معمولی باشد یا نوعی که <code>Deref</code> را پیاده‌سازی کرده باشد، به طور یکسان عمل کند.</p>
<p>دلیل اینکه متد <code>deref</code> یک ارجاع به مقدار بازمی‌گرداند و اشاره‌گر (Pointer)زدایی ساده در بیرون از پرانتز در
<code>*(y.deref())</code> همچنان لازم است، به سیستم مالکیت مرتبط است. اگر متد <code>deref</code> به‌جای یک ارجاع به مقدار، مقدار را
مستقیماً بازمی‌گرداند، مقدار از <code>self</code> منتقل می‌شد. در این حالت یا در بیشتر مواردی که از عملگر اشاره‌گر (Pointer)زدایی
استفاده می‌کنیم، نمی‌خواهیم مالکیت مقدار داخلی درون <code>MyBox&lt;T&gt;</code> را به دست بگیریم.</p>
<p>توجه داشته باشید که عملگر <code>*</code> با یک فراخوانی به متد <code>deref</code> و سپس یک فراخوانی به عملگر <code>*</code> فقط یک بار جایگزین
می‌شود، هر بار که از <code>*</code> در کدمان استفاده می‌کنیم. از آنجایی که جایگزینی عملگر <code>*</code> بی‌نهایت تکرار نمی‌شود، در
نهایت به داده‌ای از نوع <code>i32</code> می‌رسیم که با <code>5</code> در <code>assert_eq!</code> در لیستینگ ۱۵-۹ مطابقت دارد.</p>
<h3 id="فشار-اشارهگر-pointerزدایی-ضمنی-با-توابع-و-متدها"><a class="header" href="#فشار-اشارهگر-pointerزدایی-ضمنی-با-توابع-و-متدها">فشار اشاره‌گر (Pointer)زدایی ضمنی با توابع و متدها</a></h3>
<p><em>فشار اشاره‌گر (Pointer)زدایی</em> (Deref coercion) یک ارجاع به نوعی که ویژگی <code>Deref</code> را پیاده‌سازی کرده است به یک ارجاع به
نوعی دیگر تبدیل می‌کند. برای مثال، فشار اشاره‌گر (Pointer)زدایی می‌تواند <code>&amp;String</code> را به <code>&amp;str</code> تبدیل کند، زیرا
<code>String</code> ویژگی <code>Deref</code> را به گونه‌ای پیاده‌سازی کرده است که <code>&amp;str</code> بازمی‌گرداند. فشار اشاره‌گر (Pointer)زدایی یک
ویژگی کاربردی در Rust است که روی آرگومان‌های توابع و متدها اعمال می‌شود و فقط روی انواعی که ویژگی <code>Deref</code>
را پیاده‌سازی کرده‌اند عمل می‌کند. این ویژگی به‌صورت خودکار زمانی که یک ارجاع به مقدار یک نوع خاص به‌عنوان
آرگومان به یک تابع یا متدی که نوع پارامتر آن با تعریف تابع یا متد مطابقت ندارد، اتفاق می‌افتد. یک توالی از
فراخوانی‌های متد <code>deref</code> نوعی را که ارائه داده‌ایم به نوعی که پارامتر نیاز دارد تبدیل می‌کند.</p>
<p>فشار اشاره‌گر (Pointer)زدایی به Rust اضافه شد تا برنامه‌نویسانی که توابع و متدها را می‌نویسند نیاز نداشته باشند
مرجع‌دهی‌ها و اشاره‌گر (Pointer)زدایی‌های واضح زیادی با <code>&amp;</code> و <code>*</code> اضافه کنند. این ویژگی همچنین به ما امکان می‌دهد
کدی بنویسیم که می‌تواند برای ارجاعات یا اشاره‌گر (Pointer)های هوشمند کار کند.</p>
<p>برای دیدن فشار اشاره‌گر (Pointer)زدایی در عمل، بیایید از نوع <code>MyBox&lt;T&gt;</code> که در لیستینگ ۱۵-۸ تعریف کردیم به همراه پیاده‌سازی
<code>Deref</code> که در لیستینگ ۱۵-۱۰ اضافه کردیم استفاده کنیم. لیستینگ ۱۵-۱۱ تعریف یک تابع که یک پارامتر از نوع
اسلایس رشته دارد را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 15-11: یک تابع <code>hello</code> که پارامتر <code>name</code> از نوع <code>&amp;str</code> دارد</figcaption>
</figure>
<p>می‌توانیم تابع <code>hello</code> را با یک اسلایس رشته به‌عنوان آرگومان فراخوانی کنیم، مانند <code>hello("Rust");</code> برای مثال.
فشار اشاره‌گر (Pointer)زدایی این امکان را فراهم می‌کند که <code>hello</code> را با یک ارجاع به یک مقدار از نوع <code>MyBox&lt;String&gt;</code>
فراخوانی کنیم، همان‌طور که در لیستینگ ۱۵-۱۲ نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<figcaption>Listing 15-12: فراخوانی <code>hello</code> با یک ارجاع به یک مقدار <code>MyBox&lt;String&gt;</code> که به دلیل فشار اشاره‌گر (Pointer)زدایی کار می‌کند</figcaption>
</figure>
<p>در اینجا ما تابع <code>hello</code> را با آرگومان <code>&amp;m</code> که یک ارجاع به یک مقدار <code>MyBox&lt;String&gt;</code> است فراخوانی می‌کنیم.
از آنجا که ما ویژگی <code>Deref</code> را روی <code>MyBox&lt;T&gt;</code> در لیستینگ ۱۵-۱۰ پیاده‌سازی کردیم، Rust می‌تواند <code>&amp;MyBox&lt;String&gt;</code>
را به <code>&amp;String</code> با فراخوانی <code>deref</code> تبدیل کند. کتابخانه استاندارد پیاده‌سازی ویژگی <code>Deref</code> روی <code>String</code>
را ارائه می‌دهد که یک اسلایس رشته بازمی‌گرداند، و این در مستندات API برای <code>Deref</code> ذکر شده است. Rust متد
<code>deref</code> را دوباره فراخوانی می‌کند تا <code>&amp;String</code> را به <code>&amp;str</code> تبدیل کند که با تعریف تابع <code>hello</code> مطابقت دارد.</p>
<p>اگر Rust فشار اشاره‌گر (Pointer)زدایی را پیاده‌سازی نکرده بود، مجبور بودیم کدی مانند لیستینگ ۱۵-۱۳ را به‌جای کد
لیستینگ ۱۵-۱۲ بنویسیم تا <code>hello</code> را با یک مقدار از نوع <code>&amp;MyBox&lt;String&gt;</code> فراخوانی کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<figcaption>Listing 15-13: کدی که باید می‌نوشتیم اگر Rust فشار اشاره‌گر (Pointer)زدایی نداشت</figcaption>
</figure>
<p>عملگر <code>(*m)</code> مقدار <code>MyBox&lt;String&gt;</code> را به یک <code>String</code> اشاره‌گر (Pointer) زدایی می‌کند. سپس <code>&amp;</code> و <code>[..]</code> یک برش رشته‌ای از
<code>String</code> می‌گیرند که برابر با کل رشته است تا با امضای تابع <code>hello</code> تطابق داشته باشد. این کد بدون فشار
اشاره‌گر (Pointer)زدایی با تمام این نمادها دشوارتر برای خواندن، نوشتن و درک است. فشار اشاره‌گر (Pointer)زدایی به Rust اجازه می‌دهد
این تبدیل‌ها را به‌صورت خودکار برای ما انجام دهد.</p>
<p>وقتی ویژگی <code>Deref</code> برای انواع درگیر تعریف شود، Rust انواع را تحلیل می‌کند و از <code>Deref::deref</code> به دفعات لازم
استفاده می‌کند تا یک ارجاع برای مطابقت با نوع پارامتر به دست آید. تعداد دفعاتی که نیاز به فراخوانی
<code>Deref::deref</code> است در زمان کامپایل حل می‌شود، بنابراین هیچ هزینه‌ای در زمان اجرا برای استفاده از فشار
اشاره‌گر (Pointer)زدایی وجود ندارد!</p>
<h3 id="نحوه-تعامل-فشار-اشارهگر-pointerزدایی-با-قابلیت-تغییرپذیری"><a class="header" href="#نحوه-تعامل-فشار-اشارهگر-pointerزدایی-با-قابلیت-تغییرپذیری">نحوه تعامل فشار اشاره‌گر (Pointer)زدایی با قابلیت تغییرپذیری</a></h3>
<p>مشابه نحوه استفاده از ویژگی <code>Deref</code> برای بازنویسی عملگر <code>*</code> روی ارجاعات غیرقابل تغییر، می‌توانید از ویژگی
<code>DerefMut</code> برای بازنویسی عملگر <code>*</code> روی ارجاعات قابل تغییر استفاده کنید.</p>
<p>Rust هنگام پیدا کردن انواع و پیاده‌سازی‌های ویژگی در سه حالت فشار اشاره‌گر (Pointer)زدایی را انجام می‌دهد:</p>
<ul>
<li>از <code>&amp;T</code> به <code>&amp;U</code> وقتی <code>T: Deref&lt;Target=U&gt;</code> باشد</li>
<li>از <code>&amp;mut T</code> به <code>&amp;mut U</code> وقتی <code>T: DerefMut&lt;Target=U&gt;</code> باشد</li>
<li>از <code>&amp;mut T</code> به <code>&amp;U</code> وقتی <code>T: Deref&lt;Target=U&gt;</code> باشد</li>
</ul>
<p>دو حالت اول مشابه یکدیگر هستند با این تفاوت که حالت دوم قابلیت تغییرپذیری را پیاده‌سازی می‌کند. حالت اول
بیان می‌کند که اگر شما یک <code>&amp;T</code> داشته باشید و <code>T</code> ویژگی <code>Deref</code> را به نوعی <code>U</code> پیاده‌سازی کند، می‌توانید
به‌صورت شفاف یک <code>&amp;U</code> دریافت کنید. حالت دوم بیان می‌کند که همین فشار اشاره‌گر (Pointer)زدایی برای ارجاعات قابل تغییر نیز
اتفاق می‌افتد.</p>
<p>حالت سوم پیچیده‌تر است: Rust همچنین یک ارجاع قابل تغییر را به یک ارجاع غیرقابل تغییر تبدیل می‌کند. اما
عکس آن ممکن <em>نیست</em>: ارجاعات غیرقابل تغییر هرگز به ارجاعات قابل تغییر تبدیل نمی‌شوند. به دلیل قوانین
قرض‌گیری، اگر یک ارجاع قابل تغییر داشته باشید، آن ارجاع قابل تغییر باید تنها ارجاع به آن داده باشد (در غیر
این صورت، برنامه کامپایل نمی‌شد). تبدیل یک ارجاع قابل تغییر به یک ارجاع غیرقابل تغییر هرگز قوانین قرض‌گیری
را نمی‌شکند. تبدیل یک ارجاع غیرقابل تغییر به یک ارجاع قابل تغییر نیازمند این است که ارجاع غیرقابل تغییر اولیه
تنها ارجاع غیرقابل تغییر به آن داده باشد، اما قوانین قرض‌گیری این را تضمین نمی‌کنند. بنابراین، Rust نمی‌تواند
فرض کند که تبدیل یک ارجاع غیرقابل تغییر به یک ارجاع قابل تغییر امکان‌پذیر است.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="اجرای-کد-هنگام-پاکسازی-با-ویژگی-drop"><a class="header" href="#اجرای-کد-هنگام-پاکسازی-با-ویژگی-drop">اجرای کد هنگام پاکسازی با ویژگی <code>Drop</code></a></h2>
<p>ویژگی دوم که برای الگوی اشاره‌گر (Pointer) هوشمند مهم است، <code>Drop</code> است که به شما امکان می‌دهد سفارشی کنید که وقتی یک مقدار
قرار است از دامنه خارج شود، چه اتفاقی بیفتد. می‌توانید یک پیاده‌سازی برای ویژگی <code>Drop</code> روی هر نوعی ارائه دهید و
این کد می‌تواند برای آزادسازی منابعی مانند فایل‌ها یا اتصالات شبکه استفاده شود.</p>
<p>ما ویژگی <code>Drop</code> را در زمینه اشاره‌گر (Pointer)های هوشمند معرفی می‌کنیم زیرا عملکرد ویژگی <code>Drop</code> تقریباً همیشه هنگام
پیاده‌سازی یک اشاره‌گر (Pointer) هوشمند استفاده می‌شود. برای مثال، وقتی یک <code>Box&lt;T&gt;</code> حذف می‌شود، فضای موجود روی پشته‌ای
که باکس به آن اشاره می‌کند، آزاد خواهد شد.</p>
<p>در برخی زبان‌ها، برای برخی از انواع، برنامه‌نویس باید کدی را فراخوانی کند تا حافظه یا منابع را هر بار که استفاده
از یک نمونه از این انواع به پایان رسید، آزاد کند. مثال‌ها شامل دسته‌های فایل، سوکت‌ها یا قفل‌ها می‌باشند. اگر
فراموش کنند، ممکن است سیستم بیش از حد بارگذاری شود و خراب شود. در Rust، می‌توانید مشخص کنید که بخشی از کد
خاصی هر زمان که یک مقدار از دامنه خارج شد، اجرا شود و کامپایلر این کد را به صورت خودکار درج خواهد کرد.
در نتیجه، نیازی نیست که در مورد قرار دادن کد پاکسازی در همه جاهای برنامه‌ای که استفاده از یک نمونه خاص به
پایان رسیده است، مراقب باشید—شما همچنان منابع را نشت نخواهید داد!</p>
<p>شما کدی که باید هنگام خروج مقدار از دامنه اجرا شود را با پیاده‌سازی ویژگی <code>Drop</code> مشخص می‌کنید. ویژگی <code>Drop</code>
نیازمند این است که یک متد به نام <code>drop</code> را پیاده‌سازی کنید که یک مرجع متغیر به <code>self</code> می‌گیرد. برای دیدن زمانی
که Rust فراخوانی <code>drop</code> را انجام می‌دهد، بیایید <code>drop</code> را با جملات <code>println!</code> برای اکنون پیاده‌سازی کنیم.</p>
<p>فهرست 15-14 یک ساختار <code>CustomSmartPointer</code> را نشان می‌دهد که تنها قابلیت سفارشی آن این است که وقتی نمونه‌ای از آن
از دامنه خارج می‌شود، <code>Dropping CustomSmartPointer!</code> را چاپ می‌کند تا نشان دهد که چه زمانی Rust متد <code>drop</code> را اجرا
می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre></pre>
<figcaption>Listing 15-14: ساختار <code>CustomSmartPointer</code> که ویژگی <code>Drop</code> را پیاده‌سازی می‌کند و در آن کد پاکسازی خود را قرار می‌دهیم</figcaption>
</figure>
<p>ویژگی <code>Drop</code> در پیش‌درآمد (prelude) گنجانده شده است، بنابراین نیازی به وارد کردن آن به دامنه نداریم. ما ویژگی
<code>Drop</code> را روی <code>CustomSmartPointer</code> پیاده‌سازی می‌کنیم و یک پیاده‌سازی برای متد <code>drop</code> ارائه می‌دهیم که
<code>println!</code> را فراخوانی می‌کند. بدنه تابع <code>drop</code> جایی است که هر منطقی که بخواهید هنگام خروج یک نمونه از نوع شما از
دامنه اجرا شود، قرار می‌دهید. ما در اینجا متنی را چاپ می‌کنیم تا به صورت بصری نشان دهیم که چه زمانی Rust متد
<code>drop</code> را فراخوانی خواهد کرد.</p>
<p>در تابع <code>main</code>، دو نمونه از <code>CustomSmartPointer</code> ایجاد می‌کنیم و سپس <code>CustomSmartPointers created</code> را چاپ
می‌کنیم. در پایان <code>main</code>، نمونه‌های ما از <code>CustomSmartPointer</code> از دامنه خارج خواهند شد و Rust کدی که در متد
<code>drop</code> قرار داده‌ایم را فراخوانی خواهد کرد و پیام نهایی ما را چاپ می‌کند. توجه کنید که نیازی به فراخوانی صریح متد
<code>drop</code> نداشتیم.</p>
<p>وقتی این برنامه را اجرا می‌کنیم، خروجی زیر را مشاهده خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust به صورت خودکار <code>drop</code> را برای ما فراخوانی کرد وقتی که نمونه‌های ما از دامنه خارج شدند و کدی که مشخص کرده بودیم
را اجرا کرد. متغیرها به ترتیب معکوس ایجادشان حذف می‌شوند، بنابراین <code>d</code> قبل از <code>c</code> حذف شد. هدف این مثال این است
که یک راهنمای بصری برای نحوه کارکرد متد <code>drop</code> به شما بدهد؛ معمولاً شما کد پاکسازی که نوع شما نیاز دارد را مشخص
می‌کنید نه یک پیام چاپ.</p>
<h3 id="حذف-زودهنگام-یک-مقدار-با-استفاده-از-stdmemdrop"><a class="header" href="#حذف-زودهنگام-یک-مقدار-با-استفاده-از-stdmemdrop">حذف زودهنگام یک مقدار با استفاده از <code>std::mem::drop</code></a></h3>
<p>متأسفانه، غیرفعال کردن عملکرد خودکار <code>drop</code> ساده نیست. در اغلب موارد، نیازی به غیرفعال کردن <code>drop</code> نیست؛ هدف اصلی
ویژگی <code>Drop</code> این است که این کار به‌طور خودکار انجام شود. با این حال، گاهی ممکن است بخواهید یک مقدار را زودتر از زمان
خود تمیز کنید. یک مثال در این زمینه، استفاده از اشاره‌گر (Pointer)های هوشمندی است که قفل‌ها را مدیریت می‌کنند: ممکن است بخواهید
متد <code>drop</code> که قفل را آزاد می‌کند را به زور اجرا کنید تا کد دیگری در همان حوزه بتواند قفل را بدست آورد.<br />
Rust به شما اجازه نمی‌دهد متد <code>drop</code> متعلق به ویژگی <code>Drop</code> را به صورت دستی فراخوانی کنید؛ در عوض، باید از تابع
<code>std::mem::drop</code> که توسط کتابخانه استاندارد فراهم شده است، استفاده کنید اگر می‌خواهید مقداری را زودتر از زمان معمول
حذف کنید.</p>
<p>اگر بخواهیم متد <code>drop</code> مربوط به ویژگی <code>Drop</code> را به صورت دستی فراخوانی کنیم و تابع <code>main</code> را از مثال شماره 15-14
تغییر دهیم، همان‌طور که در لیست 15-15 نشان داده شده است، با خطای کامپایل مواجه خواهیم شد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre>
<figcaption>Listing 15-15: تلاش برای فراخوانی دستی متد <code>drop</code> از ویژگی <code>Drop</code> برای پاکسازی زودهنگام</figcaption>
</figure>
<p>وقتی سعی کنیم این کد را کامپایل کنیم، با این خطا مواجه می‌شویم:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>این پیام خطا نشان می‌دهد که ما اجازه نداریم به‌طور صریح <code>drop</code> را فراخوانی کنیم. پیام خطا از اصطلاح <em>تخریب‌گر</em>
(Destructor) استفاده می‌کند که اصطلاحی کلی برای تابعی است که یک نمونه را تمیز می‌کند. یک تخریب‌گر مشابه یک
<em>سازنده</em> (Constructor) است که یک نمونه را ایجاد می‌کند. تابع <code>drop</code> در Rust یک تخریب‌گر خاص است.</p>
<p>Rust به ما اجازه نمی‌دهد <code>drop</code> را به صورت صریح فراخوانی کنیم زیرا Rust به‌طور خودکار <code>drop</code> را در انتهای تابع
<code>main</code> فراخوانی می‌کند. این موضوع می‌تواند باعث خطای <em>آزادسازی دوگانه</em> شود زیرا Rust سعی می‌کند همان مقدار را دو بار
تمیز کند.</p>
<p>ما نمی‌توانیم قرار دادن خودکار <code>drop</code> را هنگام خروج یک مقدار از حوزه غیرفعال کنیم و همچنین نمی‌توانیم متد <code>drop</code>
را به صورت صریح فراخوانی کنیم. بنابراین، اگر نیاز به حذف زودهنگام یک مقدار داشته باشیم، باید از تابع <code>std::mem::drop</code>
استفاده کنیم.</p>
<p>تابع <code>std::mem::drop</code> با متد <code>drop</code> در ویژگی <code>Drop</code> متفاوت است. این تابع را با ارسال مقداری که می‌خواهیم به‌زور
حذف کنیم به‌عنوان آرگومان فراخوانی می‌کنیم. این تابع در پیش‌فرض (Prelude) قرار دارد، بنابراین می‌توانیم تابع <code>main</code>
را در لیست 15-15 تغییر دهیم تا تابع <code>drop</code> را فراخوانی کند، همان‌طور که در لیست 15-16 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre></pre>
<figcaption>Listing 15-16: فراخوانی <code>std::mem::drop</code> برای حذف صریح یک مقدار قبل از خروج آن از حوزه</figcaption>
</figure>
<p>اجرای این کد خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>متن <code>Dropping CustomSmartPointer with data 'some data'!</code> بین متون <code>CustomSmartPointer created.</code> و
<code>CustomSmartPointer dropped before the end of main.</code> چاپ می‌شود و نشان می‌دهد که کد متد <code>drop</code> برای حذف
<code>c</code> در آن نقطه فراخوانی شده است.</p>
<p>شما می‌توانید از کدی که در پیاده‌سازی ویژگی <code>Drop</code> مشخص کرده‌اید، به روش‌های مختلفی برای ساده و امن کردن عملیات
پاکسازی استفاده کنید: برای مثال، می‌توانید از آن برای ایجاد تخصیص‌دهنده حافظه خودتان استفاده کنید! با ویژگی <code>Drop</code> و
سیستم مالکیت Rust، نیازی به یادآوری پاکسازی ندارید، زیرا Rust این کار را به‌طور خودکار انجام می‌دهد.</p>
<p>همچنین نیازی به نگرانی در مورد مشکلات ناشی از پاکسازی اشتباهی مقادیری که هنوز در حال استفاده هستند، ندارید: سیستم مالکیت
که اطمینان می‌دهد ارجاعات همیشه معتبر هستند، همچنین تضمین می‌کند که <code>drop</code> فقط یک بار و زمانی که مقدار دیگر استفاده نمی‌شود،
فراخوانی شود.</p>
<p>اکنون که <code>Box&lt;T&gt;</code> و برخی از ویژگی‌های اشاره‌گر (Pointer)های هوشمند را بررسی کردیم، بیایید به چند اشاره‌گر (Pointer) هوشمند دیگر که در کتابخانه
استاندارد تعریف شده‌اند، نگاهی بیندازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-اشارهگر-pointer-هوشمند-با-شمارش-مرجع"><a class="header" href="#rct-اشارهگر-pointer-هوشمند-با-شمارش-مرجع"><code>Rc&lt;T&gt;</code>، اشاره‌گر (Pointer) هوشمند با شمارش مرجع</a></h2>
<p>در بیشتر موارد، مالکیت واضح است: شما دقیقاً می‌دانید که کدام متغیر مالک یک مقدار مشخص است. با این حال، در مواردی
ممکن است یک مقدار چندین مالک داشته باشد. برای مثال، در ساختارهای داده گراف، چندین یال ممکن است به یک گره
اشاره کنند و آن گره از نظر مفهومی متعلق به تمام یال‌هایی است که به آن اشاره دارند. یک گره نباید پاکسازی شود مگر
اینکه هیچ یالی به آن اشاره نکند و در نتیجه مالکیتی نداشته باشد.</p>
<p>برای فعال‌سازی مالکیت چندگانه باید به صورت صریح از نوع <code>Rc&lt;T&gt;</code> در Rust استفاده کنید که مخفف
<em>reference counting</em> یا شمارش مرجع است. نوع <code>Rc&lt;T&gt;</code> تعداد مراجعات به یک مقدار را دنبال می‌کند تا مشخص کند که آیا
آن مقدار هنوز در حال استفاده است یا خیر. اگر هیچ مرجعی به یک مقدار وجود نداشته باشد، مقدار می‌تواند بدون اینکه
هیچ مرجعی نامعتبر شود، پاکسازی شود.</p>
<p>تصور کنید <code>Rc&lt;T&gt;</code> مانند یک تلویزیون در اتاق نشیمن است. وقتی یک نفر وارد اتاق می‌شود تا تلویزیون تماشا کند، آن را
روشن می‌کند. افراد دیگری هم می‌توانند وارد اتاق شوند و تلویزیون تماشا کنند. وقتی آخرین نفر اتاق را ترک می‌کند،
تلویزیون را خاموش می‌کند زیرا دیگر استفاده نمی‌شود. اگر کسی تلویزیون را در حالی که دیگران هنوز در حال تماشای آن
هستند خاموش کند، اعتراض تماشاگران باقی‌مانده بلند خواهد شد!</p>
<p>ما از نوع <code>Rc&lt;T&gt;</code> استفاده می‌کنیم وقتی می‌خواهیم مقداری را در هیپ تخصیص دهیم که توسط چندین بخش از برنامه ما
خوانده شود و نمی‌توانیم در زمان کامپایل تعیین کنیم که کدام بخش استفاده از داده را زودتر به پایان می‌رساند. اگر
می‌دانستیم کدام بخش زودتر تمام می‌شود، می‌توانستیم آن بخش را مالک داده کنیم و قوانین معمول مالکیت که در زمان
کامپایل اعمال می‌شود، اعمال می‌شد.</p>
<p>توجه داشته باشید که <code>Rc&lt;T&gt;</code> فقط برای استفاده در سناریوهای تک‌ریسمانی است. هنگامی که در فصل 16 در مورد
هم‌زمانی بحث می‌کنیم، نحوه انجام شمارش مرجع در برنامه‌های چندریسمانی را پوشش خواهیم داد.</p>
<h3 id="استفاده-از-rct-برای-اشتراکگذاری-داده"><a class="header" href="#استفاده-از-rct-برای-اشتراکگذاری-داده">استفاده از <code>Rc&lt;T&gt;</code> برای اشتراک‌گذاری داده</a></h3>
<p>بیایید به مثال لیست cons در لیست 15-5 بازگردیم. به یاد داشته باشید که ما آن را با استفاده از <code>Box&lt;T&gt;</code> تعریف
کردیم. این بار، دو لیست ایجاد می‌کنیم که هر دو مالکیت یک لیست سوم را به اشتراک می‌گذارند. به طور مفهومی، این
مشابه شکل 15-3 به نظر می‌رسد:</p>
<img alt="دو لیست که مالکیت یک لیست سوم را به اشتراک می‌گذارند" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">شکل 15-3: دو لیست، <code>b</code> و <code>c</code>، که مالکیت یک لیست سوم، <code>a</code> را به اشتراک می‌گذارند</span></p>
<p>ما لیست <code>a</code> را ایجاد می‌کنیم که شامل 5 و سپس 10 است. سپس دو لیست دیگر ایجاد می‌کنیم: <code>b</code> که با 3 شروع می‌شود و
<code>c</code> که با 4 شروع می‌شود. هر دو لیست <code>b</code> و <code>c</code> سپس ادامه می‌دهند به لیست اول <code>a</code> که شامل 5 و 10 است. به عبارت
دیگر، هر دو لیست مالکیت لیست اول که شامل 5 و 10 است را به اشتراک می‌گذارند.</p>
<p>تلاش برای پیاده‌سازی این سناریو با استفاده از تعریف ما از <code>List</code> با <code>Box&lt;T&gt;</code> کار نخواهد کرد، همان‌طور که در لیست
15-17 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<figcaption>Listing 15-17: نشان دادن اینکه نمی‌توانیم دو لیست با استفاده از <code>Box&lt;T&gt;</code> داشته باشیم که سعی در اشتراک‌گذاری مالکیت یک لیست سوم دارند</figcaption>
</figure>
<p>هنگامی که این کد را کامپایل می‌کنیم، با این خطا مواجه می‌شویم:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>متغیرهای <code>Cons</code> مالک داده‌هایی هستند که در خود نگه می‌دارند. بنابراین، هنگامی که لیست <code>b</code> را ایجاد می‌کنیم،
<code>a</code> به <code>b</code> منتقل می‌شود و <code>b</code> مالک <code>a</code> می‌شود. سپس، هنگامی که سعی می‌کنیم دوباره از <code>a</code> برای ایجاد <code>c</code> استفاده
کنیم، این کار مجاز نیست زیرا <code>a</code> قبلاً منتقل شده است.</p>
<p>ما می‌توانیم تعریف <code>Cons</code> را به گونه‌ای تغییر دهیم که به جای نگهداری داده‌ها، ارجاع به آنها را نگه دارد. اما در
این صورت باید پارامترهای طول عمر (lifetime parameters) را مشخص کنیم. با مشخص کردن پارامترهای طول عمر، مشخص
می‌کنیم که هر عنصر در لیست حداقل به اندازه کل لیست زنده خواهد بود. این موضوع در مورد عناصر و لیست‌های موجود در
لیست 15-17 صدق می‌کند، اما در همه سناریوها چنین نیست.</p>
<p>در عوض، تعریف <code>List</code> خود را تغییر می‌دهیم تا به جای <code>Box&lt;T&gt;</code> از <code>Rc&lt;T&gt;</code> استفاده کند، همان‌طور که در لیست 15-18
نشان داده شده است. هر متغیر <code>Cons</code> اکنون یک مقدار و یک <code>Rc&lt;T&gt;</code> اشاره‌کننده به یک <code>List</code> را نگه می‌دارد. وقتی <code>b</code>
را ایجاد می‌کنیم، به جای تصاحب مالکیت <code>a</code>، <code>Rc&lt;List&gt;</code> که <code>a</code> نگه می‌دارد را کلون می‌کنیم، بنابراین تعداد
ارجاعات از یک به دو افزایش می‌یابد و به <code>a</code> و <code>b</code> اجازه می‌دهیم مالکیت داده‌های موجود در آن <code>Rc&lt;List&gt;</code> را به
اشتراک بگذارند. همچنین هنگام ایجاد <code>c</code>، <code>a</code> را کلون می‌کنیم و تعداد ارجاعات از دو به سه افزایش می‌یابد. هر بار
که <code>Rc::clone</code> را فراخوانی می‌کنیم، تعداد ارجاعات به داده‌های موجود در <code>Rc&lt;List&gt;</code> افزایش می‌یابد و داده‌ها تا
زمانی که هیچ ارجاعی به آنها باقی نماند پاک نمی‌شوند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<figcaption>Listing 15-18: تعریفی از <code>List</code> که از <code>Rc&lt;T&gt;</code> استفاده می‌کند</figcaption>
</figure>
<p>باید یک دستور <code>use</code> اضافه کنیم تا <code>Rc&lt;T&gt;</code> را به دامنه بیاوریم زیرا این نوع به صورت پیش‌فرض در prelude نیست.
در <code>main</code>، لیستی که شامل 5 و 10 است ایجاد می‌کنیم و آن را در یک <code>Rc&lt;List&gt;</code> جدید در <code>a</code> ذخیره می‌کنیم. سپس
هنگامی که <code>b</code> و <code>c</code> را ایجاد می‌کنیم، تابع <code>Rc::clone</code> را فراخوانی می‌کنیم و یک ارجاع به <code>Rc&lt;List&gt;</code> موجود در
<code>a</code> را به عنوان آرگومان می‌فرستیم.</p>
<p>می‌توانستیم <code>a.clone()</code> را به جای <code>Rc::clone(&amp;a)</code> فراخوانی کنیم، اما طبق قرارداد Rust در این موارد از
<code>Rc::clone</code> استفاده می‌شود. پیاده‌سازی <code>Rc::clone</code> یک کپی عمیق از تمام داده‌ها ایجاد نمی‌کند، همان‌طور که
پیاده‌سازی اکثر انواع دیگر <code>clone</code> این کار را انجام می‌دهد. فراخوانی <code>Rc::clone</code> فقط تعداد ارجاعات را افزایش
می‌دهد، که زمان زیادی نمی‌برد. کپی عمیق داده‌ها ممکن است زمان زیادی ببرد. با استفاده از <code>Rc::clone</code> برای شمارش
مرجع، می‌توانیم بین کپی‌های عمیق و کپی‌هایی که تعداد ارجاعات را افزایش می‌دهند تمایز بصری قائل شویم. هنگام
جستجوی مشکلات عملکرد در کد، فقط لازم است به کپی‌های عمیق توجه کنیم و می‌توانیم فراخوانی‌های <code>Rc::clone</code> را
نادیده بگیریم.</p>
<h3 id="کلون-کردن-یک-rct-تعداد-ارجاعات-را-افزایش-میدهد"><a class="header" href="#کلون-کردن-یک-rct-تعداد-ارجاعات-را-افزایش-میدهد">کلون کردن یک <code>Rc&lt;T&gt;</code> تعداد ارجاعات را افزایش می‌دهد</a></h3>
<p>اجازه دهید مثال کاری خود را در لیست 15-18 تغییر دهیم تا بتوانیم تغییرات تعداد ارجاعات را هنگام ایجاد و حذف
ارجاعات به <code>Rc&lt;List&gt;</code> در <code>a</code> مشاهده کنیم.</p>
<p>در لیست 15-19، <code>main</code> را تغییر خواهیم داد تا یک محدوده داخلی (inner scope) در اطراف لیست <code>c</code> داشته باشد؛
سپس می‌توانیم ببینیم که چگونه تعداد ارجاعات زمانی که <code>c</code> از محدوده خارج می‌شود تغییر می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<figcaption>Listing 15-19: چاپ تعداد ارجاعات</figcaption>
</figure>
<p>در هر نقطه از برنامه که تعداد ارجاعات تغییر می‌کند، تعداد ارجاعات را چاپ می‌کنیم که از طریق فراخوانی تابع
<code>Rc::strong_count</code> دریافت می‌شود. این تابع به جای <code>count</code>، <code>strong_count</code> نام‌گذاری شده است زیرا نوع <code>Rc&lt;T&gt;</code>
همچنین دارای <code>weak_count</code> است؛ در بخش <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“جلوگیری از چرخه‌های مرجع: تبدیل یک <code>Rc&lt;T&gt;</code> به یک
<code>Weak&lt;T&gt;</code>”</a><!-- ignore --> با کاربرد <code>weak_count</code> آشنا خواهیم شد.</p>
<p>این کد خروجی زیر را تولید می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>می‌بینیم که <code>Rc&lt;List&gt;</code> در <code>a</code> تعداد ارجاع اولیه برابر با 1 دارد؛ سپس هر بار که <code>clone</code> را فراخوانی می‌کنیم،
تعداد ارجاعات 1 واحد افزایش می‌یابد. هنگامی که <code>c</code> از محدوده خارج می‌شود، تعداد ارجاعات 1 واحد کاهش می‌یابد.
لازم نیست تابعی برای کاهش تعداد ارجاعات فراخوانی کنیم، همان‌طور که باید <code>Rc::clone</code> را برای افزایش تعداد
ارجاعات فراخوانی کنیم: پیاده‌سازی ویژگی <code>Drop</code> تعداد ارجاعات را به طور خودکار کاهش می‌دهد وقتی که یک مقدار
<code>Rc&lt;T&gt;</code> از محدوده خارج می‌شود.</p>
<p>آنچه در این مثال نمی‌توانیم ببینیم این است که وقتی <code>b</code> و سپس <code>a</code> در انتهای <code>main</code> از محدوده خارج می‌شوند، تعداد
ارجاعات به 0 می‌رسد و <code>Rc&lt;List&gt;</code> به طور کامل پاک‌سازی می‌شود. استفاده از <code>Rc&lt;T&gt;</code> به یک مقدار اجازه می‌دهد که
چندین مالک داشته باشد، و تعداد ارجاعات تضمین می‌کند که مقدار تا زمانی که هر یک از مالکان هنوز وجود دارند، معتبر
باقی می‌ماند.</p>
<p>از طریق ارجاعات غیرقابل تغییر، <code>Rc&lt;T&gt;</code> به شما اجازه می‌دهد داده‌ها را بین بخش‌های مختلف برنامه خود برای
خواندن به اشتراک بگذارید. اگر <code>Rc&lt;T&gt;</code> به شما اجازه می‌داد که چندین ارجاع قابل تغییر نیز داشته باشید، ممکن بود
یکی از قوانین قرض‌گیری که در فصل 4 بحث شد را نقض کنید: چندین قرض قابل تغییر به یک مکان می‌تواند باعث ایجاد
تناقضات و مسابقه داده‌ها شود. اما توانایی تغییر داده‌ها بسیار مفید است! در بخش بعدی، به الگوی تغییر‌پذیری داخلی
(interior mutability) و نوع <code>RefCell&lt;T&gt;</code> که می‌توانید همراه با <code>Rc&lt;T&gt;</code> برای کار با این محدودیت عدم تغییر‌پذیری
استفاده کنید، خواهیم پرداخت.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-و-الگوی-تغییرپذیری-داخلی"><a class="header" href="#refcellt-و-الگوی-تغییرپذیری-داخلی"><code>RefCell&lt;T&gt;</code> و الگوی تغییرپذیری داخلی</a></h2>
<p><em>تغییرپذیری داخلی</em> یک الگوی طراحی در راست است که به شما اجازه می‌دهد داده‌ها را حتی زمانی که
ارجاع‌های غیرقابل‌تغییر به آن داده‌ها وجود دارد، تغییر دهید؛ معمولاً این عمل توسط قوانین وام‌دهی
(‌borrowing rules) ممنوع است. برای تغییر داده‌ها، این الگو از کد <code>unsafe</code> درون یک ساختار داده
برای تغییر قوانین معمول راست که کنترل تغییرپذیری و وام‌دهی را بر عهده دارند، استفاده می‌کند. کد
<code>unsafe</code> به کامپایلر نشان می‌دهد که ما قوانین را به صورت دستی بررسی می‌کنیم و دیگر به کامپایلر
اعتماد نداریم که این کار را برای ما انجام دهد؛ ما در فصل 20 بیشتر درباره کد <code>unsafe</code> صحبت خواهیم کرد.</p>
<p>ما می‌توانیم از انواعی که از الگوی تغییرپذیری داخلی استفاده می‌کنند تنها در صورتی استفاده کنیم که
بتوانیم اطمینان حاصل کنیم که قوانین وام‌دهی در زمان اجرا رعایت خواهند شد، حتی اگر کامپایلر نتواند
این را تضمین کند. کد <code>unsafe</code> مرتبط سپس در یک API ایمن پیچیده شده و نوع بیرونی همچنان
غیرقابل‌تغییر باقی می‌ماند.</p>
<p>بیایید این مفهوم را با بررسی نوع <code>RefCell&lt;T&gt;</code> که از الگوی تغییرپذیری داخلی پیروی می‌کند،
بیشتر بررسی کنیم.</p>
<h3 id="اجرای-قوانین-وامدهی-در-زمان-اجرا-با-refcellt"><a class="header" href="#اجرای-قوانین-وامدهی-در-زمان-اجرا-با-refcellt">اجرای قوانین وام‌دهی در زمان اجرا با <code>RefCell&lt;T&gt;</code></a></h3>
<p>برخلاف <code>Rc&lt;T&gt;</code>، نوع <code>RefCell&lt;T&gt;</code> مالکیت واحد (single ownership) داده‌هایی که نگه می‌دارد
را نشان می‌دهد. پس، چه چیزی <code>RefCell&lt;T&gt;</code> را از یک نوع مثل <code>Box&lt;T&gt;</code> متمایز می‌کند؟ قوانین
وام‌دهی‌ای که در فصل 4 یاد گرفتید را به یاد آورید:</p>
<ul>
<li>در هر زمان معین، شما می‌توانید <em>یا</em> (اما نه هر دو) یک ارجاع متغیر یا تعداد زیادی ارجاع
غیرقابل‌تغییر داشته باشید.</li>
<li>ارجاع‌ها باید همیشه معتبر باشند.</li>
</ul>
<p>با استفاده از ارجاع‌ها و <code>Box&lt;T&gt;</code>، ثابت‌های قوانین وام‌دهی در زمان کامپایل اعمال می‌شوند.
اما با <code>RefCell&lt;T&gt;</code>، این ثابت‌ها در <em>زمان اجرا</em> اعمال می‌شوند. با ارجاع‌ها، اگر این قوانین
را بشکنید، یک خطای کامپایل دریافت خواهید کرد. اما با <code>RefCell&lt;T&gt;</code>، اگر این قوانین را بشکنید،
برنامه شما دچار وحشت (panic) می‌شود و متوقف می‌شود.</p>
<p>مزیت بررسی قوانین وام‌دهی در زمان کامپایل این است که خطاها زودتر در فرایند توسعه شناسایی
می‌شوند، و هیچ تأثیری بر عملکرد زمان اجرا وجود ندارد زیرا تمام تحلیل‌ها پیشاپیش انجام شده‌اند.
به همین دلایل، بررسی قوانین وام‌دهی در زمان کامپایل بهترین انتخاب در اکثر موارد است، که به
همین دلیل این روش پیش‌فرض راست است.</p>
<p>مزیت بررسی قوانین وام‌دهی در زمان اجرا این است که سناریوهایی که ایمن از نظر حافظه هستند
اجازه می‌یابند، در حالی که ممکن است توسط بررسی‌های زمان کامپایل مجاز نباشند. تحلیل
ایستا (static analysis)، مانند کامپایلر راست، به‌طور ذاتی محافظه‌کارانه است. برخی
خصوصیات کد غیرممکن است که با تحلیل کد شناسایی شوند: معروف‌ترین مثال، مشکل توقف
(Halting Problem) است که فراتر از محدوده این کتاب است اما موضوع جالبی برای تحقیق
می‌باشد.</p>
<p>زیرا برخی تحلیل‌ها غیرممکن هستند، اگر کامپایلر راست نتواند مطمئن شود که کد با قوانین
مالکیت سازگار است، ممکن است یک برنامه درست را رد کند؛ به این ترتیب، محافظه‌کارانه عمل
می‌کند. اگر راست یک برنامه نادرست را بپذیرد، کاربران نمی‌توانند به تضمین‌هایی که راست
می‌دهد، اعتماد کنند. اما اگر راست یک برنامه درست را رد کند، برنامه‌نویس ناراحت خواهد شد،
اما هیچ چیز فاجعه‌باری رخ نخواهد داد. نوع <code>RefCell&lt;T&gt;</code> زمانی مفید است که مطمئن باشید
کد شما قوانین وام‌دهی را دنبال می‌کند اما کامپایلر نمی‌تواند این را بفهمد و تضمین کند.</p>
<p>مشابه <code>Rc&lt;T&gt;</code>، <code>RefCell&lt;T&gt;</code> تنها برای استفاده در سناریوهای تک‌ریسمانی (single-threaded)
است و اگر بخواهید آن را در یک بافت چندریسمانی (multithreaded) استفاده کنید، یک خطای زمان
کامپایل به شما خواهد داد. ما در فصل 16 درباره نحوه دریافت عملکرد <code>RefCell&lt;T&gt;</code> در یک برنامه
چندریسمانی صحبت خواهیم کرد.</p>
<p>در اینجا مروری بر دلایلی برای انتخاب <code>Box&lt;T&gt;</code>، <code>Rc&lt;T&gt;</code> یا <code>RefCell&lt;T&gt;</code> آمده است:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> امکان چندین مالک برای یک داده را فراهم می‌کند؛ در حالی که <code>Box&lt;T&gt;</code> و
<code>RefCell&lt;T&gt;</code> تنها یک مالک دارند.</li>
<li><code>Box&lt;T&gt;</code> اجازه می‌دهد که وام‌دهی‌های غیرقابل‌تغییر یا قابل‌تغییر در زمان کامپایل
بررسی شوند؛ <code>Rc&lt;T&gt;</code> تنها وام‌دهی‌های غیرقابل‌تغییر را در زمان کامپایل بررسی
می‌کند؛ <code>RefCell&lt;T&gt;</code> اجازه می‌دهد که وام‌دهی‌های غیرقابل‌تغییر یا قابل‌تغییر در
زمان اجرا بررسی شوند.</li>
<li>از آنجا که <code>RefCell&lt;T&gt;</code> اجازه می‌دهد وام‌دهی‌های قابل‌تغییر در زمان اجرا بررسی شوند،
شما می‌توانید مقدار درون <code>RefCell&lt;T&gt;</code> را حتی زمانی که خود <code>RefCell&lt;T&gt;</code> غیرقابل‌تغییر
است، تغییر دهید.</li>
</ul>
<p>تغییر مقدار درون یک مقدار غیرقابل‌تغییر همان الگوی <em>تغییرپذیری داخلی</em> است. بیایید به
یک موقعیت که در آن تغییرپذیری داخلی مفید است نگاهی بیندازیم و بررسی کنیم چگونه این
امر ممکن است.</p>
<h3 id="تغییرپذیری-داخلی-وامدهی-قابلتغییر-به-یک-مقدار-غیرقابلتغییر"><a class="header" href="#تغییرپذیری-داخلی-وامدهی-قابلتغییر-به-یک-مقدار-غیرقابلتغییر">تغییرپذیری داخلی: وام‌دهی قابل‌تغییر به یک مقدار غیرقابل‌تغییر</a></h3>
<p>یکی از پیامدهای قوانین وام‌دهی این است که وقتی شما یک مقدار غیرقابل‌تغییر دارید،
نمی‌توانید آن را به صورت قابل‌تغییر وام دهید. برای مثال، این کد کامپایل نخواهد شد:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>اگر سعی کنید این کد را کامپایل کنید، خطای زیر را دریافت خواهید کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>با این حال، موقعیت‌هایی وجود دارند که در آن‌ها مفید است یک مقدار بتواند خود را در
متدهایش تغییر دهد اما برای کد دیگر غیرقابل‌تغییر به نظر برسد. کدی که خارج از متدهای
مقدار قرار دارد نمی‌تواند مقدار را تغییر دهد. استفاده از <code>RefCell&lt;T&gt;</code> یکی از
راه‌هایی است که می‌توانید قابلیت تغییرپذیری داخلی را به دست آورید، اما <code>RefCell&lt;T&gt;</code>
به طور کامل قوانین وام‌دهی را دور نمی‌زند: کنترل‌کننده وام‌دهی در کامپایلر این
تغییرپذیری داخلی را مجاز می‌کند و قوانین وام‌دهی در عوض در زمان اجرا بررسی می‌شوند.
اگر این قوانین را نقض کنید، به جای خطای کامپایل، یک <code>panic!</code> دریافت خواهید کرد.</p>
<p>بیایید با یک مثال عملی کار کنیم که در آن از <code>RefCell&lt;T&gt;</code> برای تغییر مقدار غیرقابل‌تغییر
استفاده کنیم و ببینیم چرا این کار مفید است.</p>
<h4 id="یک-کاربرد-برای-تغییرپذیری-داخلی-mock-objects"><a class="header" href="#یک-کاربرد-برای-تغییرپذیری-داخلی-mock-objects">یک کاربرد برای تغییرپذیری داخلی: Mock Objects</a></h4>
<p>گاهی اوقات در طول تست، یک برنامه‌نویس از یک نوع به جای نوع دیگری استفاده می‌کند تا
رفتار خاصی را مشاهده کند و اطمینان حاصل کند که به درستی پیاده‌سازی شده است. این نوع
جایگزین <em>تست دابل</em> نامیده می‌شود. آن را به مانند یک “بدل‌کار” در فیلم‌سازی تصور
کنید، جایی که یک نفر جایگزین بازیگر می‌شود تا یک صحنه خاص و دشوار را اجرا کند.
تست دابل‌ها به جای انواع دیگر در زمان تست استفاده می‌شوند. <em>اشیاء Mock</em> نوع خاصی از
تست دابل‌ها هستند که ثبت می‌کنند در طول یک تست چه اتفاقی می‌افتد تا شما بتوانید
اطمینان حاصل کنید که اقدامات صحیح انجام شده‌اند.</p>
<p>راست اشیاء را به همان شکلی که زبان‌های دیگر دارند، ندارد و قابلیت‌های اشیاء Mock
را نیز در کتابخانه استاندارد، مانند برخی زبان‌های دیگر، ارائه نمی‌دهد. با این حال،
شما می‌توانید یک ساختار (struct) ایجاد کنید که همان مقاصد اشیاء Mock را فراهم کند.</p>
<p>در اینجا سناریویی که قصد تست آن را داریم آورده شده است: ما یک کتابخانه ایجاد
خواهیم کرد که یک مقدار را نسبت به یک مقدار حداکثری ردیابی می‌کند و بر اساس
نزدیکی مقدار فعلی به مقدار حداکثری پیام‌هایی ارسال می‌کند. به عنوان مثال، این
کتابخانه می‌تواند برای پیگیری سهمیه تعداد درخواست‌های API که یک کاربر مجاز است
انجام دهد، استفاده شود.</p>
<p>کتابخانه ما فقط عملکرد ردیابی نزدیکی یک مقدار به حداکثر و تعیین پیام‌ها در زمان‌های
خاص را فراهم خواهد کرد. انتظار می‌رود برنامه‌هایی که از کتابخانه ما استفاده می‌کنند
مکانیسم ارسال پیام‌ها را فراهم کنند: برنامه می‌تواند پیامی را در برنامه قرار دهد، یک
ایمیل ارسال کند، یک پیام متنی ارسال کند، یا چیز دیگری. کتابخانه نیازی به دانستن این
جزئیات ندارد. همه چیزی که نیاز دارد چیزی است که یک ویژگی (trait) به نام
<code>Messenger</code> که ما ارائه خواهیم کرد را پیاده‌سازی کند. کد کتابخانه در فهرست
15-20 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<figcaption>Listing 15-20: یک کتابخانه برای پیگیری نزدیکی یک مقدار به یک مقدار حداکثری و هشدار در زمانی که مقدار در سطوح خاصی است</figcaption>
</figure>
<p>یکی از بخش‌های مهم این کد این است که ویژگی <code>Messenger</code> یک متد به نام <code>send</code>
دارد که یک ارجاع غیرقابل‌تغییر به <code>self</code> و متن پیام را می‌گیرد. این ویژگی رابطی
است که شیء Mock ما باید برای استفاده به همان شیوه که یک شیء واقعی استفاده می‌شود،
پیاده‌سازی کند. بخش مهم دیگر این است که ما می‌خواهیم رفتار متد <code>set_value</code> را
روی <code>LimitTracker</code> تست کنیم. ما می‌توانیم چیزی را که به عنوان پارامتر به <code>value</code>
می‌دهیم تغییر دهیم، اما <code>set_value</code> چیزی برای ما برنمی‌گرداند که بتوانیم روی آن
ادعا کنیم. ما می‌خواهیم بتوانیم بگوییم اگر یک <code>LimitTracker</code> با چیزی که ویژگی
<code>Messenger</code> را پیاده‌سازی کرده و مقدار خاصی برای <code>max</code> ایجاد کنیم، زمانی که
مقادیر مختلفی برای <code>value</code> ارسال می‌کنیم، پیام‌رسان گفته شده است که پیام‌های
مناسب را ارسال کند.</p>
<p>ما به یک شیء Mock نیاز داریم که به جای ارسال یک ایمیل یا پیام متنی وقتی که
<code>send</code> را فراخوانی می‌کنیم، فقط پیام‌هایی را که به آن گفته شده است ارسال کند،
پیگیری کند. ما می‌توانیم یک نمونه جدید از شیء Mock ایجاد کنیم، یک
<code>LimitTracker</code> که از شیء Mock استفاده می‌کند ایجاد کنیم، متد <code>set_value</code> را
روی <code>LimitTracker</code> فراخوانی کنیم، و سپس بررسی کنیم که آیا شیء Mock پیام‌هایی که
انتظار داریم را دارد یا نه. فهرست 15-21 تلاش برای پیاده‌سازی یک شیء Mock برای
انجام همین کار را نشان می‌دهد، اما کنترل‌کننده وام‌دهی (borrow checker) این اجازه
را نمی‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-21: تلاش برای پیاده‌سازی یک <code>MockMessenger</code> که توسط کنترل‌کننده وام‌دهی اجازه داده نمی‌شود</figcaption>
</figure>
<p>این کد تست یک ساختار <code>MockMessenger</code> تعریف می‌کند که یک فیلد <code>sent_messages</code> با یک
<code>Vec</code> از مقادیر <code>String</code> دارد تا پیام‌هایی را که به آن گفته شده است ارسال کند،
پیگیری کند. ما همچنین یک تابع مرتبط <code>new</code> تعریف می‌کنیم تا ایجاد مقادیر
<code>MockMessenger</code> جدید که با یک لیست خالی از پیام‌ها شروع می‌شود، راحت باشد. سپس
ویژگی <code>Messenger</code> را برای <code>MockMessenger</code> پیاده‌سازی می‌کنیم تا بتوانیم یک
<code>MockMessenger</code> را به یک <code>LimitTracker</code> بدهیم. در تعریف متد <code>send</code>، ما پیام
ارسال‌شده به عنوان یک پارامتر را می‌گیریم و آن را در لیست <code>sent_messages</code>
درون <code>MockMessenger</code> ذخیره می‌کنیم.</p>
<p>در تست، ما در حال تست این هستیم که وقتی به <code>LimitTracker</code> گفته می‌شود مقدار
<code>value</code> را به چیزی تنظیم کند که بیش از 75 درصد مقدار <code>max</code> است، چه اتفاقی می‌افتد.
ابتدا یک <code>MockMessenger</code> جدید ایجاد می‌کنیم که با یک لیست خالی از پیام‌ها شروع می‌شود.
سپس یک <code>LimitTracker</code> جدید ایجاد می‌کنیم و یک ارجاع به <code>MockMessenger</code> جدید و یک
مقدار <code>max</code> برابر 100 به آن می‌دهیم. متد <code>set_value</code> را روی <code>LimitTracker</code> با
مقدار 80 که بیش از 75 درصد 100 است، فراخوانی می‌کنیم. سپس ادعا می‌کنیم که لیست
پیام‌هایی که <code>MockMessenger</code> پیگیری می‌کند اکنون باید یک پیام در آن داشته باشد.</p>
<p>با این حال، یک مشکل با این تست وجود دارد، همانطور که در اینجا نشان داده شده است:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>ما نمی‌توانیم <code>MockMessenger</code> را برای پیگیری پیام‌ها تغییر دهیم، زیرا متد <code>send</code> یک
ارجاع غیرقابل‌تغییر به <code>self</code> می‌گیرد. همچنین نمی‌توانیم پیشنهاد متن خطا را برای استفاده
از <code>&amp;mut self</code> در هر دو متد <code>impl</code> و تعریف ویژگی (trait) بپذیریم. ما نمی‌خواهیم فقط به
خاطر تست، ویژگی <code>Messenger</code> را تغییر دهیم. در عوض، باید راهی پیدا کنیم که کد تست
ما با طراحی موجود به درستی کار کند.</p>
<p>این یک موقعیت است که در آن تغییرپذیری داخلی می‌تواند کمک کند! ما فیلد
<code>sent_messages</code> را درون یک <code>RefCell&lt;T&gt;</code> ذخیره می‌کنیم، و سپس متد <code>send</code> قادر خواهد بود
<code>sent_messages</code> را برای ذخیره پیام‌هایی که دیده‌ایم، تغییر دهد. فهرست 15-22 نشان می‌دهد
این کار چگونه انجام می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<figcaption>Listing 15-22: استفاده از <code>RefCell&lt;T&gt;</code> برای تغییر یک مقدار داخلی در حالی که مقدار بیرونی غیرقابل‌تغییر در نظر گرفته می‌شود</figcaption>
</figure>
<p>فیلد <code>sent_messages</code> اکنون از نوع <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> به جای <code>Vec&lt;String&gt;</code> است.
در تابع <code>new</code>، یک نمونه جدید از <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> را در اطراف وکتور خالی ایجاد
می‌کنیم.</p>
<p>برای پیاده‌سازی متد <code>send</code>، پارامتر اول همچنان یک وام‌دهی غیرقابل‌تغییر به <code>self</code>
است، که با تعریف ویژگی مطابقت دارد. ما متد <code>borrow_mut</code> را روی <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
در <code>self.sent_messages</code> فراخوانی می‌کنیم تا یک ارجاع متغیر به مقدار درون
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>، که همان وکتور است، دریافت کنیم. سپس می‌توانیم روی ارجاع
متغیر به وکتور، متد <code>push</code> را فراخوانی کنیم تا پیام‌های ارسال‌شده در طول تست را پیگیری
کنیم.</p>
<p>آخرین تغییری که باید انجام دهیم در ادعا (assertion) است: برای دیدن تعداد آیتم‌های
درون وکتور داخلی، ما متد <code>borrow</code> را روی <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> فراخوانی می‌کنیم تا
یک ارجاع غیرقابل‌تغییر به وکتور دریافت کنیم.</p>
<p>حالا که دیدید چگونه از <code>RefCell&lt;T&gt;</code> استفاده کنید، بیایید به نحوه کار آن بپردازیم!</p>
<h4 id="پیگیری-وامها-در-زمان-اجرا-با-refcellt"><a class="header" href="#پیگیری-وامها-در-زمان-اجرا-با-refcellt">پیگیری وام‌ها در زمان اجرا با <code>RefCell&lt;T&gt;</code></a></h4>
<p>هنگام ایجاد ارجاع‌های غیرقابل‌تغییر و قابل‌تغییر، ما از سینتکس <code>&amp;</code> و <code>&amp;mut</code> استفاده
می‌کنیم. با <code>RefCell&lt;T&gt;</code>، از متدهای <code>borrow</code> و <code>borrow_mut</code> استفاده می‌کنیم، که
بخشی از API ایمن متعلق به <code>RefCell&lt;T&gt;</code> هستند. متد <code>borrow</code> نوع اسمارت پوینتر
<code>Ref&lt;T&gt;</code> را برمی‌گرداند، و <code>borrow_mut</code> نوع اسمارت پوینتر <code>RefMut&lt;T&gt;</code> را برمی‌گرداند.
هر دو نوع، <code>Deref</code> را پیاده‌سازی می‌کنند، بنابراین می‌توانیم با آن‌ها مثل ارجاع‌های
معمولی رفتار کنیم.</p>
<p><code>RefCell&lt;T&gt;</code> تعداد اسمارت پوینترهای <code>Ref&lt;T&gt;</code> و <code>RefMut&lt;T&gt;</code> که در حال حاضر فعال هستند
را پیگیری می‌کند. هر بار که <code>borrow</code> را فراخوانی می‌کنیم، <code>RefCell&lt;T&gt;</code> شمارش تعداد
وام‌دهی‌های غیرقابل‌تغییر فعال را افزایش می‌دهد. وقتی یک مقدار <code>Ref&lt;T&gt;</code> از دامنه
خارج می‌شود، شمارش وام‌دهی‌های غیرقابل‌تغییر یک عدد کاهش می‌یابد. دقیقاً مثل قوانین
وام‌دهی در زمان کامپایل، <code>RefCell&lt;T&gt;</code> به ما اجازه می‌دهد که در هر لحظه تعداد زیادی
وام‌دهی غیرقابل‌تغییر یا یک وام‌دهی قابل‌تغییر داشته باشیم.</p>
<p>اگر سعی کنیم این قوانین را نقض کنیم، به جای دریافت یک خطای کامپایل مثل ارجاع‌ها،
پیاده‌سازی <code>RefCell&lt;T&gt;</code> در زمان اجرا دچار وحشت (panic) خواهد شد. فهرست 15-23
اصلاحی از پیاده‌سازی متد <code>send</code> در فهرست 15-22 را نشان می‌دهد. ما به عمد سعی داریم
دو وام‌دهی قابل‌تغییر در یک دامنه ایجاد کنیم تا نشان دهیم <code>RefCell&lt;T&gt;</code> از انجام
این کار در زمان اجرا جلوگیری می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 15-23: ایجاد دو ارجاع متغیر در یک دامنه برای دیدن اینکه <code>RefCell&lt;T&gt;</code> وحشت خواهد کرد</figcaption>
</figure>
<p>ما یک متغیر به نام <code>one_borrow</code> برای اسمارت پوینتر <code>RefMut&lt;T&gt;</code> که از <code>borrow_mut</code>
بازگردانده شده است، ایجاد می‌کنیم. سپس یک وام‌دهی متغیر دیگر به همان روش در
متغیر <code>two_borrow</code> ایجاد می‌کنیم. این کار دو ارجاع متغیر در یک دامنه ایجاد می‌کند،
که مجاز نیست. هنگامی که تست‌ها را برای کتابخانه خود اجرا می‌کنیم، کد در فهرست
15-23 بدون هیچ خطایی کامپایل می‌شود، اما تست شکست خواهد خورد:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>توجه داشته باشید که کد با پیام <code>already borrowed: BorrowMutError</code> دچار وحشت
(panic) شد. این نحوه عملکرد <code>RefCell&lt;T&gt;</code> برای مدیریت نقض قوانین وام‌دهی در زمان
اجرا است.</p>
<p>انتخاب اینکه خطاهای وام‌دهی در زمان اجرا و نه در زمان کامپایل بررسی شوند، همانطور
که در اینجا انجام دادیم، به این معنا است که ممکن است اشتباهات در کد شما در مراحل
بعدی فرآیند توسعه کشف شوند: شاید حتی تا زمانی که کد شما به محیط تولید
(production) استقرار یابد. همچنین، کد شما جریمه عملکردی کوچکی را به دلیل پیگیری
وام‌ها در زمان اجرا به جای زمان کامپایل متحمل خواهد شد. با این حال، استفاده از
<code>RefCell&lt;T&gt;</code> امکان نوشتن یک شیء Mock را فراهم می‌کند که می‌تواند خود را تغییر
دهد تا پیام‌هایی که مشاهده کرده است را پیگیری کند، در حالی که شما آن را در یک
زمینه که تنها مقادیر غیرقابل‌تغییر مجاز هستند استفاده می‌کنید. شما می‌توانید
با وجود این مبادلات، از <code>RefCell&lt;T&gt;</code> برای دریافت عملکرد بیشتری نسبت به
ارجاع‌های معمولی استفاده کنید.</p>
<h3 id="داشتن-چندین-مالک-برای-دادههای-قابلتغییر-با-ترکیب-rct-و-refcellt"><a class="header" href="#داشتن-چندین-مالک-برای-دادههای-قابلتغییر-با-ترکیب-rct-و-refcellt">داشتن چندین مالک برای داده‌های قابل‌تغییر با ترکیب <code>Rc&lt;T&gt;</code> و <code>RefCell&lt;T&gt;</code></a></h3>
<p>یک روش رایج برای استفاده از <code>RefCell&lt;T&gt;</code> ترکیب آن با <code>Rc&lt;T&gt;</code> است. به خاطر
بیاورید که <code>Rc&lt;T&gt;</code> به شما اجازه می‌دهد چندین مالک برای برخی داده‌ها داشته
باشید، اما فقط دسترسی غیرقابل‌تغییر به آن داده‌ها را می‌دهد. اگر یک <code>Rc&lt;T&gt;</code>
داشته باشید که یک <code>RefCell&lt;T&gt;</code> را نگه می‌دارد، می‌توانید یک مقداری داشته باشید
که می‌تواند چندین مالک داشته باشد <em>و</em> شما بتوانید آن را تغییر دهید!</p>
<p>برای مثال، مثال لیست cons در فهرست 15-18 را به خاطر بیاورید که در آن از <code>Rc&lt;T&gt;</code>
برای اجازه دادن به چندین لیست برای اشتراک مالکیت یک لیست دیگر استفاده کردیم.
چون <code>Rc&lt;T&gt;</code> تنها مقادیر غیرقابل‌تغییر را نگه می‌دارد، نمی‌توانیم هیچ یک از مقادیر
در لیست را پس از ایجاد تغییر دهیم. بیایید <code>RefCell&lt;T&gt;</code> را اضافه کنیم تا توانایی
تغییر مقادیر در لیست‌ها را کسب کنیم. فهرست 15-24 نشان می‌دهد که با استفاده از
<code>RefCell&lt;T&gt;</code> در تعریف <code>Cons</code>، می‌توانیم مقدار ذخیره‌شده در تمام لیست‌ها را
تغییر دهیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<figcaption>Listing 15-24: استفاده از <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> برای ایجاد یک <code>List</code> که می‌توانیم آن را تغییر دهیم</figcaption>
</figure>
<p>ما مقداری که نمونه‌ای از <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> است ایجاد می‌کنیم و آن را در یک
متغیر به نام <code>value</code> ذخیره می‌کنیم تا بتوانیم بعداً به طور مستقیم به آن دسترسی
داشته باشیم. سپس یک <code>List</code> در <code>a</code> با یک متغیر <code>Cons</code> که <code>value</code> را نگه می‌دارد
ایجاد می‌کنیم. ما نیاز داریم <code>value</code> را کلون کنیم تا هر دو <code>a</code> و <code>value</code> مالک
مقدار داخلی <code>5</code> باشند، به جای انتقال مالکیت از <code>value</code> به <code>a</code> یا اینکه <code>a</code> از
<code>value</code> وام بگیرد.</p>
<p>ما لیست <code>a</code> را در یک <code>Rc&lt;T&gt;</code> می‌پیچیم تا وقتی که لیست‌های <code>b</code> و <code>c</code> را ایجاد
می‌کنیم، هر دو بتوانند به <code>a</code> ارجاع دهند، که این همان چیزی است که در فهرست 15-18
انجام دادیم.</p>
<p>پس از ایجاد لیست‌ها در <code>a</code>، <code>b</code> و <code>c</code>، می‌خواهیم 10 به مقدار درون <code>value</code> اضافه
کنیم. این کار را با فراخوانی <code>borrow_mut</code> روی <code>value</code> انجام می‌دهیم، که از
ویژگی بازارجاع خودکار (automatic dereferencing) که در فصل 5 بحث کردیم (به
بخش <a href="ch05-03-method-syntax.html#wheres-the---operator">«عملگر <code>-&gt;</code> کجاست؟»</a><!-- ignore --> مراجعه کنید)
برای بازارجاع <code>Rc&lt;T&gt;</code> به مقدار داخلی <code>RefCell&lt;T&gt;</code> استفاده می‌کند. متد
<code>borrow_mut</code> یک اسمارت پوینتر <code>RefMut&lt;T&gt;</code> برمی‌گرداند، و ما از عملگر بازارجاع
روی آن استفاده می‌کنیم و مقدار داخلی را تغییر می‌دهیم.</p>
<p>وقتی <code>a</code>، <code>b</code> و <code>c</code> را چاپ می‌کنیم، می‌بینیم که همه آن‌ها مقدار تغییر‌یافته
15 به جای 5 را دارند:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>این تکنیک واقعاً جالب است! با استفاده از <code>RefCell&lt;T&gt;</code>، ما یک مقدار <code>List</code> داریم
که به نظر غیرقابل‌تغییر است. اما می‌توانیم از متدهای موجود در <code>RefCell&lt;T&gt;</code> که
دسترسی به تغییرپذیری داخلی آن را فراهم می‌کنند استفاده کنیم تا داده‌های خود را
هر وقت که نیاز داشتیم تغییر دهیم. بررسی‌های زمان اجرا برای قوانین وام‌دهی ما را
از رقابت‌های داده (data races) محافظت می‌کند، و گاهی اوقات ارزش آن را دارد که
مقداری سرعت را برای این انعطاف‌پذیری در ساختار داده‌هایمان معامله کنیم. توجه داشته
باشید که <code>RefCell&lt;T&gt;</code> برای کد چندریسمانی کار نمی‌کند! نسخه امن برای نخ (thread-safe)
از <code>RefCell&lt;T&gt;</code>، نوع <code>Mutex&lt;T&gt;</code> است که در فصل 16 در مورد آن صحبت خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند"><a class="header" href="#چرخههای-ارجاعی-میتوانند-منجر-به-نشت-حافظه-شوند">چرخه‌های ارجاعی می‌توانند منجر به نشت حافظه شوند</a></h2>
<p>تضمین‌های ایمنی حافظه راست ایجاد حافظه‌ای که هرگز پاک نمی‌شود (که به عنوان <em>نشت حافظه</em>
شناخته می‌شود) را دشوار می‌کنند، اما غیرممکن نمی‌کنند. جلوگیری کامل از نشت حافظه
یکی از تضمین‌های راست نیست، به این معنی که نشت حافظه در راست ایمن است. ما می‌توانیم
ببینیم که راست اجازه نشت حافظه را می‌دهد با استفاده از <code>Rc&lt;T&gt;</code> و <code>RefCell&lt;T&gt;</code>:
امکان ایجاد ارجاع‌هایی وجود دارد که آیتم‌ها در آن به یکدیگر در یک چرخه ارجاع می‌دهند.
این باعث نشت حافظه می‌شود، زیرا شمارش ارجاع هر آیتم در چرخه هرگز به 0 نمی‌رسد و
مقادیر هرگز حذف نمی‌شوند.</p>
<h3 id="ایجاد-یک-چرخه-ارجاعی"><a class="header" href="#ایجاد-یک-چرخه-ارجاعی">ایجاد یک چرخه ارجاعی</a></h3>
<p>بیایید نگاهی بیندازیم که چگونه یک چرخه ارجاعی ممکن است اتفاق بیفتد و چگونه می‌توان از آن
جلوگیری کرد، با تعریف enum <code>List</code> و یک متد <code>tail</code> در فهرست 15-25 شروع می‌کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<figcaption>Listing 15-25: تعریف یک لیست cons که یک <code>RefCell&lt;T&gt;</code> نگه می‌دارد تا بتوانیم آنچه که یک متغیر <code>Cons</code> به آن اشاره می‌کند را تغییر دهیم</figcaption>
</figure>
<p>ما از یک نسخه دیگر از تعریف <code>List</code> که در فهرست 15-5 آمده بود استفاده می‌کنیم.
عنصر دوم در متغیر <code>Cons</code> اکنون <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> است، به این معنی که به جای
توانایی تغییر مقدار <code>i32</code> که در فهرست 15-24 داشتیم، می‌خواهیم مقدار <code>List</code> را که
یک متغیر <code>Cons</code> به آن اشاره می‌کند، تغییر دهیم. همچنین، یک متد <code>tail</code> اضافه
می‌کنیم تا دسترسی به آیتم دوم را در صورتی که یک متغیر <code>Cons</code> داریم، راحت‌تر کنیم.</p>
<p>در فهرست 15-26، یک تابع <code>main</code> اضافه می‌کنیم که از تعاریف فهرست 15-25 استفاده می‌کند.
این کد لیستی در <code>a</code> و لیستی در <code>b</code> ایجاد می‌کند که به لیست <code>a</code> اشاره می‌کند.
سپس لیست در <code>a</code> را تغییر می‌دهد تا به <code>b</code> اشاره کند و یک چرخه ارجاعی ایجاد کند.
در طول این فرآیند، اظهارات <code>println!</code> وجود دارند که نشان می‌دهند شمارش ارجاع
در نقاط مختلف چه مقدار است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<figcaption>Listing 15-26: ایجاد یک چرخه ارجاعی از دو مقدار <code>List</code> که به یکدیگر اشاره می‌کنند</figcaption>
</figure>
<p>ما یک نمونه <code>Rc&lt;List&gt;</code> ایجاد می‌کنیم که یک مقدار <code>List</code> را در متغیر <code>a</code> نگه می‌دارد
با یک لیست اولیه از <code>5, Nil</code>. سپس یک نمونه <code>Rc&lt;List&gt;</code> دیگر ایجاد می‌کنیم که مقدار
دیگری از <code>List</code> را در متغیر <code>b</code> نگه می‌دارد که مقدار 10 را شامل می‌شود و به لیست
در <code>a</code> اشاره می‌کند.</p>
<p>ما <code>a</code> را تغییر می‌دهیم تا به جای <code>Nil</code> به <code>b</code> اشاره کند، و یک چرخه ایجاد می‌کنیم.
این کار را با استفاده از متد <code>tail</code> انجام می‌دهیم تا یک ارجاع به <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>
در <code>a</code> بگیریم، که آن را در متغیر <code>link</code> قرار می‌دهیم. سپس از متد <code>borrow_mut</code>
روی <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> استفاده می‌کنیم تا مقدار داخلی را از یک <code>Rc&lt;List&gt;</code> که
مقدار <code>Nil</code> را نگه می‌دارد به <code>Rc&lt;List&gt;</code> در <code>b</code> تغییر دهیم.</p>
<p>وقتی این کد را اجرا می‌کنیم و <code>println!</code> آخر را به طور موقت کامنت می‌کنیم، خروجی زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>شمارش ارجاع نمونه‌های <code>Rc&lt;List&gt;</code> در هر دو <code>a</code> و <code>b</code> پس از تغییر لیست در <code>a</code> برای اشاره به <code>b</code> برابر با 2 است. در پایان تابع <code>main</code>، راست متغیر <code>b</code> را حذف می‌کند، که شمارش ارجاع نمونه <code>Rc&lt;List&gt;</code> در <code>b</code> را از 2 به 1 کاهش می‌دهد. حافظه‌ای که <code>Rc&lt;List&gt;</code> در heap اشغال کرده است در این نقطه حذف نخواهد شد، زیرا شمارش ارجاع آن برابر با 1 است و نه 0. سپس راست متغیر <code>a</code> را حذف می‌کند، که شمارش ارجاع نمونه <code>Rc&lt;List&gt;</code> در <code>a</code> را نیز از 2 به 1 کاهش می‌دهد. حافظه این نمونه نیز نمی‌تواند حذف شود، زیرا نمونه دیگر <code>Rc&lt;List&gt;</code> همچنان به آن ارجاع می‌دهد. حافظه تخصیص‌یافته به این لیست برای همیشه غیرقابل جمع‌آوری باقی خواهد ماند. برای تجسم این چرخه ارجاع، نموداری در شکل 15-4 ایجاد کرده‌ایم.</p>
<img alt="چرخه ارجاعی لیست‌ها" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">شکل 15-4: یک چرخه ارجاعی از لیست‌های <code>a</code> و <code>b</code> که به یکدیگر اشاره می‌کنند</span></p>
<p>اگر آخرین دستور <code>println!</code> را از حالت کامنت خارج کنید و برنامه را اجرا کنید، راست سعی خواهد کرد این چرخه را با <code>a</code> که به <code>b</code> و سپس به <code>a</code> اشاره می‌کند و به همین ترتیب ادامه می‌دهد، چاپ کند تا زمانی که استک سرریز شود.</p>
<p>در مقایسه با یک برنامه واقعی، عواقب ایجاد چرخه ارجاعی در این مثال چندان وخیم نیست: درست بعد از اینکه چرخه ارجاعی ایجاد می‌شود، برنامه پایان می‌یابد. با این حال، اگر یک برنامه پیچیده‌تر مقدار زیادی حافظه در یک چرخه تخصیص دهد و برای مدت طولانی آن را نگه دارد، برنامه بیشتر از حافظه‌ای که نیاز دارد استفاده خواهد کرد و ممکن است سیستم را از حافظه موجود تخلیه کند.</p>
<p>ایجاد چرخه‌های ارجاعی کار آسانی نیست، اما غیرممکن هم نیست. اگر مقادیر <code>RefCell&lt;T&gt;</code> داشته باشید که مقادیر <code>Rc&lt;T&gt;</code> یا ترکیبات مشابهی از انواع با تغییرپذیری داخلی و شمارش ارجاع را در خود جای دهند، باید مطمئن شوید که چرخه‌ای ایجاد نمی‌کنید؛ نمی‌توانید به راست اعتماد کنید که آن‌ها را شناسایی کند. ایجاد چرخه ارجاعی یک اشکال منطقی در برنامه شما خواهد بود که باید با استفاده از تست‌های خودکار، بررسی کد، و دیگر شیوه‌های توسعه نرم‌افزار، آن را به حداقل برسانید.</p>
<p>یک راه‌حل دیگر برای جلوگیری از چرخه‌های ارجاعی، بازسازی ساختار داده‌هایتان است به‌طوری که برخی ارجاعات بیانگر مالکیت باشند و برخی نباشند. به این ترتیب، می‌توانید چرخه‌هایی داشته باشید که شامل برخی روابط مالکیت و برخی روابط غیرمالکیت هستند، و تنها روابط مالکیت تعیین می‌کنند که آیا یک مقدار می‌تواند حذف شود یا خیر. در فهرست 15-25، ما همیشه می‌خواهیم که متغیرهای <code>Cons</code> مالک لیست‌هایشان باشند، بنابراین بازسازی ساختار داده امکان‌پذیر نیست. بیایید به یک مثال با استفاده از گراف‌ها که شامل گره‌های والد و فرزند هستند نگاه کنیم تا ببینیم چه زمانی روابط غیرمالکیت یک راه مناسب برای جلوگیری از چرخه‌های ارجاعی هستند.</p>
<h3 id="جلوگیری-از-چرخههای-ارجاعی-تبدیل-یک-rct-به-یک-weakt"><a class="header" href="#جلوگیری-از-چرخههای-ارجاعی-تبدیل-یک-rct-به-یک-weakt">جلوگیری از چرخه‌های ارجاعی: تبدیل یک <code>Rc&lt;T&gt;</code> به یک <code>Weak&lt;T&gt;</code></a></h3>
<p>تا اینجا، نشان داده‌ایم که فراخوانی <code>Rc::clone</code> شمارش <code>strong_count</code> یک نمونه <code>Rc&lt;T&gt;</code> را افزایش می‌دهد، و یک نمونه <code>Rc&lt;T&gt;</code> تنها زمانی پاک‌سازی می‌شود که شمارش <code>strong_count</code> آن 0 باشد. همچنین می‌توانید با فراخوانی <code>Rc::downgrade</code> و ارسال یک ارجاع به <code>Rc&lt;T&gt;</code>، یک <em>ارجاع ضعیف</em> به مقدار درون یک نمونه <code>Rc&lt;T&gt;</code> ایجاد کنید. ارجاعات قوی به شما اجازه می‌دهند مالکیت یک نمونه <code>Rc&lt;T&gt;</code> را به اشتراک بگذارید. ارجاعات ضعیف یک رابطه مالکیت را بیان نمی‌کنند، و شمارش آن‌ها تأثیری در زمان پاک‌سازی یک نمونه <code>Rc&lt;T&gt;</code> ندارد. آن‌ها باعث ایجاد چرخه ارجاعی نمی‌شوند، زیرا هر چرخه‌ای که شامل برخی ارجاعات ضعیف باشد، وقتی شمارش ارجاع قوی مقادیر درگیر 0 شود، شکسته می‌شود.</p>
<p>وقتی <code>Rc::downgrade</code> را فراخوانی می‌کنید، یک اسمارت پوینتر از نوع <code>Weak&lt;T&gt;</code> دریافت می‌کنید. به جای افزایش شمارش <code>strong_count</code> در نمونه <code>Rc&lt;T&gt;</code> به مقدار 1، فراخوانی <code>Rc::downgrade</code> شمارش <code>weak_count</code> را به مقدار 1 افزایش می‌دهد. نوع <code>Rc&lt;T&gt;</code> از <code>weak_count</code> برای پیگیری تعداد ارجاعات <code>Weak&lt;T&gt;</code> موجود استفاده می‌کند، مشابه <code>strong_count</code>. تفاوت این است که شمارش <code>weak_count</code> نیازی به 0 بودن برای پاک‌سازی نمونه <code>Rc&lt;T&gt;</code> ندارد.</p>
<p>از آنجا که مقداری که <code>Weak&lt;T&gt;</code> به آن ارجاع می‌دهد ممکن است حذف شده باشد، برای انجام هر
کاری با مقداری که یک <code>Weak&lt;T&gt;</code> به آن اشاره می‌کند، باید مطمئن شوید که مقدار هنوز
وجود دارد. این کار را با فراخوانی متد <code>upgrade</code> روی یک نمونه <code>Weak&lt;T&gt;</code> انجام دهید،
که یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> را برمی‌گرداند. اگر مقدار <code>Rc&lt;T&gt;</code> هنوز حذف نشده باشد، نتیجه
<code>Some</code> خواهد بود و اگر مقدار <code>Rc&lt;T&gt;</code> حذف شده باشد، نتیجه <code>None</code> خواهد بود. از آنجا
که <code>upgrade</code> یک <code>Option&lt;Rc&lt;T&gt;&gt;</code> را برمی‌گرداند، راست تضمین می‌کند که حالت
<code>Some</code> و حالت <code>None</code> مدیریت می‌شوند و هیچ اشاره‌گر (Pointer) نامعتبری وجود نخواهد داشت.</p>
<p>برای مثال، به جای استفاده از یک لیست که آیتم‌های آن فقط درباره آیتم بعدی اطلاع دارند،
ما یک درخت ایجاد خواهیم کرد که آیتم‌های آن درباره آیتم‌های فرزند <em>و</em> والد خود اطلاع دارند.</p>
<h4 id="ایجاد-یک-ساختار-داده-درخت-یک-node-با-گرههای-فرزند"><a class="header" href="#ایجاد-یک-ساختار-داده-درخت-یک-node-با-گرههای-فرزند">ایجاد یک ساختار داده درخت: یک <code>Node</code> با گره‌های فرزند</a></h4>
<p>برای شروع، ما یک درخت با گره‌هایی ایجاد خواهیم کرد که درباره گره‌های فرزند خود اطلاع
دارند. ما یک ساختار به نام <code>Node</code> ایجاد خواهیم کرد که مقدار <code>i32</code> خود را نگه می‌دارد
و همچنین به گره‌های فرزند خود ارجاع می‌دهد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>ما می‌خواهیم که یک <code>Node</code> مالک فرزندان خود باشد و همچنین می‌خواهیم که این مالکیت با
متغیرها به اشتراک گذاشته شود تا بتوانیم مستقیماً به هر <code>Node</code> در درخت دسترسی داشته
باشیم. برای انجام این کار، آیتم‌های <code>Vec&lt;T&gt;</code> را به عنوان مقادیری از نوع <code>Rc&lt;Node&gt;</code>
تعریف می‌کنیم. همچنین می‌خواهیم تغییر دهیم که کدام گره‌ها فرزندان یک گره دیگر باشند،
بنابراین در <code>children</code> یک <code>RefCell&lt;T&gt;</code> در اطراف <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> قرار می‌دهیم.</p>
<p>سپس، تعریف ساختار خود را استفاده می‌کنیم و یک نمونه <code>Node</code> به نام <code>leaf</code> با مقدار 3 و
بدون فرزند، و یک نمونه دیگر به نام <code>branch</code> با مقدار 5 و <code>leaf</code> به عنوان یکی از فرزندان
آن ایجاد می‌کنیم، همانطور که در فهرست 15-27 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<figcaption>Listing 15-27: ایجاد یک گره <code>leaf</code> بدون فرزند و یک گره <code>branch</code> با <code>leaf</code> به عنوان یکی از فرزندان آن</figcaption>
</figure>
<p>ما <code>Rc&lt;Node&gt;</code> را در <code>leaf</code> کلون می‌کنیم و آن را در <code>branch</code> ذخیره می‌کنیم، به این
معنی که <code>Node</code> در <code>leaf</code> اکنون دو مالک دارد: <code>leaf</code> و <code>branch</code>. ما می‌توانیم از
<code>branch</code> به <code>leaf</code> از طریق <code>branch.children</code> برسیم، اما هیچ راهی برای رفتن از
<code>leaf</code> به <code>branch</code> وجود ندارد. دلیل این است که <code>leaf</code> هیچ ارجاعی به <code>branch</code>
ندارد و نمی‌داند که آن‌ها مرتبط هستند. ما می‌خواهیم که <code>leaf</code> بداند که <code>branch</code>
والد آن است. این کار را در مرحله بعد انجام خواهیم داد.</p>
<h4 id="افزودن-یک-ارجاع-از-فرزند-به-والد"><a class="header" href="#افزودن-یک-ارجاع-از-فرزند-به-والد">افزودن یک ارجاع از فرزند به والد</a></h4>
<p>برای آگاه کردن گره فرزند از والدش، باید یک فیلد <code>parent</code> به تعریف ساختار <code>Node</code> خود اضافه کنیم. مشکل در تصمیم‌گیری در مورد نوع <code>parent</code> است. می‌دانیم که نمی‌تواند شامل یک <code>Rc&lt;T&gt;</code> باشد، زیرا این امر باعث ایجاد چرخه ارجاعی می‌شود که در آن <code>leaf.parent</code> به <code>branch</code> اشاره می‌کند و <code>branch.children</code> به <code>leaf</code>، که باعث می‌شود مقادیر <code>strong_count</code> آن‌ها هرگز به 0 نرسد.</p>
<p>با در نظر گرفتن روابط از دیدگاهی دیگر، یک گره والد باید مالک فرزندان خود باشد: اگر یک گره والد حذف شود، گره‌های فرزند آن نیز باید حذف شوند. اما، یک فرزند نباید مالک والدش باشد: اگر یک گره فرزند حذف شود، والد باید همچنان وجود داشته باشد. این مورد برای استفاده از ارجاعات ضعیف (weak references) مناسب است!</p>
<p>بنابراین، به جای <code>Rc&lt;T&gt;</code>، نوع <code>parent</code> را از نوع <code>Weak&lt;T&gt;</code> انتخاب می‌کنیم، به طور خاص یک <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. اکنون تعریف ساختار <code>Node</code> ما به این شکل است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>یک گره قادر خواهد بود به گره والد خود ارجاع دهد اما مالک والد نخواهد بود. در فهرست 15-28، ما تابع <code>main</code> را به‌روزرسانی می‌کنیم تا از این تعریف جدید استفاده کنیم، به‌طوری که گره <code>leaf</code> راهی برای ارجاع به والد خود، <code>branch</code>، داشته باشد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<figcaption>Listing 15-28: یک گره <code>leaf</code> با یک ارجاع ضعیف به گره والد خود <code>branch</code></figcaption>
</figure>
<p>ایجاد گره <code>leaf</code> مشابه فهرست 15-27 است با این تفاوت که فیلد <code>parent</code>: <code>leaf</code> ابتدا بدون والد شروع می‌شود، بنابراین یک نمونه جدید و خالی از ارجاع <code>Weak&lt;Node&gt;</code> ایجاد می‌کنیم.</p>
<p>در این مرحله، وقتی سعی می‌کنیم با استفاده از متد <code>upgrade</code> به والد گره <code>leaf</code> دسترسی پیدا کنیم، یک مقدار <code>None</code> دریافت می‌کنیم. این مورد را در خروجی اولین دستور <code>println!</code> مشاهده می‌کنیم:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>وقتی گره <code>branch</code> را ایجاد می‌کنیم، آن نیز یک ارجاع جدید <code>Weak&lt;Node&gt;</code> در فیلد <code>parent</code> خواهد داشت، زیرا <code>branch</code> گره والد ندارد. همچنان گره <code>leaf</code> به‌عنوان یکی از فرزندان <code>branch</code> است. وقتی نمونه <code>Node</code> در <code>branch</code> را داریم، می‌توانیم <code>leaf</code> را تغییر دهیم تا به والد خود یک ارجاع <code>Weak&lt;Node&gt;</code> بدهد. از متد <code>borrow_mut</code> روی <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> در فیلد <code>parent</code> از <code>leaf</code> استفاده می‌کنیم و سپس از تابع <code>Rc::downgrade</code> برای ایجاد یک ارجاع <code>Weak&lt;Node&gt;</code> به <code>branch</code> از <code>Rc&lt;Node&gt;</code> در <code>branch</code> استفاده می‌کنیم.</p>
<p>وقتی والد گره <code>leaf</code> را دوباره چاپ می‌کنیم، این بار یک متغیر <code>Some</code> که <code>branch</code> را
نگه می‌دارد دریافت می‌کنیم: اکنون <code>leaf</code> می‌تواند به والد خود دسترسی پیدا کند!
هنگامی که <code>leaf</code> را چاپ می‌کنیم، همچنین از چرخه‌ای که نهایتاً به سرریز شدن استک
مانند فهرست 15-26 منجر می‌شد اجتناب می‌کنیم؛ ارجاعات <code>Weak&lt;Node&gt;</code> به‌صورت <code>(Weak)</code>
چاپ می‌شوند:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>نبود خروجی بی‌نهایت نشان می‌دهد که این کد چرخه ارجاعی ایجاد نکرده است. همچنین می‌توانیم
این را با مشاهده مقادیری که از فراخوانی <code>Rc::strong_count</code> و <code>Rc::weak_count</code>
دریافت می‌کنیم، تأیید کنیم.</p>
<h4 id="تجسم-تغییرات-در-strong_count-و-weak_count"><a class="header" href="#تجسم-تغییرات-در-strong_count-و-weak_count">تجسم تغییرات در <code>strong_count</code> و <code>weak_count</code></a></h4>
<p>بیایید نگاهی بیندازیم که چگونه مقادیر <code>strong_count</code> و <code>weak_count</code> نمونه‌های
<code>Rc&lt;Node&gt;</code> با ایجاد یک دامنه داخلی جدید و انتقال ایجاد <code>branch</code> به آن دامنه تغییر
می‌کنند. با این کار، می‌توانیم ببینیم چه اتفاقی می‌افتد وقتی <code>branch</code> ایجاد و سپس
هنگام خارج شدن از دامنه حذف می‌شود. تغییرات در فهرست 15-29 نشان داده شده‌اند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<figcaption>Listing 15-29: ایجاد <code>branch</code> در یک دامنه داخلی و بررسی شمارش ارجاعات قوی و ضعیف</figcaption>
</figure>
<p>پس از ایجاد <code>leaf</code>، <code>Rc&lt;Node&gt;</code> آن دارای شمارش قوی 1 و شمارش ضعیف 0 است. در دامنه
داخلی، ما <code>branch</code> را ایجاد می‌کنیم و آن را با <code>leaf</code> مرتبط می‌کنیم، در این نقطه
وقتی شمارش‌ها را چاپ می‌کنیم، <code>Rc&lt;Node&gt;</code> در <code>branch</code> دارای شمارش قوی 1 و شمارش
ضعیف 1 خواهد بود (برای <code>leaf.parent</code> که به <code>branch</code> با یک <code>Weak&lt;Node&gt;</code> اشاره
می‌کند). وقتی شمارش‌ها را در <code>leaf</code> چاپ می‌کنیم، می‌بینیم که شمارش قوی آن 2 خواهد
بود، زیرا <code>branch</code> اکنون یک کلون از <code>Rc&lt;Node&gt;</code> در <code>leaf</code> که در <code>branch.children</code>
ذخیره شده است، دارد، اما همچنان شمارش ضعیف 0 خواهد بود.</p>
<p>وقتی دامنه داخلی به پایان می‌رسد، <code>branch</code> از دامنه خارج می‌شود و شمارش قوی
<code>Rc&lt;Node&gt;</code> به 0 کاهش می‌یابد، بنابراین <code>Node</code> آن حذف می‌شود. شمارش ضعیف 1 از
<code>leaf.parent</code> تأثیری بر اینکه آیا <code>Node</code> حذف می‌شود ندارد، بنابراین هیچ نشت
حافظه‌ای نخواهیم داشت!</p>
<p>اگر سعی کنیم پس از پایان دامنه به والد <code>leaf</code> دسترسی پیدا کنیم، دوباره مقدار
<code>None</code> دریافت خواهیم کرد. در پایان برنامه، <code>Rc&lt;Node&gt;</code> در <code>leaf</code> دارای شمارش قوی 1
و شمارش ضعیف 0 است، زیرا متغیر <code>leaf</code> اکنون تنها ارجاع به <code>Rc&lt;Node&gt;</code> است.</p>
<p>تمام منطق مدیریت شمارش‌ها و حذف مقدار درون <code>Rc&lt;T&gt;</code> و <code>Weak&lt;T&gt;</code> و پیاده‌سازی‌های
ویژگی <code>Drop</code> آن‌ها تعبیه شده است. با مشخص کردن اینکه رابطه از یک فرزند به والد
آن باید یک ارجاع <code>Weak&lt;T&gt;</code> باشد در تعریف <code>Node</code>، می‌توانید گره‌های والد را
به گره‌های فرزند و بالعکس ارجاع دهید بدون ایجاد یک چرخه ارجاعی و نشت حافظه.</p>
<h2 id="خلاصه-14"><a class="header" href="#خلاصه-14">خلاصه</a></h2>
<p>این فصل نحوه استفاده از اسمارت پوینترها برای ارائه تضمین‌ها و مبادلات متفاوت
از آنچه که راست به طور پیش‌فرض با ارجاع‌های معمولی ارائه می‌دهد را پوشش داد.
نوع <code>Box&lt;T&gt;</code> دارای اندازه مشخصی است و به داده‌های تخصیص‌یافته در heap اشاره می‌کند.
نوع <code>Rc&lt;T&gt;</code> تعداد ارجاع‌ها به داده‌ها در heap را پیگیری می‌کند تا داده‌ها بتوانند
چندین مالک داشته باشند. نوع <code>RefCell&lt;T&gt;</code> با تغییرپذیری داخلی خود به ما نوعی
می‌دهد که می‌توانیم زمانی که به یک نوع غیرقابل‌تغییر نیاز داریم اما باید مقدار
درونی آن نوع را تغییر دهیم، استفاده کنیم؛ همچنین قوانین وام‌دهی را در زمان اجرا
به جای زمان کامپایل اعمال می‌کند.</p>
<p>همچنین، ویژگی‌های <code>Deref</code> و <code>Drop</code> که بسیاری از قابلیت‌های اسمارت پوینترها را
ممکن می‌سازند، مورد بحث قرار گرفتند. ما چرخه‌های ارجاعی که می‌توانند باعث
نشت حافظه شوند و نحوه جلوگیری از آن‌ها با استفاده از <code>Weak&lt;T&gt;</code> را بررسی کردیم.</p>
<p>اگر این فصل علاقه شما را برانگیخته و می‌خواهید اسمارت پوینترهای خود را پیاده‌سازی
کنید، به <a href="../nomicon/index.html">“The Rustonomicon”</a> برای اطلاعات مفید بیشتر مراجعه کنید.</p>
<p>در فصل بعدی، درباره همزمانی (concurrency) در راست صحبت خواهیم کرد. حتی با
چند اسمارت پوینتر جدید نیز آشنا خواهید شد.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="همزمانی-بدون-ترس"><a class="header" href="#همزمانی-بدون-ترس">همزمانی بدون ترس</a></h1>
<p>مدیریت برنامه‌نویسی همزمان به صورت ایمن و کارآمد یکی از اهداف اصلی Rust است. <em>برنامه‌نویسی همزمان</em>، جایی که بخش‌های مختلف یک برنامه به صورت مستقل اجرا می‌شوند، و <em>برنامه‌نویسی موازی</em>، جایی که بخش‌های مختلف یک برنامه به صورت همزمان اجرا می‌شوند، در حال تبدیل شدن به جنبه‌های فزاینده‌ای مهم هستند زیرا تعداد بیشتری از کامپیوترها از پردازنده‌های چندگانه خود استفاده می‌کنند. به طور تاریخی، برنامه‌نویسی در این زمینه‌ها سخت و مستعد خطا بوده است: Rust امیدوار است این موضوع را تغییر دهد.</p>
<p>در ابتدا، تیم Rust فکر می‌کرد که تضمین ایمنی حافظه و جلوگیری از مشکلات همزمانی دو چالش جداگانه هستند که باید با روش‌های متفاوت حل شوند. با گذشت زمان، تیم دریافت که سیستم‌های مالکیت و نوع مجموعه‌ای قدرتمند از ابزارها هستند که به مدیریت ایمنی حافظه <em>و</em> مشکلات همزمانی کمک می‌کنند! با استفاده از مالکیت و بررسی نوع، بسیاری از خطاهای همزمانی در Rust به جای خطاهای زمان اجرا، به خطاهای زمان کامپایل تبدیل می‌شوند. بنابراین، به جای اینکه وقت زیادی را صرف بازتولید دقیق شرایطی کنید که در آن یک خطای همزمانی در زمان اجرا رخ می‌دهد، کد نادرست از کامپایل خودداری کرده و یک خطا ارائه می‌دهد که مشکل را توضیح می‌دهد. در نتیجه، می‌توانید کد خود را در حین کار روی آن برطرف کنید، به جای اینکه احتمالاً بعد از ارسال آن به تولید. ما این جنبه از Rust را <em>همزمانی بدون ترس</em> نامیده‌ایم. همزمانی بدون ترس به شما امکان می‌دهد کدی بنویسید که بدون باگ‌های ظریف باشد و به راحتی بازسازی شود بدون اینکه باگ‌های جدید معرفی کند.</p>
<blockquote>
<p>نکته: برای سادگی، ما به بسیاری از مشکلات به عنوان <em>همزمان</em> اشاره خواهیم کرد به جای اینکه دقیق‌تر بگوییم <em>همزمان و/یا موازی</em>. اگر این کتاب درباره همزمانی و/یا موازی بودن بود، دقیق‌تر بودیم. برای این فصل، لطفاً هر جا که از <em>همزمان</em> استفاده می‌کنیم، به صورت ذهنی <em>همزمان و/یا موازی</em> را جایگزین کنید.</p>
</blockquote>
<p>بسیاری از زبان‌ها درباره راه‌حل‌هایی که برای مدیریت مشکلات همزمان ارائه می‌دهند بسیار دگماتیک هستند. برای مثال، Erlang عملکرد زیبا و کارآمدی برای همزمانی مبتنی بر پیام‌رسانی ارائه می‌دهد اما فقط روش‌های پیچیده‌ای برای اشتراک وضعیت بین نخ‌ها دارد. پشتیبانی از یک زیرمجموعه از راه‌حل‌های ممکن یک استراتژی منطقی برای زبان‌های سطح بالا است، زیرا یک زبان سطح بالا وعده‌هایی در ازای از دست دادن بخشی از کنترل برای به دست آوردن انتزاع‌ها ارائه می‌دهد. با این حال، از زبان‌های سطح پایین انتظار می‌رود که بهترین راه‌حل را برای هر وضعیت خاص با بهترین عملکرد ارائه دهند و انتزاع کمتری نسبت به سخت‌افزار داشته باشند. بنابراین، Rust مجموعه‌ای از ابزارها را برای مدل‌سازی مشکلات در هر راهی که برای وضعیت و نیازهای شما مناسب باشد، ارائه می‌دهد.</p>
<p>موضوعاتی که در این فصل پوشش خواهیم داد عبارت‌اند از:</p>
<div dir="rtl">
    <ul>
        <li>نحوه ایجاد نخ‌ها برای اجرای همزمان چندین بخش از کد</li>
        <li>همزمانی <em>پیام‌رسانی</em>، جایی که کانال‌ها پیام‌ها را بین نخ‌ها ارسال می‌کنند</li>
        <li>همزمانی <em>حالت اشتراکی</em>، جایی که چندین نخ به بخشی از داده دسترسی دارند</li>
        <li>صفات <code>Sync</code> و <code>Send</code>، که تضمین‌های همزمانی Rust را به انواع تعریف‌شده توسط کاربر و همچنین انواع ارائه‌شده توسط کتابخانه استاندارد گسترش می‌دهند</li>
    </ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="استفاده-از-نخها-برای-اجرای-همزمان-کد"><a class="header" href="#استفاده-از-نخها-برای-اجرای-همزمان-کد">استفاده از نخ‌ها برای اجرای همزمان کد</a></h2>
<p>در بیشتر سیستم‌عامل‌های مدرن، کدی که یک برنامه اجرا می‌کند در یک <em>فرایند</em> اجرا می‌شود و سیستم‌عامل به طور همزمان چندین فرایند را مدیریت می‌کند. در یک برنامه، شما همچنین می‌توانید بخش‌های مستقلی داشته باشید که به صورت همزمان اجرا شوند. ویژگی‌هایی که این بخش‌های مستقل را اجرا می‌کنند <em>نخ‌ها</em> نامیده می‌شوند. برای مثال، یک سرور وب می‌تواند چندین نخ داشته باشد تا بتواند به بیش از یک درخواست به طور همزمان پاسخ دهد.</p>
<p>تقسیم محاسبات در برنامه شما به چندین نخ برای اجرای چندین کار به طور همزمان می‌تواند عملکرد را بهبود بخشد، اما همچنین پیچیدگی را افزایش می‌دهد. از آنجایی که نخ‌ها می‌توانند به طور همزمان اجرا شوند، هیچ تضمینی برای ترتیب اجرای بخش‌های کد در نخ‌های مختلف وجود ندارد. این موضوع می‌تواند به مشکلاتی منجر شود، مانند:</p>
<ul>
<li>شرایط رقابتی (Race conditions)، جایی که نخ‌ها داده‌ها یا منابع را به ترتیب ناسازگار دسترسی دارند</li>
<li>بن‌بست‌ها (Deadlocks)، جایی که دو نخ منتظر یکدیگر هستند و مانع از ادامه کار هر دو نخ می‌شوند</li>
<li>باگ‌هایی که فقط در شرایط خاص رخ می‌دهند و به سختی قابل بازتولید و رفع هستند</li>
</ul>
<p>Rust تلاش می‌کند اثرات منفی استفاده از نخ‌ها را کاهش دهد، اما برنامه‌نویسی در یک زمینه چندنخی همچنان نیاز به تفکر دقیق و ساختاری متفاوت از برنامه‌های تک‌نخی دارد.</p>
<p>زبان‌های برنامه‌نویسی نخ‌ها را به چندین روش مختلف پیاده‌سازی می‌کنند و بسیاری از سیستم‌عامل‌ها API‌هایی ارائه می‌دهند که زبان می‌تواند برای ایجاد نخ‌های جدید فراخوانی کند. کتابخانه استاندارد Rust از یک مدل پیاده‌سازی نخ <em>1:1</em> استفاده می‌کند، به این معنا که برنامه یک نخ سیستم‌عامل به ازای هر نخ زبان استفاده می‌کند. جعبه‌ها (crates)یی وجود دارند که مدل‌های دیگر نخ را پیاده‌سازی می‌کنند و مبادله‌های متفاوتی نسبت به مدل 1:1 ارائه می‌دهند. (سیستم async در Rust، که در فصل بعدی آن را خواهیم دید، روش دیگری برای همزمانی ارائه می‌دهد.)</p>
<h3 id="ایجاد-یک-نخ-جدید-با-spawn"><a class="header" href="#ایجاد-یک-نخ-جدید-با-spawn">ایجاد یک نخ جدید با <code>spawn</code></a></h3>
<p>برای ایجاد یک نخ جدید، تابع <code>thread::spawn</code> را فراخوانی می‌کنیم و یک closure (که در فصل 13 در مورد آن صحبت کردیم) شامل کدی که می‌خواهیم در نخ جدید اجرا کنیم، به آن پاس می‌دهیم. مثال در لیستینگ 16-1 متنی را از نخ اصلی و متن دیگری را از یک نخ جدید چاپ می‌کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<figcaption>Listing 16-1: ایجاد یک نخ جدید برای چاپ یک چیز در حالی که نخ اصلی چیز دیگری چاپ می‌کند</figcaption>
</figure>
<p>توجه داشته باشید که وقتی نخ اصلی یک برنامه Rust تکمیل می‌شود، تمام نخ‌های ایجادشده متوقف می‌شوند، چه آن‌ها اجرای خود را تکمیل کرده باشند یا نه. خروجی این برنامه ممکن است هر بار کمی متفاوت باشد، اما به صورت مشابه زیر خواهد بود:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>فراخوانی‌های <code>thread::sleep</code> باعث می‌شوند یک نخ اجرای خود را برای مدت کوتاهی متوقف کند و به نخ دیگری اجازه اجرا دهد. احتمالاً نخ‌ها نوبتی اجرا می‌شوند، اما این موضوع تضمین‌شده نیست: به نحوه زمان‌بندی نخ‌ها توسط سیستم‌عامل شما بستگی دارد. در این اجرای برنامه، نخ اصلی ابتدا چاپ کرد، حتی با اینکه دستور چاپ از نخ ایجادشده در کد ابتدا ظاهر می‌شود. و با اینکه به نخ ایجادشده گفتیم تا زمانی که مقدار <code>i</code> به 9 برسد چاپ کند، فقط تا مقدار 5 رسید قبل از اینکه نخ اصلی خاموش شود.</p>
<p>اگر این کد را اجرا کردید و فقط خروجی نخ اصلی را دیدید یا هیچ تداخل زمانی مشاهده نکردید، سعی کنید اعداد موجود در بازه‌ها را افزایش دهید تا فرصت بیشتری برای سیستم‌عامل ایجاد شود تا بین نخ‌ها جابه‌جا شود.</p>
<h3 id="منتظر-ماندن-برای-تکمیل-همه-نخها-با-استفاده-از-join-handles"><a class="header" href="#منتظر-ماندن-برای-تکمیل-همه-نخها-با-استفاده-از-join-handles">منتظر ماندن برای تکمیل همه نخ‌ها با استفاده از <code>join</code> Handles</a></h3>
<p>کد موجود در لیستینگ 16-1 نه تنها بیشتر اوقات نخ ایجادشده را به دلیل پایان نخ اصلی زودتر از موعد متوقف می‌کند، بلکه به دلیل اینکه هیچ تضمینی برای ترتیب اجرای نخ‌ها وجود ندارد، نمی‌توانیم اطمینان حاصل کنیم که نخ ایجادشده اجرا خواهد شد!</p>
<p>می‌توانیم مشکل اجرا نشدن یا پایان زودهنگام نخ ایجادشده را با ذخیره مقدار بازگشتی <code>thread::spawn</code> در یک متغیر رفع کنیم. نوع بازگشتی <code>thread::spawn</code> یک <code>JoinHandle</code> است. یک <code>JoinHandle</code> یک مقدار مالکیت‌دار است که وقتی متد <code>join</code> را روی آن فراخوانی می‌کنیم، منتظر می‌ماند تا نخ مرتبط با آن تکمیل شود. لیستینگ 16-2 نشان می‌دهد چگونه از <code>JoinHandle</code> نخ ایجادشده در لیستینگ 16-1 استفاده کنیم و <code>join</code> را فراخوانی کنیم تا مطمئن شویم نخ ایجادشده قبل از خروج <code>main</code> تکمیل می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<figcaption>Listing 16-2: ذخیره یک <code>JoinHandle</code> از <code>thread::spawn</code> برای اطمینان از اینکه نخ تا پایان اجرا می‌شود</figcaption>
</figure>
<p>فراخوانی <code>join</code> روی handle نخ جاری را مسدود می‌کند تا زمانی که نخ نمایانده‌شده توسط handle خاتمه یابد. <em>مسدود کردن</em> یک نخ به این معناست که آن نخ از انجام کار یا خروج جلوگیری می‌شود. چون فراخوانی <code>join</code> را بعد از حلقه <code>for</code> نخ اصلی قرار داده‌ایم، اجرای لیستینگ 16-2 باید خروجی مشابه زیر تولید کند:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>دو نخ همچنان به صورت متناوب اجرا می‌شوند، اما نخ اصلی به دلیل فراخوانی <code>handle.join()</code> منتظر می‌ماند و تا زمانی که نخ ایجادشده تکمیل نشود پایان نمی‌یابد.</p>
<p>اما بیایید ببینیم چه اتفاقی می‌افتد اگر <code>handle.join()</code> را قبل از حلقه <code>for</code> در <code>main</code> منتقل کنیم، به این صورت:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</figure>
<p>نخ اصلی منتظر می‌ماند تا نخ ایجادشده خاتمه یابد و سپس حلقه <code>for</code> خود را اجرا می‌کند، بنابراین خروجی دیگر به صورت متناوب نخواهد بود، همان‌طور که در اینجا نشان داده شده است:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>جزئیات کوچک، مانند مکان فراخوانی <code>join</code>، می‌توانند بر اینکه نخ‌های شما همزمان اجرا می‌شوند یا خیر تأثیر بگذارند.</p>
<h3 id="استفاده-از-closureهای-move-با-نخها"><a class="header" href="#استفاده-از-closureهای-move-با-نخها">استفاده از Closureهای <code>move</code> با نخ‌ها</a></h3>
<p>ما اغلب از کلمه کلیدی <code>move</code> با closureهایی که به <code>thread::spawn</code> پاس داده می‌شوند استفاده می‌کنیم، زیرا این closure سپس مالکیت مقادیری را که از محیط استفاده می‌کند، می‌گیرد و بنابراین مالکیت آن مقادیر را از یک نخ به نخ دیگر منتقل می‌کند. در بخش <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">“گرفتن ارجاع‌ها یا انتقال مالکیت”</a><!-- ignore --> در فصل 13، <code>move</code> را در زمینه closureها مورد بحث قرار دادیم. اکنون بیشتر روی تعامل بین <code>move</code> و <code>thread::spawn</code> تمرکز خواهیم کرد.</p>
<p>توجه کنید که در لیستینگ 16-1، closureی که به <code>thread::spawn</code> پاس می‌دهیم هیچ آرگومانی نمی‌گیرد: ما از هیچ داده‌ای از نخ اصلی در کد نخ ایجادشده استفاده نمی‌کنیم. برای استفاده از داده‌های نخ اصلی در نخ ایجادشده، closure نخ ایجادشده باید مقادیری که نیاز دارد را بگیرد. لیستینگ 16-3 تلاشی برای ایجاد یک بردار در نخ اصلی و استفاده از آن در نخ ایجادشده را نشان می‌دهد. با این حال، این کد هنوز کار نخواهد کرد، همان‌طور که در لحظه‌ای خواهید دید.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
<figcaption>Listing 16-3: تلاش برای استفاده از یک بردار ایجادشده توسط نخ اصلی در یک نخ دیگر</figcaption>
</figure>
<p>این closure از <code>v</code> استفاده می‌کند، بنابراین <code>v</code> را می‌گیرد و آن را بخشی از محیط closure می‌کند. از آنجا که <code>thread::spawn</code> این closure را در یک نخ جدید اجرا می‌کند، باید بتوانیم به <code>v</code> در داخل آن نخ جدید دسترسی داشته باشیم. اما وقتی این مثال را کامپایل می‌کنیم، خطای زیر را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust به طور <em>استنتاجی</em> تعیین می‌کند که چگونه <code>v</code> را بگیرد، و چون <code>println!</code> فقط به یک ارجاع به <code>v</code> نیاز دارد، closure سعی می‌کند <code>v</code> را قرض بگیرد. با این حال، مشکلی وجود دارد: Rust نمی‌تواند بگوید نخ ایجادشده چه مدت اجرا خواهد شد، بنابراین نمی‌داند که ارجاع به <code>v</code> همیشه معتبر خواهد بود.</p>
<p>لیستینگ 16-4 سناریویی را ارائه می‌دهد که احتمال بیشتری برای داشتن یک ارجاع نامعتبر به <code>v</code> دارد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<figcaption>Listing 16-4: یک نخ با closureی که سعی می‌کند یک ارجاع به <code>v</code> را از نخ اصلی که <code>v</code> را حذف می‌کند بگیرد</figcaption>
</figure>
<p>اگر Rust به ما اجازه اجرای این کد را می‌داد، این احتمال وجود داشت که نخ ایجادشده بلافاصله به پس‌زمینه برود بدون اینکه اصلاً اجرا شود. نخ ایجادشده یک ارجاع به <code>v</code> داخل خود دارد، اما نخ اصلی بلافاصله <code>v</code> را حذف می‌کند، با استفاده از تابع <code>drop</code> که در فصل 15 مورد بحث قرار گرفت. سپس، وقتی نخ ایجادشده شروع به اجرا می‌کند، <code>v</code> دیگر معتبر نیست، بنابراین ارجاع به آن نیز نامعتبر است. اوه نه!</p>
<p>برای رفع خطای کامپایل در لیستینگ 16-3، می‌توانیم از مشاوره پیام خطا استفاده کنیم:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>با افزودن کلمه کلیدی <code>move</code> قبل از closure، ما closure را مجبور می‌کنیم که مالکیت مقادیری که استفاده می‌کند را بگیرد، به جای اینکه به Rust اجازه دهیم استنتاج کند که باید مقادیر را قرض بگیرد. تغییرات اعمال‌شده به لیستینگ 16-3 که در لیستینگ 16-5 نشان داده شده است، همان‌طور که انتظار داریم کامپایل و اجرا خواهد شد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<figcaption>Listing 16-5: استفاده از کلمه کلیدی <code>move</code> برای مجبور کردن یک closure به گرفتن مالکیت مقادیری که استفاده می‌کند</figcaption>
</figure>
<p>ممکن است وسوسه شویم که همین کار را برای رفع کد در لیستینگ 16-4 که نخ اصلی <code>drop</code> را فراخوانی می‌کند با استفاده از یک closure <code>move</code> انجام دهیم. با این حال، این راه‌حل کار نخواهد کرد زیرا آنچه لیستینگ 16-4 تلاش می‌کند انجام دهد به دلیل دیگری مجاز نیست. اگر <code>move</code> را به closure اضافه کنیم، <code>v</code> را به محیط closure منتقل می‌کنیم و دیگر نمی‌توانیم <code>drop</code> را در نخ اصلی روی آن فراخوانی کنیم. در عوض، این خطای کامپایل را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>قوانین مالکیت Rust دوباره ما را نجات دادند! ما از کد موجود در لیستینگ 16-3 خطا گرفتیم زیرا Rust محافظه‌کار بود و فقط <code>v</code> را برای نخ قرض گرفت، که به این معنا بود که نخ اصلی می‌توانست به‌صورت نظری مرجع نخ ایجادشده را نامعتبر کند. با گفتن به Rust که مالکیت <code>v</code> را به نخ ایجادشده منتقل کند، ما به Rust تضمین می‌دهیم که نخ اصلی دیگر از <code>v</code> استفاده نخواهد کرد. اگر لیستینگ 16-4 را به همان روش تغییر دهیم، آنگاه هنگام تلاش برای استفاده از <code>v</code> در نخ اصلی، قوانین مالکیت را نقض می‌کنیم. کلمه کلیدی <code>move</code> رفتار محافظه‌کارانه پیش‌فرض Rust در قرض‌گیری را لغو می‌کند؛ اما اجازه نمی‌دهد قوانین مالکیت را نقض کنیم.</p>
<p>با داشتن درک اولیه‌ای از نخ‌ها و API مربوط به نخ‌ها، بیایید ببینیم که با نخ‌ها چه کاری می‌توانیم <em>انجام دهیم</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="استفاده-از-پیامرسانی-برای-انتقال-داده-بین-نخها"><a class="header" href="#استفاده-از-پیامرسانی-برای-انتقال-داده-بین-نخها">استفاده از پیام‌رسانی برای انتقال داده بین نخ‌ها</a></h2>
<p>یکی از رویکردهای محبوب و فزاینده برای اطمینان از همزمانی ایمن، <em>پیام‌رسانی</em> است، جایی که نخ‌ها یا بازیگران با ارسال پیام‌های حاوی داده به یکدیگر ارتباط برقرار می‌کنند. ایده این رویکرد در یک شعار از <a href="https://golang.org/doc/effective_go.html#concurrency">مستندات زبان Go</a> آمده است:<br />
«با به اشتراک گذاشتن حافظه ارتباط برقرار نکنید؛ بلکه حافظه را با ارتباط برقرار کردن به اشتراک بگذارید.»</p>
<p>برای رسیدن به همزمانی مبتنی بر ارسال پیام، کتابخانه استاندارد Rust یک پیاده‌سازی از <em>کانال‌ها</em> ارائه می‌دهد. کانال یک مفهوم عمومی برنامه‌نویسی است که داده‌ها را از یک نخ به نخ دیگر ارسال می‌کند.</p>
<p>می‌توانید یک کانال در برنامه‌نویسی را مانند یک کانال آبی جهت‌دار، مانند یک جریان یا رودخانه تصور کنید. اگر چیزی مانند یک اردک پلاستیکی را به داخل رودخانه بیندازید، آن اردک به پایین‌دست رودخانه سفر می‌کند و به انتهای آن می‌رسد.</p>
<p>یک کانال دو نیمه دارد: یک فرستنده و یک گیرنده. نیمه فرستنده محل بالادستی است که اردک‌های پلاستیکی را به داخل رودخانه می‌اندازید، و نیمه گیرنده جایی است که اردک پلاستیکی در پایین‌دست پایان می‌یابد. یک بخش از کد شما متدهایی روی فرستنده با داده‌ای که می‌خواهید ارسال کنید فراخوانی می‌کند، و بخش دیگری انتهای گیرنده را برای پیام‌های واردشده بررسی می‌کند. اگر هر یک از نیمه‌های فرستنده یا گیرنده حذف شوند، کانال به عنوان <em>بسته‌شده</em> در نظر گرفته می‌شود.</p>
<p>اینجا، برنامه‌ای ایجاد می‌کنیم که یک نخ برای تولید مقادیر و ارسال آن‌ها از طریق یک کانال دارد، و نخ دیگری مقادیر را دریافت کرده و چاپ می‌کند. برای نمایش این ویژگی، مقادیر ساده‌ای بین نخ‌ها از طریق یک کانال ارسال خواهیم کرد. پس از آشنایی با این تکنیک، می‌توانید از کانال‌ها برای هر نخ‌هایی که نیاز به ارتباط با یکدیگر دارند استفاده کنید، مانند یک سیستم چت یا سیستمی که بسیاری از نخ‌ها بخش‌هایی از یک محاسبه را انجام می‌دهند و آن بخش‌ها را به یک نخ ارسال می‌کنند که نتایج را تجمیع می‌کند.</p>
<p>ابتدا، در لیستینگ 16-6، یک کانال ایجاد می‌کنیم اما هنوز کاری با آن انجام نمی‌دهیم. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود زیرا Rust نمی‌تواند نوع مقادیری که می‌خواهیم از طریق کانال ارسال کنیم را تعیین کند.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">لیستینگ 16-6: ایجاد یک کانال و اختصاص دو نیمه آن به <code>tx</code> و <code>rx</code></span></p>
<p>ما یک کانال جدید با استفاده از تابع <code>mpsc::channel</code> ایجاد می‌کنیم؛ <code>mpsc</code> مخفف <em>تولیدکننده‌های چندگانه، مصرف‌کننده تک‌گانه</em> است. به طور خلاصه، نحوه پیاده‌سازی کانال‌ها توسط کتابخانه استاندارد Rust به این معناست که یک کانال می‌تواند چندین انتهای <em>ارسال‌کننده</em> داشته باشد که مقادیر تولید می‌کنند، اما فقط یک انتهای <em>گیرنده</em> که آن مقادیر را مصرف می‌کند. تصور کنید چندین جریان کوچک به یک رودخانه بزرگ می‌ریزند: هر چیزی که در هر یک از جریان‌ها ارسال شود، در نهایت به رودخانه بزرگ در انتها می‌رسد. فعلاً با یک تولیدکننده شروع می‌کنیم، اما وقتی این مثال کار کرد، چندین تولیدکننده اضافه خواهیم کرد.</p>
<p>تابع <code>mpsc::channel</code> یک جفت را برمی‌گرداند که عنصر اول آن انتهای ارسال‌کننده (فرستنده) و عنصر دوم آن انتهای گیرنده (گیرنده) است. اختصارات <code>tx</code> و <code>rx</code> در بسیاری از حوزه‌ها به ترتیب برای <em>فرستنده</em> و <em>گیرنده</em> استفاده می‌شوند، بنابراین متغیرهای خود را به این نام‌ها می‌نامیم تا هر انتها را نشان دهیم. ما از یک دستور <code>let</code> با یک الگو که جفت را تخریب می‌کند استفاده می‌کنیم؛ در فصل 19 درباره استفاده از الگوها در دستورات <code>let</code> و تخریب بحث خواهیم کرد. فعلاً بدانید که استفاده از یک دستور <code>let</code> به این روش یک رویکرد مناسب برای استخراج قطعات جفت بازگشتی توسط <code>mpsc::channel</code> است.</p>
<p>بیایید انتهای ارسال‌کننده را به یک نخ ایجادشده منتقل کنیم و یک رشته ارسال کنیم تا نخ ایجادشده با نخ اصلی ارتباط برقرار کند، همان‌طور که در لیستینگ 16-7 نشان داده شده است. این شبیه به انداختن یک اردک پلاستیکی در رودخانه در بالادست یا ارسال یک پیام چت از یک نخ به نخ دیگر است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<figcaption>Listing 16-7: انتقال <code>tx</code> به یک نخ ایجادشده و ارسال ‘hi’</figcaption>
</figure>
<p>دوباره از <code>thread::spawn</code> برای ایجاد یک نخ جدید استفاده می‌کنیم و سپس از <code>move</code> برای انتقال <code>tx</code> به closure استفاده می‌کنیم تا نخ ایجادشده مالک <code>tx</code> شود. نخ ایجادشده باید مالک فرستنده باشد تا بتواند پیام‌ها را از طریق کانال ارسال کند. فرستنده یک متد <code>send</code> دارد که مقداری که می‌خواهیم ارسال کنیم را می‌گیرد. متد <code>send</code> نوع <code>Result&lt;T, E&gt;</code> را برمی‌گرداند، بنابراین اگر گیرنده قبلاً حذف شده باشد و جایی برای ارسال مقدار وجود نداشته باشد، عملیات ارسال یک خطا برمی‌گرداند. در این مثال، ما <code>unwrap</code> را برای panic در صورت خطا فراخوانی می‌کنیم. اما در یک برنامه واقعی، باید آن را به درستی مدیریت کنیم: برای مرور استراتژی‌های مدیریت خطای مناسب به فصل 9 بازگردید.</p>
<p>در لیستینگ 16-8، مقداری را از گیرنده در نخ اصلی دریافت می‌کنیم. این شبیه به گرفتن اردک پلاستیکی از آب در انتهای رودخانه یا دریافت یک پیام چت است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
<figcaption>Listing 16-8: Receiving the value “hi” in the main thread and printing it</figcaption>
</figure>
<p>گیرنده دو متد مفید دارد: <code>recv</code> و <code>try_recv</code>. ما از <code>recv</code>، که مخفف <em>receive</em> است، استفاده می‌کنیم. این متد اجرای نخ اصلی را مسدود کرده و منتظر می‌ماند تا مقداری از طریق کانال ارسال شود. هنگامی که مقداری ارسال شد، <code>recv</code> آن را در یک مقدار <code>Result&lt;T, E&gt;</code> بازمی‌گرداند. وقتی فرستنده بسته می‌شود، <code>recv</code> یک خطا برمی‌گرداند تا نشان دهد که هیچ مقدار دیگری نمی‌آید.</p>
<p>متد <code>try_recv</code> مسدود نمی‌کند، بلکه بلافاصله یک مقدار <code>Result&lt;T, E&gt;</code> بازمی‌گرداند: یک مقدار <code>Ok</code> حاوی یک پیام اگر موجود باشد، و یک مقدار <code>Err</code> اگر این بار هیچ پیامی موجود نباشد. استفاده از <code>try_recv</code> زمانی مفید است که این نخ کار دیگری برای انجام دارد در حالی که منتظر پیام‌ها است: می‌توانیم یک حلقه بنویسیم که هر چند وقت یک بار <code>try_recv</code> را فراخوانی کند، یک پیام را اگر موجود باشد پردازش کند، و در غیر این صورت کار دیگری را برای مدتی انجام دهد تا دوباره بررسی کند.</p>
<p>ما در این مثال برای سادگی از <code>recv</code> استفاده کرده‌ایم؛ نخ اصلی کار دیگری جز منتظر ماندن برای پیام‌ها ندارد، بنابراین مسدود کردن نخ اصلی مناسب است.</p>
<p>وقتی کد موجود در لیستینگ 16-8 را اجرا کنیم، مقدار چاپ‌شده از نخ اصلی را خواهیم دید:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>عالی!</p>
<h3 id="کانالها-و-انتقال-مالکیت"><a class="header" href="#کانالها-و-انتقال-مالکیت">کانال‌ها و انتقال مالکیت</a></h3>
<p>قوانین مالکیت نقش حیاتی در ارسال پیام دارند زیرا به شما کمک می‌کنند کد ایمن و همزمان بنویسید. جلوگیری از خطاها در برنامه‌نویسی همزمان مزیت فکر کردن به مالکیت در سراسر برنامه‌های Rust شما است. بیایید یک آزمایش انجام دهیم تا نشان دهیم کانال‌ها و مالکیت چگونه با هم کار می‌کنند تا از مشکلات جلوگیری کنند: ما سعی خواهیم کرد مقدار <code>val</code> را در نخ ایجادشده <em>پس از</em> ارسال آن از طریق کانال استفاده کنیم. کد موجود در لیستینگ 16-9 را کامپایل کنید تا ببینید چرا این کد مجاز نیست:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
<figcaption>Listing 16-9: تلاش برای استفاده از <code>val</code> پس از ارسال آن از طریق کانال</figcaption>
</figure>
<p>در اینجا، ما سعی می‌کنیم <code>val</code> را پس از ارسال آن از طریق <code>tx.send</code> چاپ کنیم. اجازه دادن به این کار ایده بدی خواهد بود: هنگامی که مقدار به نخ دیگری ارسال شده است، آن نخ می‌تواند قبل از اینکه سعی کنیم دوباره از مقدار استفاده کنیم، آن را تغییر دهد یا حذف کند. به طور بالقوه، تغییرات نخ دیگر می‌تواند باعث خطاها یا نتایج غیرمنتظره به دلیل داده‌های ناسازگار یا غیرموجود شود. با این حال، Rust اگر سعی کنیم کد موجود در لیستینگ 16-9 را کامپایل کنیم، به ما خطا می‌دهد:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>اشتباه ما در همزمانی باعث ایجاد یک خطای زمان کامپایل شده است. تابع <code>send</code> مالکیت پارامتر خود را می‌گیرد و وقتی مقدار منتقل می‌شود، گیرنده مالکیت آن را می‌گیرد. این از استفاده تصادفی مجدد مقدار پس از ارسال آن جلوگیری می‌کند؛ سیستم مالکیت بررسی می‌کند که همه چیز درست است.</p>
<h3 id="ارسال-مقادیر-متعدد-و-مشاهده-انتظار-گیرنده"><a class="header" href="#ارسال-مقادیر-متعدد-و-مشاهده-انتظار-گیرنده">ارسال مقادیر متعدد و مشاهده انتظار گیرنده</a></h3>
<p>کد موجود در لیستینگ 16-8 کامپایل و اجرا شد، اما به وضوح نشان نمی‌داد که دو نخ جداگانه از طریق کانال با یکدیگر صحبت می‌کنند. در لیستینگ 16-10 تغییراتی اعمال کرده‌ایم که ثابت می‌کند کد موجود در لیستینگ 16-8 به صورت همزمان اجرا می‌شود: نخ ایجادشده اکنون چندین پیام ارسال می‌کند و بین هر پیام یک ثانیه مکث می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
<figcaption>Listing 16-10: Sending multiple messages and pausing between each</figcaption>
</figure>
<p>این بار، نخ ایجادشده یک بردار از رشته‌هایی دارد که می‌خواهیم به نخ اصلی ارسال کنیم. ما روی آن‌ها پیمایش می‌کنیم، هر کدام را به صورت جداگانه ارسال می‌کنیم و بین هر پیام با فراخوانی تابع <code>thread::sleep</code> با یک مقدار <code>Duration</code> برابر با 1 ثانیه مکث می‌کنیم.</p>
<p>در نخ اصلی، دیگر تابع <code>recv</code> را به طور صریح فراخوانی نمی‌کنیم: در عوض، با <code>rx</code> به عنوان یک تکرارگر رفتار می‌کنیم. برای هر مقداری که دریافت می‌شود، آن را چاپ می‌کنیم. هنگامی که کانال بسته می‌شود، تکرار متوقف خواهد شد.</p>
<p>وقتی کد موجود در لیستینگ 16-10 را اجرا می‌کنید، باید خروجی زیر را ببینید، با یک مکث 1 ثانیه‌ای بین هر خط:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>از آنجا که هیچ کدی در حلقه <code>for</code> نخ اصلی نداریم که مکث یا تأخیری ایجاد کند، می‌توانیم بگوییم که نخ اصلی منتظر دریافت مقادیر از نخ ایجادشده است.</p>
<h3 id="ایجاد-تولیدکنندههای-متعدد-با-کلون-کردن-فرستنده"><a class="header" href="#ایجاد-تولیدکنندههای-متعدد-با-کلون-کردن-فرستنده">ایجاد تولیدکننده‌های متعدد با کلون کردن فرستنده</a></h3>
<p>قبلاً اشاره کردیم که <code>mpsc</code> مخفف <em>چندین تولیدکننده، یک مصرف‌کننده</em> است. بیایید از <code>mpsc</code> استفاده کنیم و کد موجود در لیستینگ 16-10 را گسترش دهیم تا چندین نخ ایجاد کنیم که همگی مقادیر را به همان گیرنده ارسال می‌کنند. می‌توانیم این کار را با کلون کردن فرستنده انجام دهیم، همان‌طور که در لیستینگ 16-11 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
<figcaption>Listing 16-11: ارسال چندین پیام از چندین تولیدکننده</figcaption>
</figure>
<p>این بار، قبل از اینکه نخ ایجادشده اول را ایجاد کنیم، روی فرستنده <code>clone</code> فراخوانی می‌کنیم. این کار به ما یک فرستنده جدید می‌دهد که می‌توانیم به نخ ایجادشده اول ارسال کنیم. فرستنده اصلی را به نخ ایجادشده دوم ارسال می‌کنیم. این کار به ما دو نخ می‌دهد که هر کدام پیام‌های مختلفی را به یک گیرنده ارسال می‌کنند.</p>
<p>وقتی کد را اجرا می‌کنید، خروجی شما باید چیزی شبیه به این باشد:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>ممکن است مقادیر را به ترتیب دیگری ببینید، بسته به سیستم شما. این همان چیزی است که همزمانی را هم جالب و هم دشوار می‌کند. اگر با <code>thread::sleep</code> آزمایش کنید و مقادیر مختلفی را در نخ‌های مختلف به آن بدهید، هر اجرا غیرقطعی‌تر خواهد شد و هر بار خروجی متفاوتی ایجاد می‌کند.</p>
<p>اکنون که دیدیم کانال‌ها چگونه کار می‌کنند، بیایید به یک روش دیگر همزمانی نگاهی بیندازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="همزمانی-با-حالت-مشترک-shared-state-concurrency"><a class="header" href="#همزمانی-با-حالت-مشترک-shared-state-concurrency">همزمانی با حالت مشترک (Shared-State Concurrency)</a></h2>
<p>ارسال پیام یک روش مناسب برای مدیریت همزمانی است، اما تنها روش نیست. روش دیگر این
است که چندین نخ به یک داده مشترک دسترسی داشته باشند. دوباره این بخش از شعار
مستندات زبان Go را در نظر بگیرید: «با به اشتراک‌گذاری حافظه ارتباط برقرار نکنید.»</p>
<p>ارتباط با به اشتراک‌گذاری حافظه چگونه خواهد بود؟ علاوه بر این، چرا علاقه‌مندان به
ارسال پیام هشدار می‌دهند که از اشتراک حافظه استفاده نکنید؟</p>
<p>به نوعی، کانال‌ها (channels) در هر زبان برنامه‌نویسی شبیه مالکیت یکتا هستند، زیرا
هنگامی که یک مقدار را از طریق یک کانال منتقل می‌کنید، دیگر نباید از آن مقدار استفاده
کنید. همزمانی با حافظه مشترک مانند مالکیت چندگانه است: چندین نخ می‌توانند به
یک موقعیت حافظه‌ای یکسان به‌طور هم‌زمان دسترسی داشته باشند. همانطور که در فصل
15 دیدید، جایی که اسمارت پوینترها مالکیت چندگانه را ممکن می‌کردند، مالکیت
چندگانه می‌تواند پیچیدگی اضافه کند زیرا این مالکیت‌های مختلف نیاز به مدیریت
دارند. سیستم نوعی و قوانین مالکیت راست به طور قابل‌توجهی به صحیح مدیریت کردن
این موارد کمک می‌کند. برای یک مثال، بیایید به mutex‌ها نگاهی بیندازیم، یکی از
ابتدایی‌ترین سازوکارهای همزمانی برای حافظه مشترک.</p>
<h3 id="استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان"><a class="header" href="#استفاده-از-mutexها-برای-اجازه-دسترسی-به-دادهها-توسط-یک-نخ-در-هر-زمان">استفاده از Mutex‌ها برای اجازه دسترسی به داده‌ها توسط یک نخ در هر زمان</a></h3>
<p><em>Mutex</em> مخفف <em>mutual exclusion</em> (حذف متقابل) است، به این معنا که یک mutex فقط
به یک نخ اجازه می‌دهد در هر لحظه به برخی داده‌ها دسترسی داشته باشد. برای دسترسی
به داده‌های یک mutex، یک نخ باید ابتدا سیگنال دهد که می‌خواهد دسترسی داشته باشد
با درخواست قفل کردن (acquire the lock) mutex. قفل یک ساختار داده است که بخشی
از mutex است و پیگیری می‌کند که چه کسی در حال حاضر به‌طور انحصاری به داده‌ها
دسترسی دارد. بنابراین، mutex به‌عنوان نگهبانی از داده‌هایی که نگه می‌دارد توصیف
می‌شود که از طریق سیستم قفل کار می‌کند.</p>
<p>Mutex‌ها به دلیل این که باید دو قانون را به خاطر بسپارید، به سخت بودن شهرت دارند:</p>
<ul>
<li>شما باید قبل از استفاده از داده‌ها، سعی کنید قفل را بگیرید.</li>
<li>هنگامی که استفاده شما از داده‌هایی که mutex نگهبانی می‌کند تمام شد، باید
داده‌ها را باز کنید تا نخ‌های دیگر بتوانند قفل را بگیرند.</li>
</ul>
<p>برای یک تمثیل دنیای واقعی برای mutex، یک بحث پانل در یک کنفرانس را تصور کنید
که فقط یک میکروفون وجود دارد. قبل از اینکه یک عضو پانل بتواند صحبت کند، باید
درخواست دهد یا سیگنال دهد که می‌خواهد از میکروفون استفاده کند. وقتی میکروفون را
می‌گیرد، می‌تواند هر چقدر که بخواهد صحبت کند و سپس میکروفون را به عضو بعدی
که درخواست صحبت کرده است بدهد. اگر یک عضو پانل فراموش کند که میکروفون را پس
دهد، هیچ کس دیگری نمی‌تواند صحبت کند. اگر مدیریت میکروفون مشترک اشتباه انجام
شود، پانل مطابق برنامه پیش نخواهد رفت!</p>
<p>مدیریت mutex‌ها می‌تواند بسیار دشوار باشد، به همین دلیل است که بسیاری از افراد
به کانال‌ها علاقه‌مند هستند. اما به لطف سیستم نوعی و قوانین مالکیت راست، شما
نمی‌توانید در قفل کردن و باز کردن قفل اشتباه کنید.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>به‌عنوان مثالی از نحوه استفاده از mutex، بیایید با استفاده از یک mutex در یک
زمینه تک‌ریسمانی شروع کنیم، همانطور که در فهرست 16-12 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<figcaption>Listing 16-12: بررسی API <code>Mutex&lt;T&gt;</code> در یک زمینه تک‌ریسمانی برای سادگی</figcaption>
</figure>
<p>همان‌طور که با بسیاری از نوع‌ها مشاهده می‌شود، یک <code>Mutex&lt;T&gt;</code> را با استفاده از تابع وابسته <code>new</code> ایجاد می‌کنیم. برای دسترسی به داده داخل Mutex، از متد <code>lock</code> استفاده می‌کنیم تا قفل را به دست آوریم. این فراخوانی Thread فعلی را متوقف می‌کند، بنابراین نمی‌تواند کاری انجام دهد تا زمانی که نوبت ما برای گرفتن قفل برسد.</p>
<p>فراخوانی <code>lock</code> در صورتی که یک Thread دیگر که قفل را نگه داشته دچار وحشت (<em>panic</em>) شود، شکست می‌خورد. در چنین حالتی، هیچ‌کس دیگر نمی‌تواند قفل را به دست آورد، بنابراین انتخاب کرده‌ایم که از <code>unwrap</code> استفاده کنیم و اگر در چنین وضعیتی قرار گرفتیم، این Thread نیز دچار وحشت شود.</p>
<p>بعد از گرفتن قفل، می‌توانیم مقدار بازگردانده‌شده را، که در اینجا به نام <code>num</code> است، به عنوان یک مرجع قابل تغییر به داده داخل در نظر بگیریم. سیستم نوع تضمین می‌کند که قبل از استفاده از مقدار داخل <code>m</code> قفل را به دست آوریم. نوع <code>m</code> برابر با <code>Mutex&lt;i32&gt;</code> است، نه <code>i32</code>، بنابراین <em>باید</em> برای استفاده از مقدار <code>i32</code>، متد <code>lock</code> را فراخوانی کنیم. نمی‌توانیم فراموش کنیم؛ سیستم نوع اجازه دسترسی به مقدار داخلی <code>i32</code> را به ما نمی‌دهد.</p>
<p>همان‌طور که احتمالاً حدس می‌زنید، <code>Mutex&lt;T&gt;</code> یک اشاره‌گر هوشمند است. دقیق‌تر، فراخوانی <code>lock</code> یک اشاره‌گر هوشمند به نام <code>MutexGuard</code> را بازمی‌گرداند، که در یک <code>LockResult</code> بسته‌بندی شده است و آن را با فراخوانی <code>unwrap</code> مدیریت کردیم. اشاره‌گر هوشمند <code>MutexGuard</code> ویژگی <code>Deref</code> را پیاده‌سازی می‌کند تا به داده داخلی ما اشاره کند. همچنین، این اشاره‌گر هوشمند یک پیاده‌سازی از <code>Drop</code> دارد که به‌طور خودکار قفل را زمانی که یک <code>MutexGuard</code> از محدوده خارج می‌شود، آزاد می‌کند، که این اتفاق در انتهای محدوده داخلی رخ می‌دهد. در نتیجه، خطر فراموش کردن آزاد کردن قفل و جلوگیری از استفاده دیگر Threadها از Mutex وجود ندارد، زیرا آزادسازی قفل به صورت خودکار انجام می‌شود.</p>
<p>پس از آزاد کردن قفل، می‌توانیم مقدار Mutex را چاپ کنیم و ببینیم که توانستیم مقدار داخلی <code>i32</code> را به ۶ تغییر دهیم.</p>
<h4 id="اشتراکگذاری-یک-mutext-بین-چندین-thread"><a class="header" href="#اشتراکگذاری-یک-mutext-بین-چندین-thread">اشتراک‌گذاری یک <code>Mutex&lt;T&gt;</code> بین چندین Thread</a></h4>
<p>حالا، بیایید تلاش کنیم یک مقدار را بین چندین Thread با استفاده از <code>Mutex&lt;T&gt;</code> به اشتراک بگذاریم. ما ۱۰ Thread ایجاد خواهیم کرد و هرکدام مقدار شمارنده را ۱ واحد افزایش می‌دهند، بنابراین شمارنده از ۰ به ۱۰ می‌رسد. مثال بعدی در لیست ۱۶-۱۳ دارای خطای کامپایل خواهد بود، و از آن خطا برای یادگیری بیشتر در مورد استفاده از <code>Mutex&lt;T&gt;</code> و اینکه چگونه Rust به ما کمک می‌کند از آن به درستی استفاده کنیم، استفاده خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption>Listing 16-13: ده نخ که هر کدام مقدار شمارنده محافظت‌شده توسط یک <code>Mutex&lt;T&gt;</code> را افزایش می‌دهند</figcaption>
</figure>
<p>ما یک متغیر <code>counter</code> ایجاد می‌کنیم تا یک مقدار <code>i32</code> را در یک <code>Mutex&lt;T&gt;</code> نگه دارد، همان‌طور که در لیست ۱۶-۱۲ انجام دادیم. سپس، با تکرار روی یک بازه عددی، ۱۰ Thread ایجاد می‌کنیم. از <code>thread::spawn</code> استفاده می‌کنیم و به تمام Threadها یک Closure یکسان می‌دهیم: یک Closure که متغیر <code>counter</code> را به Thread منتقل می‌کند، قفل <code>Mutex&lt;T&gt;</code> را با فراخوانی متد <code>lock</code> به دست می‌آورد، و سپس ۱ واحد به مقدار داخل Mutex اضافه می‌کند. وقتی یک Thread اجرای Closure خود را تمام می‌کند، <code>num</code> از محدوده خارج شده و قفل را آزاد می‌کند تا Thread دیگری بتواند آن را به دست آورد.</p>
<p>در Thread اصلی، تمام handleهای join را جمع‌آوری می‌کنیم. سپس، همان‌طور که در لیست ۱۶-۲ انجام دادیم، متد <code>join</code> را روی هر handle فراخوانی می‌کنیم تا مطمئن شویم تمام Threadها تمام شده‌اند. در آن نقطه، Thread اصلی قفل را به دست می‌آورد و نتیجه این برنامه را چاپ می‌کند.</p>
<p>ما اشاره کردیم که این مثال کامپایل نخواهد شد. حالا بیایید ببینیم چرا!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>پیام خطا نشان می‌دهد که مقدار <code>counter</code> در تکرار قبلی حلقه منتقل شده است. Rust به ما می‌گوید که نمی‌توانیم مالکیت <code>counter</code> را به چندین Thread منتقل کنیم. بیایید این خطای کامپایلر را با استفاده از روش مالکیت چندگانه که در فصل ۱۵ بحث کردیم، برطرف کنیم.</p>
<h4 id="مالکیت-چندگانه-با-چندین-thread"><a class="header" href="#مالکیت-چندگانه-با-چندین-thread">مالکیت چندگانه با چندین Thread</a></h4>
<p>در فصل ۱۵، ما با استفاده از اشاره‌گر هوشمند <code>Rc&lt;T&gt;</code> برای ایجاد یک مقدار شمارش‌شده توسط مرجع (<em>reference-counted value</em>) به یک مقدار چندین مالک دادیم. بیایید همین کار را اینجا انجام دهیم و ببینیم چه اتفاقی می‌افتد. ما <code>Mutex&lt;T&gt;</code> را در <code>Rc&lt;T&gt;</code> بسته‌بندی می‌کنیم (همان‌طور که در لیست ۱۶-۱۴ نشان داده شده است) و قبل از انتقال مالکیت به Thread، <code>Rc&lt;T&gt;</code> را کلون می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption>Listing 16-14: تلاش برای استفاده از <code>Rc&lt;T&gt;</code> برای اجازه مالکیت چندگانه <code>Mutex&lt;T&gt;</code> توسط چندین Thread</figcaption>
</figure>
<p>دوباره کامپایل می‌کنیم و… خطاهای متفاوتی دریافت می‌کنیم! کامپایلر چیزهای زیادی به ما یاد می‌دهد.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- required by a bound in this function
...
675 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>وای، این پیام خطا بسیار طولانی است! اما بخش مهمی که باید روی آن تمرکز کنیم این است:<br />
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>.<br />
کامپایلر همچنین دلیل آن را به ما می‌گوید:<br />
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>.</p>
<p>ما در بخش بعدی درباره <code>Send</code> صحبت خواهیم کرد: یکی از ویژگی‌هایی که اطمینان می‌دهد نوع‌هایی که با Threadها استفاده می‌کنیم برای استفاده در شرایط همزمان طراحی شده‌اند.</p>
<p>متأسفانه، <code>Rc&lt;T&gt;</code> برای اشتراک‌گذاری بین Threadها ایمن نیست. وقتی <code>Rc&lt;T&gt;</code> شمارش مرجع را مدیریت می‌کند، برای هر فراخوانی به <code>clone</code> به شمارش اضافه می‌کند و وقتی هر کلون حذف می‌شود، از شمارش کم می‌کند. اما از هیچ ابزار همزمانی استفاده نمی‌کند تا مطمئن شود که تغییرات در شمارش نمی‌توانند توسط یک Thread دیگر قطع شوند. این می‌تواند به شمارش‌های اشتباه منجر شود—باگ‌های ظریفی که ممکن است باعث نشت حافظه یا حذف یک مقدار قبل از اتمام کار ما با آن شوند. چیزی که نیاز داریم، نوعی دقیقاً مانند <code>Rc&lt;T&gt;</code> است، اما یکی که تغییرات شمارش مرجع را به صورت ایمن در برابر Thread مدیریت کند.</p>
<h4 id="شمارش-ارجاع-اتمی-با-arct"><a class="header" href="#شمارش-ارجاع-اتمی-با-arct">شمارش ارجاع اتمی با <code>Arc&lt;T&gt;</code></a></h4>
<p>خوشبختانه، <code>Arc&lt;T&gt;</code> یک نوع مشابه <code>Rc&lt;T&gt;</code> است که برای استفاده در شرایط همزمان ایمن است. حرف <em>a</em> در <code>Arc</code> مخفف <em>atomic</em> است، به این معنا که یک نوع <em>شمارش مرجع اتمی</em> است. اتمیک‌ها نوع دیگری از عناصر ابتدایی همزمانی هستند که در اینجا به‌طور مفصل به آن‌ها نمی‌پردازیم؛ برای جزئیات بیشتر به مستندات کتابخانه استاندارد در مورد <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> مراجعه کنید. در این مرحله، فقط باید بدانید که اتمیک‌ها مانند نوع‌های ابتدایی کار می‌کنند اما برای اشتراک‌گذاری بین Threadها ایمن هستند.</p>
<p>شاید از خود بپرسید چرا تمام نوع‌های ابتدایی اتمی نیستند و چرا نوع‌های کتابخانه استاندارد به‌طور پیش‌فرض از <code>Arc&lt;T&gt;</code> استفاده نمی‌کنند. دلیل این است که ایمنی Thread با یک هزینه عملکردی همراه است که فقط زمانی که واقعاً نیاز باشد، می‌خواهید آن را پرداخت کنید. اگر فقط روی مقادیر در یک Thread واحد عملیات انجام می‌دهید، کد شما می‌تواند سریع‌تر اجرا شود اگر مجبور به اعمال تضمین‌های اتمیک نباشد.</p>
<p>بیایید به مثال خود برگردیم: <code>Arc&lt;T&gt;</code> و <code>Rc&lt;T&gt;</code> API یکسانی دارند، بنابراین برنامه خود را با تغییر خط <code>use</code>، فراخوانی <code>new</code>، و فراخوانی <code>clone</code> اصلاح می‌کنیم. کد موجود در لیست ۱۶-۱۵ در نهایت کامپایل و اجرا می‌شود:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<figcaption>Listing 16-15: استفاده از <code>Arc&lt;T&gt;</code> برای بسته‌بندی <code>Mutex&lt;T&gt;</code> جهت اشتراک مالکیت بین چندین Thread</figcaption>
</figure>
<p>این کد خروجی زیر را چاپ خواهد کرد:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>ما موفق شدیم! شمارنده را از ۰ به ۱۰ افزایش دادیم که ممکن است خیلی چشمگیر به نظر نرسد، اما چیزهای زیادی درباره <code>Mutex&lt;T&gt;</code> و ایمنی Thread یاد گرفتیم. همچنین می‌توانید از ساختار این برنامه برای انجام عملیات پیچیده‌تری به‌جز افزایش یک شمارنده استفاده کنید. با استفاده از این استراتژی، می‌توانید یک محاسبه را به بخش‌های مستقل تقسیم کنید، این بخش‌ها را بین Threadها تقسیم کنید، و سپس از یک <code>Mutex&lt;T&gt;</code> استفاده کنید تا هر Thread نتیجه نهایی را با بخش مربوط به خودش به‌روزرسانی کند.</p>
<p>توجه داشته باشید که اگر در حال انجام عملیات عددی ساده هستید، نوع‌های ساده‌تری نسبت به <code>Mutex&lt;T&gt;</code> در ماژول <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code> از کتابخانه استاندارد</a><!-- ignore --> ارائه شده‌اند. این نوع‌ها دسترسی اتمی، ایمن و همزمان به نوع‌های ابتدایی فراهم می‌کنند. ما برای این مثال از <code>Mutex&lt;T&gt;</code> با یک نوع ابتدایی استفاده کردیم تا بتوانیم بر نحوه کار <code>Mutex&lt;T&gt;</code> تمرکز کنیم.</p>
<h3 id="شباهتهای-بین-refcelltrct-و-mutextarct"><a class="header" href="#شباهتهای-بین-refcelltrct-و-mutextarct">شباهت‌های بین <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> و <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>ممکن است متوجه شده باشید که <code>counter</code> تغییرناپذیر است، اما توانستیم یک مرجع قابل تغییر به مقدار داخل آن بگیریم؛ این بدان معناست که <code>Mutex&lt;T&gt;</code> قابلیت تغییر داخلی (<em>interior mutability</em>) را فراهم می‌کند، همان‌طور که خانواده <code>Cell</code> این کار را می‌کنند. به همان شکلی که در فصل ۱۵ از <code>RefCell&lt;T&gt;</code> برای اجازه تغییر محتوا درون یک <code>Rc&lt;T&gt;</code> استفاده کردیم، از <code>Mutex&lt;T&gt;</code> برای تغییر محتوا درون یک <code>Arc&lt;T&gt;</code> استفاده می‌کنیم.</p>
<p>نکته دیگری که باید توجه کنید این است که Rust نمی‌تواند شما را از تمام انواع خطاهای منطقی هنگام استفاده از <code>Mutex&lt;T&gt;</code> محافظت کند. به یاد بیاورید که در فصل ۱۵ استفاده از <code>Rc&lt;T&gt;</code> با خطر ایجاد چرخه‌های مرجع همراه بود، جایی که دو مقدار <code>Rc&lt;T&gt;</code> به یکدیگر ارجاع می‌دادند و باعث نشت حافظه می‌شدند. به‌طور مشابه، <code>Mutex&lt;T&gt;</code> با خطر ایجاد <em>بن‌بست</em> (<em>deadlock</em>) همراه است. این وضعیت زمانی رخ می‌دهد که یک عملیات نیاز به قفل کردن دو منبع دارد و دو Thread هر کدام یکی از قفل‌ها را به دست آورده‌اند و باعث می‌شوند که برای همیشه منتظر یکدیگر بمانند. اگر به بن‌بست علاقه دارید، سعی کنید یک برنامه Rust ایجاد کنید که دچار بن‌بست شود؛ سپس استراتژی‌های کاهش بن‌بست برای Mutexها در هر زبانی را تحقیق کنید و آن‌ها را در Rust پیاده‌سازی کنید. مستندات API کتابخانه استاندارد برای <code>Mutex&lt;T&gt;</code> و <code>MutexGuard</code> اطلاعات مفیدی ارائه می‌دهد.</p>
<p>ما این فصل را با صحبت درباره ویژگی‌های <code>Send</code> و <code>Sync</code> و نحوه استفاده از آن‌ها با نوع‌های سفارشی تکمیل خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="همزمانی-قابلتوسعه-با-ویژگیهای-sync-و-send"><a class="header" href="#همزمانی-قابلتوسعه-با-ویژگیهای-sync-و-send">همزمانی قابل‌توسعه با ویژگی‌های <code>Sync</code> و <code>Send</code></a></h2>
<p>جالب است که زبان راست ویژگی‌های <em>بسیار</em> کمی برای همزمانی دارد. تقریباً هر ویژگی
همزمانی که تاکنون در این فصل درباره آن صحبت کرده‌ایم بخشی از کتابخانه استاندارد
بوده است، نه زبان. گزینه‌های شما برای مدیریت همزمانی محدود به زبان یا کتابخانه
استاندارد نیستند؛ می‌توانید ویژگی‌های همزمانی خود را بنویسید یا از ویژگی‌هایی که
دیگران نوشته‌اند استفاده کنید.</p>
<p>با این حال، دو مفهوم همزمانی در زبان تعبیه شده‌اند: ویژگی‌های <code>std::marker</code>
به نام‌های <code>Sync</code> و <code>Send</code>.</p>
<h3 id="اجازه-انتقال-مالکیت-بین-نخها-با-send"><a class="header" href="#اجازه-انتقال-مالکیت-بین-نخها-با-send">اجازه انتقال مالکیت بین نخ‌ها با <code>Send</code></a></h3>
<p>ویژگی نشانگر <code>Send</code> نشان می‌دهد که مالکیت مقادیر نوعی که <code>Send</code> را پیاده‌سازی
می‌کند می‌تواند بین نخ‌ها منتقل شود. تقریباً هر نوعی در راست <code>Send</code> است، اما
برخی استثناها وجود دارند، از جمله <code>Rc&lt;T&gt;</code>: این نوع نمی‌تواند <code>Send</code> باشد زیرا
اگر یک مقدار <code>Rc&lt;T&gt;</code> را کلون کنید و سعی کنید مالکیت کلون را به نخ دیگری منتقل
کنید، هر دو نخ ممکن است شمارش ارجاع را هم‌زمان به‌روزرسانی کنند. به این دلیل،
<code>Rc&lt;T&gt;</code> برای استفاده در شرایط تک‌ریسمانی طراحی شده است که نمی‌خواهید جریمه
عملکرد ایمنی نخ را پرداخت کنید.</p>
<p>بنابراین، سیستم نوعی و محدودیت‌های ویژگی راست تضمین می‌کنند که هرگز به‌طور
ناخواسته یک مقدار <code>Rc&lt;T&gt;</code> را به صورت ناایمن بین نخ‌ها ارسال نکنید. وقتی سعی
کردیم این کار را در فهرست 16-14 انجام دهیم، خطای <code>the trait Send is not  implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code> دریافت کردیم. وقتی به <code>Arc&lt;T&gt;</code> که <code>Send</code> است
تغییر دادیم، کد کامپایل شد.</p>
<p>هر نوعی که به‌طور کامل از نوع‌های <code>Send</code> تشکیل شده باشد به‌طور خودکار به عنوان
<code>Send</code> علامت‌گذاری می‌شود. تقریباً تمام نوع‌های اولیه <code>Send</code> هستند، به جز
اشاره‌گر (Pointer)های خام، که در فصل 20 درباره آن‌ها صحبت خواهیم کرد.</p>
<h3 id="اجازه-دسترسی-از-چندین-نخ-با-sync"><a class="header" href="#اجازه-دسترسی-از-چندین-نخ-با-sync">اجازه دسترسی از چندین نخ با <code>Sync</code></a></h3>
<p>ویژگی نشانگر <code>Sync</code> نشان می‌دهد که نوعی که <code>Sync</code> را پیاده‌سازی می‌کند می‌تواند
از چندین نخ به آن ارجاع داده شود. به عبارت دیگر، هر نوع <code>T</code>، <code>Sync</code> است اگر
<code>&amp;T</code> (یک ارجاع غیرقابل‌تغییر به <code>T</code>) <code>Send</code> باشد، به این معنی که ارجاع می‌تواند
به صورت ایمن به نخ دیگری ارسال شود. مشابه <code>Send</code>، نوع‌های اولیه <code>Sync</code> هستند و
نوع‌هایی که به طور کامل از نوع‌های <code>Sync</code> تشکیل شده‌اند نیز <code>Sync</code> هستند.</p>
<p>اسمارت پوینتر <code>Rc&lt;T&gt;</code> نیز به همان دلایلی که <code>Send</code> نیست، <code>Sync</code> هم نیست. نوع
<code>RefCell&lt;T&gt;</code> (که در فصل 15 درباره آن صحبت کردیم) و خانواده نوع‌های مرتبط <code>Cell&lt;T&gt;</code>
نیز <code>Sync</code> نیستند. پیاده‌سازی بررسی وام‌دهی که <code>RefCell&lt;T&gt;</code> در زمان اجرا انجام
می‌دهد، برای نخ ایمن نیست. اسمارت پوینتر <code>Mutex&lt;T&gt;</code>، <code>Sync</code> است و می‌تواند
برای اشتراک‌گذاری دسترسی بین چندین نخ استفاده شود، همانطور که در بخش <a href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">«اشتراک
یک <code>Mutex&lt;T&gt;</code> بین چندین نخ»</a><!-- ignore -->
مشاهده کردید.</p>
<h3 id="پیادهسازی-دستی-send-و-sync-ناایمن-است"><a class="header" href="#پیادهسازی-دستی-send-و-sync-ناایمن-است">پیاده‌سازی دستی <code>Send</code> و <code>Sync</code> ناایمن است</a></h3>
<p>از آنجا که نوع‌هایی که از ویژگی‌های <code>Send</code> و <code>Sync</code> تشکیل شده‌اند به‌طور خودکار
به‌عنوان <code>Send</code> و <code>Sync</code> علامت‌گذاری می‌شوند، ما نیازی به پیاده‌سازی دستی این
ویژگی‌ها نداریم. به عنوان ویژگی‌های نشانگر، آن‌ها حتی هیچ متدی برای پیاده‌سازی
ندارند. آن‌ها فقط برای اعمال اصول مربوط به همزمانی مفید هستند.</p>
<p>پیاده‌سازی دستی این ویژگی‌ها شامل پیاده‌سازی کد ناایمن در راست می‌شود. ما در فصل
20 درباره استفاده از کد ناایمن در راست صحبت خواهیم کرد؛ فعلاً، اطلاعات مهم این
است که ساخت نوع‌های همزمان جدید که از قسمت‌های <code>Send</code> و <code>Sync</code> تشکیل نشده‌اند
نیاز به دقت زیادی دارد تا اصول ایمنی رعایت شوند. <a href="../nomicon/index.html">“The Rustonomicon”</a>
اطلاعات بیشتری درباره این اصول و نحوه رعایت آن‌ها ارائه می‌دهد.</p>
<h2 id="خلاصه-15"><a class="header" href="#خلاصه-15">خلاصه</a></h2>
<p>این آخرین باری نیست که در این کتاب با همزمانی روبه‌رو می‌شوید: کل فصل بعدی بر برنامه‌نویسی
async تمرکز دارد، و پروژه در فصل 21 از مفاهیم این فصل در یک موقعیت واقعی‌تر نسبت به
مثال‌های کوچک‌تر مطرح‌شده در اینجا استفاده خواهد کرد.</p>
<p>همانطور که قبلاً اشاره شد، به دلیل اینکه بخش بسیار کمی از نحوه مدیریت همزمانی در راست
بخشی از زبان است، بسیاری از راه‌حل‌های همزمانی به‌عنوان crate پیاده‌سازی شده‌اند.
این‌ها سریع‌تر از کتابخانه استاندارد تکامل می‌یابند، بنابراین حتماً به صورت آنلاین جستجو
کنید تا crate‌های به‌روز و پیشرفته‌ای که برای موقعیت‌های چندریسمانی مناسب هستند را پیدا کنید.</p>
<p>کتابخانه استاندارد راست کانال‌هایی برای ارسال پیام و انواع اسمارت پوینتر، مانند <code>Mutex&lt;T&gt;</code>
و <code>Arc&lt;T&gt;</code>، فراهم می‌کند که استفاده از آن‌ها در زمینه‌های همزمان ایمن است. سیستم نوعی
و کنترل‌کننده وام‌دهی تضمین می‌کنند که کدی که از این راه‌حل‌ها استفاده می‌کند با رقابت‌های
داده یا ارجاع‌های نامعتبر مواجه نمی‌شود. هنگامی که کد شما کامپایل شود، می‌توانید مطمئن
باشید که بدون آن دسته از اشکال‌های سخت‌ردیابی که در زبان‌های دیگر معمول است، به خوبی
روی چندین نخ اجرا خواهد شد. برنامه‌نویسی همزمان دیگر مفهومی برای ترسیدن نیست:
پیش بروید و برنامه‌های خود را بی‌باکانه همزمان کنید!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="اصول-برنامهنویسی-ناهمزمان-async-await-futures-و-streams"><a class="header" href="#اصول-برنامهنویسی-ناهمزمان-async-await-futures-و-streams">اصول برنامه‌نویسی ناهمزمان: Async، Await، Futures، و Streams</a></h1>
<p>بسیاری از عملیات‌هایی که از کامپیوتر می‌خواهیم انجام دهد ممکن است مدتی طول بکشد تا کامل شوند. خوب می‌شد اگر می‌توانستیم در حالی که منتظر این فرآیندهای طولانی هستیم، کار دیگری انجام دهیم. کامپیوترهای مدرن دو تکنیک برای انجام هم‌زمان بیش از یک عملیات ارائه می‌دهند: <em>موازی‌سازی</em> و <em>همزمانی</em>. اما وقتی شروع به نوشتن برنامه‌هایی می‌کنیم که شامل عملیات موازی یا همزمان هستند، به سرعت با چالش‌های جدیدی مواجه می‌شویم که در ذات <em>برنامه‌نویسی ناهمزمان</em> هستند، جایی که عملیات‌ها ممکن است به ترتیب شروع‌شده تکمیل نشوند. این فصل بر اساس استفاده از Threadها برای موازی‌سازی و همزمانی که در فصل ۱۶ دیدیم، یک رویکرد جایگزین برای برنامه‌نویسی ناهمزمان معرفی می‌کند: Futures، Streams، سینتکس <code>async</code> و <code>await</code> در Rust، و ابزارهایی برای مدیریت و هماهنگی بین عملیات ناهمزمان.</p>
<p>بیایید یک مثال را بررسی کنیم. فرض کنید در حال خروجی گرفتن از یک ویدئو هستید که از یک جشن خانوادگی ساخته‌اید؛ این عملیات ممکن است از چند دقیقه تا چند ساعت طول بکشد. خروجی ویدئو تا جایی که ممکن است از قدرت CPU و GPU استفاده خواهد کرد. اگر فقط یک هسته CPU داشتید و سیستم‌عامل شما آن خروجی را تا پایان تکمیل متوقف نمی‌کرد—یعنی اگر آن را به صورت <em>همزمان</em> اجرا می‌کرد—در حالی که آن کار در حال اجرا بود نمی‌توانستید هیچ کار دیگری روی کامپیوتر خود انجام دهید. این تجربه بسیار ناامیدکننده‌ای می‌شد. خوشبختانه، سیستم‌عامل کامپیوتر شما می‌تواند و معمولاً هم می‌کند، به طور نامرئی خروجی را به اندازه کافی متوقف می‌کند تا بتوانید همزمان کارهای دیگری انجام دهید.</p>
<p>حالا فرض کنید یک ویدئو که توسط شخص دیگری به اشتراک گذاشته شده است را دانلود می‌کنید، که این نیز ممکن است مدتی طول بکشد اما به اندازه خروجی گرفتن از CPU زمان نمی‌برد. در این حالت، CPU باید منتظر بماند تا داده از شبکه برسد. در حالی که می‌توانید داده را از زمانی که شروع به رسیدن می‌کند بخوانید، ممکن است مدتی طول بکشد تا همه آن برسد. حتی وقتی داده به طور کامل موجود باشد، اگر ویدئو خیلی بزرگ باشد، ممکن است حداقل یک یا دو ثانیه طول بکشد تا همه آن بارگذاری شود. شاید به نظر نرسد زمان زیادی باشد، اما برای یک پردازنده مدرن که می‌تواند میلیاردها عملیات را در هر ثانیه انجام دهد، این زمان بسیار طولانی است. باز هم، سیستم‌عامل برنامه شما را به طور نامرئی متوقف می‌کند تا CPU بتواند در حالی که منتظر تماس شبکه است، کارهای دیگری انجام دهد.</p>
<p>خروجی ویدئو یک مثال از یک عملیات <em>وابسته به CPU</em> یا <em>وابسته به محاسبه</em> (<em>CPU-bound</em>) است. این عملیات محدود به سرعت پردازش داده کامپیوتر در CPU یا GPU و میزان توانایی آن برای اختصاص این سرعت به عملیات است. دانلود ویدئو یک مثال از یک عملیات <em>وابسته به ورودی و خروجی</em> (<em>IO-bound</em>) است، زیرا محدود به سرعت <em>ورودی و خروجی</em> کامپیوتر است؛ این عملیات فقط به سرعتی که داده می‌تواند از طریق شبکه ارسال شود، وابسته است.</p>
<p>در هر دو این مثال‌ها، وقفه‌های نامرئی سیستم‌عامل نوعی همزمانی فراهم می‌کنند. با این حال، این همزمانی فقط در سطح کل برنامه اتفاق می‌افتد: سیستم‌عامل یک برنامه را متوقف می‌کند تا برنامه‌های دیگر بتوانند کار انجام دهند. در بسیاری از موارد، از آنجا که ما برنامه‌های خود را در سطح بسیار جزئی‌تری نسبت به سیستم‌عامل درک می‌کنیم، می‌توانیم فرصت‌هایی برای همزمانی پیدا کنیم که سیستم‌عامل نمی‌تواند ببیند.</p>
<p>به عنوان مثال، اگر در حال ساخت یک ابزار برای مدیریت دانلود فایل‌ها هستید، باید بتوانید برنامه خود را طوری بنویسید که شروع یک دانلود، رابط کاربری را قفل نکند، و کاربران بتوانند به طور همزمان چندین دانلود را آغاز کنند. بسیاری از APIهای سیستم‌عامل برای تعامل با شبکه <em>مسدودکننده</em> (<em>blocking</em>) هستند؛ یعنی پیشرفت برنامه را تا زمانی که داده‌ای که پردازش می‌کنند کاملاً آماده باشد، متوقف می‌کنند.</p>
<blockquote>
<p>نکته: این همان چیزی است که <em>بیشتر</em> فراخوانی‌های توابع انجام می‌دهند، اگر در مورد آن فکر کنید. با این حال، اصطلاح <em>blocking</em> معمولاً برای فراخوانی توابعی که با فایل‌ها، شبکه یا منابع دیگر روی کامپیوتر تعامل دارند استفاده می‌شود، زیرا این مواردی هستند که یک برنامه فردی می‌تواند از غیرمسدودکننده (<em>non-blocking</em>) بودن عملیات بهره‌مند شود.</p>
</blockquote>
<p>ما می‌توانیم با ایجاد یک Thread اختصاصی برای دانلود هر فایل، از مسدود شدن Thread اصلی جلوگیری کنیم. با این حال، سربار آن Threadها در نهایت به مشکل تبدیل خواهد شد. بهتر است که فراخوانی از ابتدا مسدودکننده نباشد. همچنین بهتر است که بتوانیم به همان سبک مستقیم کدی که در کد مسدودکننده استفاده می‌کنیم، بنویسیم، شبیه به این:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>این دقیقاً همان چیزی است که انتزاع <em>async</em> (مخفف <em>asynchronous</em>) در Rust به ما می‌دهد. در این فصل، همه چیز درباره async را یاد خواهید گرفت و موضوعات زیر را پوشش خواهیم داد:</p>
<ul>
<li>نحوه استفاده از سینتکس <code>async</code> و <code>await</code> در Rust</li>
<li>نحوه استفاده از مدل async برای حل برخی از چالش‌هایی که در فصل ۱۶ بررسی کردیم</li>
<li>چگونگی ارائه راه‌حل‌های مکمل توسط multithreading و async، که در بسیاری از موارد می‌توانید آن‌ها را با هم ترکیب کنید</li>
</ul>
<p>با این حال، قبل از اینکه ببینیم async در عمل چگونه کار می‌کند، باید یک توقف کوتاه برای بحث درباره تفاوت‌های بین موازی‌سازی و همزمانی داشته باشیم.</p>
<h3 id="تفاوت-بین-موازیسازی-و-همزمانی"><a class="header" href="#تفاوت-بین-موازیسازی-و-همزمانی">تفاوت بین موازی‌سازی و همزمانی</a></h3>
<p>ما تاکنون همزمانی (<em>concurrency</em>) و موازی‌سازی (<em>parallelism</em>) را تقریباً به جای هم در نظر گرفته‌ایم. اکنون باید آن‌ها را به طور دقیق‌تر از هم متمایز کنیم، زیرا تفاوت‌هایشان در هنگام کار مشخص خواهد شد.</p>
<p>به روش‌های مختلفی که یک تیم می‌تواند کار بر روی یک پروژه نرم‌افزاری را تقسیم کند فکر کنید. می‌توانید چندین وظیفه را به یک عضو اختصاص دهید، به هر عضو یک وظیفه اختصاص دهید، یا ترکیبی از این دو روش را استفاده کنید.</p>
<p>وقتی یک فرد روی چندین وظیفه مختلف قبل از اتمام هر یک از آن‌ها کار می‌کند، این <em>همزمانی</em> است. شاید شما دو پروژه مختلف را روی کامپیوتر خود باز کرده‌اید و وقتی از یکی خسته یا در آن گیر کردید، به دیگری تغییر می‌دهید. شما فقط یک نفر هستید، بنابراین نمی‌توانید به طور همزمان روی هر دو وظیفه پیشرفت کنید، اما می‌توانید چندوظیفه‌ای (<em>multi-tasking</em>) کنید و با جابه‌جا شدن بین آن‌ها، یکی یکی پیشرفت کنید (نگاه کنید به شکل ۱۷-۱).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B." />
<figcaption>شکل ۱۷-۱: یک جریان کاری همزمان، که بین وظیفه A و وظیفه B جابه‌جا می‌شود.</figcaption>
</figure>
<p>وقتی تیم گروهی از وظایف را به این صورت تقسیم می‌کند که هر عضو یک وظیفه را بر عهده می‌گیرد و به تنهایی روی آن کار می‌کند، این <em>موازی‌سازی</em> است. هر فرد در تیم می‌تواند دقیقاً به طور همزمان پیشرفت کند (نگاه کنید به شکل ۱۷-۲).</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="یک نمودار با جعبه‌هایی که با برچسب‌های وظیفه A و وظیفه B نام‌گذاری شده‌اند، و لوزی‌هایی درون آن‌ها که نمایانگر زیروظایف هستند. فلش‌هایی از A1 به A2، A2 به A3، A3 به A4، B1 به B2، و B2 به B3 اشاره می‌کنند. هیچ فلشی بین جعبه‌های وظیفه A و وظیفه B عبور نمی‌کند." />
<figcaption>شکل ۱۷-۲: یک جریان کاری موازی، که در آن کار روی وظیفه A و وظیفه B به طور مستقل انجام می‌شود.</figcaption>
</figure>
<p>در هر دو این جریان‌های کاری، ممکن است نیاز به هماهنگی بین وظایف مختلف داشته باشید. شاید <em>فکر</em> می‌کردید وظیفه‌ای که به یک نفر اختصاص داده شده کاملاً مستقل از کار سایر اعضای تیم است، اما در واقع نیاز دارد که یک نفر دیگر در تیم ابتدا وظیفه خود را به پایان برساند. بخشی از کار می‌تواند به صورت موازی انجام شود، اما بخشی از آن در واقع <em>سریالی</em> است: فقط می‌تواند به صورت متوالی انجام شود، یک وظیفه پس از دیگری، همان‌طور که در شکل ۱۷-۳ نشان داده شده است.</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="یک نمودار با جعبه‌هایی که با برچسب وظیفه A و وظیفه B نام‌گذاری شده‌اند، و لوزی‌هایی درون آن‌ها که نمایانگر زیروظایف هستند. فلش‌هایی از A1 به A2، A2 به یک جفت خطوط عمودی ضخیم مانند نماد 'توقف'، از آن نماد به A3، B1 به B2، B2 به B3 (که در زیر آن نماد قرار دارد)، B3 به A3، و B3 به B4 اشاره می‌کنند." />
<figcaption>شکل ۱۷-۳: یک جریان کاری نیمه موازی، که در آن کار روی وظیفه A و وظیفه B به طور مستقل انجام می‌شود تا زمانی که A3 به نتایج B3 وابسته باشد.</figcaption>
</figure>
<p>به همین ترتیب، ممکن است متوجه شوید که یکی از وظایف شما به وظیفه دیگری از کارهای شما بستگی دارد. اکنون کار همزمان شما نیز سریالی شده است.</p>
<p>موازی‌سازی و همزمانی می‌توانند با یکدیگر تقاطع داشته باشند. اگر متوجه شوید که یک همکار تا زمانی که یکی از وظایف شما به پایان نرسیده گیر کرده است، احتمالاً تمام تلاش خود را روی آن وظیفه متمرکز می‌کنید تا “همکارتان را از بن‌بست خارج کنید.” شما و همکارتان دیگر نمی‌توانید به صورت موازی کار کنید، و همچنین دیگر نمی‌توانید به صورت همزمان روی وظایف خودتان کار کنید.</p>
<p>همان دینامیک‌های اساسی در نرم‌افزار و سخت‌افزار نیز وجود دارند. روی ماشینی با یک هسته CPU، CPU فقط می‌تواند یک عملیات را در هر لحظه انجام دهد، اما همچنان می‌تواند به صورت همزمان کار کند. با استفاده از ابزارهایی مانند Threads، فرآیندها (<em>processes</em>) و async، کامپیوتر می‌تواند یک فعالیت را متوقف کند و به فعالیت‌های دیگر تغییر دهد، و در نهایت دوباره به فعالیت اول بازگردد. روی ماشینی با چندین هسته CPU، می‌تواند کارها را به صورت موازی نیز انجام دهد. یک هسته می‌تواند یک وظیفه را اجرا کند در حالی که هسته دیگری وظیفه‌ای کاملاً نامرتبط را اجرا می‌کند، و این عملیات‌ها واقعاً در یک زمان اتفاق می‌افتند.</p>
<p>هنگام کار با async در Rust، همیشه با همزمانی سر و کار داریم. بسته به سخت‌افزار، سیستم‌عامل، و Runtime async که استفاده می‌کنیم (که در ادامه درباره Runtimeهای async بیشتر صحبت خواهیم کرد)، این همزمانی ممکن است در پس‌زمینه از موازی‌سازی نیز استفاده کند.</p>
<p>حالا بیایید به این بپردازیم که برنامه‌نویسی async در Rust در عمل چگونه کار می‌کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="futures-و-سینتکس-async"><a class="header" href="#futures-و-سینتکس-async">Futures و سینتکس Async</a></h2>
<p>عناصر کلیدی برنامه‌نویسی ناهمزمان در Rust شامل <em>futures</em> و کلمات کلیدی <code>async</code> و <code>await</code> هستند.</p>
<p>یک <em>future</em> مقداری است که ممکن است اکنون آماده نباشد، اما در آینده در نقطه‌ای آماده خواهد شد. (این مفهوم در بسیاری از زبان‌ها وجود دارد، گاهی با نام‌های دیگر مانند <em>task</em> یا <em>promise</em>.) Rust یک ویژگی <code>Future</code> به عنوان یک بلوک سازنده فراهم می‌کند تا عملیات‌های async مختلف با ساختارهای داده متفاوت اما با یک رابط مشترک پیاده‌سازی شوند. در Rust، futures نوع‌هایی هستند که ویژگی <code>Future</code> را پیاده‌سازی می‌کنند. هر future اطلاعات خود را در مورد پیشرفت و اینکه “آماده” به چه معناست نگه می‌دارد.</p>
<p>می‌توانید کلمه کلیدی <code>async</code> را به بلوک‌ها و توابع اعمال کنید تا مشخص کنید که می‌توانند متوقف شده و از سر گرفته شوند. درون یک بلوک async یا تابع async، می‌توانید از کلمه کلیدی <code>await</code> برای <em>انتظار یک future</em> (یعنی منتظر ماندن تا آماده شود) استفاده کنید. هر نقطه‌ای که در آن یک future را در یک بلوک یا تابع async انتظار می‌کشید، یک نقطه بالقوه برای متوقف و از سر گرفتن آن بلوک یا تابع async است. فرآیند بررسی یک future برای اینکه ببیند مقدار آن هنوز آماده است یا خیر، <em>polling</em> نامیده می‌شود.</p>
<p>برخی زبان‌های دیگر، مانند C# و JavaScript، نیز از کلمات کلیدی <code>async</code> و <code>await</code> برای برنامه‌نویسی ناهمزمان استفاده می‌کنند. اگر با این زبان‌ها آشنا هستید، ممکن است تفاوت‌های قابل توجهی در نحوه عملکرد Rust، از جمله نحوه مدیریت سینتکس آن، مشاهده کنید. این تفاوت‌ها دلایل خوبی دارند، همان‌طور که خواهیم دید!</p>
<p>هنگام نوشتن کد async در Rust، بیشتر اوقات از کلمات کلیدی <code>async</code> و <code>await</code> استفاده می‌کنیم. Rust آن‌ها را به کدی معادل با استفاده از ویژگی <code>Future</code> کامپایل می‌کند، همان‌طور که حلقه‌های <code>for</code> را به کدی معادل با استفاده از ویژگی <code>Iterator</code> کامپایل می‌کند. با این حال، از آنجا که Rust ویژگی <code>Future</code> را ارائه می‌دهد، می‌توانید آن را برای نوع‌های داده خودتان نیز پیاده‌سازی کنید. بسیاری از توابعی که در طول این فصل مشاهده خواهیم کرد نوع‌هایی را بازمی‌گردانند که پیاده‌سازی‌های خود از <code>Future</code> را دارند. در انتهای فصل به تعریف این ویژگی بازمی‌گردیم و بیشتر در مورد نحوه عملکرد آن بحث می‌کنیم، اما این توضیحات برای ادامه کافی است.</p>
<p>ممکن است این توضیحات کمی انتزاعی به نظر برسند، بنابراین بیایید اولین برنامه async خود را بنویسیم: یک web scraper کوچک. ما دو URL را از خط فرمان دریافت می‌کنیم، هر دو را به صورت همزمان دریافت می‌کنیم و نتیجه اولین URL که به پایان می‌رسد را بازمی‌گردانیم. این مثال دارای سینتکس جدیدی خواهد بود، اما نگران نباشید—همه چیزهایی که باید بدانید را در طول مسیر توضیح خواهیم داد.</p>
<h2 id="اولین-برنامه-async-ما"><a class="header" href="#اولین-برنامه-async-ما">اولین برنامه Async ما</a></h2>
<p>برای تمرکز این فصل روی یادگیری async به جای مدیریت بخش‌های اکوسیستم، یک crate به نام <code>trpl</code> ایجاد کرده‌ایم (<code>trpl</code> مخفف “The Rust Programming Language” است). این crate همه نوع‌ها، ویژگی‌ها، و توابع مورد نیاز شما را بازصادر می‌کند، عمدتاً از crateهای <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore --> و <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore -->. crate <code>futures</code> خانه رسمی برای آزمایش کد async در Rust است و در واقع جایی است که ویژگی <code>Future</code> در ابتدا طراحی شد. <code>tokio</code> امروز رایج‌ترین Runtime async در Rust است، به ویژه برای برنامه‌های وب. Runtimeهای عالی دیگری نیز وجود دارند که ممکن است برای اهداف شما مناسب‌تر باشند. ما از crate <code>tokio</code> در زیرساخت <code>trpl</code> استفاده می‌کنیم زیرا به خوبی تست شده و به طور گسترده استفاده می‌شود.</p>
<p>در برخی موارد، <code>trpl</code> همچنین APIهای اصلی را تغییر نام داده یا آن‌ها را پوشش می‌دهد تا شما را بر روی جزئیات مرتبط با این فصل متمرکز نگه دارد. اگر می‌خواهید بفهمید این crate چه می‌کند، ما شما را تشویق می‌کنیم که <a href="https://github.com/persian-rust/book/tree/main/packages/trpl">سورس کد آن</a><!-- ignore --> را بررسی کنید. می‌توانید ببینید که هر بازصادر از کدام crate می‌آید، و توضیحات گسترده‌ای در مورد آنچه که crate انجام می‌دهد گذاشته‌ایم.</p>
<p>یک پروژه باینری جدید به نام <code>hello-async</code> ایجاد کنید و crate <code>trpl</code> را به عنوان وابستگی اضافه کنید:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>اکنون می‌توانیم از بخش‌های مختلف ارائه‌شده توسط <code>trpl</code> استفاده کنیم تا اولین برنامه async خود را بنویسیم. ما یک ابزار کوچک خط فرمان ایجاد خواهیم کرد که دو صفحه وب را دریافت می‌کند، عنصر <code>&lt;title&gt;</code> را از هرکدام استخراج می‌کند و عنوان صفحه‌ای که سریع‌تر کل این فرآیند را تکمیل می‌کند، چاپ می‌کند.</p>
<h3 id="تعریف-تابع-page_title"><a class="header" href="#تعریف-تابع-page_title">تعریف تابع <code>page_title</code></a></h3>
<p>بیایید با نوشتن یک تابع که یک URL صفحه را به عنوان پارامتر می‌گیرد، یک درخواست به آن ارسال می‌کند و متن عنصر <code>&lt;title&gt;</code> را بازمی‌گرداند شروع کنیم (نگاه کنید به لیست ۱۷-۱).</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
<figcaption>Listing 17-1: تعریف یک تابع async برای دریافت عنصر <code>&lt;title&gt;</code> از یک صفحه HTML</figcaption>
</figure>
<p>ابتدا یک تابع به نام <code>page_title</code> تعریف می‌کنیم و آن را با کلمه کلیدی <code>async</code> علامت‌گذاری می‌کنیم. سپس از تابع <code>trpl::get</code> برای دریافت هر URL که به آن ارسال می‌شود استفاده می‌کنیم و کلمه کلیدی <code>await</code> را اضافه می‌کنیم تا منتظر پاسخ بمانیم. برای دریافت متن پاسخ، متد <code>text</code> را فراخوانی می‌کنیم و دوباره با کلمه کلیدی <code>await</code> منتظر آن می‌مانیم. هر دو این مراحل ناهمزمان هستند. برای تابع <code>get</code>، باید منتظر باشیم تا سرور اولین قسمت از پاسخ خود را ارسال کند که شامل هدرهای HTTP، کوکی‌ها و غیره است و می‌تواند جدا از بدنه پاسخ ارسال شود. به ویژه اگر بدنه بسیار بزرگ باشد، ممکن است مدتی طول بکشد تا همه آن برسد. از آنجا که باید منتظر <em>تمامیت</em> پاسخ بمانیم، متد <code>text</code> نیز async است.</p>
<p>باید به‌صراحت منتظر هر دو future باشیم، زیرا futures در Rust <em>تنبل</em> هستند: تا زمانی که از آن‌ها با کلمه کلیدی <code>await</code> درخواست نشود، هیچ کاری انجام نمی‌دهند. (در واقع، Rust یک هشدار کامپایلر نمایش می‌دهد اگر از یک future استفاده نکنید.) این ممکن است شما را به یاد بحث فصل ۱۳ درباره iteratorها در بخش <a href="ch13-02-iterators.html">پردازش یک سری از آیتم‌ها با iteratorها</a><!-- ignore --> بیندازد. iteratorها هیچ کاری انجام نمی‌دهند مگر اینکه متد <code>next</code> آن‌ها را فراخوانی کنید—چه به صورت مستقیم یا با استفاده از حلقه‌های <code>for</code> یا متدهایی مانند <code>map</code> که در پشت صحنه از <code>next</code> استفاده می‌کنند. به همین ترتیب، futures هیچ کاری انجام نمی‌دهند مگر اینکه به‌صراحت از آن‌ها درخواست شود. این ویژگی تنبلی به Rust اجازه می‌دهد تا کد async را تا زمانی که واقعاً مورد نیاز است، اجرا نکند.</p>
<blockquote>
<p>نکته: این رفتار متفاوت از چیزی است که در فصل قبلی هنگام استفاده از <code>thread::spawn</code> در <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">ایجاد یک Thread جدید با <code>spawn</code></a><!-- ignore --> مشاهده کردیم، جایی که Closureی که به یک Thread دیگر ارسال کردیم بلافاصله شروع به اجرا کرد. همچنین، این رفتار با نحوه استفاده بسیاری از زبان‌های دیگر از async متفاوت است. اما این برای Rust مهم است و بعداً خواهیم دید چرا.</p>
</blockquote>
<p>وقتی <code>response_text</code> را داریم، می‌توانیم آن را با استفاده از <code>Html::parse</code> به یک نمونه از نوع <code>Html</code> تجزیه کنیم. به جای یک رشته خام، اکنون یک نوع داده داریم که می‌توانیم از آن برای کار با HTML به عنوان یک ساختار داده غنی‌تر استفاده کنیم. به طور خاص، می‌توانیم از متد <code>select_first</code> برای پیدا کردن اولین نمونه از یک انتخابگر CSS خاص استفاده کنیم. با ارسال رشته <code>"title"</code>، اولین عنصر <code>&lt;title&gt;</code> در سند را دریافت خواهیم کرد، اگر وجود داشته باشد. چون ممکن است هیچ عنصر مطابقتی وجود نداشته باشد، <code>select_first</code> یک <code>Option&lt;ElementRef&gt;</code> بازمی‌گرداند. در نهایت، از متد <code>Option::map</code> استفاده می‌کنیم که به ما اجازه می‌دهد با آیتم موجود در <code>Option</code> کار کنیم، اگر موجود باشد، و اگر موجود نباشد، هیچ کاری انجام ندهیم. (می‌توانستیم از یک عبارت <code>match</code> هم استفاده کنیم، اما <code>map</code> بیشتر idiomatic است.) در بدنه تابعی که به <code>map</code> می‌دهیم، متد <code>inner_html</code> را روی <code>title_element</code> فراخوانی می‌کنیم تا محتوای آن را که یک <code>String</code> است، دریافت کنیم. وقتی همه چیز انجام شد، یک <code>Option&lt;String&gt;</code> خواهیم داشت.</p>
<p>توجه کنید که کلمه کلیدی <code>await</code> در Rust <em>بعد از</em> عبارت مورد انتظار قرار می‌گیرد، نه قبل از آن. یعنی این یک کلمه کلیدی <em>postfix</em> است. این ممکن است با چیزی که به آن عادت دارید اگر از async در زبان‌های دیگر استفاده کرده باشید، متفاوت باشد، اما در Rust این کار زنجیره‌ای از متدها را بسیار راحت‌تر می‌کند. در نتیجه، می‌توانیم بدنه <code>page_url_for</code> را تغییر دهیم تا فراخوانی‌های تابع <code>trpl::get</code> و <code>text</code> را با <code>await</code> بین آن‌ها به هم زنجیر کنیم، همان‌طور که در لیست ۱۷-۲ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-2: زنجیره کردن با کلمه کلیدی <code>await</code></figcaption>
</figure>
<p>با این توضیحات، ما اولین تابع async خود را با موفقیت نوشتیم! پیش از اضافه کردن کدی در <code>main</code> برای فراخوانی آن، بیایید کمی بیشتر درباره آنچه نوشته‌ایم و معنای آن صحبت کنیم.</p>
<p>هنگامی که Rust یک بلوک که با کلمه کلیدی <code>async</code> علامت‌گذاری شده است را می‌بیند، آن را به یک نوع داده منحصربه‌فرد و ناشناس که ویژگی <code>Future</code> را پیاده‌سازی می‌کند، کامپایل می‌کند. هنگامی که Rust یک تابع که با <code>async</code> علامت‌گذاری شده است را می‌بیند، آن را به یک تابع غیر-async که بدنه آن یک بلوک async است، کامپایل می‌کند. نوع بازگشتی یک تابع async نوع داده ناشناسی است که کامپایلر برای آن بلوک async ایجاد می‌کند.</p>
<p>بنابراین، نوشتن <code>async fn</code> معادل نوشتن تابعی است که یک <em>future</em> از نوع بازگشتی برمی‌گرداند. برای کامپایلر، یک تعریف تابع مانند <code>async fn page_title</code> در لیست ۱۷-۱ معادل یک تابع غیر-async به شکل زیر است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>بیایید هر بخش از نسخه تبدیل‌شده را بررسی کنیم:</p>
<ul>
<li>از سینتکس <code>impl Trait</code> که در فصل ۱۰ در بخش <a href="ch10-02-traits.html#traits-as-parameters">“ویژگی‌ها به عنوان پارامتر”</a><!-- ignore --> بحث کردیم، استفاده می‌کند.</li>
<li>ویژگی بازگردانده‌شده یک <code>Future</code> با یک نوع وابسته به نام <code>Output</code> است. توجه کنید که نوع <code>Output</code> برابر با <code>Option&lt;String&gt;</code> است، که همان نوع بازگشتی نسخه اصلی <code>async fn</code> تابع <code>page_title</code> است.</li>
<li>تمام کدی که در بدنه تابع اصلی فراخوانی شده است، در یک بلوک <code>async move</code> بسته‌بندی شده است. به یاد داشته باشید که بلوک‌ها بیان (<em>expression</em>) هستند. این بلوک کامل، بیانی است که از تابع بازگردانده می‌شود.</li>
<li>این بلوک async یک مقداری با نوع <code>Option&lt;String&gt;</code> تولید می‌کند، همان‌طور که توضیح داده شد. این مقدار با نوع <code>Output</code> در نوع بازگشتی مطابقت دارد. این درست مانند بلوک‌های دیگری است که قبلاً دیده‌اید.</li>
<li>بدنه جدید تابع یک بلوک <code>async move</code> است به دلیل نحوه استفاده از پارامتر <code>url</code>. (در ادامه فصل بیشتر درباره تفاوت <code>async</code> و <code>async move</code> صحبت خواهیم کرد.)</li>
<li>نسخه جدید تابع دارای نوعی طول عمر است که قبلاً ندیده‌ایم: <code>'_</code>. از آنجا که تابع یک future بازمی‌گرداند که به یک مرجع اشاره می‌کند—در این مورد، مرجعی که از پارامتر <code>url</code> آمده است—باید به Rust بگوییم که می‌خواهیم آن مرجع شامل شود. نیازی نیست طول عمر را اینجا نام‌گذاری کنیم، زیرا Rust به اندازه کافی هوشمند است که بفهمد فقط یک مرجع می‌تواند درگیر باشد، اما باید صراحتاً مشخص کنیم که future حاصل به آن طول عمر محدود شده است.</li>
</ul>
<p>حالا می‌توانیم <code>page_title</code> را در <code>main</code> فراخوانی کنیم.</p>
<h2 id="تعیین-عنوان-یک-صفحه"><a class="header" href="#تعیین-عنوان-یک-صفحه">تعیین عنوان یک صفحه</a></h2>
<p>برای شروع، فقط عنوان یک صفحه را دریافت می‌کنیم. در لیست ۱۷-۳، همان الگویی که در فصل ۱۲ برای دریافت آرگومان‌های خط فرمان در بخش <a href="ch12-01-accepting-command-line-arguments.html">پذیرفتن آرگومان‌های خط فرمان</a><!-- ignore --> استفاده کردیم را دنبال می‌کنیم. سپس URL اول را به <code>page_title</code> ارسال کرده و نتیجه را انتظار می‌کشیم. چون مقداری که توسط future تولید می‌شود یک <code>Option&lt;String&gt;</code> است، از یک عبارت <code>match</code> برای چاپ پیام‌های مختلف استفاده می‌کنیم تا مشخص شود آیا صفحه یک <code>&lt;title&gt;</code> داشته است یا خیر.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-3: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument</figcaption>
</figure>
<p>متأسفانه، این کد کامپایل نمی‌شود. تنها جایی که می‌توانیم از کلمه کلیدی <code>await</code> استفاده کنیم، در توابع یا بلوک‌های async است، و Rust اجازه نمی‌دهد تابع ویژه <code>main</code> را به‌عنوان <code>async</code> علامت‌گذاری کنیم.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>دلیل اینکه نمی‌توان <code>main</code> را به‌عنوان <code>async</code> علامت‌گذاری کرد این است که کد async به یک <em>runtime</em> نیاز دارد: یک crate در Rust که جزئیات اجرای کد ناهمزمان را مدیریت می‌کند. تابع <code>main</code> یک برنامه می‌تواند یک runtime را <em>مقداردهی اولیه</em> کند، اما خودش یک runtime نیست. (در ادامه، بیشتر خواهیم دید که چرا این‌گونه است.) هر برنامه Rust که کد async اجرا می‌کند، حداقل یک مکان دارد که در آن یک runtime راه‌اندازی کرده و futures را اجرا می‌کند.</p>
<p>بیشتر زبان‌هایی که از async پشتیبانی می‌کنند، یک runtime همراه دارند، اما Rust این کار را نمی‌کند. در عوض، بسیاری از runtimeهای async مختلف موجود هستند که هرکدام موازنه‌های متفاوتی برای موارد استفاده خاص خود ارائه می‌دهند. برای مثال، یک وب سرور با توان عملیاتی بالا که دارای هسته‌های CPU متعدد و مقدار زیادی RAM است، نیازهای بسیار متفاوتی نسبت به یک میکروکنترلر با یک هسته، مقدار کمی RAM و بدون قابلیت تخصیص heap دارد. crateهایی که این runtimeها را فراهم می‌کنند اغلب نسخه‌های async از قابلیت‌های عمومی مانند I/O فایل یا شبکه را نیز ارائه می‌دهند.</p>
<p>اینجا و در بقیه این فصل، از تابع <code>run</code> از crate <code>trpl</code> استفاده خواهیم کرد، که یک future را به‌عنوان آرگومان می‌گیرد و آن را تا پایان اجرا می‌کند. در پشت صحنه، فراخوانی <code>run</code> یک runtime راه‌اندازی می‌کند که برای اجرای future ارسال‌شده استفاده می‌شود. وقتی future کامل شد، <code>run</code> هر مقداری که future تولید کرده باشد، بازمی‌گرداند.</p>
<p>می‌توانستیم future بازگردانده‌شده توسط <code>page_title</code> را مستقیماً به <code>run</code> ارسال کنیم، و وقتی کامل شد، می‌توانستیم بر اساس <code>Option&lt;String&gt;</code> نتیجه، یک <code>match</code> انجام دهیم، همان‌طور که در لیست ۱۷-۳ تلاش کردیم. با این حال، برای بیشتر مثال‌های این فصل (و بیشتر کد async در دنیای واقعی)، بیش از یک فراخوانی تابع async انجام خواهیم داد، بنابراین به‌جای آن یک بلوک <code>async</code> ارسال می‌کنیم و صراحتاً نتیجه فراخوانی <code>page_title</code> را انتظار می‌کشیم، همان‌طور که در لیست ۱۷-۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-4: منتظر ماندن یک بلوک async با <code>trpl::run</code></figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، رفتاری را که ممکن است ابتدا انتظار داشتیم دریافت می‌کنیم:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>پوووف—بالاخره مقداری کد async کارا داریم! اما قبل از اینکه کدی اضافه کنیم که دو سایت را در مقابل یکدیگر رقابت دهد، بیایید به‌طور مختصر دوباره به نحوه کار futures توجه کنیم.</p>
<p>هر <em>نقطه انتظار</em>—یعنی هر جایی که کد از کلمه کلیدی <code>await</code> استفاده می‌کند—نمایانگر جایی است که کنترل به runtime بازمی‌گردد. برای اینکه این کار انجام شود، Rust نیاز دارد وضعیت مربوط به بلوک async را پیگیری کند تا runtime بتواند کار دیگری را آغاز کند و سپس وقتی آماده شد دوباره برای پیشرفت بلوک اول بازگردد. این یک ماشین حالت نامرئی است، گویی که شما یک enum مانند این نوشته‌اید تا وضعیت فعلی را در هر نقطه انتظار ذخیره کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>نوشتن کدی که به صورت دستی بین هر حالت انتقال یابد خسته‌کننده و مستعد خطا خواهد بود، به‌ویژه زمانی که بخواهید عملکرد بیشتری اضافه کرده و حالات بیشتری به کد اضافه کنید. خوشبختانه، کامپایلر Rust به طور خودکار ساختارهای داده مربوط به ماشین حالت را برای کد async ایجاد و مدیریت می‌کند. قوانین عادی مالکیت و قرض‌گیری در مورد ساختارهای داده همچنان اعمال می‌شوند، و خوشبختانه، کامپایلر بررسی این موارد را نیز برای ما انجام می‌دهد و پیام‌های خطای مفیدی ارائه می‌دهد. در ادامه فصل چند مورد از این پیام‌ها را بررسی خواهیم کرد.</p>
<p>در نهایت، چیزی باید این ماشین حالت را اجرا کند، و آن چیز یک runtime است. (به همین دلیل ممکن است در بررسی runtimeها به ارجاعاتی به <em>executors</em> برخورد کنید: یک executor بخشی از runtime است که مسئول اجرای کد async است.)</p>
<p>حالا می‌توانید بفهمید چرا کامپایلر مانع شد که <code>main</code> خودش به عنوان یک تابع async در لیست ۱۷-۳ تعریف شود. اگر <code>main</code> یک تابع async بود، چیزی دیگری باید ماشین حالت را برای futureی که <code>main</code> بازمی‌گرداند مدیریت می‌کرد، اما <code>main</code> نقطه شروع برنامه است! در عوض، ما تابع <code>trpl::run</code> را در <code>main</code> فراخوانی کردیم تا یک runtime راه‌اندازی کند و future بازگردانده‌شده توسط بلوک <code>async</code> را تا زمانی که <code>Ready</code> بازگرداند، اجرا کند.</p>
<blockquote>
<p>نکته: برخی runtimeها ماکروهایی ارائه می‌دهند که به شما اجازه می‌دهند یک تابع async برای <code>main</code> بنویسید. این ماکروها <code>async fn main() { ... }</code> را به یک <code>fn main</code> عادی تبدیل می‌کنند، که همان کاری را انجام می‌دهد که ما به صورت دستی در لیست ۱۷-۵ انجام دادیم: فراخوانی یک تابع که یک future را به طور کامل اجرا می‌کند، همان‌طور که <code>trpl::run</code> انجام می‌دهد.</p>
</blockquote>
<p>حالا بیایید این بخش‌ها را کنار هم قرار دهیم و ببینیم چگونه می‌توان کدی همزمان نوشت.</p>
<h3 id="رقابت-بین-دو-url"><a class="header" href="#رقابت-بین-دو-url">رقابت بین دو URL</a></h3>
<p>در لیست ۱۷-۵، ما <code>page_title</code> را با دو URL مختلف که از خط فرمان ارسال شده‌اند، فراخوانی کرده و آن‌ها را با یکدیگر رقابت می‌دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title is: '{title}'"),
            None =&gt; println!("Its title could not be parsed."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption>Listing 17-5: </figcaption>
</figure>
<p>ما با فراخوانی <code>page_title</code> برای هر یک از URLهایی که توسط کاربر ارسال شده‌اند، شروع می‌کنیم. Futureهای حاصل را به نام‌های <code>title_fut_1</code> و <code>title_fut_2</code> ذخیره می‌کنیم. به یاد داشته باشید، این‌ها هنوز کاری انجام نمی‌دهند، زیرا futures تنبل هستند و هنوز منتظر آن‌ها نمانده‌ایم. سپس این futures را به <code>trpl::race</code> ارسال می‌کنیم، که مقداری بازمی‌گرداند تا نشان دهد کدام یک از futures ارسال‌شده به آن ابتدا کامل شده است.</p>
<blockquote>
<p>نکته: در پشت صحنه، <code>race</code> بر اساس یک تابع عمومی‌تر به نام <code>select</code> ساخته شده است، که اغلب در کدهای واقعی Rust با آن مواجه خواهید شد. یک تابع <code>select</code> می‌تواند کارهایی انجام دهد که تابع <code>trpl::race</code> نمی‌تواند، اما همچنین دارای پیچیدگی‌های اضافی است که فعلاً می‌توانیم از آن صرف‌نظر کنیم.</p>
</blockquote>
<p>هرکدام از futures می‌توانند به طور قانونی “برنده” شوند، بنابراین بازگرداندن یک <code>Result</code> منطقی نیست. در عوض، <code>race</code> نوعی را بازمی‌گرداند که قبلاً ندیده‌ایم: <code>trpl::Either</code>. نوع <code>Either</code> تا حدودی شبیه به <code>Result</code> است به این معنا که دو حالت دارد. اما برخلاف <code>Result</code>، هیچ مفهومی از موفقیت یا شکست در <code>Either</code> وجود ندارد. در عوض، از <code>Left</code> و <code>Right</code> برای نشان دادن “یکی یا دیگری” استفاده می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>تابع <code>race</code> مقدار <code>Left</code> را با خروجی future اول بازمی‌گرداند اگر آرگومان اول برنده شود، و مقدار <code>Right</code> را با خروجی future دوم بازمی‌گرداند اگر <em>آن</em> یکی برنده شود. این ترتیب با ترتیبی که آرگومان‌ها هنگام فراخوانی تابع ظاهر می‌شوند مطابقت دارد: آرگومان اول در سمت چپ آرگومان دوم قرار دارد.</p>
<p>همچنین تابع <code>page_title</code> را به‌روزرسانی می‌کنیم تا همان URL ارسال‌شده را بازگرداند. به این ترتیب، اگر صفحه‌ای که ابتدا بازمی‌گردد، دارای یک <code>&lt;title&gt;</code> نباشد که بتوانیم آن را استخراج کنیم، همچنان می‌توانیم یک پیام معنادار چاپ کنیم. با در دسترس بودن این اطلاعات، خروجی <code>println!</code> خود را به‌روزرسانی می‌کنیم تا مشخص کند کدام URL اول کامل شده است و <code>&lt;title&gt;</code> صفحه وب در آن URL چیست (اگر وجود داشته باشد).</p>
<p>شما اکنون یک web scraper کوچک و کارا ساخته‌اید! چند URL انتخاب کنید و ابزار خط فرمان را اجرا کنید. ممکن است متوجه شوید که برخی سایت‌ها به طور مداوم سریع‌تر از بقیه هستند، در حالی که در موارد دیگر، سایت سریع‌تر از اجرای به اجرای دیگر متفاوت است. مهم‌تر از همه، شما اصول کار با futures را آموخته‌اید، بنابراین حالا می‌توانیم عمیق‌تر به آنچه می‌توان با async انجام داد، بپردازیم.</p>
<!-- TODO: map source link version to version of Rust? -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="applying-concurrency-with-async"><a class="header" href="#applying-concurrency-with-async">Applying Concurrency with Async</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p>در این بخش، async را به برخی از همان چالش‌های همزمانی که با نخ‌ها در فصل 16 انجام دادیم اعمال می‌کنیم. از آنجا که قبلاً درباره بسیاری از ایده‌های کلیدی در آنجا صحبت کرده‌ایم، در این بخش تمرکز بر تفاوت‌های بین نخ‌ها و آینده‌ها (futures) خواهیم داشت.</p>
<p>در بسیاری از موارد، APIها برای کار با همزمانی (<em>concurrency</em>) با استفاده از async بسیار شبیه به APIهایی هستند که برای استفاده از Threadها استفاده می‌شوند. در موارد دیگر، این APIها کاملاً متفاوت هستند. حتی زمانی که APIها بین Threadها و async <em>شبیه</em> به نظر می‌رسند، اغلب رفتار متفاوتی دارند—و تقریباً همیشه ویژگی‌های عملکردی متفاوتی دارند.</p>
<p><a id="counting"></a></p>
<h3 id="ایجاد-یک-task-جدید-با-spawn_task"><a class="header" href="#ایجاد-یک-task-جدید-با-spawn_task">ایجاد یک Task جدید با <code>spawn_task</code></a></h3>
<p>اولین عملیاتی که در <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">ایجاد یک Thread جدید با Spawn</a><!-- ignore --> انجام دادیم، شمارش افزایشی در دو Thread جداگانه بود. بیایید همان کار را با استفاده از async انجام دهیم. crate <code>trpl</code> یک تابع <code>spawn_task</code> فراهم می‌کند که بسیار شبیه به API <code>thread::spawn</code> است، و یک تابع <code>sleep</code> که نسخه async از API <code>thread::sleep</code> است. می‌توانیم از این دو با هم استفاده کنیم تا مثال شمارش را پیاده‌سازی کنیم، همان‌طور که در لیست ۱۷-۶ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-6: ایجاد یک Task جدید برای چاپ یک چیز در حالی که Task اصلی چیز دیگری را چاپ می‌کند</figcaption>
</figure>
<p>به‌عنوان نقطه شروع، تابع <code>main</code> خود را با استفاده از <code>trpl::run</code> تنظیم می‌کنیم تا تابع سطح بالای ما بتواند async باشد.</p>
<blockquote>
<p>نکته: از این نقطه به بعد در فصل، هر مثال این کد بسته‌بندی یکسان را با <code>trpl::run</code> در <code>main</code> شامل خواهد شد، بنابراین اغلب آن را مانند <code>main</code> نادیده می‌گیریم. فراموش نکنید که آن را در کد خود بگنجانید!</p>
</blockquote>
<p>سپس دو حلقه درون آن بلوک می‌نویسیم که هر کدام شامل یک فراخوانی به trpl::sleep هستند، که قبل از ارسال پیام بعدی به مدت نیم ثانیه (۵۰۰ میلی‌ثانیه) منتظر می‌مانند. یکی از حلقه‌ها را در بدنه یک trpl::spawn_task قرار می‌دهیم و دیگری را در یک حلقه for در سطح بالا. همچنین پس از فراخوانی‌های sleep یک await اضافه می‌کنیم.</p>
<p>این کد رفتاری مشابه با پیاده‌سازی مبتنی بر Thread دارد—از جمله اینکه ممکن است پیام‌ها را در ترتیبی متفاوت در ترمینال خود هنگام اجرا مشاهده کنید:s</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>این نسخه به محض اینکه حلقه <code>for</code> در بدنه بلوک async اصلی به پایان می‌رسد، متوقف می‌شود، زیرا taskی که توسط <code>spawn_task</code> ایجاد شده است با پایان یافتن تابع <code>main</code> متوقف می‌شود. اگر بخواهید تا اتمام کامل task اجرا شود، باید از یک handle join استفاده کنید تا منتظر بمانید اولین task به پایان برسد. با Threadها، از متد <code>join</code> برای “مسدود کردن” تا زمانی که Thread اجرا می‌شد، استفاده می‌کردیم. در لیست ۱۷-۷، می‌توانیم از <code>await</code> برای انجام همین کار استفاده کنیم، زیرا handle task خودش یک future است. نوع <code>Output</code> آن یک <code>Result</code> است، بنابراین پس از منتظر ماندن آن را unwrap می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-7: استفاده از <code>await</code> با یک handle الحاقی برای اجرای تسک تا تکمیل</figcaption>
</figure>
<p>نسخه به‌روزرسانی‌شده تا زمانی که <em>هر دو</em> حلقه تمام شوند اجرا می‌شود.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>تا اینجا، به نظر می‌رسد async و نخ‌ها نتایج اصلی یکسانی به ما می‌دهند، فقط با سینتکس متفاوت: استفاده از <code>await</code> به جای فراخوانی <code>join</code> روی handle الحاقی و انتظار برای فراخوانی‌های <code>sleep</code>.</p>
<p>تفاوت بزرگ‌تر این است که نیازی به ایجاد یک نخ سیستم‌عامل جداگانه برای این کار نداشتیم. در واقع، حتی نیازی به ایجاد یک تسک هم در اینجا نداریم. زیرا بلوک‌های async به آینده‌های ناشناس کامپایل می‌شوند، می‌توانیم هر حلقه را در یک بلوک async قرار دهیم و اجازه دهیم runtime هر دو را با استفاده از تابع <code>trpl::join</code> تا تکمیل اجرا کند.</p>
<p>در بخش <a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles">انتظار برای اتمام تمام Threadها با استفاده از Handles <code>join</code></a><!-- ignore -->، نشان دادیم که چگونه می‌توان از متد <code>join</code> در نوع <code>JoinHandle</code> که هنگام فراخوانی <code>std::thread::spawn</code> بازگردانده می‌شود، استفاده کرد. تابع <code>trpl::join</code> مشابه است، اما برای futures طراحی شده است. وقتی دو future به آن می‌دهید، یک future جدید ایجاد می‌کند که خروجی آن یک tuple شامل خروجی هر یک از futureهایی است که به آن ارسال کرده‌اید، به شرطی که <em>هر دو</em> کامل شوند. بنابراین، در لیست ۱۷-۸، از <code>trpl::join</code> استفاده می‌کنیم تا منتظر بمانیم <code>fut1</code> و <code>fut2</code> به پایان برسند. ما <em>نه</em> برای <code>fut1</code> و <code>fut2</code>، بلکه برای future جدیدی که توسط <code>trpl::join</code> تولید می‌شود، منتظر می‌مانیم. خروجی را نادیده می‌گیریم، زیرا فقط یک tuple شامل دو مقدار unit است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-8: استفاده از <code>trpl::join</code> برای منتظر ماندن دو آینده ناشناس</figcaption>
</figure>
<p>وقتی این کد را اجرا می‌کنیم، می‌بینیم هر دو futures تا تکمیل اجرا می‌شوند:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>اکنون، هر بار دقیقاً همان ترتیب را مشاهده خواهید کرد، که بسیار متفاوت از چیزی است که با Threadها دیدیم. دلیل این امر این است که تابع <code>trpl::join</code> <em>منصفانه</em> است، به این معنی که هر future را به یک اندازه بررسی می‌کند، بین آن‌ها تناوب می‌گذارد و هرگز اجازه نمی‌دهد یکی از آن‌ها جلو بیفتد اگر دیگری آماده باشد. با Threadها، سیستم‌عامل تصمیم می‌گیرد که کدام Thread بررسی شود و چه مدت به آن اجازه اجرا بدهد. با Rust async، runtime تصمیم می‌گیرد که کدام task بررسی شود. (در عمل، جزئیات پیچیده می‌شوند زیرا یک runtime async ممکن است از Threadهای سیستم‌عامل در پشت صحنه به‌عنوان بخشی از نحوه مدیریت همزمانی استفاده کند، بنابراین تضمین منصفانه بودن می‌تواند برای runtime بیشتر کار ببرد—اما همچنان ممکن است!) runtimeها نیازی به تضمین منصفانه بودن برای هر عملیات خاصی ندارند، و اغلب APIهای مختلفی ارائه می‌دهند که به شما اجازه می‌دهند انتخاب کنید آیا می‌خواهید منصفانه بودن را اعمال کنید یا خیر.</p>
<p>برخی از این تغییرات در انتظار برای futures را امتحان کنید و ببینید چه می‌کنند:</p>
<ul>
<li>بلوک async را از اطراف یکی یا هر دو حلقه حذف کنید.</li>
<li>هر بلوک async را بلافاصله پس از تعریف آن منتظر بمانید.</li>
<li>فقط حلقه اول را در یک بلوک async قرار دهید و آینده حاصل را پس از بدنه حلقه دوم منتظر بمانید.</li>
</ul>
<p>برای یک چالش اضافی، ببینید آیا می‌توانید پیش از اجرای کد پیش‌بینی کنید که خروجی چه خواهد بود!</p>
<p><a id="message-passing"></a></p>
<h3 id="شمارش-افزایشی-در-دو-task-با-استفاده-از-ارسال-پیام"><a class="header" href="#شمارش-افزایشی-در-دو-task-با-استفاده-از-ارسال-پیام">شمارش افزایشی در دو Task با استفاده از ارسال پیام</a></h3>
<p>اشتراک داده‌ها بین futures نیز آشنا خواهد بود: دوباره از ارسال پیام استفاده خواهیم کرد، اما این بار با نسخه‌های async از انواع و توابع. ما مسیری کمی متفاوت از <a href="ch16-02-message-passing.html">استفاده از ارسال پیام برای انتقال داده‌ها بین Threadها</a><!-- ignore --> خواهیم پیمود تا برخی از تفاوت‌های کلیدی بین همزمانی مبتنی بر Thread و همزمانی مبتنی بر futures را نشان دهیم. در لیست ۱۷-۹، فقط با یک بلوک async شروع می‌کنیم—و <em>نه</em> ایجاد یک task جداگانه، همان‌طور که یک Thread جداگانه ایجاد کردیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-9: ایجاد یک کانال async و اختصاص دو نیمه به <code>tx</code> و <code>rx</code></figcaption>
</figure>
<p>اینجا، از <code>trpl::channel</code> استفاده می‌کنیم، نسخه async از API کانال چندتولیدی، یک‌مصرفی که در فصل 16 با نخ‌ها استفاده کردیم. نسخه async از API فقط کمی با نسخه مبتنی بر نخ متفاوت است: به جای استفاده از یک گیرنده غیرقابل‌تغییر (immutable)، از یک گیرنده قابل‌تغییر (mutable) <code>rx</code> استفاده می‌کند، و متد <code>recv</code> آن یک آینده تولید می‌کند که باید منتظر آن بمانیم، به جای تولید مقدار به‌طور مستقیم. اکنون می‌توانیم پیام‌ها را از فرستنده به گیرنده ارسال کنیم. توجه کنید که نیازی به ایجاد یک نخ جداگانه یا حتی یک تسک نداریم؛ فقط باید فراخوانی <code>rx.recv</code> را منتظر بمانیم.</p>
<p>متد همگام <code>Receiver::recv</code> در <code>std::mpsc::channel</code> تا زمانی که پیامی دریافت شود مسدود می‌شود. متد <code>trpl::Receiver::recv</code> این کار را نمی‌کند، زیرا async است. به جای مسدود شدن، کنترل را به runtime بازمی‌گرداند تا زمانی که یا پیامی دریافت شود یا سمت ارسال کانال بسته شود. در مقابل، ما فراخوانی <code>send</code> را منتظر نمی‌مانیم، زیرا مسدود نمی‌شود. نیازی به این کار ندارد، زیرا کانالی که پیام را به آن ارسال می‌کنیم بدون حد است.</p>
<blockquote>
<p>نکته: از آنجا که تمام این کد async در یک بلوک async درون یک فراخوانی <code>trpl::run</code> اجرا می‌شود، همه چیز درون آن می‌تواند از مسدود شدن اجتناب کند. با این حال، کد <em>خارج</em> از آن روی بازگشت تابع <code>run</code> مسدود می‌شود. این همان هدف اصلی تابع <code>trpl::run</code> است: به شما اجازه می‌دهد <em>انتخاب</em> کنید که کجا روی مجموعه‌ای از کد async مسدود شوید و بنابراین کجا بین کدهای sync و async انتقال دهید. در بیشتر runtimeهای async، <code>run</code> در واقع به همین دلیل <code>block_on</code> نامیده می‌شود.</p>
</blockquote>
<p>دو نکته در مورد این مثال توجه کنید. اول، پیام بلافاصله خواهد رسید. دوم، اگرچه ما اینجا از یک future استفاده می‌کنیم، هنوز هم هیچ همزمانی (<em>concurrency</em>) وجود ندارد. همه چیز در این لیست به ترتیب انجام می‌شود، درست مانند اینکه هیچ futureای در کار نباشد.</p>
<p>بیایید به قسمت اول بپردازیم، با ارسال یک سری پیام و خوابیدن بین آن‌ها، همان‌طور که در لیست ۱۷-۱۰ نشان داده شده است.</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-10: ارسال و دریافت چندین پیام از طریق کانال async و استفاده از <code>await</code> بین هر پیام</figcaption>
</figure>
<p>علاوه بر ارسال پیام‌ها، باید آن‌ها را دریافت کنیم. در این مورد، چون می‌دانیم چند پیام قرار است دریافت شوند، می‌توانستیم این کار را به‌صورت دستی با چهار بار فراخوانی <code>rx.recv().await</code> انجام دهیم. اما در دنیای واقعی، معمولاً در انتظار یک تعداد <em>نامعلوم</em> از پیام‌ها خواهیم بود، بنابراین نیاز داریم تا زمانی که مشخص کنیم پیام دیگری وجود ندارد، به انتظار ادامه دهیم.</p>
<p>در لیست ۱۶-۱۰، از یک حلقه <code>for</code> برای پردازش تمام آیتم‌های دریافت‌شده از یک کانال همزمان استفاده کردیم. با این حال، Rust هنوز راهی برای نوشتن یک حلقه <code>for</code> روی یک سری آیتم <em>ناهمزمان</em> ندارد، بنابراین باید از حلقه‌ای استفاده کنیم که قبلاً ندیده‌ایم: حلقه شرطی <code>while let</code>. این حلقه نسخه حلقه‌ای از ساختار <code>if let</code> است که در بخش <a href="ch06-03-if-let.html">کنترل جریان مختصر با <code>if let</code> و <code>let else</code></a><!-- ignore --> دیدیم. این حلقه تا زمانی که الگوی مشخص‌شده آن همچنان با مقدار مطابقت داشته باشد، به اجرا ادامه می‌دهد.</p>
<p>فراخوانی <code>rx.recv</code> یک future تولید می‌کند که منتظر آن می‌مانیم. runtime تا زمانی که future آماده شود، آن را متوقف می‌کند. وقتی پیامی برسد، future به <code>Some(message)</code> حل می‌شود، به ازای هر باری که پیام برسد. وقتی کانال بسته شود، صرف‌نظر از اینکه <em>آیا</em> پیام‌هایی رسیده‌اند یا خیر، future به <code>None</code> حل می‌شود تا نشان دهد دیگر مقادیری وجود ندارد و بنابراین باید polling را متوقف کنیم—یعنی منتظر ماندن را متوقف کنیم.</p>
<p>حلقه <code>while let</code> همه این‌ها را کنار هم قرار می‌دهد. اگر نتیجه فراخوانی <code>rx.recv().await</code> برابر با <code>Some(message)</code> باشد، به پیام دسترسی پیدا می‌کنیم و می‌توانیم از آن در بدنه حلقه استفاده کنیم، همانطور که با <code>if let</code> می‌توانستیم. اگر نتیجه <code>None</code> باشد، حلقه متوقف می‌شود. هر بار که حلقه کامل می‌شود، به نقطه انتظار بازمی‌گردد، بنابراین runtime دوباره آن را متوقف می‌کند تا زمانی که پیام دیگری برسد.</p>
<p>کد اکنون تمام پیام‌ها را با موفقیت ارسال و دریافت می‌کند. متأسفانه، هنوز چند مشکل وجود دارد. برای یک مورد، پیام‌ها با فواصل نیم‌ثانیه‌ای نمی‌رسند. همه آن‌ها به‌یک‌باره و ۲ ثانیه (۲۰۰۰ میلی‌ثانیه) پس از شروع برنامه می‌رسند. برای مورد دیگر، این برنامه هرگز به‌طور خودکار پایان نمی‌یابد! در عوض، برای همیشه منتظر پیام‌های جدید می‌ماند. برای متوقف کردن آن باید از <span class="keystroke">ctrl-c</span> استفاده کنید.</p>
<p>بیایید با بررسی دلیل اینکه چرا پیام‌ها پس از تأخیر کامل به‌یک‌باره می‌آیند، شروع کنیم، به‌جای اینکه با تأخیر بین هرکدام ظاهر شوند. در یک بلوک async خاص، ترتیب ظاهر شدن کلمات کلیدی <code>await</code> در کد، همان ترتیبی است که هنگام اجرای برنامه اجرا می‌شوند.</p>
<p>در فهرست 17-10 فقط یک بلوک async وجود دارد، بنابراین همه چیز در آن به‌صورت خطی اجرا می‌شود. هنوز هم هیچ همزمانی وجود ندارد. تمام فراخوانی‌های <code>tx.send</code> انجام می‌شوند، در میان تمام فراخوانی‌های <code>trpl::sleep</code> و نقاط انتظار مرتبط با آن‌ها. فقط پس از آن، حلقه <code>while let</code> به نقاط انتظار روی فراخوانی‌های <code>recv</code> می‌رسد.</p>
<p>برای به دست آوردن رفتار مورد نظر، که در آن تأخیر خواب بین هر پیام رخ می‌دهد، باید عملیات‌های <code>tx</code> و <code>rx</code> را در بلوک‌های async جداگانه قرار دهیم، همان‌طور که در لیست ۱۷-۱۱ نشان داده شده است. سپس runtime می‌تواند هر یک از آن‌ها را جداگانه با استفاده از <code>trpl::join</code> اجرا کند، دقیقاً مانند مثال شمارش. بار دیگر، منتظر نتیجه فراخوانی <code>trpl::join</code> می‌مانیم، نه futures فردی. اگر به صورت ترتیبی برای futures فردی منتظر می‌ماندیم، دوباره به جریان ترتیبی بازمی‌گشتیم—دقیقاً چیزی که تلاش می‌کنیم <em>انجام ندهیم</em>.</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-11: جدا کردن <code>send</code> و <code>recv</code> در بلوک‌های <code>async</code> جداگانه و منتظر ماندن برای آینده‌های این بلوک‌ها</figcaption>
</figure>
<p>با کد به‌روزرسانی‌شده در لیست ۱۷-۱۱، پیام‌ها با فواصل ۵۰۰ میلی‌ثانیه چاپ می‌شوند، به‌جای اینکه همه با عجله پس از ۲ ثانیه ظاهر شوند.</p>
<p>برنامه هنوز هم هرگز خارج نمی‌شود، به دلیل نحوه تعامل حلقه <code>while let</code> با <code>trpl::join</code>:</p>
<ul>
<li>Future بازگردانده‌شده از <code>trpl::join</code> تنها زمانی تکمیل می‌شود که <em>هر دو</em> future ارسال‌شده به آن تکمیل شده باشند.</li>
<li>Future مربوط به <code>tx</code> زمانی تکمیل می‌شود که پس از ارسال آخرین پیام در <code>vals</code> خوابیدن آن به پایان برسد.</li>
<li>Future مربوط به <code>rx</code> تا زمانی که حلقه <code>while let</code> به پایان نرسد تکمیل نخواهد شد.</li>
<li>حلقه <code>while let</code> تا زمانی که منتظر <code>rx.recv</code> باشد و مقدار <code>None</code> تولید شود، پایان نمی‌یابد.</li>
<li>منتظر شدن برای <code>rx.recv</code> تنها زمانی مقدار <code>None</code> بازمی‌گرداند که طرف دیگر کانال بسته شود.</li>
<li>کانال تنها در صورتی بسته می‌شود که <code>rx.close</code> را فراخوانی کنیم یا طرف فرستنده، یعنی <code>tx</code>، حذف شود.</li>
<li>ما هیچ‌جا <code>rx.close</code> را فراخوانی نمی‌کنیم، و <code>tx</code> تا زمانی که بیرونی‌ترین بلوک async ارسال‌شده به <code>trpl::run</code> به پایان نرسد، حذف نمی‌شود.</li>
<li>این بلوک نمی‌تواند به پایان برسد زیرا منتظر تکمیل شدن <code>trpl::join</code> است، که ما را دوباره به بالای این لیست بازمی‌گرداند.</li>
</ul>
<p>ما می‌توانیم به‌صورت دستی با فراخوانی <code>rx.close</code> کانال را ببندیم، اما این کار چندان منطقی نیست. توقف پس از پردازش تعداد دلخواهی از پیام‌ها باعث می‌شود برنامه خاموش شود، اما ممکن است پیام‌ها را از دست بدهیم. ما به راه دیگری نیاز داریم تا مطمئن شویم که <code>tx</code> <em>قبل از</em> پایان تابع حذف می‌شود.</p>
<p>در حال حاضر، بلوک async که پیام‌ها را ارسال می‌کند فقط <code>tx</code> را قرض می‌گیرد زیرا ارسال پیام نیاز به مالکیت ندارد، اما اگر می‌توانستیم <code>tx</code> را به داخل آن بلوک async منتقل کنیم، پس از پایان آن بلوک حذف می‌شد. در بخش فصل ۱۳ <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">گرفتن مراجع یا جابه‌جایی مالکیت</a><!-- ignore --> یاد گرفتید چگونه از کلمه کلیدی <code>move</code> با closures استفاده کنید، و همان‌طور که در بخش فصل ۱۶ <a href="ch16-01-threads.html#using-move-closures-with-threads">استفاده از closures <code>move</code> با Threadها</a><!-- ignore --> بحث شد، اغلب هنگام کار با Threadها نیاز داریم داده‌ها را به داخل closures منتقل کنیم. همان دینامیک‌های اساسی برای بلوک‌های async اعمال می‌شود، بنابراین کلمه کلیدی <code>move</code> با بلوک‌های async همان‌طور کار می‌کند که با closures کار می‌کند.</p>
<p>در لیست ۱۷-۱۲، بلوک مورد استفاده برای ارسال پیام‌ها را از <code>async</code> به <code>async move</code> تغییر می‌دهیم. وقتی <em>این</em> نسخه از کد را اجرا می‌کنیم، برنامه پس از ارسال و دریافت آخرین پیام به‌طور مرتب خاتمه می‌یابد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-12: نسخه بازبینی‌شده کد از لیست ۱۷-۱۱ که به‌درستی پس از اتمام خاتمه می‌یابد</figcaption>
</figure>
<p>این کانال async همچنین یک کانال چند-تولیدی (<em>multiple-producer</em>) است، بنابراین اگر بخواهیم پیام‌ها را از چندین future ارسال کنیم، می‌توانیم <code>clone</code> را روی <code>tx</code> فراخوانی کنیم، همان‌طور که در لیست ۱۷-۱۳ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-13: استفاده از تولیدکنندگان متعدد با بلوک‌های async</figcaption>
</figure>
<p>ابتدا، <code>tx</code> را clone کرده و <code>tx1</code> را خارج از بلوک async اول ایجاد می‌کنیم. <code>tx1</code> را همانند قبل با <code>tx</code> به داخل آن بلوک منتقل می‌کنیم. سپس، در ادامه، <code>tx</code> اصلی را به یک بلوک <em>جدید</em> async منتقل می‌کنیم، جایی که پیام‌های بیشتری با یک تأخیر کمی کندتر ارسال می‌کنیم. ما این بلوک async جدید را بعد از بلوک async برای دریافت پیام‌ها قرار می‌دهیم، اما می‌توانستیم به همان اندازه آن را قبل از آن قرار دهیم. نکته کلیدی ترتیب منتظر ماندن برای futures است، نه ترتیب ایجاد آن‌ها.</p>
<p>هر دو بلوک async برای ارسال پیام‌ها باید بلوک‌های <code>async move</code> باشند تا <code>tx</code> و <code>tx1</code> هر دو پس از پایان آن بلوک‌ها حذف شوند. در غیر این صورت، دوباره به همان حلقه بی‌نهایت اولیه بازمی‌گردیم. در نهایت، از <code>trpl::join</code> به <code>trpl::join3</code> تغییر می‌دهیم تا future اضافی را مدیریت کنیم.</p>
<p>اکنون تمام پیام‌های هر دو future ارسال را می‌بینیم، و چون futures ارسال از تأخیرهای کمی متفاوت پس از ارسال استفاده می‌کنند، پیام‌ها نیز در این فواصل مختلف دریافت می‌شوند.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>این یک شروع خوب است، اما ما را به تعداد محدودی از futures محدود می‌کند: دو عدد با <code>join</code> یا سه عدد با <code>join3</code>. بیایید ببینیم چگونه می‌توانیم با تعداد بیشتری از futures کار کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="کار-با-تعداد-دلخواهی-از-futures"><a class="header" href="#کار-با-تعداد-دلخواهی-از-futures">کار با تعداد دلخواهی از Futures</a></h2>
<p>وقتی در بخش قبلی از استفاده از دو future به سه future تغییر دادیم، مجبور شدیم به جای استفاده از <code>join</code> از <code>join3</code> استفاده کنیم. این مسئله آزاردهنده خواهد بود اگر هر بار که تعداد futuresی که می‌خواهیم join کنیم تغییر می‌کند، مجبور به فراخوانی یک تابع متفاوت باشیم. خوشبختانه، یک فرم ماکروی <code>join</code> داریم که می‌توانیم به آن تعداد دلخواهی از آرگومان‌ها را ارسال کنیم. این ماکرو همچنین خودش مدیریت انتظار برای futures را انجام می‌دهد. بنابراین، می‌توانیم کد لیست ۱۷-۱۳ را بازنویسی کنیم تا به جای <code>join3</code> از <code>join!</code> استفاده کنیم، همان‌طور که در لیست ۱۷-۱۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-14: استفاده از <code>join!</code> برای منتظر ماندن چندین آینده</figcaption>
</figure>
<p>این قطعاً نسبت به جابجایی بین <code>join</code>، <code>join3</code>، <code>join4</code> و موارد دیگر بهبود یافته است! با این حال، حتی این فرم ماکرو نیز فقط زمانی کار می‌کند که تعداد futures را از قبل بدانیم. اما در دنیای واقعی Rust، اضافه کردن futures به یک مجموعه و سپس انتظار برای کامل شدن برخی یا تمام آن‌ها یک الگوی رایج است.</p>
<p>برای بررسی تمام futures در یک مجموعه، باید روی <em>همه</em> آن‌ها حلقه بزنیم و آن‌ها را join کنیم. تابع <code>trpl::join_all</code> هر نوعی را که ویژگی <code>Iterator</code> را پیاده‌سازی می‌کند قبول می‌کند، که در فصل ۱۳ در بخش <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">ویژگی Iterator و متد <code>next</code></a><!-- ignore --> درباره آن یاد گرفتید، بنابراین به نظر می‌رسد دقیقاً همان چیزی است که نیاز داریم. بیایید سعی کنیم futures خود را در یک وکتور قرار دهیم و <code>join!</code> را با <code>join_all</code> جایگزین کنیم، همان‌طور که در لیست ۱۷-۱۵ نشان داده شده است.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-15: ذخیره آینده‌های ناشناس در یک بردار و فراخوانی <code>join_all</code></figcaption>
</figure>
<p>متأسفانه، این کد کامپایل نمی‌شود. در عوض، با این خطا مواجه می‌شویم:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a 
different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>این ممکن است شگفت‌آور باشد. بالاخره، هیچ‌یک از بلوک‌های async چیزی بازنمی‌گردانند، بنابراین هر کدام یک <code>Future&lt;Output = ()&gt;</code> تولید می‌کنند. اما به یاد داشته باشید که <code>Future</code> یک ویژگی (<em>trait</em>) است و کامپایلر برای هر بلوک async یک enum منحصربه‌فرد ایجاد می‌کند. نمی‌توانید دو struct مختلف را که دستی نوشته شده‌اند در یک <code>Vec</code> قرار دهید، و همین قانون برای enumهای مختلفی که توسط کامپایلر تولید می‌شوند اعمال می‌شود.</p>
<p>برای اینکه این کار انجام شود، باید از <em>اشیاء ویژگی</em> (<em>trait objects</em>) استفاده کنیم، همان‌طور که در <a href="ch12-03-improving-error-handling-and-modularity.html">“بازگرداندن خطاها از تابع run”</a><!-- ignore --> در فصل ۱۲ انجام دادیم. (ما اشیاء ویژگی را در فصل ۱۸ به‌طور مفصل پوشش خواهیم داد.) استفاده از اشیاء ویژگی به ما اجازه می‌دهد هر یک از futureهای ناشناس تولیدشده توسط این انواع را به‌عنوان یک نوع یکسان در نظر بگیریم، زیرا همه آن‌ها ویژگی <code>Future</code> را پیاده‌سازی می‌کنند.</p>
<blockquote>
<p>نکته: در بخش فصل ۸ <a href="ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-the-run-function">استفاده از یک Enum برای ذخیره مقادیر متعدد</a><!-- ignore -->، درباره یک روش دیگر برای شامل کردن چندین نوع در یک <code>Vec</code> صحبت کردیم: استفاده از یک enum برای نمایش هر نوعی که می‌تواند در وکتور ظاهر شود. اما نمی‌توانیم اینجا از آن استفاده کنیم. از یک طرف، هیچ راهی برای نام‌گذاری انواع مختلف نداریم، زیرا آن‌ها ناشناس هستند. از طرف دیگر، دلیلی که ما در وهله اول به دنبال یک وکتور و <code>join_all</code> رفتیم، این بود که بتوانیم با یک مجموعه پویا از futures کار کنیم، جایی که فقط به این اهمیت می‌دهیم که همه آن‌ها خروجی یکسانی دارند.</p>
</blockquote>
<p>ابتدا هر future درون <code>vec!</code> را در یک <code>Box::new</code> بسته‌بندی می‌کنیم، همان‌طور که در لیست ۱۷-۱۶ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-16: استفاده از <code>Box::new</code> برای تطبیق انواع futures در یک <code>Vec</code></figcaption>
</figure>
<p>متأسفانه، این کد هنوز هم کامپایل نمی‌شود. در واقع، همان خطای پایه‌ای که قبلاً دریافت کردیم، برای فراخوانی‌های دوم و سوم <code>Box::new</code> نیز رخ می‌دهد، به همراه خطاهای جدیدی که به ویژگی <code>Unpin</code> اشاره دارند. به زودی به خطاهای مرتبط با <code>Unpin</code> بازمی‌گردیم. ابتدا، بیایید خطاهای نوع در فراخوانی‌های <code>Box::new</code> را با مشخص کردن صریح نوع متغیر <code>futures</code> رفع کنیم (نگاه کنید به لیست ۱۷-۱۷).</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-17: برطرف کردن بقیه خطاهای ناسازگاری نوع با استفاده از اعلان صریح نوع</figcaption>
</figure>
<p>این type declaration کمی پیچیده است، بنابراین بیایید آن را مرحله به مرحله بررسی کنیم:</p>
<ol>
<li>نوع داخلی‌ترین، خود future است. به‌طور صریح اعلام می‌کنیم که خروجی future نوع واحد <code>()</code> است، با نوشتن <code>Future&lt;Output = ()&gt;</code>.</li>
<li>سپس ویژگی را با <code>dyn</code> علامت‌گذاری می‌کنیم تا به‌صورت دینامیک باشد.</li>
<li>کل مرجع ویژگی در یک <code>Box</code> بسته‌بندی می‌شود.</li>
<li>در نهایت، به‌طور صریح بیان می‌کنیم که <code>futures</code> یک <code>Vec</code> است که شامل این آیتم‌ها است.</li>
</ol>
<p>این تغییر تأثیر قابل‌توجهی داشت. اکنون وقتی کامپایلر را اجرا می‌کنیم، فقط خطاهایی که به <code>Unpin</code> اشاره دارند باقی می‌مانند. اگرچه سه خطا وجود دارد، اما محتوای آن‌ها بسیار مشابه است.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/main.rs:46:46
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
24  |         let rx_fut = async {
    |                      ----- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                     -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                     |
    |                                     arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:24:22: 24:27}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0308]: mismatched types
   --&gt; src/main.rs:46:64
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
30  |         let tx_fut = async move {
    |                      ---------- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                                       -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                                       |
    |                                                       arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:30:22: 30:32}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
   --&gt; src/main.rs:48:24
    |
48  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:9
   |
48 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>این پیام اطلاعات زیادی برای هضم کردن دارد، بنابراین بیایید آن را تجزیه کنیم. بخش اول پیام به ما می‌گوید که اولین بلوک async (<code>src/main.rs:8:23: 20:10</code>) ویژگی <code>Unpin</code> را پیاده‌سازی نمی‌کند و پیشنهاد می‌دهد از <code>pin!</code> یا <code>Box::pin</code> برای حل آن استفاده کنیم. در ادامه این فصل، جزئیات بیشتری درباره <code>Pin</code> و <code>Unpin</code> بررسی خواهیم کرد. با این حال، فعلاً می‌توانیم فقط از توصیه کامپایلر پیروی کنیم تا از این مشکل عبور کنیم. در لیست ۱۷-۱۸، ابتدا با به‌روزرسانی اعلان نوع برای <code>futures</code> شروع می‌کنیم، به طوری که هر <code>Box</code> درون یک <code>Pin</code> قرار بگیرد. دوم، از <code>Box::pin</code> برای pin کردن خود futures استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-18: استفاده از <code>Pin</code> و <code>Box::pin</code> برای برطرف کردن نوع <code>Vec</code></figcaption>
</figure>
<p>اگر این کد را کامپایل و اجرا کنیم، در نهایت خروجی موردنظر خود را دریافت می‌کنیم:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>آه!</p>
<p>اینجا چیزهای بیشتری برای بررسی وجود دارد. برای یک مورد، استفاده از <code>Pin&lt;Box&lt;T&gt;&gt;</code> یک مقدار کمی سربار اضافه می‌کند، زیرا این futures را با <code>Box</code> روی heap قرار می‌دهیم—و ما فقط این کار را برای هم‌تراز کردن انواع انجام می‌دهیم. بعد از همه این‌ها، ما <em>واقعاً</em> نیازی به تخصیص heap نداریم: این futures به این تابع خاص محدود هستند. همان‌طور که قبلاً ذکر شد، <code>Pin</code> خودش یک نوع wrapper است، بنابراین می‌توانیم از مزیت داشتن یک نوع واحد در <code>Vec</code> بهره‌مند شویم—دلیل اصلی که به دنبال <code>Box</code> رفتیم—بدون انجام تخصیص heap. می‌توانیم مستقیماً از <code>Pin</code> با هر future استفاده کنیم، با استفاده از ماکروی <code>std::pin::pin</code>.</p>
<p>با این حال، هنوز باید نوع مرجع pin شده را به‌صراحت مشخص کنیم؛ در غیر این صورت، Rust هنوز نمی‌داند که این‌ها را به‌عنوان اشیاء ویژگی دینامیک تفسیر کند، که دقیقاً همان چیزی است که ما در <code>Vec</code> به آن نیاز داریم. بنابراین، هر future را زمانی که تعریف می‌کنیم با <code>pin!</code> pin می‌کنیم، و <code>futures</code> را به‌عنوان یک <code>Vec</code> که شامل مراجع متغیر pin شده به نوع future دینامیک است تعریف می‌کنیم، همان‌طور که در لیست ۱۷-۱۹ نشان داده شده است.</p>
<p>با این حال، باید به‌صراحت نوع مرجع pinned را مشخص کنیم؛ در غیر این صورت، راست همچنان نمی‌داند که این‌ها را به‌عنوان شیءهای ویژگی دینامیک تفسیر کند، که همان چیزی است که برای قرار گرفتن در <code>Vec</code> نیاز داریم. بنابراین، هر آینده را وقتی تعریف می‌کنیم <code>pin!</code> می‌کنیم و <code>futures</code> را به‌عنوان یک <code>Vec</code> که شامل مراجع متغیر pinned به نوع ویژگی دینامیک <code>Future</code> است تعریف می‌کنیم، همانطور که در فهرست 17-19 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-19: استفاده مستقیم از <code>Pin</code> با ماکروی <code>pin!</code> برای اجتناب از تخصیص‌های غیرضروری heap</figcaption>
</figure>
<p>تا اینجا با نادیده گرفتن این واقعیت که ممکن است نوع‌های <code>Output</code> مختلفی داشته باشیم، پیش رفتیم. برای مثال، در فهرست 17-20، آینده ناشناس برای <code>a</code> ویژگی <code>Future&lt;Output = u32&gt;</code> را پیاده‌سازی می‌کند، آینده ناشناس برای <code>b</code> ویژگی <code>Future&lt;Output = &amp;str&gt;</code> را پیاده‌سازی می‌کند، و آینده ناشناس برای <code>c</code> ویژگی <code>Future&lt;Output = bool&gt;</code> را پیاده‌سازی می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-20: سه آینده با نوع‌های متفاوت</figcaption>
</figure>
<p>می‌توانیم از <code>trpl::join!</code> برای منتظر ماندن استفاده کنیم، زیرا به ما اجازه می‌دهد چندین نوع future را ارسال کنیم و یک tuple از آن انواع تولید می‌کند. اما <em>نمی‌توانیم</em> از <code>trpl::join_all</code> استفاده کنیم، زیرا این تابع نیاز دارد که همه futures ارسال‌شده نوع یکسانی داشته باشند. به یاد داشته باشید، همین خطا بود که ما را به این ماجراجویی با <code>Pin</code> کشاند!</p>
<p>این یک معاوضه بنیادی است: می‌توانیم با تعداد پویایی از futures با استفاده از <code>join_all</code> کار کنیم، به شرطی که همه آن‌ها نوع یکسانی داشته باشند، یا می‌توانیم با تعداد مشخصی از futures با توابع <code>join</code> یا ماکروی <code>join!</code> کار کنیم، حتی اگر آن‌ها انواع مختلفی داشته باشند. این همان شرایطی است که هنگام کار با هر نوع دیگری در Rust با آن مواجه می‌شویم. Futures خاص نیستند، حتی اگر سینتکس مناسبی برای کار با آن‌ها داشته باشیم، و این یک نکته مثبت است.</p>
<h3 id="racing-futures"><a class="header" href="#racing-futures">Racing Futures</a></h3>
<p>وقتی آینده‌ها را با خانواده توابع و ماکروهای <code>join</code> “منتظر می‌مانیم”، نیاز داریم <em>همه</em> آن‌ها تمام شوند قبل از اینکه به مرحله بعدی برویم. گاهی اوقات، اما، فقط نیاز داریم <em>یکی</em> از آینده‌ها از مجموعه‌ای تمام شود قبل از اینکه به مرحله بعدی برویم—کمی شبیه به مسابقه دادن یک آینده در برابر دیگری.</p>
<p>در لیست ۱۷-۲۱، ما دوباره از <code>trpl::race</code> استفاده می‌کنیم تا دو future، یعنی <code>slow</code> و <code>fast</code>، را در برابر یکدیگر اجرا کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-21: استفاده از <code>race</code> برای دریافت نتیجه اولین آینده‌ای که تمام می‌شود</figcaption>
</figure>
<p>هر future یک پیام هنگام شروع اجرا چاپ می‌کند، با فراخوانی و انتظار برای <code>sleep</code> به مدت مشخصی مکث می‌کند، و سپس یک پیام دیگر هنگام اتمام چاپ می‌کند. سپس، هر دو future یعنی <code>slow</code> و <code>fast</code> را به <code>trpl::race</code> ارسال می‌کنیم و منتظر می‌مانیم تا یکی از آن‌ها به پایان برسد. (نتیجه اینجا چندان شگفت‌آور نیست: <code>fast</code> برنده می‌شود.) برخلاف زمانی که در <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“اولین برنامه Async ما”</a><!-- ignore --> از <code>race</code> استفاده کردیم، اینجا به نمونه <code>Either</code> که بازمی‌گرداند توجه نمی‌کنیم، زیرا تمام رفتار جالب در بدنه بلوک‌های async رخ می‌دهد.</p>
<p>توجه کنید که اگر ترتیب آرگومان‌ها به <code>race</code> را جابه‌جا کنید، ترتیب پیام‌های “started” تغییر می‌کند، حتی اگر future <code>fast</code> همیشه زودتر به پایان برسد. دلیل این است که پیاده‌سازی این تابع خاص <code>race</code> منصفانه نیست. این تابع همیشه futures ارسال‌شده را به ترتیب آرگومان‌ها اجرا می‌کند. سایر پیاده‌سازی‌ها <em>منصفانه</em> هستند و به صورت تصادفی انتخاب می‌کنند که کدام future را ابتدا poll کنند. با این حال، صرف‌نظر از اینکه پیاده‌سازی <code>race</code> ما منصفانه باشد یا نه، <em>یکی</em> از futures تا اولین <code>await</code> در بدنه‌اش اجرا می‌شود قبل از اینکه task دیگری بتواند شروع شود.</p>
<p>به یاد بیاورید از <a href="ch17-01-futures-and-syntax.html#our-first-async-program">اولین برنامه Async ما</a><!-- ignore --> که در هر نقطه <code>await</code>، Rust به runtime اجازه می‌دهد تا task را متوقف کند و به task دیگری سوئیچ کند اگر future در حال انتظار آماده نباشد. عکس این موضوع هم صادق است: Rust فقط بلوک‌های async را متوقف می‌کند و کنترل را به runtime بازمی‌گرداند در یک نقطه <code>await</code>.</p>
<p>این بدان معناست که اگر در یک بلوک async بدون نقطه <code>await</code> مقدار زیادی کار انجام دهید، آن future دیگر futures را از پیشرفت باز می‌دارد. گاهی اوقات ممکن است به این موضوع اشاره شود که یک future <em>دیگر futures را گرسنه می‌کند</em>. در برخی موارد، این ممکن است مشکل بزرگی نباشد. با این حال، اگر در حال انجام برخی تنظیمات پرهزینه یا کار طولانی‌مدت هستید، یا اگر futureای دارید که به طور نامحدود یک کار خاص را انجام می‌دهد، باید به این فکر کنید که چه زمانی و کجا کنترل را به runtime بازگردانید.</p>
<p>به همان اندازه، اگر عملیات‌های مسدودکننده طولانی‌مدت دارید، async می‌تواند ابزاری مفید برای ارائه راه‌هایی باشد که بخش‌های مختلف برنامه بتوانند با یکدیگر تعامل داشته باشند.</p>
<p>اما در این موارد <em>چگونه</em> کنترل را به runtime بازمی‌گردانید؟</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="yielding-control-to-the-runtime"><a class="header" href="#yielding-control-to-the-runtime">Yielding Control to the Runtime</a></h3>
<p>بیایید یک عملیات طولانی‌مدت را شبیه‌سازی کنیم. لیست ۱۷-۲۲ یک تابع به نام <code>slow</code> معرفی می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
<figcaption>Listing 17-22: استفاده از <code>thread::sleep</code> برای شبیه‌سازی عملیات کند</figcaption>
</figure>
<p>این کد از <code>std::thread::sleep</code> به جای <code>trpl::sleep</code> استفاده می‌کند، به طوری که فراخوانی <code>slow</code>، Thread فعلی را برای مدت مشخصی از میلی‌ثانیه‌ها مسدود می‌کند. می‌توانیم از <code>slow</code> به عنوان جایگزینی برای عملیات‌های واقعی که هم طولانی‌مدت هستند و هم مسدودکننده، استفاده کنیم.</p>
<p>در لیست ۱۷-۲۳، از <code>slow</code> برای شبیه‌سازی انجام این نوع کارهای CPU-bound در یک جفت future استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-23: استفاده از <code>thread::sleep</code> برای شبیه‌سازی عملیات کند</figcaption>
</figure>
<p>برای شروع، هر future فقط <em>پس از</em> انجام یک سری عملیات کند، کنترل را به runtime بازمی‌گرداند. اگر این کد را اجرا کنید، این خروجی را مشاهده خواهید کرد:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>همان‌طور که در مثال قبلی دیدیم، <code>race</code> همچنان به محض اینکه <code>a</code> تمام شود، کار را تمام می‌کند. اما بین دو future هیچ تداخل یا جابه‌جایی وجود ندارد. future <code>a</code> تمام کار خود را انجام می‌دهد تا زمانی که فراخوانی <code>trpl::sleep</code> منتظر بماند، سپس future <code>b</code> تمام کار خود را انجام می‌دهد تا زمانی که فراخوانی <code>trpl::sleep</code> خودش منتظر بماند، و در نهایت future <code>a</code> کامل می‌شود. برای اینکه هر دو future بتوانند بین taskهای کند خود پیشرفت کنند، به نقاط <code>await</code> نیاز داریم تا بتوانیم کنترل را به runtime بازگردانیم. این به این معناست که به چیزی نیاز داریم که بتوانیم برای آن منتظر بمانیم!</p>
<p>هم‌اکنون می‌توانیم این نوع انتقال کنترل را در لیست ۱۷-۲۳ مشاهده کنیم: اگر <code>trpl::sleep</code> در انتهای future <code>a</code> را حذف کنیم، این future بدون اجرای future <code>b</code> به طور کامل به پایان می‌رسد. بیایید از تابع <code>sleep</code> به‌عنوان نقطه شروعی برای اجازه دادن به عملیات‌ها برای جابه‌جا شدن و پیشرفت استفاده کنیم، همان‌طور که در لیست ۱۷-۲۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-24: استفاده از <code>sleep</code> برای اجازه دادن به عملیات‌ها برای پیشرفت متناوب</figcaption>
</figure>
<p>در فهرست 17-24، فراخوانی‌های <code>trpl::sleep</code> با نقاط انتظار بین هر فراخوانی به <code>slow</code> اضافه می‌کنیم. اکنون کار دو آینده درهم‌تنیده شده است:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>future <code>a</code> هنوز برای مدتی اجرا می‌شود قبل از اینکه کنترل را به <code>b</code> منتقل کند، زیرا ابتدا <code>slow</code> را فراخوانی می‌کند قبل از اینکه <code>trpl::sleep</code> را فراخوانی کند. اما پس از آن، futures هر بار که یکی از آن‌ها به یک نقطه <code>await</code> می‌رسد، به صورت متناوب جابه‌جا می‌شوند. در این مورد، ما این کار را پس از هر فراخوانی به <code>slow</code> انجام داده‌ایم، اما می‌توانستیم کار را به هر شکلی که برای ما منطقی‌تر است تقسیم کنیم.</p>
<p>با این حال، واقعاً نمی‌خواهیم اینجا <em>sleep</em> کنیم؛ می‌خواهیم به سریع‌ترین شکلی که می‌توانیم پیشرفت کنیم. فقط نیاز داریم کنترل را به runtime بازگردانیم. می‌توانیم این کار را به‌طور مستقیم با استفاده از تابع <code>yield_now</code> انجام دهیم. در فهرست 17-25، تمام این فراخوانی‌های <code>sleep</code> را با <code>yield_now</code> جایگزین می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-25: استفاده از <code>yield_now</code> برای اجازه دادن به عملیات‌ها برای پیشرفت متناوب</figcaption>
</figure>
<p>این کد هم از نظر بیان هدف واقعی واضح‌تر است و هم می‌تواند به طور قابل‌توجهی سریع‌تر از استفاده از <code>sleep</code> باشد، زیرا تایمرهایی مانند آنچه که توسط <code>sleep</code> استفاده می‌شود اغلب محدودیت‌هایی در دقت خود دارند. نسخه‌ای از <code>sleep</code> که ما استفاده می‌کنیم، برای مثال، همیشه حداقل به مدت یک میلی‌ثانیه می‌خوابد، حتی اگر یک <code>Duration</code> یک نانوثانیه‌ای به آن بدهیم. دوباره، کامپیوترهای مدرن <em>سریع</em> هستند: آن‌ها می‌توانند در یک میلی‌ثانیه کارهای زیادی انجام دهند!</p>
<p>می‌توانید خودتان این را ببینید با راه‌اندازی یک بنچمارک کوچک، مانند آنچه در لیست ۱۷-۲۶ نشان داده شده است. (این روش به‌ویژه دقیقی برای انجام تست عملکرد نیست، اما برای نشان دادن تفاوت در اینجا کافی است.)</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-26: مقایسه عملکرد <code>sleep</code> و <code>yield_now</code></figcaption>
</figure>
<p>در اینجا، تمام چاپ وضعیت را کنار می‌گذاریم، یک <code>Duration</code> یک نانوثانیه‌ای به <code>trpl::sleep</code> می‌دهیم و اجازه می‌دهیم هر future به‌صورت مستقل اجرا شود، بدون هیچ جابه‌جایی بین futures. سپس ۱,۰۰۰ بار این عملیات را تکرار می‌کنیم و می‌بینیم که futureی که از <code>trpl::sleep</code> استفاده می‌کند در مقایسه با futureی که از <code>trpl::yield_now</code> استفاده می‌کند چقدر زمان می‌برد.</p>
<p>نسخه‌ای که از <code>yield_now</code> استفاده می‌کند، <em>بسیار</em> سریع‌تر است!</p>
<p>این بدان معناست که async حتی برای وظایف وابسته به CPU می‌تواند مفید باشد، بسته به اینکه برنامه شما چه کار دیگری انجام می‌دهد، زیرا ابزاری مفید برای ساختاردهی روابط بین بخش‌های مختلف برنامه فراهم می‌کند. این نوعی از <em>چندوظیفه‌گی مشارکتی</em> است، جایی که هر آینده قدرت تصمیم‌گیری درباره زمان واگذاری کنترل از طریق نقاط انتظار را دارد. بنابراین، هر آینده نیز مسئولیت دارد که از مسدود کردن بیش از حد طولانی اجتناب کند. در برخی سیستم‌عامل‌های مبتنی بر راست برای سیستم‌های تعبیه‌شده، این <em>تنها</em> نوع چندوظیفه‌گی است!</p>
<p>در کد واقعی، معمولاً فراخوانی توابع را با نقاط <code>await</code> در هر خط متناوب نمی‌کنید، البته. در حالی که واگذاری کنترل به این روش نسبتاً کم‌هزینه است، اما رایگان نیست. در بسیاری از موارد، تلاش برای تقسیم یک task که CPU-bound است ممکن است آن را به‌طور قابل توجهی کندتر کند، بنابراین گاهی اوقات برای <em>عملکرد کلی</em> بهتر است که اجازه دهید یک عملیات به‌طور مختصر مسدود شود. همیشه اندازه‌گیری کنید تا ببینید تنگناهای عملکرد واقعی کد شما کجا هستند. اما، این دینامیک اساسی را باید در ذهن داشته باشید، به‌ویژه اگر <em>واقعاً</em> شاهد انجام مقدار زیادی کار به‌صورت ترتیبی باشید، در حالی که انتظار داشتید به‌طور همزمان انجام شود!</p>
<h3 id="ساخت-انتزاعات-async-خودمان"><a class="header" href="#ساخت-انتزاعات-async-خودمان">ساخت انتزاعات Async خودمان</a></h3>
<p>ما همچنین می‌توانیم futures را با هم ترکیب کنیم تا الگوهای جدیدی ایجاد کنیم. برای مثال، می‌توانیم یک تابع <code>timeout</code> با استفاده از بلوک‌های سازنده async که از قبل داریم، بسازیم. هنگامی که کارمان تمام شد، نتیجه یک بلوک سازنده دیگر خواهد بود که می‌توانیم برای ایجاد انتزاعات async بیشتری از آن استفاده کنیم.</p>
<p>فهرست 17-27 نشان می‌دهد که چگونه انتظار داریم این <code>timeout</code> با یک آینده کند کار کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-27: تعریف نحوه کار <code>timeout</code> با یک آینده کند</figcaption>
</figure>
<p>بیایید این را پیاده‌سازی کنیم! برای شروع، بیایید به API مورد نیاز برای <code>timeout</code> فکر کنیم:</p>
<ul>
<li>باید خودش یک تابع async باشد تا بتوانیم منتظر آن بمانیم.</li>
<li>پارامتر اول آن باید یک آینده برای اجرا باشد. می‌توانیم آن را عمومی کنیم تا بتواند با هر آینده‌ای کار کند.</li>
<li>پارامتر دوم آن مدت‌زمان حداکثری برای انتظار خواهد بود. اگر از یک <code>Duration</code> استفاده کنیم، این کار ارسال آن به <code>trpl::sleep</code> را آسان می‌کند.</li>
<li>باید یک <code>Result</code> بازگرداند. اگر آینده با موفقیت کامل شود، <code>Result</code> شامل <code>Ok</code> با مقدار تولیدشده توسط آینده خواهد بود. اگر زمان محدودیت زودتر سپری شود، <code>Result</code> شامل <code>Err</code> با مدت‌زمانی که زمان محدودیت برای آن منتظر ماند خواهد بود.</li>
</ul>
<p>فهرست 17-28 این اعلان را نشان می‌دهد.</p>
<!-- This is not tested because it intentionally does not compile. -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
<figcaption>Listing 17-28: تعریف امضای <code>timeout</code></figcaption>
</figure>
<p>این اهداف ما برای نوع‌ها را برآورده می‌کند. حالا بیایید به <em>رفتاری</em> که نیاز داریم فکر کنیم: می‌خواهیم آینده ارسال‌شده به آن را در برابر مدت‌زمان محدودیت مسابقه دهیم. می‌توانیم از <code>trpl::sleep</code> برای ساختن یک آینده تایمر از مدت‌زمان استفاده کنیم و از <code>trpl::race</code> برای اجرای آن تایمر با آینده‌ای که کاربر ارسال می‌کند استفاده کنیم.</p>
<p>ما همچنین می‌دانیم که <code>race</code> منصفانه نیست و آرگومان‌ها را به ترتیب ارسال‌شده poll می‌کند. بنابراین، ابتدا <code>future_to_try</code> را به <code>race</code> ارسال می‌کنیم تا حتی اگر <code>max_time</code> مدت زمان بسیار کوتاهی باشد، فرصتی برای تکمیل شدن داشته باشد. اگر <code>future_to_try</code> زودتر تمام شود، <code>race</code> مقدار <code>Left</code> را با خروجی <code>future_to_try</code> بازمی‌گرداند. اگر <code>timer</code> زودتر تمام شود، <code>race</code> مقدار <code>Right</code> را با خروجی <code>()</code> تایمر بازمی‌گرداند.</p>
<p>در لیست ۱۷-۲۹، نتیجه انتظار برای <code>trpl::race</code> را match می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-29: تعریف <code>timeout</code> با استفاده از <code>race</code> و <code>sleep</code></figcaption>
</figure>
<p>اگر <code>future_to_try</code> موفق شود و مقدار <code>Left(output)</code> دریافت کنیم، مقدار <code>Ok(output)</code> را بازمی‌گردانیم. اگر به جای آن تایمر خواب منقضی شود و مقدار <code>Right(())</code> دریافت کنیم، <code>()</code> را با <code>_</code> نادیده گرفته و به جای آن مقدار <code>Err(max_time)</code> را بازمی‌گردانیم.</p>
<p>با این کار، یک <code>timeout</code> عملیاتی داریم که از دو ابزار کمکی async دیگر ساخته شده است. اگر کد خود را اجرا کنیم، پس از انقضای timeout، حالت شکست را چاپ خواهد کرد:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>از آنجا که futures می‌توانند با دیگر futures ترکیب شوند، می‌توانید ابزارهای بسیار قدرتمندی با استفاده از بلوک‌های سازنده کوچک‌تر async بسازید. برای مثال، می‌توانید از همین رویکرد برای ترکیب timeoutها با retries استفاده کنید و به نوبه خود از آن‌ها با عملیاتی مانند تماس‌های شبکه (یکی از مثال‌های ابتدای فصل) استفاده کنید.</p>
<p>در عمل، معمولاً مستقیماً با <code>async</code> و <code>await</code> کار می‌کنید و به طور ثانویه از توابع و ماکروهایی مانند <code>join</code>، <code>join_all</code>، <code>race</code> و غیره استفاده می‌کنید. فقط گاهی نیاز خواهید داشت از <code>pin</code> برای استفاده از futures با آن APIها استفاده کنید.</p>
<p>اکنون روش‌های متعددی برای کار با چندین future به طور همزمان دیده‌ایم. در ادامه، بررسی خواهیم کرد که چگونه می‌توانیم با چندین future به صورت متوالی در طول زمان با <em>streams</em> کار کنیم. با این حال، در ابتدا ممکن است بخواهید به چند نکته دیگر توجه کنید:</p>
<ul>
<li>
<p>ما از یک <code>Vec</code> همراه با <code>join_all</code> استفاده کردیم تا منتظر بمانیم تمام futures در یک گروه به پایان برسند. چگونه می‌توانید از یک <code>Vec</code> برای پردازش یک گروه از futures به صورت متوالی استفاده کنید؟ معاوضه‌های انجام این کار چیست؟</p>
</li>
<li>
<p>به نوع <code>futures::stream::FuturesUnordered</code> از crate <code>futures</code> نگاهی بیندازید. استفاده از آن چگونه می‌تواند با استفاده از یک <code>Vec</code> متفاوت باشد؟ (نگران این نباشید که این نوع از بخش <code>stream</code> crate آمده است؛ با هر مجموعه‌ای از futures به خوبی کار می‌کند.)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="streamها-futures-به-صورت-متوالی"><a class="header" href="#streamها-futures-به-صورت-متوالی">Stream‌ها: Futures به صورت متوالی</a></h2>
<p>تا اینجا در این فصل، بیشتر به آینده‌های فردی (<em>individual futures</em>) پایبند بوده‌ایم. یک استثنای بزرگ استفاده از کانال async بود. به یاد بیاورید چگونه در ابتدای این فصل در بخش <a href="ch17-02-concurrency-with-async.html#message-passing">“ارسال پیام”</a><!-- ignore --> از گیرنده کانال async استفاده کردیم. متد async به نام <code>recv</code> یک دنباله از آیتم‌ها را در طول زمان تولید می‌کند. این یک نمونه از یک الگوی کلی‌تر به نام <em>stream</em> است.</p>
<p>ما در فصل ۱۳ یک دنباله از آیتم‌ها را دیدیم، زمانی که ویژگی <code>Iterator</code> را در بخش <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">ویژگی Iterator و متد <code>next</code></a><!-- ignore --> بررسی کردیم، اما بین iteratorها و گیرنده کانال async دو تفاوت وجود دارد. تفاوت اول در زمان است: iteratorها همزمان (<em>synchronous</em>) هستند، در حالی که گیرنده کانال async است. تفاوت دوم در API است. هنگام کار مستقیم با <code>Iterator</code>، ما متد همزمان <code>next</code> را فراخوانی می‌کنیم. به طور خاص، با stream <code>trpl::Receiver</code>، به جای آن، یک متد async به نام <code>recv</code> را فراخوانی کردیم. در غیر این صورت، این APIها احساس بسیار مشابهی دارند و این شباهت تصادفی نیست. یک stream مانند یک شکل ناهمزمان از iteration است. در حالی که <code>trpl::Receiver</code> به طور خاص منتظر دریافت پیام‌ها است، API عمومی stream بسیار گسترده‌تر است: این API آیتم بعدی را همان‌طور که <code>Iterator</code> انجام می‌دهد ارائه می‌دهد، اما به صورت ناهمزمان.</p>
<p>شباهت بین iteratorها و stream‌ها در Rust به این معناست که ما در واقع می‌توانیم از هر iterator یک stream ایجاد کنیم. مانند یک iterator، می‌توانیم با فراخوانی متد <code>next</code> یک stream کار کنیم و سپس خروجی را انتظار بکشیم، همان‌طور که در لیست ۱۷-۳۰ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-30: ایجاد یک stream از یک iterator و چاپ مقادیر آن</figcaption>
</figure>
<p>ما با یک آرایه از اعداد شروع می‌کنیم، آن را به یک iterator تبدیل کرده و سپس متد <code>map</code> را فراخوانی می‌کنیم تا تمام مقادیر را دو برابر کنیم. سپس با استفاده از تابع <code>trpl::stream_from_iter</code>، این iterator را به یک stream تبدیل می‌کنیم. در ادامه، با استفاده از حلقه <code>while let</code>، بر روی آیتم‌های موجود در stream که به مرور می‌رسند، حلقه می‌زنیم.</p>
<p>متأسفانه، وقتی سعی می‌کنیم این کد را اجرا کنیم، کامپایل نمی‌شود و به جای آن گزارش می‌دهد که متد <code>next</code> در دسترس نیست:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>همان‌طور که این خروجی توضیح می‌دهد، دلیل خطای کامپایلر این است که برای استفاده از متد <code>next</code> باید ویژگی مناسب در دامنه باشد. با توجه به بحث‌هایی که تاکنون داشته‌ایم، ممکن است منطقی باشد که انتظار داشته باشید این ویژگی <code>Stream</code> باشد، اما در واقع <code>StreamExt</code> است. <code>Ext</code> که مخفف <em>extension</em> است، یک الگوی رایج در جامعه Rust برای گسترش یک ویژگی با ویژگی دیگر است.</p>
<p>ما در انتهای این فصل ویژگی‌های <code>Stream</code> و <code>StreamExt</code> را با جزئیات بیشتری توضیح خواهیم داد، اما فعلاً تنها چیزی که باید بدانید این است که ویژگی <code>Stream</code> یک رابط سطح پایین تعریف می‌کند که به طور مؤثری ویژگی‌های <code>Iterator</code> و <code>Future</code> را ترکیب می‌کند. <code>StreamExt</code> مجموعه‌ای از APIهای سطح بالاتر را روی <code>Stream</code> ارائه می‌دهد، از جمله متد <code>next</code> و همچنین متدهای کاربردی دیگر مشابه آنچه ویژگی <code>Iterator</code> ارائه می‌دهد. <code>Stream</code> و <code>StreamExt</code> هنوز بخشی از کتابخانه استاندارد Rust نیستند، اما بیشتر crateهای اکوسیستم از همین تعریف استفاده می‌کنند.</p>
<p>برای رفع خطای کامپایل، باید یک دستور <code>use</code> برای <code>trpl::StreamExt</code> اضافه کنیم، همان‌طور که در فهرست 17-31 آمده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-31: استفاده موفق از یک iterator به‌عنوان پایه‌ای برای یک stream</figcaption>
</figure>
<p>با قرار دادن همه این قطعات در کنار هم، این کد به همان روشی که می‌خواهیم کار می‌کند! مهم‌تر از همه، اکنون که <code>StreamExt</code> در دامنه داریم، می‌توانیم از تمام متدهای کاربردی آن استفاده کنیم، درست مانند iteratorها. برای مثال، در فهرست 17-32، از متد <code>filter</code> برای فیلتر کردن همه چیز به جز مضرب‌های سه و پنج استفاده می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-32: فیلتر کردن یک <code>Stream</code> با استفاده از متد <code>StreamExt::filter</code></figcaption>
</figure>
<p>البته این خیلی جالب نیست، چون می‌توانستیم همین کار را با iteratorهای معمولی و بدون هیچ async انجام دهیم. بیایید ببینیم چه کاری می‌توانیم انجام دهیم که <em>منحصربه‌فرد</em> برای stream‌ها باشد.</p>
<h3 id="ترکیب-streamها"><a class="header" href="#ترکیب-streamها">ترکیب Stream‌ها</a></h3>
<p>بسیاری از مفاهیم به طور طبیعی به‌عنوان stream‌ها نمایش داده می‌شوند: آیتم‌هایی که در یک صف در دسترس می‌شوند، بخش‌هایی از داده که به صورت تدریجی از سیستم فایل خوانده می‌شوند وقتی مجموعه داده کامل برای حافظه کامپیوتر بیش از حد بزرگ است، یا داده‌هایی که به مرور زمان از طریق شبکه می‌رسند. چون stream‌ها نیز futures هستند، می‌توانیم از آن‌ها با هر نوع دیگر future استفاده کنیم و آن‌ها را به روش‌های جالبی ترکیب کنیم. برای مثال، می‌توانیم رویدادها را به صورت دسته‌ای جمع کنیم تا از ایجاد تعداد زیادی فراخوانی شبکه جلوگیری کنیم، تایم‌اوت‌هایی روی دنباله‌ای از عملیات‌های طولانی تنظیم کنیم، یا رویدادهای رابط کاربری را کنترل کنیم تا از انجام کارهای غیرضروری اجتناب کنیم.</p>
<p>بیایید با ساخت یک stream کوچک از پیام‌ها شروع کنیم که به‌عنوان یک جایگزین برای یک stream از داده‌هایی که ممکن است از یک WebSocket یا یک پروتکل ارتباطی بلادرنگ دیگر ببینیم، همان‌طور که در لیست ۱۷-۳۳ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption>Listing 17-33: استفاده از گیرنده <code>rx</code> به‌عنوان یک <code>ReceiverStream</code></figcaption>
</figure>
<p>ابتدا یک تابع به نام <code>get_messages</code> ایجاد می‌کنیم که <code>impl Stream&lt;Item = String&gt;</code> را بازمی‌گرداند. برای پیاده‌سازی آن، یک کانال async ایجاد می‌کنیم، بر روی ۱۰ حرف اول الفبای انگلیسی حلقه می‌زنیم، و آن‌ها را از طریق کانال ارسال می‌کنیم.</p>
<p>همچنین از یک نوع جدید به نام <code>ReceiverStream</code> استفاده می‌کنیم، که <code>rx</code> گیرنده از <code>trpl::channel</code> را به یک <code>Stream</code> با متد <code>next</code> تبدیل می‌کند. دوباره در <code>main</code>، از یک حلقه <code>while let</code> برای چاپ تمام پیام‌ها از stream استفاده می‌کنیم.</p>
<p>وقتی این کد را اجرا می‌کنیم، دقیقاً نتایجی را که انتظار داریم دریافت می‌کنیم:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>دوباره، می‌توانستیم این کار را با API معمولی <code>Receiver</code> یا حتی API معمولی <code>Iterator</code> انجام دهیم، اما بیایید ویژگی‌ای اضافه کنیم که نیاز به streams داشته باشد: اضافه کردن یک تایم‌اوت که برای هر آیتم در stream اعمال شود، و یک تأخیر روی آیتم‌هایی که ارسال می‌کنیم، همان‌طور که در لیست ۱۷-۳۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-34: استفاده از متد <code>StreamExt::timeout</code> برای تعیین یک محدودیت زمانی برای آیتم‌های موجود در یک stream</figcaption>
</figure>
<p>ابتدا یک تایم‌اوت به stream با استفاده از متد <code>timeout</code> اضافه می‌کنیم، که از ویژگی <code>StreamExt</code> می‌آید. سپس بدنه حلقه <code>while let</code> را به‌روزرسانی می‌کنیم، زیرا اکنون stream یک <code>Result</code> بازمی‌گرداند. حالت <code>Ok</code> نشان‌دهنده این است که یک پیام به‌موقع رسیده است؛ حالت <code>Err</code> نشان می‌دهد که تایم‌اوت قبل از رسیدن هر پیامی منقضی شده است. روی این نتیجه یک <code>match</code> انجام می‌دهیم و یا پیام را وقتی با موفقیت دریافت می‌کنیم چاپ می‌کنیم، یا اخطاری درباره تایم‌اوت چاپ می‌کنیم. در نهایت، توجه کنید که پس از اعمال تایم‌اوت به پیام‌ها، آن‌ها را pin می‌کنیم، زیرا ابزار تایم‌اوت یک stream تولید می‌کند که باید pin شود تا بتوان آن را poll کرد.</p>
<p>با این حال، چون بین پیام‌ها تأخیری وجود ندارد، این تایم‌اوت رفتار برنامه را تغییر نمی‌دهد. بیایید یک تأخیر متغیر به پیام‌هایی که ارسال می‌کنیم اضافه کنیم، همان‌طور که در لیست ۱۷-۳۵ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption>Listing 17-35: ارسال پیام‌ها از طریق <code>tx</code> با یک تأخیر async بدون تبدیل <code>get_messages</code> به یک تابع async</figcaption>
</figure>
<p>برای خوابیدن بین پیام‌ها در تابع <code>get_messages</code> بدون مسدود کردن، باید از async استفاده کنیم. با این حال، نمی‌توانیم خود <code>get_messages</code> را به یک تابع async تبدیل کنیم، زیرا در این صورت یک <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> به جای یک <code>Stream&lt;Item = String&gt;</code> بازمی‌گرداند. کاربر باید خود <code>get_messages</code> را منتظر بماند تا به stream دسترسی پیدا کند. اما به یاد داشته باشید: هر چیزی در یک آینده مشخص به‌صورت خطی اتفاق می‌افتد؛ همزمانی <em>بین</em> آینده‌ها اتفاق می‌افتد. انتظار برای <code>get_messages</code> نیاز دارد که تمام پیام‌ها را ارسال کند، از جمله خوابیدن بین ارسال هر پیام، قبل از بازگرداندن stream گیرنده. در نتیجه، زمان محدود بی‌فایده می‌شود. هیچ تأخیری در خود stream وجود نخواهد داشت: تمام تأخیرها قبل از در دسترس قرار گرفتن stream اتفاق می‌افتد.</p>
<p>در عوض، <code>get_messages</code> را به‌عنوان یک تابع معمولی که یک stream بازمی‌گرداند باقی می‌گذاریم و یک تسک برای مدیریت فراخوانی‌های async <code>sleep</code> ایجاد می‌کنیم.</p>
<blockquote>
<p>نکته: فراخوانی <code>spawn_task</code> به این روش کار می‌کند زیرا ما از قبل runtime خود را تنظیم کرده‌ایم. فراخوانی این پیاده‌سازی خاص از <code>spawn_task</code> <em>بدون</em> تنظیم اولیه یک runtime باعث panic می‌شود. پیاده‌سازی‌های دیگر معاملات متفاوتی انتخاب می‌کنند: ممکن است یک runtime جدید ایجاد کنند و بنابراین از panic اجتناب کنند، اما با کمی سربار اضافی مواجه شوند، یا به سادگی راهی مستقل برای ایجاد تسک‌ها بدون ارجاع به یک runtime ارائه ندهند. باید مطمئن شوید که می‌دانید runtime شما چه معامله‌ای انتخاب کرده است و کد خود را بر این اساس بنویسید!</p>
</blockquote>
<p>اکنون کد ما نتیجه بسیار جالب‌تری دارد! بین هر جفت پیام، یک خطا گزارش می‌شود: <code>Problem: Elapsed(())</code>.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-35
cargo run
copy only the program output, *not* the compiler output
-->
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>تایم‌اوت از رسیدن پیام‌ها در نهایت جلوگیری نمی‌کند. ما همچنان تمام پیام‌های اصلی را دریافت می‌کنیم، زیرا کانال ما <em>بدون محدودیت</em> است: می‌تواند به اندازه‌ای که در حافظه جا شود پیام‌ها را نگه دارد. اگر پیام قبل از تایم‌اوت نرسد، handler stream ما آن را مدیریت می‌کند، اما وقتی دوباره stream را poll کند، ممکن است پیام اکنون رسیده باشد.</p>
<p>اگر به رفتار متفاوتی نیاز دارید، می‌توانید از انواع دیگر کانال‌ها یا به طور کلی انواع دیگر streamها استفاده کنید. بیایید یکی از این موارد را در عمل ببینیم، با ترکیب یک stream از فواصل زمانی با این stream از پیام‌ها.</p>
<h3 id="ترکیب-streamها-1"><a class="header" href="#ترکیب-streamها-1">ترکیب Streamها</a></h3>
<p>ابتدا، یک stream دیگر ایجاد می‌کنیم که اگر به طور مستقیم اجرا شود، هر میلی‌ثانیه یک آیتم ارسال می‌کند. برای سادگی، می‌توانیم از تابع <code>sleep</code> برای ارسال یک پیام با تأخیر استفاده کنیم و آن را با همان روشی که در <code>get_messages</code> استفاده کردیم—ایجاد یک stream از یک کانال—ترکیب کنیم. تفاوت این است که این بار، می‌خواهیم تعداد فواصل زمانی که گذشته‌اند را بازگردانیم، بنابراین نوع بازگشتی <code>impl Stream&lt;Item = u32&gt;</code> خواهد بود، و می‌توانیم تابع را <code>get_intervals</code> بنامیم (نگاه کنید به لیست ۱۷-۳۶).</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption>Listing 17-36: ایجاد یک stream با یک شمارنده که هر میلی‌ثانیه یک بار ارسال می‌شود</figcaption>
</figure>
<p>ابتدا یک متغیر <code>count</code> را درون task تعریف می‌کنیم. (می‌توانستیم آن را خارج از task نیز تعریف کنیم، اما محدود کردن دامنه هر متغیر داده‌شده واضح‌تر است.) سپس یک حلقه بی‌نهایت ایجاد می‌کنیم. در هر تکرار حلقه، به صورت ناهمزمان به مدت یک میلی‌ثانیه می‌خوابد، مقدار <code>count</code> را افزایش می‌دهد و سپس آن را از طریق کانال ارسال می‌کند. از آنجا که همه این‌ها درون taskی که توسط <code>spawn_task</code> ایجاد شده است قرار دارد، همه آن—از جمله حلقه بی‌نهایت—همراه با runtime پاک‌سازی می‌شود.</p>
<p>این نوع حلقه بی‌نهایت، که تنها زمانی به پایان می‌رسد که کل runtime از بین برود، در async Rust نسبتاً رایج است: بسیاری از برنامه‌ها نیاز دارند که به طور نامحدود اجرا شوند. با async، این کار چیزی دیگر را مسدود نمی‌کند، تا زمانی که حداقل یک نقطه انتظار (<em>await point</em>) در هر تکرار از حلقه وجود داشته باشد.</p>
<p>حالا، درون بلوک async تابع اصلی ما، می‌توانیم تلاش کنیم که streamهای <code>messages</code> و <code>intervals</code> را با هم ترکیب کنیم، همان‌طور که در لیست ۱۷-۳۷ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-37: تلاش برای ترکیب streamهای <code>messages</code> و <code>intervals</code></figcaption>
</figure>
<p>ابتدا <code>get_intervals</code> را فراخوانی می‌کنیم. سپس streamهای <code>messages</code> و <code>intervals</code> را با استفاده از متد <code>merge</code> ترکیب می‌کنیم. این متد چندین stream را به یک stream ترکیب می‌کند که آیتم‌ها را از هر یک از streamهای منبع، به محض در دسترس بودن، تولید می‌کند، بدون اینکه ترتیب خاصی را اعمال کند. در نهایت، به جای اینکه روی <code>messages</code> حلقه بزنیم، روی این stream ترکیبی حلقه می‌زنیم.</p>
<p>در این مرحله، نه <code>messages</code> و نه <code>intervals</code> نیازی به pin یا mutable بودن ندارند، زیرا هر دو در یک stream واحد به نام <code>merged</code> ترکیب می‌شوند. با این حال، این فراخوانی به <code>merge</code> کامپایل نمی‌شود! (فراخوانی <code>next</code> در حلقه <code>while let</code> هم کامپایل نمی‌شود، اما به آن برمی‌گردیم.) دلیل آن این است که این دو stream انواع مختلفی دارند. stream <code>messages</code> نوع <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code> دارد، جایی که <code>Timeout</code> نوعی است که ویژگی <code>Stream</code> را برای فراخوانی <code>timeout</code> پیاده‌سازی می‌کند. stream <code>intervals</code> نوع <code>impl Stream&lt;Item = u32&gt;</code> دارد. برای ترکیب این دو stream، باید یکی از آن‌ها را به نوع دیگری تبدیل کنیم. ما stream <code>intervals</code> را بازبینی می‌کنیم، زیرا <code>messages</code> قبلاً در قالب اصلی مورد نظر ما است و باید خطاهای timeout را مدیریت کند (نگاه کنید به لیست ۱۷-۳۸).</p>
<!-- We cannot directly test this one, because it never stops. -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-38: هماهنگ کردن نوع‌های stream <code>intervals</code> با نوع stream <code>messages</code></figcaption>
</figure>
<p>ابتدا می‌توانیم از متد کمکی <code>map</code> برای تبدیل <code>intervals</code> به یک رشته استفاده کنیم. دوم، نیاز داریم که <code>Timeout</code> از <code>messages</code> را مدیریت کنیم. با این حال، چون واقعاً <em>نمی‌خواهیم</em> تایم‌اوتی برای <code>intervals</code> داشته باشیم، می‌توانیم یک تایم‌اوت ایجاد کنیم که طولانی‌تر از مدت‌های دیگر مورد استفاده ما باشد. در اینجا، یک تایم‌اوت ۱۰ ثانیه‌ای با استفاده از <code>Duration::from_secs(10)</code> ایجاد می‌کنیم. در نهایت، نیاز داریم که <code>stream</code> را متغیر (<code>mutable</code>) کنیم تا فراخوانی‌های <code>next</code> در حلقه <code>while let</code> بتوانند روی stream تکرار کنند و آن را pin کنیم تا این کار ایمن باشد. این ما را <em>تقریباً</em> به جایی که باید برسیم می‌رساند. همه چیز از نظر نوع بررسی می‌شود. اما اگر این کد را اجرا کنید، دو مشکل وجود خواهد داشت. اول، هیچ‌گاه متوقف نمی‌شود! باید با زدن <span class="keystroke">ctrl-c</span> آن را متوقف کنید. دوم، پیام‌های الفبای انگلیسی در میان تمام پیام‌های شمارنده interval دفن خواهند شد:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks running differently rather than
changes in the compiler -->
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>لیست ۱۷-۳۹ یک روش برای حل این دو مشکل آخر را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-39: استفاده از <code>throttle</code> و <code>take</code> برای مدیریت streams ترکیب‌شده</figcaption>
</figure>
<p>ابتدا از متد <code>throttle</code> روی stream <code>intervals</code> استفاده می‌کنیم تا این stream باعث غرق شدن stream <code>messages</code> نشود. <em>Throttling</em> روشی برای محدود کردن نرخ فراخوانی یک تابع است—یا در این مورد، محدود کردن نرخ poll کردن یک stream. یک بار در هر ۱۰۰ میلی‌ثانیه کافی خواهد بود، زیرا تقریباً به همان اندازه پیام‌های ما می‌رسند.</p>
<p>برای محدود کردن تعداد آیتم‌هایی که از یک stream قبول می‌کنیم، متد <code>take</code> را روی stream <code>merged</code> اعمال می‌کنیم، زیرا می‌خواهیم خروجی نهایی را محدود کنیم، نه فقط یکی از streamها را.</p>
<p>اکنون وقتی برنامه را اجرا می‌کنیم، پس از دریافت ۲۰ آیتم از stream متوقف می‌شود و intervals باعث غرق شدن messages نمی‌شود. همچنین، ما دیگر <code>Interval: 100</code> یا <code>Interval: 200</code> و موارد مشابه را نمی‌بینیم، بلکه به جای آن <code>Interval: 1</code>، <code>Interval: 2</code> و به همین ترتیب دریافت می‌کنیم—حتی اگر یک stream منبع داریم که <em>می‌تواند</em> هر میلی‌ثانیه یک رویداد تولید کند. دلیل این است که فراخوانی <code>throttle</code> یک stream جدید تولید می‌کند که stream اصلی را بسته‌بندی می‌کند تا stream اصلی فقط با نرخ throttle و نه با نرخ “ذاتی” خود poll شود. ما یک سری پیام interval غیرقابل پردازش نداریم که انتخاب کرده باشیم آن‌ها را نادیده بگیریم. بلکه، ما هرگز آن پیام‌های interval را در وهله اول تولید نمی‌کنیم! این همان “تنبلی” ذاتی futures در Rust است که دوباره به کار گرفته می‌شود و به ما اجازه می‌دهد ویژگی‌های عملکردی خود را انتخاب کنیم.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-39
cargo run
copy and paste only the program output
-->
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>تنها یک مورد باقی مانده که باید مدیریت کنیم: خطاها! با هر دو stream مبتنی بر کانال، فراخوانی‌های <code>send</code> ممکن است در صورتی که طرف دیگر کانال بسته شود، با شکست مواجه شوند—و این به نحوه اجرای runtime برای futures که stream را تشکیل می‌دهند بستگی دارد. تاکنون این احتمال را با فراخوانی <code>unwrap</code> نادیده گرفته‌ایم، اما در یک برنامه با رفتار مناسب، باید به‌طور صریح خطا را مدیریت کنیم، حداقل با پایان دادن به حلقه تا دیگر پیام ارسال نکنیم. لیست ۱۷-۴۰ یک استراتژی ساده برای مدیریت خطا را نشان می‌دهد: چاپ مشکل و سپس <code>break</code> از حلقه‌ها.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption>Listing 17-40: مدیریت خطاها و خاتمه دادن به حلقه‌ها</figcaption>
</figure>
<p>همان‌طور که معمول است، روش درست برای مدیریت یک خطای ارسال پیام می‌تواند متفاوت باشد؛ فقط مطمئن شوید که یک استراتژی دارید.</p>
<p>اکنون که مقدار زیادی از کد async را در عمل مشاهده کردیم، بیایید کمی به عقب برگردیم و به جزئیات نحوه کارکرد <code>Future</code>، <code>Stream</code> و ویژگی‌های کلیدی دیگر که Rust برای اجرای async استفاده می‌کند، بپردازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="بررسی-دقیقتر-ویژگیها-برای-async"><a class="header" href="#بررسی-دقیقتر-ویژگیها-برای-async">بررسی دقیق‌تر ویژگی‌ها برای Async</a></h2>
<p>در طول این فصل، از ویژگی‌های <code>Future</code>، <code>Pin</code>، <code>Unpin</code>، <code>Stream</code>، و <code>StreamExt</code> به روش‌های مختلفی استفاده کرده‌ایم. تاکنون، از ورود بیش از حد به جزئیات نحوه کارکرد یا چگونگی تطبیق آن‌ها با یکدیگر اجتناب کرده‌ایم، که برای بیشتر کارهای روزمره شما با Rust کافی است. با این حال، گاهی اوقات با موقعیت‌هایی مواجه می‌شوید که نیاز دارید کمی بیشتر از این جزئیات را بفهمید. در این بخش، به اندازه‌ای به این موضوع می‌پردازیم که در این سناریوها کمک کند، در حالی که بررسی <em>عمیق‌تر</em> را به مستندات دیگر می‌سپاریم.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="future"></a></p>
<h3 id="ویژگی-future"><a class="header" href="#ویژگی-future">ویژگی <code>Future</code></a></h3>
<p>بیایید با بررسی دقیق‌تر نحوه عملکرد ویژگی <code>Future</code> شروع کنیم. در اینجا نحوه تعریف آن در Rust آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>این تعریف Trait شامل چندین نوع جدید و همچنین نحوی است که قبلاً ندیده‌ایم، بنابراین بیایید قطعه به قطعه آن را بررسی کنیم.</p>
<p>ابتدا، نوع وابسته <code>Output</code> در ویژگی <code>Future</code> مشخص می‌کند که نتیجه future چه خواهد بود. این شبیه به نوع وابسته <code>Item</code> در ویژگی <code>Iterator</code> است. دوم، ویژگی <code>Future</code> همچنین متد <code>poll</code> را دارد که یک مرجع خاص <code>Pin</code> برای پارامتر <code>self</code> و یک مرجع متغیر به نوع <code>Context</code> می‌گیرد و یک <code>Poll&lt;Self::Output&gt;</code> بازمی‌گرداند. در ادامه درباره <code>Pin</code> و <code>Context</code> بیشتر صحبت خواهیم کرد. فعلاً بیایید روی چیزی که متد بازمی‌گرداند، یعنی نوع <code>Poll</code>، تمرکز کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>نوع <code>Poll</code> شبیه به یک <code>Option</code> است. این نوع دو حالت دارد: یکی <code>Ready(T)</code> که شامل یک مقدار است و دیگری <code>Pending</code> که شامل مقدار نیست. با این حال، <code>Poll</code> معنای کاملاً متفاوتی از <code>Option</code> دارد! حالت <code>Pending</code> نشان می‌دهد که future هنوز کارهایی برای انجام دادن دارد، بنابراین فراخواننده باید بعداً دوباره بررسی کند. حالت <code>Ready</code> نشان می‌دهد که future کار خود را به پایان رسانده و مقدار <code>T</code> در دسترس است.</p>
<blockquote>
<p>نکته: برای بیشتر futures، فراخواننده نباید پس از اینکه future مقدار <code>Ready</code> بازگرداند، دوباره <code>poll</code> را فراخوانی کند. بسیاری از futures اگر پس از آماده شدن دوباره <code>poll</code> شوند، دچار وحشت (<em>panic</em>) می‌شوند. futuresی که ایمن برای poll دوباره هستند، به‌طور صریح این موضوع را در مستندات خود ذکر خواهند کرد. این شبیه به نحوه رفتار <code>Iterator::next</code> است.</p>
</blockquote>
<p>وقتی کدی را می‌بینید که از <code>await</code> استفاده می‌کند، Rust آن را در پشت صحنه به کدی که <code>poll</code> را فراخوانی می‌کند کامپایل می‌کند. اگر به لیست ۱۷-۴ که در آن عنوان صفحه برای یک URL واحد پس از حل‌شدن چاپ شد، نگاهی بیندازید، Rust آن را به چیزی که (اگرچه دقیقاً نه، اما تقریباً) شبیه به این است کامپایل می‌کند:</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p>وقتی که future هنوز در حالت <code>Pending</code> است، چه کاری باید انجام دهیم؟ نیاز داریم به نوعی دوباره امتحان کنیم، و این کار را بارها تکرار کنیم، تا زمانی که future در نهایت آماده شود. به عبارت دیگر، نیاز به یک حلقه داریم:</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p>اگر Rust دقیقاً این کد را کامپایل می‌کرد، هر <code>await</code> مسدودکننده (<em>blocking</em>) می‌شد—دقیقاً برعکس چیزی که می‌خواستیم! در عوض، Rust اطمینان حاصل می‌کند که حلقه بتواند کنترل را به چیزی واگذار کند که بتواند کار روی این future را متوقف کرده، روی futures دیگر کار کند، و سپس دوباره این یکی را بررسی کند. همان‌طور که دیدیم، این وظیفه یک runtime async است، و این برنامه‌ریزی و هماهنگی یکی از وظایف اصلی آن است.</p>
<p>در ابتدای فصل، درباره انتظار برای <code>rx.recv</code> صحبت کردیم. فراخوانی <code>recv</code> یک future بازمی‌گرداند و منتظر شدن برای future آن را poll می‌کند. اشاره کردیم که یک runtime future را تا زمانی که آماده شود—چه با <code>Some(message)</code> یا با <code>None</code> در صورت بسته شدن کانال—متوقف می‌کند. با درک عمیق‌تر از ویژگی <code>Future</code> و به‌طور خاص <code>Future::poll</code>، می‌توانیم ببینیم این چگونه کار می‌کند. وقتی future مقدار <code>Poll::Pending</code> بازمی‌گرداند، runtime می‌داند که آماده نیست. برعکس، وقتی <code>poll</code> مقدار <code>Poll::Ready(Some(message))</code> یا <code>Poll::Ready(None)</code> بازمی‌گرداند، runtime می‌داند که future آماده است و آن را پیش می‌برد.</p>
<p>جزئیات دقیق نحوه انجام این کار توسط یک runtime فراتر از محدوده این کتاب است، اما نکته کلیدی این است که مکانیک پایه‌ای futures را ببینیم: یک runtime هر future که مسئول آن است را <em>poll</em> می‌کند و وقتی هنوز آماده نیست، future را دوباره به حالت خواب می‌برد.</p>
<p><a id="pinning-and-the-pin-and-unpin-traits"></a></p>
<h3 id="ویژگیهای-pin-و-unpin"><a class="header" href="#ویژگیهای-pin-و-unpin">ویژگی‌های <code>Pin</code> و <code>Unpin</code></a></h3>
<p>وقتی مفهوم pinning را در لیست ۱۷-۱۶ معرفی کردیم، با یک پیام خطای بسیار پیچیده مواجه شدیم. در اینجا بخش مرتبط با آن دوباره آمده است:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>این پیام خطا نه تنها به ما می‌گوید که باید مقادیر را pin کنیم، بلکه دلیل نیاز به pinning را نیز توضیح می‌دهد. تابع <code>trpl::join_all</code> یک ساختار به نام <code>JoinAll</code> بازمی‌گرداند. این ساختار به نوعی عمومی به نام <code>F</code> وابسته است که محدود به پیاده‌سازی ویژگی <code>Future</code> است. منتظر شدن مستقیم یک future با <code>await</code>، future را به‌طور ضمنی pin می‌کند. به همین دلیل نیازی نیست که از <code>pin!</code> در همه جاهایی که می‌خواهیم برای futures منتظر بمانیم، استفاده کنیم.</p>
<p>با این حال، ما اینجا مستقیماً منتظر یک future نیستیم. در عوض، یک future جدید به نام <code>JoinAll</code> می‌سازیم با ارسال مجموعه‌ای از futures به تابع <code>join_all</code>. امضای <code>join_all</code> نیاز دارد که نوع آیتم‌های مجموعه، ویژگی <code>Future</code> را پیاده‌سازی کنند، و <code>Box&lt;T&gt;</code> فقط در صورتی ویژگی <code>Future</code> را پیاده‌سازی می‌کند که <code>T</code> که بسته‌بندی می‌کند، یک future باشد که ویژگی <code>Unpin</code> را پیاده‌سازی کرده است.</p>
<p>این اطلاعات زیادی برای هضم کردن است! برای درک واقعی آن، بیایید کمی بیشتر به نحوه کار واقعی ویژگی <code>Future</code>، به‌ویژه در ارتباط با <em>pinning</em>، بپردازیم.</p>
<p>دوباره به تعریف ویژگی <code>Future</code> نگاه کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // متد مورد نیاز
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>پارامتر <code>cx</code> و نوع آن، <code>Context</code>، کلید اصلی برای این است که یک runtime چگونه می‌داند چه زمانی یک future خاص را بررسی کند، در حالی که همچنان تنبلی (<em>lazy</em>) باقی می‌ماند. باز هم، جزئیات نحوه کار این فرآیند فراتر از محدوده این فصل است، و معمولاً تنها زمانی که بخواهید یک پیاده‌سازی سفارشی برای <code>Future</code> بنویسید، نیاز به فکر کردن به این موضوع دارید. در عوض، ما بر روی نوع <code>self</code> تمرکز می‌کنیم، زیرا این اولین باری است که یک متد با یک نوع مشخص برای <code>self</code> روبرو می‌شویم. یک نوع مشخص برای <code>self</code> مانند نوع‌های مشخص برای سایر پارامترهای تابع عمل می‌کند، اما با دو تفاوت کلیدی:</p>
<ul>
<li>
<p>به Rust می‌گوید که نوع <code>self</code> برای فراخوانی متد باید چه باشد.</p>
</li>
<li>
<p>نمی‌تواند هر نوعی باشد. این نوع به نوعی که متد روی آن پیاده‌سازی شده است، یا یک مرجع یا اشاره‌گر هوشمند به آن نوع، یا یک <code>Pin</code> که یک مرجع به آن نوع را بسته‌بندی می‌کند، محدود است.</p>
</li>
</ul>
<p>در <a href="ch18-00-oop.html">فصل ۱۸</a><!-- ignore --> بیشتر درباره این سینتکس صحبت خواهیم کرد. فعلاً کافی است بدانیم که اگر بخواهیم یک future را poll کنیم تا بررسی کنیم که آیا <code>Pending</code> یا <code>Ready(Output)</code> است، به یک مرجع متغیر بسته‌بندی‌شده در <code>Pin</code> برای آن نوع نیاز داریم.</p>
<p><code>Pin</code> یک بسته‌بندی برای انواع اشاره‌گر مانند <code>&amp;</code>، <code>&amp;mut</code>، <code>Box</code>، و <code>Rc</code> است. (به‌طور فنی، <code>Pin</code> با نوع‌هایی کار می‌کند که ویژگی‌های <code>Deref</code> یا <code>DerefMut</code> را پیاده‌سازی می‌کنند، اما این به طور مؤثر معادل کار با اشاره‌گرها است.) <code>Pin</code> خودش یک اشاره‌گر نیست و هیچ رفتاری مانند <code>Rc</code> و <code>Arc</code> که شمارش مرجع انجام می‌دهند ندارد؛ این صرفاً یک ابزار است که کامپایلر می‌تواند برای اعمال محدودیت‌ها در استفاده از اشاره‌گرها استفاده کند.</p>
<p>به یاد آوردن این که <code>await</code> بر اساس فراخوانی‌های <code>poll</code> پیاده‌سازی شده است، شروع به توضیح پیام خطایی که قبلاً دیدیم می‌کند، اما آن پیام در مورد <code>Unpin</code> بود، نه <code>Pin</code>. پس دقیقاً چگونه <code>Pin</code> با <code>Unpin</code> مرتبط است، و چرا <code>Future</code> نیاز دارد که <code>self</code> در یک نوع <code>Pin</code> باشد تا بتواند <code>poll</code> را فراخوانی کند؟</p>
<p>به یاد بیاورید که در اوایل این فصل، یک سری از نقاط انتظار (<em>await points</em>) در یک future به یک ماشین حالت کامپایل می‌شوند، و کامپایلر اطمینان حاصل می‌کند که این ماشین حالت تمام قوانین معمول ایمنی Rust، از جمله قرض‌گیری و مالکیت، را دنبال می‌کند. برای اینکه این کار انجام شود، Rust بررسی می‌کند که چه داده‌ای بین یک نقطه انتظار و یا نقطه انتظار بعدی یا پایان بلوک async مورد نیاز است. سپس یک حالت متناظر در ماشین حالت کامپایل‌شده ایجاد می‌کند. هر حالت دسترسی لازم به داده‌هایی که در آن بخش از کد منبع استفاده می‌شوند را دریافت می‌کند، چه با گرفتن مالکیت آن داده‌ها یا با دریافت یک مرجع متغیر یا غیرمتغیر به آن.</p>
<p>تا اینجا خوب است: اگر در مورد مالکیت یا مراجع در یک بلوک async خطایی داشته باشیم، borrow checker به ما اطلاع می‌دهد. اما وقتی بخواهیم futureای که به آن بلوک مربوط می‌شود را جابه‌جا کنیم—مثلاً آن را به یک ساختار داده push کنیم تا به‌عنوان یک iterator با <code>join_all</code> استفاده شود یا آن را از یک تابع بازگردانیم—مسائل پیچیده‌تر می‌شوند.</p>
<p>وقتی یک future را جابه‌جا می‌کنیم—چه با push کردن آن به یک ساختار داده برای استفاده به‌عنوان iterator با <code>join_all</code> یا با بازگرداندن آن از یک تابع—این در واقع به معنای جابه‌جا کردن ماشین حالتی است که Rust برای ما ایجاد می‌کند. و برخلاف بیشتر انواع دیگر در Rust، futureهایی که Rust برای بلوک‌های async ایجاد می‌کند، می‌توانند در فیلدهای هر حالت معین، دارای مراجع به خودشان باشند، همان‌طور که در تصویر ساده‌شده‌ای که در شکل ۱۷-۴ نشان داده شده است.</p>
<figure>
<img alt="A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future." src="img/trpl17-04.svg" class="center" />
<figcaption>شکل 17-4: یک نوع داده خودارجاعی.</figcaption>
</figure>
<p>به‌طور پیش‌فرض، هر شیئی که مرجعی به خودش دارد، جابه‌جا کردن آن ناایمن است، زیرا مراجع همیشه به آدرس حافظه واقعی چیزی که به آن اشاره می‌کنند اشاره دارند (نگاه کنید به شکل ۱۷-۵). اگر خود ساختار داده را جابه‌جا کنید، آن مراجع داخلی همچنان به مکان قدیمی اشاره می‌کنند. با این حال، آن مکان حافظه اکنون نامعتبر است. از یک طرف، مقدار آن هنگام ایجاد تغییرات در ساختار داده به‌روزرسانی نمی‌شود. از طرف دیگر—و مهم‌تر—کامپیوتر اکنون می‌تواند آن مکان حافظه را برای مقاصد دیگر بازاستفاده کند! ممکن است بعداً داده‌هایی کاملاً نامرتبط بخوانید.</p>
<figure>
<img alt="Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved." src="img/trpl17-05.svg" class="center" />
<figcaption>شکل ۱۷-۵: نتیجه ناایمن جابه‌جایی یک نوع داده که به خودش ارجاع دارد</figcaption>
</figure>
<p>از نظر تئوری، کامپایلر Rust می‌تواند سعی کند هر مرجع به یک شیء را هر زمان که جابه‌جا می‌شود، به‌روزرسانی کند، اما این کار می‌تواند سربار عملکرد زیادی ایجاد کند، به‌ویژه اگر یک شبکه کامل از مراجع نیاز به به‌روزرسانی داشته باشد. اگر بتوانیم به جای آن مطمئن شویم که ساختار داده مورد نظر <em>در حافظه جابه‌جا نمی‌شود</em>، نیازی به به‌روزرسانی مراجع نخواهیم داشت. این دقیقاً همان چیزی است که borrow checker در Rust نیاز دارد: در کد ایمن، از جابه‌جا کردن هر آیتمی که مرجع فعالی به آن دارد جلوگیری می‌کند.</p>
<p><code>Pin</code> بر اساس این اصل عمل می‌کند و تضمین دقیقی که نیاز داریم را ارائه می‌دهد. وقتی یک مقدار را با بسته‌بندی یک اشاره‌گر به آن مقدار در <code>Pin</code> <em>pin</em> می‌کنیم، دیگر نمی‌تواند جابه‌جا شود. بنابراین، اگر <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code> داشته باشید، در واقع مقدار <code>SomeType</code> را pin می‌کنید، <em>نه</em> اشاره‌گر <code>Box</code>. شکل ۱۷-۶ این فرآیند را نشان می‌دهد.</p>
<figure>
<img alt="Three boxes laid out side by side. The first is labeled “Pin”, the second “b1”, and the third “pinned”. Within “pinned” is a table labeled “fut”, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value “0”, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value “1” in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the “fut” table represents a future which is self-referential. An arrow leaves the box labeled “Pin”, goes through the box labeled “b1” and has terminates inside the “pinned” box at the “fut” table." src="img/trpl17-06.svg" class="center" />
<figcaption>شکل 17-6: pin کردن یک `Box` که به یک نوع آینده خودارجاعی اشاره می‌کند.</figcaption>
</figure>
<p>در واقع، اشاره‌گر (Pointer) <code>Box</code> هنوز می‌تواند به‌طور آزاد جابه‌جا شود. به یاد داشته باشید: ما به مطمئن شدن از اینکه داده‌ای که در نهایت به آن ارجاع داده می‌شود در جای خود باقی می‌ماند اهمیت می‌دهیم. اگر یک اشاره‌گر (Pointer) جابه‌جا شود اما داده‌ای که به آن اشاره می‌کند در همان مکان باقی بماند، همانطور که در شکل 17-7 نشان داده شده است، هیچ مشکلی پیش نمی‌آید. (چگونگی انجام این کار با یک <code>Pin</code> که یک <code>Box</code> را می‌پیچد فراتر از بحث این بخش خاص است، اما می‌تواند تمرین خوبی باشد! اگر به مستندات نوع‌ها و همچنین ماژول <code>std::pin</code> نگاه کنید، ممکن است بتوانید بفهمید چگونه این کار را انجام دهید.) نکته کلیدی این است که نوع خودارجاعی خود نمی‌تواند جابه‌جا شود، زیرا همچنان pin شده است.</p>
<figure>
<img alt="Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled “b1” and “b2”, “b1” is grayed out, and the arrow from “Pin” goes through “b2” instead of “b1”, indicating that the pointer has moved from “b1” to “b2”, but the data in “pinned” has not moved." src="img/trpl17-07.svg" class="center" />
<figcaption>شکل 17-7: جابه‌جایی یک `Box` که به یک نوع آینده خودارجاعی اشاره می‌کند.</figcaption>
</figure>
<p>با این حال، اکثر انواع کاملاً برای جابه‌جایی ایمن هستند، حتی اگر پشت یک اشاره‌گر <code>Pin</code> قرار داشته باشند. فقط زمانی نیاز به فکر کردن به pinning داریم که آیتم‌ها دارای مراجع داخلی باشند. مقادیر اولیه (<em>primitive</em>) مانند اعداد و مقادیر Boolean ایمن هستند، زیرا به‌وضوح هیچ مرجع داخلی ندارند، بنابراین بدیهی است که ایمن هستند. بیشتر انواعی که معمولاً با آن‌ها در Rust کار می‌کنید نیز این‌گونه‌اند. برای مثال، می‌توانید یک <code>Vec</code> را بدون نگرانی جابه‌جا کنید. با توجه به آنچه تاکنون دیده‌ایم، اگر یک <code>Pin&lt;Vec&lt;String&gt;&gt;</code> داشته باشید، باید همه چیز را از طریق APIهای ایمن اما محدودکننده‌ای که <code>Pin</code> ارائه می‌دهد انجام دهید، حتی اگر یک <code>Vec&lt;String&gt;</code> همیشه برای جابه‌جایی ایمن باشد اگر هیچ مرجع دیگری به آن وجود نداشته باشد. ما به روشی نیاز داریم که به کامپایلر بگوییم در چنین مواردی جابه‌جا کردن آیتم‌ها مشکلی ندارد—و اینجا است که <code>Unpin</code> وارد عمل می‌شود.</p>
<p><code>Unpin</code> یک ویژگی علامت‌گذار (<em>marker trait</em>) است، مشابه ویژگی‌های <code>Send</code> و <code>Sync</code> که در فصل ۱۶ دیدیم، و بنابراین هیچ عملکردی از خود ندارد. ویژگی‌های علامت‌گذار فقط برای این وجود دارند که به کامپایلر بگویند استفاده از نوعی که یک ویژگی خاص را پیاده‌سازی می‌کند در یک زمینه خاص ایمن است. <code>Unpin</code> به کامپایلر اطلاع می‌دهد که یک نوع خاص <em>نیازی</em> به تضمین اینکه مقدار مربوطه به‌صورت ایمن جابه‌جا می‌شود، ندارد.</p>
<p>مشابه <code>Send</code> و <code>Sync</code>، کامپایلر به‌طور خودکار <code>Unpin</code> را برای تمام انواعی که می‌تواند ثابت کند ایمن هستند، پیاده‌سازی می‌کند. یک مورد خاص، دوباره مشابه <code>Send</code> و <code>Sync</code>، این است که <code>Unpin</code> برای یک نوع <em>پیاده‌سازی نمی‌شود</em>. نشانه‌گذاری برای این حالت به شکل <code>impl !Unpin for <em>SomeType</em></code> است، که در آن <code><em>SomeType</em></code> نام نوعی است که <em>باید</em> آن تضمین‌ها را برای ایمن بودن، هر زمان که اشاره‌گری به آن نوع در یک <code>Pin</code> استفاده می‌شود، حفظ کند.</p>
<p>به عبارت دیگر، دو نکته در مورد رابطه بین <code>Pin</code> و <code>Unpin</code> باید در نظر داشته باشید. اول، <code>Unpin</code> حالت “معمولی” است و <code>!Unpin</code> حالت خاص. دوم، اینکه آیا یک نوع ویژگی <code>Unpin</code> یا <code>!Unpin</code> را پیاده‌سازی می‌کند <em>فقط</em> زمانی اهمیت دارد که در حال استفاده از یک اشاره‌گر pin شده به آن نوع مانند <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code> باشید.</p>
<p>برای روشن‌تر کردن این موضوع، به یک <code>String</code> فکر کنید: این نوع دارای طول و کاراکترهای Unicode است که آن را تشکیل می‌دهند. ما می‌توانیم یک <code>String</code> را در <code>Pin</code> بسته‌بندی کنیم، همان‌طور که در شکل ۱۷-۸ دیده می‌شود. با این حال، <code>String</code> به طور خودکار ویژگی <code>Unpin</code> را پیاده‌سازی می‌کند، همان‌طور که بیشتر انواع دیگر در Rust این کار را انجام می‌دهند.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center" />
<figcaption>شکل ۱۷-۸: Pin کردن یک `String`؛ خط نقطه‌چین نشان می‌دهد که `String` ویژگی `Unpin` را پیاده‌سازی می‌کند و بنابراین pin نشده است.</figcaption>
</figure>
<p>در نتیجه، می‌توانیم کارهایی انجام دهیم که اگر <code>String</code> ویژگی <code>!Unpin</code> را پیاده‌سازی می‌کرد غیرقانونی بود، مانند جایگزین کردن یک رشته با رشته‌ای دیگر در همان مکان حافظه، همان‌طور که در شکل ۱۷-۹ نشان داده شده است. این کار قرارداد <code>Pin</code> را نقض نمی‌کند، زیرا <code>String</code> هیچ مرجع داخلی ندارد که جابه‌جایی آن را ناایمن کند! این دقیقاً دلیلی است که ویژگی <code>Unpin</code> را به جای <code>!Unpin</code> پیاده‌سازی می‌کند.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center" />
<figcaption>شکل 17-9: جایگزینی یک String با یک String کاملاً متفاوت در حافظه.</figcaption>
</figure>
<p>اکنون به‌اندازه کافی می‌دانیم تا خطاهایی که برای آن فراخوانی <code>join_all</code> در فهرست 17-17 گزارش شدند را درک کنیم. ما در ابتدا سعی کردیم آینده‌های تولیدشده توسط بلوک‌های async را به یک <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code> منتقل کنیم، اما همان‌طور که دیدیم، این آینده‌ها ممکن است ارجاعات داخلی داشته باشند، بنابراین ویژگی <code>Unpin</code> را پیاده‌سازی نمی‌کنند. آن‌ها نیاز به pin شدن دارند، و سپس می‌توانیم نوع <code>Pin</code> را به <code>Vec</code> ارسال کنیم، با اطمینان از اینکه داده‌های زیربنایی در آینده‌ها <em>جابه‌جا نخواهند شد</em>.</p>
<p><code>Pin</code> و <code>Unpin</code> بیشتر برای ساخت کتابخانه‌های سطح پایین یا وقتی که خودتان یک runtime می‌سازید مهم هستند، نه برای کد روزمره راست. وقتی این Traits را در پیام‌های خطا مشاهده می‌کنید، اکنون ایده بهتری از نحوه رفع کد خواهید داشت!</p>
<blockquote>
<p>نکته: این ترکیب <code>Pin</code> و <code>Unpin</code> اجازه می‌دهد که یک کلاس کامل از نوع‌های پیچیده در راست ایمن باشند که در غیر این صورت به دلیل خودارجاعی بودن دشوار برای پیاده‌سازی هستند. نوع‌هایی که نیاز به <code>Pin</code> دارند <em>بیشتر</em> در راست async امروزی ظاهر می‌شوند، اما ممکن است—بسیار به‌ندرت!—در زمینه‌های دیگر نیز ببینید.</p>
<p>جزئیات نحوه کار <code>Pin</code> و <code>Unpin</code> و قوانینی که باید رعایت کنند، به‌طور گسترده در مستندات API برای <code>std::pin</code> پوشش داده شده‌اند، بنابراین اگر می‌خواهید آن‌ها را عمیق‌تر درک کنید، این مکان خوبی برای شروع است.</p>
<p>اگر می‌خواهید بفهمید که “در پشت صحنه” چگونه کار می‌کنند، کتاب رسمی <a href="https://rust-lang.github.io/async-book/"><em>برنامه‌نویسی ناهمگام در راست</em></a> پاسخگوی شماست:</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">Chapter 2: Under the Hood: Executing Futures and Tasks</a></li>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Chapter 4: Pinning</a></li>
</ul>
</blockquote>
<h3 id="the-stream-trait"><a class="header" href="#the-stream-trait">The Stream Trait</a></h3>
<p>اکنون که درک عمیق‌تری از Traits‌های <code>Future</code>، <code>Pin</code>، و <code>Unpin</code> داریم، می‌توانیم توجه خود را به Trait <code>Stream</code> معطوف کنیم. همانطور که در بخش معرفی streams توضیح داده شد، streams مشابه iteratorهای ناهمگام هستند. برخلاف <code>Iterator</code> و <code>Future</code>، در زمان نگارش این متن، تعریف <code>Stream</code> در کتابخانه استاندارد وجود ندارد، اما یک تعریف بسیار رایج از crate <code>futures</code> وجود دارد که در سراسر اکوسیستم استفاده می‌شود.</p>
<p>بیایید تعاریف Traits‌های <code>Iterator</code> و <code>Future</code> را مرور کنیم تا بتوانیم تصور کنیم یک Trait <code>Stream</code> که این دو را ترکیب می‌کند چگونه ممکن است به نظر برسد. از <code>Iterator</code>، مفهوم یک توالی را داریم: متد <code>next</code> آن یک <code>Option&lt;Self::Item&gt;</code> فراهم می‌کند. از <code>Future</code>، مفهوم آماده شدن در طول زمان را داریم: متد <code>poll</code> آن یک <code>Poll&lt;Self::Output&gt;</code> فراهم می‌کند. برای نمایش یک توالی از آیتم‌هایی که در طول زمان آماده می‌شوند، یک Trait <code>Stream</code> تعریف می‌کنیم که این ویژگی‌ها را ترکیب می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait <code>Stream</code> یک نوع مرتبط به نام <code>Item</code> برای نوع آیتم‌هایی که توسط stream تولید می‌شوند تعریف می‌کند. این مشابه با <code>Iterator</code> است: ممکن است تعداد این آیتم‌ها صفر تا بی‌نهایت باشد، برخلاف <code>Future</code> که همیشه یک <code>Output</code> واحد دارد (حتی اگر نوع واحد <code>()</code> باشد).</p>
<p><code>Stream</code> همچنین یک متد برای دریافت این آیتم‌ها تعریف می‌کند. ما آن را <code>poll_next</code> می‌نامیم تا واضح باشد که این متد به همان روشی که <code>Future::poll</code> بررسی می‌کند، آیتم‌ها را بررسی می‌کند و به همان روشی که <code>Iterator::next</code> یک توالی از آیتم‌ها تولید می‌کند، آیتم‌ها را تولید می‌کند. نوع بازگشتی آن <code>Poll</code> را با <code>Option</code> ترکیب می‌کند. نوع خارجی <code>Poll</code> است، زیرا باید برای آماده بودن بررسی شود، همان‌طور که یک آینده بررسی می‌شود. نوع داخلی <code>Option</code> است، زیرا باید نشان دهد که آیا پیام‌های بیشتری وجود دارد یا نه، همان‌طور که یک iterator انجام می‌دهد.</p>
<p>چیزی بسیار مشابه با این احتمالاً در نهایت به‌عنوان بخشی از کتابخانه استاندارد راست استانداردسازی خواهد شد. در حال حاضر، این Trait بخشی از ابزار اکثر runtime‌ها است، بنابراین می‌توانید روی آن حساب کنید و همه چیزهایی که در ادامه می‌بینید عموماً قابل اعمال هستند!</p>
<p>با این حال، در مثالی که در بخش مربوط به streams دیدیم، ما از <code>poll_next</code> یا <code>Stream</code> استفاده نکردیم، بلکه از <code>next</code> و <code>StreamExt</code> استفاده کردیم. البته می‌توانیم مستقیماً از API <code>poll_next</code> استفاده کنیم و ماشین‌های حالت <code>Stream</code> خود را با دست بنویسیم، همان‌طور که می‌توانیم مستقیماً از طریق متد <code>poll</code> با آینده‌ها کار کنیم. اما استفاده از <code>await</code> بسیار دلپذیرتر است، بنابراین Trait <code>StreamExt</code> متد <code>next</code> را فراهم می‌کند تا بتوانیم دقیقاً این کار را انجام دهیم.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>نکته: تعریف واقعی که قبلاً در این فصل استفاده کردیم کمی متفاوت به نظر می‌رسد، زیرا از نسخه‌هایی از راست پشتیبانی می‌کند که هنوز از استفاده از توابع async در Traits پشتیبانی نمی‌کنند. در نتیجه، این‌گونه به نظر می‌رسد:</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>نوع <code>Next</code> یک <code>struct</code> است که <code>Future</code> را پیاده‌سازی می‌کند و راهی برای نام‌گذاری طول عمر ارجاع به <code>self</code> با <code>Next&lt;'_, Self&gt;</code> فراهم می‌کند، به‌طوری که <code>await</code> بتواند با این متد کار کند!</p>
</blockquote>
<p>Trait <code>StreamExt</code> همچنین محل تمام متدهای جالبی است که می‌توان با streams استفاده کرد. <code>StreamExt</code> به‌طور خودکار برای هر نوعی که <code>Stream</code> را پیاده‌سازی کند، پیاده‌سازی می‌شود، اما این Traits به‌طور جداگانه تعریف شده‌اند تا جامعه بتواند به‌صورت جداگانه روی Trait بنیادی و API‌های راحتی کار کند.</p>
<p>در نسخه <code>StreamExt</code> استفاده‌شده در crate <code>trpl</code>، این Trait نه تنها متد <code>next</code> را تعریف می‌کند، بلکه یک پیاده‌سازی از <code>next</code> ارائه می‌دهد که جزئیات فراخوانی <code>Stream::poll_next</code> را به‌درستی مدیریت می‌کند. این بدان معناست که حتی زمانی که نیاز دارید نوع داده‌های جریان خود را بنویسید، فقط کافی است <code>Stream</code> را پیاده‌سازی کنید، و سپس هرکسی که از نوع داده شما استفاده کند، می‌تواند به‌طور خودکار از <code>StreamExt</code> و متدهای آن با آن استفاده کند.</p>
<p>این تمام چیزی است که درباره جزئیات سطح پایین این Traits پوشش خواهیم داد. برای جمع‌بندی، بیایید در نظر بگیریم که چگونه آینده‌ها (شامل streams)، تسک‌ها، و نخ‌ها همگی با هم سازگار هستند!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="جمعبندی-futures-tasks-و-threads"><a class="header" href="#جمعبندی-futures-tasks-و-threads">جمع‌بندی: Futures، Tasks، و Threads</a></h2>
<p>همان‌طور که در <a href="http://localhost:3000/ch16-00-concurrency.html">فصل ۱۶</a><!-- ignore --> دیدیم، Threads یکی از روش‌های همزمانی را فراهم می‌کنند. در این فصل با روش دیگری آشنا شدیم: استفاده از async با Futures و Streams. اگر برایتان سؤال پیش آمده که چه زمانی باید یکی از این روش‌ها را انتخاب کنید، پاسخ این است: بستگی دارد! و در بسیاری از موارد، انتخاب فقط بین Threads <em>یا</em> async نیست، بلکه ترکیبی از Threads <em>و</em> async است.</p>
<p>بسیاری از سیستم‌عامل‌ها مدل‌های همزمانی مبتنی بر Threads را دهه‌هاست که فراهم کرده‌اند و بسیاری از زبان‌های برنامه‌نویسی از این مدل‌ها پشتیبانی می‌کنند. با این حال، این مدل‌ها بدون نقاط ضعف نیستند. در بسیاری از سیستم‌عامل‌ها، هر Thread مقدار زیادی حافظه استفاده می‌کند و راه‌اندازی و خاموش کردن آن‌ها نیز هزینه‌ای به همراه دارد. Threads همچنین فقط زمانی قابل استفاده هستند که سیستم‌عامل و سخت‌افزار شما از آن‌ها پشتیبانی کنند. برخلاف کامپیوترهای دسکتاپ و موبایل اصلی، برخی از سیستم‌های تعبیه‌شده (<em>embedded systems</em>) هیچ سیستم‌عاملی ندارند و بنابراین Threads هم ندارند.</p>
<p>مدل async مجموعه‌ای متفاوت و در نهایت مکمل از مصالحه‌ها را فراهم می‌کند. در مدل async، عملیات همزمان نیازی به Threadهای جداگانه ندارند. در عوض، می‌توانند بر روی Tasks اجرا شوند، همان‌طور که در بخش Streams از <code>trpl::spawn_task</code> برای شروع کار از یک تابع همزمان استفاده کردیم. یک Task مشابه یک Thread است، اما به جای اینکه توسط سیستم‌عامل مدیریت شود، توسط کد سطح کتابخانه‌ای یعنی Runtime مدیریت می‌شود.</p>
<p>در بخش قبلی، دیدیم که می‌توانیم یک Stream با استفاده از یک کانال async و ایجاد یک Task async که می‌توانیم از کد همزمان فراخوانی کنیم، بسازیم. می‌توانیم همین کار را با یک Thread انجام دهیم. در لیست ۱۷-۴۰ از <code>trpl::spawn_task</code> و <code>trpl::sleep</code> استفاده کردیم. در لیست ۱۷-۴۱، این موارد را با APIهای <code>thread::spawn</code> و <code>thread::sleep</code> از کتابخانه استاندارد در تابع <code>get_intervals</code> جایگزین می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
</span><span class="boring">                eprintln!("Cannot send message '{message}': {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption>Listing 17-41: استفاده از APIهای <code>std::thread</code> به جای APIهای async <code>trpl</code> برای تابع <code>get_intervals</code></figcaption>
</figure>
<p>اگر این کد را اجرا کنید، خروجی آن دقیقاً مشابه لیست ۱۷-۴۰ خواهد بود. و توجه کنید که از دید کدی که فراخوانی انجام می‌دهد، تغییرات بسیار کمی وجود دارد. علاوه بر این، حتی اگر یکی از توابع ما یک Task async را روی Runtime ایجاد کرده و دیگری یک Thread سیستم‌عامل را ایجاد کرده باشد، Streamهای حاصل از این تفاوت‌ها تأثیری نمی‌گیرند.</p>
<p>با وجود شباهت‌هایشان، این دو رویکرد رفتارهای بسیار متفاوتی دارند، اگرچه ممکن است در این مثال بسیار ساده سخت باشد این تفاوت‌ها را اندازه‌گیری کنیم. می‌توانیم میلیون‌ها Task async را روی هر کامپیوتر شخصی مدرن ایجاد کنیم. اما اگر بخواهیم همین کار را با Threads انجام دهیم، واقعاً از حافظه خارج خواهیم شد!</p>
<p>اما دلیلی وجود دارد که این APIها این‌قدر مشابه هستند. نخ‌ها به عنوان مرزی برای مجموعه‌ای از عملیات همزمان عمل می‌کنند؛ همزمانی <em>بین</em> نخ‌ها ممکن است. tasks به عنوان مرزی برای مجموعه‌ای از عملیات <em>غیرهمزمان</em> عمل می‌کنند؛ همزمانی هم <em>بین</em> و هم <em>درون</em> tasks ممکن است، زیرا یک task می‌تواند بین futures در بدنه خود جابه‌جا شود. در نهایت، futures کوچک‌ترین واحد همزمانی در Rust هستند و هر future ممکن است یک درخت از futures دیگر را نمایندگی کند. runtime—به‌ویژه، executor آن—tasks را مدیریت می‌کند و tasks futures را مدیریت می‌کنند. از این نظر، tasks شبیه نخ‌های سبک و مدیریت‌شده توسط runtime هستند که قابلیت‌های بیشتری دارند زیرا توسط runtime به جای سیستم‌عامل مدیریت می‌شوند.</p>
<p>این بدان معنا نیست که Taskهای async همیشه بهتر از Threads هستند (یا برعکس). همزمانی با Threads از برخی جهات مدل برنامه‌نویسی ساده‌تری نسبت به همزمانی با <code>async</code> است. این می‌تواند یک نقطه قوت یا ضعف باشد. Threads تا حدودی “آتش و فراموشی” (<em>fire and forget</em>) هستند؛ آن‌ها معادل ذاتی برای یک Future ندارند، بنابراین بدون اینکه جز توسط خود سیستم‌عامل متوقف شوند، تا انتها اجرا می‌شوند. به عبارت دیگر، آن‌ها پشتیبانی داخلی برای <em>همزمانی درون وظیفه‌ای</em> (<em>intratask concurrency</em>) مانند Futures ندارند. همچنین، Threads در Rust هیچ مکانیزمی برای لغو ندارند—موضوعی که به‌طور صریح در این فصل به آن پرداخته نشده است، اما از این واقعیت که هر زمان یک Future به پایان می‌رسید، وضعیت آن به درستی پاک‌سازی می‌شد، به‌طور ضمنی بیان شده است.</p>
<p>این محدودیت‌ها همچنین باعث می‌شوند Threads سخت‌تر از Futures ترکیب شوند. برای مثال، استفاده از Threads برای ساخت ابزارهایی مانند متدهای <code>timeout</code> و <code>throttle</code> که قبلاً در این فصل ساخته‌ایم، بسیار دشوارتر است. این واقعیت که Futures ساختار داده غنی‌تری هستند به این معناست که آن‌ها می‌توانند به‌طور طبیعی‌تر با هم ترکیب شوند، همان‌طور که دیده‌ایم.</p>
<p>Tasks، در نتیجه، کنترل <em>اضافه‌ای</em> بر روی Futures به ما می‌دهند و به ما اجازه می‌دهند که انتخاب کنیم کجا و چگونه آن‌ها را گروه‌بندی کنیم. و معلوم می‌شود که Threads و Tasks اغلب به خوبی با هم کار می‌کنند، زیرا Tasks می‌توانند (حداقل در برخی Runtimeها) بین Threads جابه‌جا شوند. در واقع، در پس‌زمینه، Runtimeی که استفاده کرده‌ایم—از جمله توابع <code>spawn_blocking</code> و <code>spawn_task</code>—به طور پیش‌فرض چند Threadی (<em>multithreaded</em>) است! بسیاری از Runtimeها از رویکردی به نام <em>دزدیدن کار</em> (<em>work stealing</em>) استفاده می‌کنند تا Tasks را به‌طور شفاف بین Threads جابه‌جا کنند، بر اساس اینکه چگونه Threads در حال حاضر استفاده می‌شوند، تا عملکرد کلی سیستم را بهبود بخشند. این رویکرد در واقع به Threads <em>و</em> Tasks، و بنابراین Futures نیاز دارد.</p>
<p>وقتی در مورد استفاده از روش‌های مختلف فکر می‌کنید، این قوانین کلی را در نظر بگیرید:</p>
<ul>
<li>اگر کار <em>به شدت قابل موازی‌سازی</em> است، مانند پردازش مقدار زیادی داده که هر بخش می‌تواند جداگانه پردازش شود، Threads انتخاب بهتری هستند.</li>
<li>اگر کار <em>به شدت همزمان</em> است، مانند مدیریت پیام‌ها از منابع مختلفی که ممکن است در فواصل یا نرخ‌های مختلف وارد شوند، async انتخاب بهتری است.</li>
</ul>
<p>و اگر به هر دو موازی‌سازی و همزمانی نیاز دارید، لازم نیست بین Threads و async یکی را انتخاب کنید. می‌توانید از هر دو به طور آزادانه استفاده کنید و اجازه دهید هر کدام نقشی که در آن بهتر هستند را بازی کنند. برای مثال، لیست ۱۷-۴۲ یک نمونه نسبتاً رایج از این نوع ترکیب در کد Rust دنیای واقعی را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // for mdbook test
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-42: ارسال پیام‌ها با کد مسدودکننده در یک نخ و انتظار برای پیام‌ها در یک بلوک async</figcaption>
</figure>
<p>ما با ایجاد یک کانال async شروع می‌کنیم، سپس یک Thread ایجاد می‌کنیم که مالکیت بخش ارسال‌کننده کانال را به دست می‌گیرد. درون Thread، اعداد ۱ تا ۱۰ را ارسال می‌کنیم و بین هر ارسال یک ثانیه می‌خوابیم. در نهایت، یک Future که با یک بلوک async ایجاد شده و به <code>trpl::run</code> ارسال شده است را اجرا می‌کنیم، درست همان‌طور که در طول این فصل انجام داده‌ایم. در آن Future، منتظر دریافت پیام‌ها می‌مانیم، دقیقاً مانند سایر مثال‌های ارسال پیام که دیده‌ایم.</p>
<p>برای بازگشت به سناریویی که فصل را با آن آغاز کردیم، تصور کنید که مجموعه‌ای از وظایف کدگذاری ویدئو را با استفاده از یک Thread اختصاصی (زیرا کدگذاری ویدئو به شدت وابسته به پردازش است) اجرا می‌کنید، اما با استفاده از یک کانال async به رابط کاربری اطلاع می‌دهید که آن عملیات به پایان رسیده‌اند. در موارد استفاده واقعی، بی‌شمار نمونه از این نوع ترکیب‌ها وجود دارد.</p>
<h2 id="خلاصه-16"><a class="header" href="#خلاصه-16">خلاصه</a></h2>
<p>این آخرین باری نیست که در این کتاب با همزمانی مواجه می‌شوید. پروژه موجود در <a href="ch21-00-final-project-a-web-server.html">فصل ۲۱</a><!-- ignore --> این مفاهیم را در یک موقعیت واقعی‌تر از مثال‌های ساده‌ای که در اینجا بحث شد، به کار خواهد گرفت و حل مسئله با استفاده از Threadها در مقابل Tasks را به طور مستقیم‌تر مقایسه خواهد کرد.</p>
<p>صرف‌نظر از اینکه کدام یک از این رویکردها را انتخاب می‌کنید، Rust ابزارهای لازم برای نوشتن کدی ایمن، سریع و همزمان را در اختیار شما قرار می‌دهد—چه برای یک وب سرور با توان عملیاتی بالا و چه برای یک سیستم‌عامل تعبیه‌شده.</p>
<p>در ادامه، درباره روش‌های ایدئوماتیک برای مدل‌سازی مشکلات و ساختاردهی راه‌حل‌ها به‌عنوان برنامه‌های Rust شما بزرگ‌تر می‌شوند صحبت خواهیم کرد. علاوه بر این، درباره اینکه ایدئوم‌های Rust چگونه با آن‌هایی که ممکن است از برنامه‌نویسی شی‌گرا با آن‌ها آشنا باشید مرتبط هستند بحث خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ویژگیهای-برنامهنویسی-شیگرا-oop-در-rust"><a class="header" href="#ویژگیهای-برنامهنویسی-شیگرا-oop-در-rust">ویژگی‌های برنامه‌نویسی شی‌گرا (OOP) در Rust</a></h1>
<p>برنامه‌نویسی شی‌گرا (OOP) روشی برای مدل‌سازی برنامه‌ها است. مفهوم اشیاء به‌عنوان یک مفهوم برنامه‌نویسی در دهه 1960 در زبان برنامه‌نویسی Simula معرفی شد. این اشیاء بر معماری برنامه‌نویسی آلن کی تأثیر گذاشتند که در آن اشیاء پیام‌هایی را به یکدیگر ارسال می‌کنند. برای توصیف این معماری، او اصطلاح <em>برنامه‌نویسی شی‌گرا</em> را در سال 1967 ابداع کرد. تعاریف متعددی با یکدیگر رقابت می‌کنند تا توضیح دهند که OOP چیست، و بر اساس برخی از این تعاریف Rust شی‌گرا است، اما بر اساس برخی دیگر این‌گونه نیست. در این فصل، ویژگی‌هایی که معمولاً شی‌گرا در نظر گرفته می‌شوند و چگونگی ترجمه آن ویژگی‌ها به Rust ایدئوماتیک را بررسی خواهیم کرد. سپس نشان می‌دهیم چگونه یک الگوی طراحی شی‌گرا را در Rust پیاده‌سازی کنیم و مزایا و معایب انجام این کار در مقابل استفاده از نقاط قوت Rust را بررسی خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ویژگیهای-زبانهای-شیگرا"><a class="header" href="#ویژگیهای-زبانهای-شیگرا">ویژگی‌های زبان‌های شی‌گرا</a></h2>
<p>در جامعه برنامه‌نویسی هیچ توافقی درباره اینکه یک زبان باید چه ویژگی‌هایی داشته باشد تا به‌عنوان شی‌گرا در نظر گرفته شود، وجود ندارد. Rust تحت تأثیر بسیاری از پارادایم‌های برنامه‌نویسی قرار گرفته است، از جمله OOP؛ برای مثال، ما ویژگی‌هایی که از برنامه‌نویسی تابعی آمده بودند را در فصل 13 بررسی کردیم. می‌توان گفت که زبان‌های شی‌گرا برخی ویژگی‌های مشترک دارند، یعنی اشیاء، کپسوله‌سازی (encapsulation) و وراثت (inheritance). بیایید بررسی کنیم که هر یک از این ویژگی‌ها چه معنایی دارند و آیا Rust از آن‌ها پشتیبانی می‌کند یا خیر.</p>
<h3 id="اشیاء-شامل-دادهها-و-رفتار-هستند"><a class="header" href="#اشیاء-شامل-دادهها-و-رفتار-هستند">اشیاء شامل داده‌ها و رفتار هستند</a></h3>
<p>کتاب <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> نوشته Erich Gamma، Richard Helm، Ralph Johnson و John Vlissides (انتشارات Addison-Wesley Professional، 1994)، که به طور غیررسمی به عنوان کتاب <em>Gang of Four</em> شناخته می‌شود، یک فهرست از الگوهای طراحی شی‌گرا است. این کتاب OOP را به این صورت تعریف می‌کند:</p>
<blockquote>
<p>برنامه‌های شی‌گرا از اشیاء تشکیل شده‌اند. یک <em>شیء</em> شامل داده‌ها و روش‌هایی که بر روی آن داده‌ها عمل می‌کنند، است. این روش‌ها معمولاً به نام <em>متدها</em> یا <em>عملیات</em> شناخته می‌شوند.</p>
</blockquote>
<p>با استفاده از این تعریف، Rust یک زبان شی‌گرا است: structها و enumها داده دارند، و بلوک‌های <code>impl</code> متدهایی را برای structها و enumها ارائه می‌دهند. حتی اگر structها و enumها با متدهایی که دارند <em>اشیاء</em> نامیده نشوند، بر اساس تعریف Gang of Four، آن‌ها همان عملکرد را ارائه می‌دهند.</p>
<h3 id="کپسولهسازی-برای-مخفی-کردن-جزئیات-پیادهسازی"><a class="header" href="#کپسولهسازی-برای-مخفی-کردن-جزئیات-پیادهسازی">کپسوله‌سازی برای مخفی کردن جزئیات پیاده‌سازی</a></h3>
<p>یکی دیگر از جنبه‌هایی که معمولاً با OOP مرتبط است، مفهوم <em>کپسوله‌سازی</em> است، که به این معناست که جزئیات پیاده‌سازی یک شیء برای کدی که از آن شیء استفاده می‌کند قابل دسترسی نیست. بنابراین تنها راه تعامل با یک شیء از طریق API عمومی آن است؛ کدی که از شیء استفاده می‌کند نباید بتواند به جزئیات داخلی شیء دسترسی پیدا کند و داده‌ها یا رفتار را به صورت مستقیم تغییر دهد. این امکان را به برنامه‌نویس می‌دهد که جزئیات داخلی شیء را تغییر داده و بازسازی کند بدون اینکه نیازی به تغییر کدی که از آن شیء استفاده می‌کند، داشته باشد.</p>
<p>ما در فصل 7 بحث کردیم که چگونه می‌توان کپسوله‌سازی را کنترل کرد: می‌توانیم از کلمه کلیدی <code>pub</code> استفاده کنیم تا تصمیم بگیریم کدام ماژول‌ها، انواع، توابع و متدها در کد ما عمومی باشند، و به‌طور پیش‌فرض همه چیز دیگر خصوصی است. برای مثال، می‌توانیم یک struct به نام <code>AveragedCollection</code> تعریف کنیم که یک فیلد شامل یک بردار از مقادیر <code>i32</code> دارد. این struct همچنین می‌تواند یک فیلد داشته باشد که میانگین مقادیر موجود در بردار را نگه می‌دارد، به این معنا که نیازی به محاسبه میانگین به صورت لحظه‌ای نیست هر زمان که کسی به آن نیاز داشت. به عبارت دیگر، <code>AveragedCollection</code> میانگین محاسبه‌شده را برای ما کش می‌کند. لیستینگ 18-1 تعریف struct <code>AveragedCollection</code> را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<figcaption>Listing 18-1: An <code>AveragedCollection</code> struct that maintains a list of integers and the average of the items in the collection</figcaption>
</figure>
<p>ساختار <code>struct</code> با کلمه کلیدی <code>pub</code> علامت‌گذاری شده است تا کدهای دیگر بتوانند از آن استفاده کنند، اما فیلدهای داخل struct همچنان خصوصی باقی می‌مانند. این نکته در این مثال مهم است، زیرا می‌خواهیم اطمینان حاصل کنیم که هر زمان مقداری به لیست اضافه یا از آن حذف می‌شود، میانگین نیز به‌روزرسانی می‌شود. این کار را با پیاده‌سازی متدهای <code>add</code>، <code>remove</code> و <code>average</code> روی struct انجام می‌دهیم، همان‌طور که در لیستینگ 18-2 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<figcaption>Listing 18-2: پیاده‌سازی متدهای عمومی <code>add</code>، <code>remove</code> و <code>average</code> در <code>AveragedCollection</code></figcaption>
</figure>
<p>متدهای عمومی <code>add</code>، <code>remove</code> و <code>average</code> تنها راه‌های دسترسی یا تغییر داده‌ها در یک نمونه از <code>AveragedCollection</code> هستند. زمانی که یک آیتم با استفاده از متد <code>add</code> به <code>list</code> اضافه می‌شود یا با استفاده از متد <code>remove</code> از آن حذف می‌شود، پیاده‌سازی هر یک از آن‌ها متد خصوصی <code>update_average</code> را فراخوانی می‌کند که به‌روزرسانی فیلد <code>average</code> را مدیریت می‌کند.</p>
<p>ما فیلدهای <code>list</code> و <code>average</code> را خصوصی نگه می‌داریم تا هیچ راهی برای کد خارجی وجود نداشته باشد که مستقیماً آیتم‌ها را به <code>list</code> اضافه یا از آن حذف کند. در غیر این صورت، فیلد <code>average</code> ممکن است با تغییرات <code>list</code> هماهنگ نباشد. متد <code>average</code> مقدار موجود در فیلد <code>average</code> را بازمی‌گرداند و به کد خارجی اجازه می‌دهد تا مقدار میانگین را بخواند اما آن را تغییر ندهد.</p>
<p>از آنجایی که جزئیات پیاده‌سازی ساختار <code>AveragedCollection</code> را کپسوله کرده‌ایم، می‌توانیم به راحتی جنبه‌هایی از آن را در آینده تغییر دهیم. برای مثال، می‌توانیم به جای استفاده از <code>Vec&lt;i32&gt;</code> برای فیلد <code>list</code>، از یک <code>HashSet&lt;i32&gt;</code> استفاده کنیم. تا زمانی که امضای متدهای عمومی <code>add</code>، <code>remove</code> و <code>average</code> یکسان باقی بماند، کدی که از <code>AveragedCollection</code> استفاده می‌کند نیازی به تغییر برای کامپایل شدن نخواهد داشت. اگر <code>list</code> عمومی بود، این موضوع لزوماً صادق نبود: <code>HashSet&lt;i32&gt;</code> و <code>Vec&lt;i32&gt;</code> متدهای متفاوتی برای اضافه کردن و حذف آیتم‌ها دارند، بنابراین کد خارجی احتمالاً باید تغییر کند اگر مستقیماً <code>list</code> را تغییر می‌داد.</p>
<p>اگر کپسوله‌سازی یکی از جنبه‌های ضروری برای در نظر گرفتن یک زبان به عنوان شی‌گرا باشد، Rust این نیاز را برآورده می‌کند. امکان استفاده یا عدم استفاده از <code>pub</code> برای بخش‌های مختلف کد، کپسوله‌سازی جزئیات پیاده‌سازی را ممکن می‌سازد.</p>
<h3 id="وراثت-بهعنوان-سیستم-نوع-و-بهعنوان-اشتراکگذاری-کد"><a class="header" href="#وراثت-بهعنوان-سیستم-نوع-و-بهعنوان-اشتراکگذاری-کد">وراثت به‌عنوان سیستم نوع و به‌عنوان اشتراک‌گذاری کد</a></h3>
<p><em>وراثت</em> مکانیزمی است که به یک شیء اجازه می‌دهد عناصر را از تعریف یک شیء دیگر به ارث ببرد و در نتیجه داده‌ها و رفتار شیء والد را بدون نیاز به تعریف مجدد آن‌ها به دست آورد.</p>
<p>اگر وراثت باید برای یک زبان وجود داشته باشد تا شی‌گرا در نظر گرفته شود، Rust یک زبان شی‌گرا نیست. در Rust، نمی‌توانید یک struct تعریف کنید که فیلدها و پیاده‌سازی متدهای struct والد را بدون استفاده از یک ماکرو به ارث ببرد.</p>
<p>با این حال، اگر به استفاده از وراثت در ابزارهای برنامه‌نویسی خود عادت کرده‌اید، می‌توانید بسته به دلیل خود برای استفاده از وراثت، از راه‌حل‌های دیگری در Rust استفاده کنید.</p>
<p>دو دلیل اصلی برای انتخاب وراثت وجود دارد. یکی برای استفاده مجدد از کد: می‌توانید یک رفتار خاص را برای یک نوع پیاده‌سازی کنید و وراثت این امکان را فراهم می‌کند که از آن پیاده‌سازی برای یک نوع دیگر استفاده مجدد کنید. در Rust، این کار را به صورت محدود با استفاده از پیاده‌سازی‌های پیش‌فرض متدهای صفت (trait) انجام دهید، همان‌طور که در لیستینگ 10-14 دیدیم که یک پیاده‌سازی پیش‌فرض برای متد <code>summarize</code> در صفت <code>Summary</code> اضافه کردیم. هر نوعی که صفت <code>Summary</code> را پیاده‌سازی کند، متد <code>summarize</code> را بدون نیاز به کد اضافی خواهد داشت. این شبیه به این است که یک کلاس والد یک پیاده‌سازی از یک متد داشته باشد و یک کلاس فرزند ارث‌برده نیز آن پیاده‌سازی متد را داشته باشد. همچنین می‌توانیم پیاده‌سازی پیش‌فرض متد <code>summarize</code> را زمانی که صفت <code>Summary</code> را پیاده‌سازی می‌کنیم، بازنویسی کنیم که شبیه به بازنویسی پیاده‌سازی یک متد ارث‌برده شده در کلاس فرزند است.</p>
<p>دلیل دیگر استفاده از وراثت مربوط به سیستم نوع است: برای این که یک نوع فرزند بتواند در همان مکان‌هایی که نوع والد استفاده می‌شود، مورد استفاده قرار گیرد. این مفهوم <em>چندریختی (polymorphism)</em> نیز نامیده می‌شود، که به این معناست که می‌توانید چندین شیء را در زمان اجرا جایگزین یکدیگر کنید اگر آن‌ها ویژگی‌های خاصی را به اشتراک بگذارند.</p>
<section class="note" aria-role="note">
<h3 id="چندریختی-polymorphism"><a class="header" href="#چندریختی-polymorphism">چندریختی (Polymorphism)</a></h3>
<p>برای بسیاری از افراد، چندریختی مترادف با وراثت است. اما در واقع یک مفهوم عمومی‌تر است که به کدی اشاره دارد که می‌تواند با داده‌هایی از انواع مختلف کار کند. در مورد وراثت، این انواع معمولاً زیرکلاس‌ها هستند.</p>
<p>در مقابل، Rust از جنریک‌ها برای انتزاع انواع ممکن مختلف استفاده می‌کند و محدودیت‌های صفت (trait bounds) را برای تحمیل این که این انواع باید چه ویژگی‌هایی ارائه دهند، اعمال می‌کند. این رویکرد گاهی <em>چندریختی پارامتریک محدودشده</em> نامیده می‌شود.</p>
</section>
<p>وراثت اخیراً به‌عنوان یک راه‌حل طراحی برنامه‌نویسی در بسیاری از زبان‌ها محبوبیت خود را از دست داده است زیرا اغلب خطر اشتراک‌گذاری بیش از حد کد را به همراه دارد. زیرکلاس‌ها نباید همیشه تمام ویژگی‌های کلاس والد خود را به اشتراک بگذارند، اما با وراثت این اتفاق می‌افتد. این می‌تواند طراحی برنامه را کمتر انعطاف‌پذیر کند. همچنین امکان فراخوانی متدهایی روی زیرکلاس‌ها را فراهم می‌کند که معنا ندارند یا باعث خطا می‌شوند زیرا متدها برای زیرکلاس اعمال نمی‌شوند. علاوه بر این، برخی زبان‌ها فقط اجازه وراثت تک (single inheritance) را می‌دهند (یعنی یک زیرکلاس فقط می‌تواند از یک کلاس ارث ببرد)، که انعطاف‌پذیری طراحی برنامه را بیشتر محدود می‌کند.</p>
<p>به این دلایل، Rust رویکرد متفاوتی را با استفاده از اشیاء صفت (trait objects) به جای وراثت اتخاذ می‌کند. بیایید ببینیم که چگونه اشیاء صفت در Rust چندریختی را ممکن می‌سازند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="استفاده-از-اشیاء-صفت-برای-مقادیر-با-انواع-مختلف"><a class="header" href="#استفاده-از-اشیاء-صفت-برای-مقادیر-با-انواع-مختلف">استفاده از اشیاء صفت برای مقادیر با انواع مختلف</a></h2>
<p>در فصل 8، اشاره کردیم که یکی از محدودیت‌های وکتورها این است که می‌توانند فقط عناصر یک نوع را ذخیره کنند. در لیستینگ 8-9، راه‌حلی ایجاد کردیم که در آن یک enum به نام <code>SpreadsheetCell</code> تعریف کردیم که انواع مختلفی مانند اعداد صحیح، اعداد اعشاری و متن را در خود جای می‌داد. این به ما اجازه می‌داد داده‌های مختلفی را در هر سلول ذخیره کنیم و همچنان یک وکتور داشته باشیم که نمایانگر یک ردیف از سلول‌ها باشد. این راه‌حل زمانی مناسب است که آیتم‌های قابل تعویض ما مجموعه‌ای ثابت از انواع باشد که هنگام کامپایل کد می‌دانیم.</p>
<p>با این حال، گاهی اوقات می‌خواهیم کاربران کتابخانه ما بتوانند مجموعه‌ای از انواع معتبر در یک وضعیت خاص را گسترش دهند. برای نشان دادن نحوه انجام این کار، یک ابزار رابط کاربری گرافیکی (GUI) نمونه ایجاد می‌کنیم که از طریق یک لیست از آیتم‌ها تکرار می‌کند و متدی به نام <code>draw</code> را برای هر آیتم فراخوانی می‌کند تا آن را روی صفحه رسم کند—یک تکنیک رایج برای ابزارهای GUI. یک crate کتابخانه‌ای به نام <code>gui</code> ایجاد می‌کنیم که ساختار یک کتابخانه GUI را شامل می‌شود. این crate ممکن است شامل برخی انواع باشد که افراد از آن‌ها استفاده کنند، مانند <code>Button</code> یا <code>TextField</code>. علاوه بر این، کاربران <code>gui</code> می‌خواهند انواع خود را که می‌توانند رسم شوند ایجاد کنند: برای مثال، یک برنامه‌نویس ممکن است یک <code>Image</code> اضافه کند و دیگری ممکن است یک <code>SelectBox</code> اضافه کند.</p>
<p>ما برای این مثال یک کتابخانه GUI کامل پیاده‌سازی نخواهیم کرد، اما نشان خواهیم داد که قطعات چگونه به هم متصل می‌شوند. هنگام نوشتن این کتابخانه، نمی‌توانیم تمام انواعی که برنامه‌نویسان دیگر ممکن است بخواهند ایجاد کنند را بدانیم و تعریف کنیم. اما می‌دانیم که <code>gui</code> باید مقادیر زیادی از انواع مختلف را پیگیری کند و باید متدی به نام <code>draw</code> را برای هر یک از این مقادیر با نوع متفاوت فراخوانی کند. نیازی به دانستن دقیق آنچه هنگام فراخوانی متد <code>draw</code> اتفاق می‌افتد نداریم، فقط اینکه مقدار باید این متد را داشته باشد.</p>
<p>برای انجام این کار در یک زبان با وراثت، ممکن است یک کلاس به نام <code>Component</code> تعریف کنیم که یک متد به نام <code>draw</code> داشته باشد. سایر کلاس‌ها، مانند <code>Button</code>، <code>Image</code> و <code>SelectBox</code>، از <code>Component</code> ارث می‌برند و به این ترتیب متد <code>draw</code> را به ارث می‌برند. آن‌ها می‌توانند متد <code>draw</code> را بازنویسی کنند تا رفتار سفارشی خود را تعریف کنند، اما فریم‌ورک می‌تواند تمام این انواع را به گونه‌ای مدیریت کند که گویی نمونه‌هایی از <code>Component</code> هستند و متد <code>draw</code> را روی آن‌ها فراخوانی کند. اما چون Rust وراثت ندارد، باید راه دیگری برای ساختاردهی کتابخانه <code>gui</code> پیدا کنیم تا به کاربران اجازه دهد آن را با انواع جدید گسترش دهند.</p>
<h3 id="تعریف-یک-صفت-برای-رفتار-مشترک"><a class="header" href="#تعریف-یک-صفت-برای-رفتار-مشترک">تعریف یک صفت برای رفتار مشترک</a></h3>
<p>برای پیاده‌سازی رفتاری که می‌خواهیم <code>gui</code> داشته باشد، یک صفت به نام <code>Draw</code> تعریف می‌کنیم که یک متد به نام <code>draw</code> خواهد داشت. سپس می‌توانیم یک وکتور تعریف کنیم که یک <em>شیء صفت</em> را بگیرد. یک شیء صفت به یک نمونه از یک نوع که صفت مشخصی را پیاده‌سازی کرده اشاره می‌کند و همچنین یک جدول برای جستجوی متدهای صفت روی آن نوع در زمان اجرا را شامل می‌شود. برای ایجاد یک شیء صفت، باید نوع اشاره‌گر (Pointer) (مانند یک ارجاع <code>&amp;</code> یا یک اشاره‌گر (Pointer) هوشمند <code>Box&lt;T&gt;</code>)، کلمه کلیدی <code>dyn</code> و سپس صفت مربوطه را مشخص کنیم. (در فصل 20، بخش <a href="ch20-03-advanced-types.html#dynamically-sized-types-and-the-sized-trait">“انواع با اندازه پویا و صفت <code>Sized</code>”</a><!-- ignore --> دلیل اینکه اشیاء صفت باید از یک اشاره‌گر (Pointer) استفاده کنند را توضیح خواهیم داد.) می‌توانیم از اشیاء صفت به جای یک نوع جنریک یا نوع مشخص استفاده کنیم. هر جا که از یک شیء صفت استفاده کنیم، سیستم نوع Rust در زمان کامپایل تضمین می‌کند که هر مقداری که در آن زمینه استفاده شود، صفت شیء صفت را پیاده‌سازی می‌کند. بنابراین نیازی به دانستن تمام انواع ممکن در زمان کامپایل نداریم.</p>
<p>اشاره کردیم که در Rust از استفاده از اصطلاح “اشیاء” برای structها و enumها اجتناب می‌کنیم تا آن‌ها را از اشیاء سایر زبان‌ها متمایز کنیم. در یک struct یا enum، داده‌ها در فیلدهای struct و رفتار در بلوک‌های <code>impl</code> جدا شده‌اند، در حالی که در سایر زبان‌ها داده‌ها و رفتار معمولاً در یک مفهوم واحد به نام شیء ترکیب می‌شوند. اما اشیاء صفت در Rust بیشتر شبیه اشیاء در سایر زبان‌ها هستند، زیرا داده‌ها و رفتار را ترکیب می‌کنند. با این حال، اشیاء صفت از اشیاء سنتی متفاوت هستند زیرا نمی‌توان داده‌ای به یک شیء صفت اضافه کرد. اشیاء صفت به اندازه اشیاء در سایر زبان‌ها عمومی نیستند: هدف خاص آن‌ها فراهم کردن انتزاع در رفتار مشترک است.</p>
<p>لیستینگ 18-3 نشان می‌دهد چگونه می‌توان یک صفت به نام <code>Draw</code> با یک متد به نام <code>draw</code> تعریف کرد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<figcaption>Listing 18-3: Definition of the <code>Draw</code> trait</figcaption>
</figure>
<p>این نحو باید از بحث‌های ما در فصل 10 در مورد نحوه تعریف صفات آشنا باشد. حالا به نحو جدیدی می‌رسیم: لیستینگ 18-4 یک ساختار به نام <code>Screen</code> را تعریف می‌کند که یک بردار به نام <code>components</code> دارد. این بردار از نوع <code>Box&lt;dyn Draw&gt;</code> است، که یک شیء صفت است؛ این به‌عنوان جایگزینی برای هر نوع داخل یک <code>Box</code> که صفت <code>Draw</code> را پیاده‌سازی کرده عمل می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<figcaption>Listing 18-4: تعریف ساختار <code>Screen</code> با یک فیلد <code>components</code> که یک بردار از اشیاء صفت را نگه می‌دارد که صفت <code>Draw</code> را پیاده‌سازی کرده‌اند</figcaption>
</figure>
<p>روی ساختار <code>Screen</code>، متدی به نام <code>run</code> تعریف می‌کنیم که متد <code>draw</code> را روی هر یک از <code>components</code> خود فراخوانی می‌کند، همان‌طور که در لیستینگ 18-5 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption>Listing 18-5: متد <code>run</code> روی <code>Screen</code> که متد <code>draw</code> را روی هر کامپوننت فراخوانی می‌کند</figcaption>
</figure>
<p>این روش متفاوت از تعریف ساختاری است که از یک پارامتر نوع جنریک با محدودیت‌های صفت استفاده می‌کند. یک پارامتر نوع جنریک فقط می‌تواند یک نوع مشخص را در هر زمان جایگزین کند، در حالی که اشیاء صفت به ما اجازه می‌دهند چندین نوع مشخص را در زمان اجرا به جای اشیاء صفت قرار دهیم. برای مثال، می‌توانستیم ساختار <code>Screen</code> را با استفاده از یک نوع جنریک و یک محدودیت صفت به صورت لیستینگ 18-6 تعریف کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption>Listing 18-6: یک پیاده‌سازی جایگزین برای ساختار <code>Screen</code> و متد <code>run</code> آن با استفاده از جنریک‌ها و محدودیت‌های صفت</figcaption>
</figure>
<p>این روش ما را محدود به یک نمونه <code>Screen</code> می‌کند که لیستی از کامپوننت‌ها همه از نوع <code>Button</code> یا همه از نوع <code>TextField</code> داشته باشد. اگر فقط مجموعه‌های همگن داشته باشید، استفاده از جنریک‌ها و محدودیت‌های صفت ترجیح داده می‌شود زیرا این تعاریف در زمان کامپایل با استفاده از انواع مشخص مونومورفیزه می‌شوند.</p>
<p>از طرف دیگر، با استفاده از روش مبتنی بر اشیاء صفت، یک نمونه <code>Screen</code> می‌تواند یک <code>Vec&lt;T&gt;</code> داشته باشد که شامل یک <code>Box&lt;Button&gt;</code> و همچنین یک <code>Box&lt;TextField&gt;</code> باشد. بیایید ببینیم که چگونه این کار می‌کند، سپس درباره پیامدهای عملکرد در زمان اجرا صحبت کنیم.</p>
<h3 id="پیادهسازی-صفت"><a class="header" href="#پیادهسازی-صفت">پیاده‌سازی صفت</a></h3>
<p>حالا برخی از انواعی که صفت <code>Draw</code> را پیاده‌سازی می‌کنند اضافه می‌کنیم. نوع <code>Button</code> را ارائه می‌دهیم. دوباره، پیاده‌سازی یک کتابخانه GUI کامل فراتر از محدوده این کتاب است، بنابراین متد <code>draw</code> هیچ پیاده‌سازی مفیدی در بدنه خود نخواهد داشت. برای تصور اینکه پیاده‌سازی ممکن است چگونه باشد، یک ساختار <code>Button</code> ممکن است فیلدهایی برای <code>width</code>، <code>height</code> و <code>label</code> داشته باشد، همان‌طور که در لیستینگ 18-7 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<figcaption>Listing 18-7: یک ساختار <code>Button</code> که صفت <code>Draw</code> را پیاده‌سازی می‌کند</figcaption>
</figure>
<p>فیلدهای <code>width</code>، <code>height</code> و <code>label</code> در <code>Button</code> با فیلدهای کامپوننت‌های دیگر متفاوت خواهند بود. برای مثال، یک نوع <code>TextField</code> ممکن است همان فیلدها به‌علاوه یک فیلد <code>placeholder</code> داشته باشد. هر یک از انواعی که می‌خواهیم روی صفحه رسم شوند، صفت <code>Draw</code> را پیاده‌سازی می‌کنند اما از کد متفاوتی در متد <code>draw</code> برای تعریف نحوه رسم آن نوع خاص استفاده می‌کنند، همان‌طور که در اینجا برای <code>Button</code> آمده است (بدون کد GUI واقعی، همان‌طور که ذکر شد). نوع <code>Button</code>، برای مثال، ممکن است یک بلوک <code>impl</code> اضافی شامل متدهایی مرتبط با آنچه هنگام کلیک کاربر روی دکمه اتفاق می‌افتد داشته باشد. این نوع متدها برای انواعی مانند <code>TextField</code> اعمال نمی‌شوند.</p>
<p>اگر کسی که از کتابخانه ما استفاده می‌کند تصمیم بگیرد یک ساختار <code>SelectBox</code> با فیلدهای <code>width</code>، <code>height</code> و <code>options</code> پیاده‌سازی کند، می‌تواند صفت <code>Draw</code> را روی نوع <code>SelectBox</code> نیز پیاده‌سازی کند، همان‌طور که در لیستینگ 18-8 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption>Listing 18-8: یک crate دیگر که از <code>gui</code> استفاده می‌کند و صفت <code>Draw</code> را روی یک ساختار <code>SelectBox</code> پیاده‌سازی می‌کند</figcaption>
</figure>
<p>اکنون کاربر کتابخانه ما می‌تواند تابع <code>main</code> خود را بنویسد تا یک نمونه <code>Screen</code> ایجاد کند. به نمونه <code>Screen</code>، آن‌ها می‌توانند یک <code>SelectBox</code> و یک <code>Button</code> اضافه کنند، با قرار دادن هر یک در یک <code>Box&lt;T&gt;</code> تا به یک شیء صفت تبدیل شوند. سپس می‌توانند متد <code>run</code> را روی نمونه <code>Screen</code> فراخوانی کنند، که متد <code>draw</code> را روی هر یک از کامپوننت‌ها فراخوانی می‌کند. لیستینگ 18-9 این پیاده‌سازی را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
<figcaption>Listing 18-9: استفاده از اشیاء صفت برای ذخیره مقادیری با انواع مختلف که یک صفت یکسان را پیاده‌سازی می‌کنند</figcaption>
</figure>
<p>وقتی کتابخانه را نوشتیم، نمی‌دانستیم که کسی ممکن است نوع <code>SelectBox</code> را اضافه کند، اما پیاده‌سازی <code>Screen</code> ما توانست روی نوع جدید عمل کند و آن را رسم کند زیرا <code>SelectBox</code> صفت <code>Draw</code> را پیاده‌سازی کرده است، که به این معناست که متد <code>draw</code> را پیاده‌سازی کرده است.</p>
<p>این مفهوم—فقط به پیام‌هایی که یک مقدار به آن‌ها پاسخ می‌دهد اهمیت داده می‌شود، نه نوع دقیق مقدار—مشابه مفهوم <em>duck typing</em> در زبان‌های با نوع‌دهی پویا است: اگر مانند اردک حرکت می‌کند و مانند اردک صدا می‌کند، پس حتماً یک اردک است! در پیاده‌سازی متد <code>run</code> روی <code>Screen</code> در لیستینگ 18-5، <code>run</code> نیازی ندارد بداند نوع دقیق هر کامپوننت چیست. نیازی ندارد بررسی کند که آیا یک کامپوننت نمونه‌ای از <code>Button</code> یا <code>SelectBox</code> است؛ فقط متد <code>draw</code> را روی کامپوننت فراخوانی می‌کند. با مشخص کردن <code>Box&lt;dyn Draw&gt;</code> به‌عنوان نوع مقادیر در بردار <code>components</code>، ما تعریف کرده‌ایم که <code>Screen</code> به مقادیری نیاز دارد که بتوانیم متد <code>draw</code> را روی آن‌ها فراخوانی کنیم.</p>
<p>مزیت استفاده از اشیاء صفت و سیستم نوع Rust برای نوشتن کدی مشابه با duck typing این است که هرگز نیازی به بررسی نداریم که آیا یک مقدار متدی خاص را در زمان اجرا پیاده‌سازی کرده است یا خیر، یا نگران خطاهایی باشیم اگر یک مقدار متدی را پیاده‌سازی نکرده اما ما آن را فراخوانی کنیم. Rust کد ما را کامپایل نمی‌کند اگر مقادیر صفاتی را که اشیاء صفت نیاز دارند پیاده‌سازی نکنند.</p>
<p>برای مثال، لیستینگ 18-10 نشان می‌دهد چه اتفاقی می‌افتد اگر بخواهیم یک <code>Screen</code> با یک <code>String</code> به‌عنوان یک کامپوننت ایجاد کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}</code></pre>
<figcaption>Listing 18-10: تلاش برای استفاده از نوعی که صفت شیء صفت را پیاده‌سازی نکرده است</figcaption>
</figure>
<p>ما این خطا را دریافت خواهیم کرد زیرا <code>String</code> صفت <code>Draw</code> را پیاده‌سازی نکرده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>این خطا به ما می‌گوید یا چیزی را به <code>Screen</code> ارسال می‌کنیم که قصد نداشتیم ارسال کنیم و بنابراین باید نوع دیگری را ارسال کنیم یا باید <code>Draw</code> را روی <code>String</code> پیاده‌سازی کنیم تا <code>Screen</code> بتواند متد <code>draw</code> را روی آن فراخوانی کند.</p>
<h3 id="اشیاء-صفت-اجرای-dispatch-پویا-را-انجام-میدهند"><a class="header" href="#اشیاء-صفت-اجرای-dispatch-پویا-را-انجام-میدهند">اشیاء صفت اجرای Dispatch پویا را انجام می‌دهند</a></h3>
<p>به یاد بیاورید که در بخش <a href="ch10-01-syntax.html#performance-of-code-using-generics">“عملکرد کد با استفاده از جنریک‌ها”</a><!-- ignore --> در فصل 10 بحث کردیم که کامپایلر فرایند مونومورفیزه کردن را روی جنریک‌ها انجام می‌دهد: کامپایلر پیاده‌سازی‌های غیربنریک از توابع و متدها را برای هر نوع مشخصی که به جای یک پارامتر نوع جنریک استفاده می‌کنیم، تولید می‌کند. کدی که از مونومورفیزه کردن به دست می‌آید، <em>dispatch استاتیک</em> انجام می‌دهد، به این معنا که کامپایلر در زمان کامپایل می‌داند کدام متد را فراخوانی می‌کنید. این برخلاف <em>dispatch پویا</em> است، که در آن کامپایلر نمی‌تواند در زمان کامپایل تشخیص دهد کدام متد را فراخوانی می‌کنید. در موارد dispatch پویا، کامپایلر کدی تولید می‌کند که در زمان اجرا تشخیص می‌دهد کدام متد باید فراخوانی شود.</p>
<p>وقتی از اشیاء صفت استفاده می‌کنیم، Rust مجبور است از dispatch پویا استفاده کند. کامپایلر نمی‌داند که چه نوع‌هایی ممکن است با کدی که از اشیاء صفت استفاده می‌کند، استفاده شوند، بنابراین نمی‌داند کدام متد پیاده‌سازی‌شده روی کدام نوع را باید فراخوانی کند. در عوض، در زمان اجرا، Rust از اشاره‌گر (Pointer)های داخل شیء صفت استفاده می‌کند تا بداند کدام متد را باید فراخوانی کند. این جستجو هزینه زمان اجرایی به همراه دارد که با dispatch استاتیک اتفاق نمی‌افتد. dispatch پویا همچنین از این جلوگیری می‌کند که کامپایلر کد یک متد را inline کند، که به نوبه خود از برخی بهینه‌سازی‌ها جلوگیری می‌کند. Rust همچنین قوانینی دارد که مشخص می‌کنند کجا می‌توانید و کجا نمی‌توانید از dispatch پویا استفاده کنید، که به <a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility"><em>سازگاری dyn</em></a> معروف است. با این حال، ما در کدی که در لیستینگ 18-5 نوشتیم و توانستیم در لیستینگ 18-9 پشتیبانی کنیم، انعطاف‌پذیری بیشتری به دست آوردیم، بنابراین این موضوع یک موازنه است که باید مورد توجه قرار گیرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="پیادهسازی-یک-الگوی-طراحی-شیگرا"><a class="header" href="#پیادهسازی-یک-الگوی-طراحی-شیگرا">پیاده‌سازی یک الگوی طراحی شی‌گرا</a></h2>
<p><em>الگوی وضعیت</em> یک الگوی طراحی شی‌گرا است. هسته این الگو این است که مجموعه‌ای از وضعیت‌ها را که یک مقدار می‌تواند
به‌طور داخلی داشته باشد، تعریف کنیم. این وضعیت‌ها با مجموعه‌ای از <em>اشیای وضعیت</em> نمایش داده می‌شوند و رفتار مقدار
بر اساس وضعیت آن تغییر می‌کند. قصد داریم مثالی از یک ساختار blog post (پست وبلاگ) را بررسی کنیم که یک فیلد برای
نگه‌داشتن وضعیت دارد. این وضعیت یک شیء از مجموعه “پیش‌نویس” (draft)، “در حال بررسی” (review)، یا “منتشرشده”
(published) خواهد بود.</p>
<p>اشیای وضعیت قابلیت‌هایی را به اشتراک می‌گذارند: در Rust، البته، ما از ساختارها (structs) و صفت‌ها (traits) به جای
اشیا و ارث‌بری استفاده می‌کنیم. هر شیء وضعیت مسئول رفتار خود و مدیریت زمانی است که باید به وضعیت دیگری تغییر کند.
مقداری که یک شیء وضعیت را نگه می‌دارد، هیچ اطلاعی از رفتارهای مختلف وضعیت‌ها یا زمان تغییر وضعیت ندارد.</p>
<p>مزیت استفاده از الگوی وضعیت این است که وقتی نیازهای تجاری برنامه تغییر می‌کنند، نیازی به تغییر کد مقداری که وضعیت
را نگه می‌دارد یا کدی که از آن مقدار استفاده می‌کند، نداریم. تنها لازم است کد داخل یکی از اشیای وضعیت را برای تغییر
قوانین آن یا شاید اضافه کردن اشیای وضعیت جدید به‌روزرسانی کنیم.</p>
<p>ابتدا الگوی وضعیت را به روش سنتی شی‌گرایی پیاده‌سازی می‌کنیم، سپس از رویکردی که در Rust طبیعی‌تر است استفاده خواهیم
کرد. بیایید به‌صورت مرحله‌به‌مرحله پیاده‌سازی یک فرآیند کاری پست وبلاگ با استفاده از الگوی وضعیت را بررسی کنیم.</p>
<p>قابلیت نهایی به این شکل خواهد بود:</p>
<ol>
<li>یک پست وبلاگ به‌صورت یک پیش‌نویس خالی شروع می‌شود.</li>
<li>وقتی پیش‌نویس تمام شد، بررسی پست درخواست می‌شود.</li>
<li>وقتی پست تأیید شد، منتشر می‌شود.</li>
<li>تنها پست‌های وبلاگی که منتشر شده‌اند متن را برای چاپ بازمی‌گردانند، بنابراین پست‌های تأییدنشده نمی‌توانند به‌طور
تصادفی منتشر شوند.</li>
</ol>
<p>هر تغییر دیگری که روی یک پست تلاش شود نباید تأثیری داشته باشد. برای مثال، اگر بخواهیم یک پست وبلاگ پیش‌نویس را
قبل از درخواست بررسی تأیید کنیم، پست باید به‌عنوان پیش‌نویس منتشرنشده باقی بماند.</p>
<p>لیستینگ 18-11 این فرآیند کاری را به‌صورت کدی نشان می‌دهد: این یک نمونه از استفاده از API است که قصد داریم در یک
crate کتابخانه‌ای به نام <code>blog</code> پیاده‌سازی کنیم. این کد هنوز کامپایل نخواهد شد زیرا هنوز crate <code>blog</code> را پیاده‌سازی
نکرده‌ایم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption>Listing 18-11: کدی که رفتار مورد نظر ما برای crate <code>blog</code> را نشان می‌دهد</figcaption>
</figure>
<p>ما می‌خواهیم به کاربر اجازه دهیم یک پست وبلاگ پیش‌نویس جدید با <code>Post::new</code> ایجاد کند. می‌خواهیم امکان اضافه کردن
متن به پست وبلاگ را فراهم کنیم. اگر فوراً بخواهیم محتوای پست را دریافت کنیم، قبل از تأیید، نباید هیچ متنی دریافت
کنیم، زیرا پست هنوز یک پیش‌نویس است. ما از <code>assert_eq!</code> در کد برای اهداف نمایشی استفاده کرده‌ایم. یک تست واحد عالی
برای این مورد این است که تأیید کنیم یک پست وبلاگ پیش‌نویس یک رشته خالی از متد <code>content</code> بازمی‌گرداند، اما قصد نداریم
برای این مثال تست بنویسیم.</p>
<p>سپس می‌خواهیم امکان درخواست بررسی برای پست فراهم شود و می‌خواهیم <code>content</code> در حین انتظار برای بررسی یک رشته خالی
بازگرداند. وقتی پست تأیید شود، باید منتشر شود، به این معنی که متن پست هنگام فراخوانی <code>content</code> بازگردانده خواهد شد.</p>
<p>توجه داشته باشید که تنها نوعی که از crate تعامل داریم، نوع <code>Post</code> است. این نوع از الگوی وضعیت استفاده خواهد کرد و
مقداری نگه می‌دارد که یکی از سه شیء وضعیت نمایش‌دهنده وضعیت‌های مختلف یک پست باشد—پیش‌نویس، در انتظار بررسی، یا
منتشرشده. تغییر از یک وضعیت به وضعیت دیگر به‌صورت داخلی در نوع <code>Post</code> مدیریت می‌شود. تغییر وضعیت‌ها در پاسخ به
متدهایی که کاربران کتابخانه ما روی نمونه <code>Post</code> فراخوانی می‌کنند اتفاق می‌افتد، اما کاربران مجبور نیستند تغییر
وضعیت‌ها را مستقیماً مدیریت کنند. همچنین، کاربران نمی‌توانند در مورد وضعیت‌ها اشتباه کنند، مانند انتشار یک پست قبل
از بررسی آن.</p>
<h3 id="تعریف-post-و-ایجاد-یک-نمونه-جدید-در-وضعیت-پیشنویس"><a class="header" href="#تعریف-post-و-ایجاد-یک-نمونه-جدید-در-وضعیت-پیشنویس">تعریف <code>Post</code> و ایجاد یک نمونه جدید در وضعیت پیش‌نویس</a></h3>
<p>بیایید پیاده‌سازی کتابخانه را شروع کنیم! می‌دانیم که به یک ساختار <code>Post</code> عمومی نیاز داریم که مقداری محتوا را نگه
می‌دارد، بنابراین با تعریف این ساختار و یک تابع مرتبط <code>new</code> عمومی برای ایجاد یک نمونه از <code>Post</code> شروع می‌کنیم. این
تعاریف در لیستینگ 18-12 آمده‌اند. همچنین، یک صفت خصوصی <code>State</code> ایجاد خواهیم کرد که رفتاری را که تمام اشیای وضعیت
برای <code>Post</code> باید داشته باشند تعریف می‌کند.</p>
<p>سپس، <code>Post</code> یک شیء صفت <code>Box&lt;dyn State&gt;</code> را درون یک <code>Option&lt;T&gt;</code> در یک فیلد خصوصی به نام <code>state</code> نگه خواهد داشت تا
شیء وضعیت را مدیریت کند. در ادامه خواهید دید که چرا <code>Option&lt;T&gt;</code> ضروری است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<figcaption>Listing 18-12: تعریف یک ساختار <code>Post</code> و یک تابع <code>new</code> که یک نمونه جدید از <code>Post</code> ایجاد می‌کند، یک صفت <code>State</code>، و یک ساختار <code>Draft</code></figcaption>
</figure>
<p>صفت <code>State</code> رفتاری را که وضعیت‌های مختلف پست‌ها به اشتراک می‌گذارند تعریف می‌کند. اشیای وضعیت شامل <code>Draft</code>,
<code>PendingReview</code> و <code>Published</code> هستند و همه آن‌ها صفت <code>State</code> را پیاده‌سازی خواهند کرد. فعلاً صفت هیچ متدی ندارد و
ما با تعریف تنها وضعیت <code>Draft</code> شروع می‌کنیم، زیرا این وضعیت است که می‌خواهیم پست در آن شروع شود.</p>
<p>وقتی یک <code>Post</code> جدید ایجاد می‌کنیم، فیلد <code>state</code> آن را به یک مقدار <code>Some</code> تنظیم می‌کنیم که یک <code>Box</code> را نگه می‌دارد.
این <code>Box</code> به یک نمونه جدید از ساختار <code>Draft</code> اشاره می‌کند. این کار تضمین می‌کند که هرگاه یک نمونه جدید از <code>Post</code>
ایجاد شود، به‌عنوان یک پیش‌نویس شروع شود. از آنجا که فیلد <code>state</code> در <code>Post</code> خصوصی است، هیچ راهی برای ایجاد یک
<code>Post</code> در وضعیت دیگری وجود ندارد! در تابع <code>Post::new</code>، فیلد <code>content</code> را به یک <code>String</code> جدید و خالی تنظیم
می‌کنیم.</p>
<h3 id="ذخیره-متن-محتوای-پست"><a class="header" href="#ذخیره-متن-محتوای-پست">ذخیره متن محتوای پست</a></h3>
<p>در لیستینگ 18-11 دیدیم که می‌خواهیم بتوانیم یک متد به نام <code>add_text</code> فراخوانی کنیم و یک <code>&amp;str</code> به آن بدهیم که به
عنوان محتوای متنی پست وبلاگ اضافه شود. این کار را به‌صورت یک متد پیاده‌سازی می‌کنیم تا فیلد <code>content</code> را به‌جای
تعریف آن به‌صورت <code>pub</code> کنترل کنیم و بتوانیم در آینده متدی برای کنترل چگونگی خواندن داده فیلد <code>content</code>
پیاده‌سازی کنیم. متد <code>add_text</code> نسبتاً ساده است، بنابراین بیایید پیاده‌سازی آن را به بلوک <code>impl Post</code> در لیستینگ
18-13 اضافه کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption>Listing 18-13: پیاده‌سازی متد <code>add_text</code> برای افزودن متن به <code>content</code> یک پست</figcaption>
</figure>
<p>متد <code>add_text</code> یک ارجاع متغیر به <code>self</code> می‌گیرد، زیرا در حال تغییر نمونه <code>Post</code> هستیم که <code>add_text</code> روی آن فراخوانی
شده است. سپس، متد <code>push_str</code> را روی <code>String</code> موجود در <code>content</code> فراخوانی می‌کنیم و آرگومان <code>text</code> را برای افزودن
به محتوای ذخیره‌شده به آن می‌دهیم. این رفتار به وضعیتی که پست در آن قرار دارد وابسته نیست، بنابراین بخشی از الگوی
وضعیت نیست. متد <code>add_text</code> هیچ تعاملی با فیلد <code>state</code> ندارد، اما بخشی از رفتاری است که می‌خواهیم پشتیبانی کنیم.</p>
<h3 id="اطمینان-از-خالی-بودن-محتوای-یک-پست-پیشنویس"><a class="header" href="#اطمینان-از-خالی-بودن-محتوای-یک-پست-پیشنویس">اطمینان از خالی بودن محتوای یک پست پیش‌نویس</a></h3>
<p>حتی پس از فراخوانی <code>add_text</code> و افزودن محتوایی به پست، همچنان می‌خواهیم متد <code>content</code> یک برش رشته خالی بازگرداند،
زیرا پست هنوز در وضعیت پیش‌نویس است، همان‌طور که در خط 7 لیستینگ 18-11 نشان داده شده است. فعلاً متد <code>content</code> را
با ساده‌ترین چیزی که این نیاز را برآورده می‌کند پیاده‌سازی می‌کنیم: همیشه بازگرداندن یک برش رشته خالی. بعداً این را
تغییر خواهیم داد تا قابلیت تغییر وضعیت پست به حالت منتشرشده را اضافه کنیم. تاکنون، پست‌ها فقط می‌توانند در وضعیت
پیش‌نویس باشند، بنابراین محتوای پست باید همیشه خالی باشد. لیستینگ 18-14 این پیاده‌سازی موقت را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption>Listing 18-14: افزودن یک پیاده‌سازی موقت برای متد <code>content</code> در <code>Post</code> که همیشه یک برش رشته خالی بازمی‌گرداند</figcaption>
</figure>
<p>با افزودن این متد <code>content</code>، تمام موارد تا خط 7 لیستینگ 18-11 به درستی کار می‌کنند.</p>
<h3 id="درخواست-بررسی-پست-و-تغییر-وضعیت-آن"><a class="header" href="#درخواست-بررسی-پست-و-تغییر-وضعیت-آن">درخواست بررسی پست و تغییر وضعیت آن</a></h3>
<p>در مرحله بعد، باید قابلیت درخواست بررسی پست را اضافه کنیم، که باید وضعیت آن را از <code>Draft</code> به <code>PendingReview</code>
تغییر دهد. لیستینگ 18-15 این کد را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption>Listing 18-15: پیاده‌سازی متدهای <code>request_review</code> برای <code>Post</code> و صفت <code>State</code></figcaption>
</figure>
<p>ما یک متد عمومی به نام <code>request_review</code> به <code>Post</code> اضافه می‌کنیم که یک ارجاع متغیر به <code>self</code> می‌گیرد. سپس یک متد
داخلی <code>request_review</code> را روی وضعیت فعلی <code>Post</code> فراخوانی می‌کنیم، و این متد دوم وضعیت فعلی را مصرف کرده و یک وضعیت
جدید بازمی‌گرداند.</p>
<p>ما متد <code>request_review</code> را به صفت <code>State</code> اضافه می‌کنیم؛ تمام انواعی که این صفت را پیاده‌سازی می‌کنند اکنون باید
متد <code>request_review</code> را پیاده‌سازی کنند. توجه داشته باشید که به جای <code>self</code>، <code>&amp;self</code> یا <code>&amp;mut self</code> به‌عنوان اولین
پارامتر متد، از <code>self: Box&lt;Self&gt;</code> استفاده کرده‌ایم. این نحو به این معنی است که متد فقط زمانی معتبر است که روی
یک <code>Box</code> نگه‌دارنده نوع فراخوانی شود. این نحو مالکیت <code>Box&lt;Self&gt;</code> را می‌گیرد و وضعیت قدیمی را باطل می‌کند تا مقدار
وضعیت <code>Post</code> بتواند به یک وضعیت جدید تبدیل شود.</p>
<p>برای مصرف وضعیت قدیمی، متد <code>request_review</code> نیاز به گرفتن مالکیت مقدار وضعیت دارد. اینجاست که <code>Option</code> در فیلد
<code>state</code> از <code>Post</code> وارد عمل می‌شود: ما متد <code>take</code> را فراخوانی می‌کنیم تا مقدار <code>Some</code> را از فیلد <code>state</code> خارج کرده
و یک مقدار <code>None</code> به جای آن قرار دهیم، زیرا Rust به ما اجازه نمی‌دهد فیلدهای ساختار را بدون مقدار رها کنیم. این
کار به ما امکان می‌دهد مقدار <code>state</code> را از <code>Post</code> منتقل کنیم، نه اینکه آن را قرض بگیریم. سپس مقدار <code>state</code> پست را
به نتیجه این عملیات تنظیم خواهیم کرد.</p>
<p>باید به‌طور موقت <code>state</code> را به <code>None</code> تنظیم کنیم، نه اینکه مستقیماً آن را با کدی مانند
<code>self.state = self.state.request_review();</code> تنظیم کنیم، تا مالکیت مقدار <code>state</code> را بدست آوریم. این کار اطمینان
می‌دهد که <code>Post</code> نمی‌تواند از مقدار قدیمی <code>state</code> پس از تبدیل آن به یک وضعیت جدید استفاده کند.</p>
<p>متد <code>request_review</code> در <code>Draft</code> یک نمونه جدید از ساختار <code>PendingReview</code> را که نشان‌دهنده وضعیت زمانی است که یک
پست منتظر بررسی است بازمی‌گرداند. ساختار <code>PendingReview</code> نیز متد <code>request_review</code> را پیاده‌سازی می‌کند، اما هیچ
تبدیلی انجام نمی‌دهد. بلکه خودش را بازمی‌گرداند، زیرا وقتی برای یک پست در وضعیت <code>PendingReview</code> درخواست بررسی
می‌کنیم، باید در همان وضعیت باقی بماند.</p>
<p>اکنون می‌توانیم مزایای الگوی وضعیت را مشاهده کنیم: متد <code>request_review</code> در <code>Post</code> بدون توجه به مقدار <code>state</code> آن
یکسان است. هر وضعیت مسئول قوانین خاص خود است.</p>
<p>ما متد <code>content</code> در <code>Post</code> را به همان صورت باقی می‌گذاریم که یک برش رشته خالی بازمی‌گرداند. اکنون می‌توانیم
یک <code>Post</code> در وضعیت <code>PendingReview</code> و همچنین در وضعیت <code>Draft</code> داشته باشیم، اما می‌خواهیم همان رفتار در وضعیت
<code>PendingReview</code> نیز باشد. لیستینگ 18-11 اکنون تا خط 10 کار می‌کند!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="افزودن-approve-برای-تغییر-رفتار-content"><a class="header" href="#افزودن-approve-برای-تغییر-رفتار-content">افزودن <code>approve</code> برای تغییر رفتار <code>content</code></a></h3>
<p>متد <code>approve</code> شبیه متد <code>request_review</code> خواهد بود: این متد مقدار <code>state</code> را به مقداری تنظیم می‌کند که وضعیت فعلی هنگام
تأیید باید داشته باشد، همان‌طور که در لیستینگ 18-16 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption>Listing 18-16: پیاده‌سازی متد <code>approve</code> در <code>Post</code> و صفت <code>State</code></figcaption>
</figure>
<p>ما متد <code>approve</code> را به صفت <code>State</code> اضافه می‌کنیم و یک ساختار جدید که صفت <code>State</code> را پیاده‌سازی می‌کند، یعنی وضعیت
<code>Published</code>، اضافه می‌کنیم.</p>
<p>مشابه کاری که <code>request_review</code> در <code>PendingReview</code> انجام می‌دهد، اگر متد <code>approve</code> را روی یک <code>Draft</code> فراخوانی کنیم،
هیچ تأثیری نخواهد داشت زیرا <code>approve</code> مقدار <code>self</code> را بازمی‌گرداند. وقتی <code>approve</code> را روی <code>PendingReview</code> فراخوانی
می‌کنیم، یک نمونه جدید از ساختار <code>Published</code> که در یک <code>Box</code> قرار دارد، بازمی‌گرداند. ساختار <code>Published</code> صفت
<code>State</code> را پیاده‌سازی می‌کند، و برای متدهای <code>request_review</code> و <code>approve</code> خودش را بازمی‌گرداند، زیرا در این موارد
پست باید در وضعیت <code>Published</code> باقی بماند.</p>
<p>اکنون باید متد <code>content</code> در <code>Post</code> را به‌روزرسانی کنیم. می‌خواهیم مقدار بازگشتی از <code>content</code> به وضعیت فعلی <code>Post</code>
بستگی داشته باشد، بنابراین می‌خواهیم <code>Post</code> این وظیفه را به متد <code>content</code> تعریف‌شده در وضعیت خود واگذار کند، همان‌طور
که در لیستینگ 18-17 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 18-17: به‌روزرسانی متد <code>content</code> در <code>Post</code> برای ارجاع به متد <code>content</code> در <code>State</code></figcaption>
</figure>
<p>چون هدف این است که تمام این قوانین در داخل ساختارهایی که صفت <code>State</code> را پیاده‌سازی می‌کنند باقی بماند، ما یک متد
<code>content</code> را روی مقدار <code>state</code> فراخوانی می‌کنیم و نمونه پست (یعنی <code>self</code>) را به‌عنوان آرگومان به آن می‌دهیم. سپس
مقداری که از متد <code>content</code> روی مقدار <code>state</code> بازمی‌گردد را بازمی‌گردانیم.</p>
<p>ما متد <code>as_ref</code> را روی <code>Option</code> فراخوانی می‌کنیم زیرا می‌خواهیم یک ارجاع به مقدار داخل <code>Option</code> داشته باشیم، نه
مالکیت مقدار. چون <code>state</code> یک <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> است، وقتی <code>as_ref</code> را فراخوانی می‌کنیم، یک
<code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> بازمی‌گردد. اگر <code>as_ref</code> را فراخوانی نکنیم، با یک خطا مواجه می‌شویم زیرا نمی‌توانیم
<code>state</code> را از <code>&amp;self</code> که به‌عنوان پارامتر به تابع داده شده است خارج کنیم.</p>
<p>سپس متد <code>unwrap</code> را فراخوانی می‌کنیم که می‌دانیم هرگز وحشت (panic) نخواهد کرد، زیرا می‌دانیم متدهای <code>Post</code>
تضمین می‌کنند که <code>state</code> همیشه یک مقدار <code>Some</code> دارد وقتی این متدها کارشان را تمام می‌کنند. این یکی از مواردی است
که در بخش <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“مواردی که شما اطلاعات بیشتری نسبت به کامپایلر دارید”</a><!-- ignore --> در فصل 9
در مورد آن صحبت کردیم، زمانی که می‌دانیم یک مقدار <code>None</code> هرگز ممکن نیست، حتی اگر کامپایلر نتواند این موضوع را
درک کند.</p>
<p>در این مرحله، وقتی <code>content</code> را روی <code>&amp;Box&lt;dyn State&gt;</code> فراخوانی می‌کنیم، تبدیل خودکار به نوع ارجاع (<code>deref coercion</code>)
روی <code>&amp;</code> و <code>Box</code> اعمال می‌شود تا متد <code>content</code> در نهایت روی نوعی که صفت <code>State</code> را پیاده‌سازی می‌کند، فراخوانی شود.
این بدان معناست که باید <code>content</code> را به تعریف صفت <code>State</code> اضافه کنیم، و اینجا جایی است که منطق مربوط به بازگرداندن
محتوا بر اساس وضعیت فعلی قرار خواهد گرفت، همان‌طور که در لیستینگ 18-18 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<figcaption>Listing 18-18: Adding the <code>content</code> method to the <code>State</code> trait</figcaption>
</figure>
<p>ما برای متد <code>content</code> یک پیاده‌سازی پیش‌فرض اضافه می‌کنیم که یک برش رشته خالی بازمی‌گرداند. این کار باعث می‌شود
نیازی به پیاده‌سازی <code>content</code> روی ساختارهای <code>Draft</code> و <code>PendingReview</code> نداشته باشیم. ساختار <code>Published</code> متد
<code>content</code> را بازنویسی کرده و مقدار موجود در <code>post.content</code> را بازمی‌گرداند.</p>
<p>توجه داشته باشید که برای این متد نیاز به حاشیه‌نویسی طول عمر داریم، همان‌طور که در فصل 10 توضیح داده شد. چون یک
ارجاع به یک <code>post</code> را به‌عنوان آرگومان می‌گیریم و یک ارجاع به بخشی از آن <code>post</code> را بازمی‌گردانیم، طول عمر ارجاع
بازگشتی به طول عمر آرگومان <code>post</code> مرتبط است.</p>
<p>و تمام—اکنون تمام لیستینگ 18-11 کار می‌کند! ما الگوی وضعیت را با قوانین مربوط به فرآیند کاری پست وبلاگ پیاده‌سازی
کرده‌ایم. منطق مربوط به قوانین در اشیای وضعیت قرار دارد، نه اینکه در سراسر <code>Post</code> پراکنده باشد.</p>
<section class="note" aria-role="note">
<h4 id="چرا-از-enum-استفاده-نکردیم"><a class="header" href="#چرا-از-enum-استفاده-نکردیم">چرا از Enum استفاده نکردیم؟</a></h4>
<p>ممکن است این سؤال برای شما پیش آمده باشد که چرا از یک <code>enum</code> با حالت‌های مختلف پست به‌عنوان متغیرها استفاده
نکردیم. این قطعاً یک راه‌حل ممکن است؛ آن را امتحان کنید و نتایج نهایی را مقایسه کنید تا ببینید کدام را ترجیح
می‌دهید! یکی از معایب استفاده از <code>enum</code> این است که هر جا مقدار <code>enum</code> بررسی می‌شود نیاز به یک عبارت <code>match</code> یا
چیزی مشابه برای مدیریت تمام متغیرهای ممکن داریم. این می‌تواند نسبت به راه‌حل اشیای صفتی که استفاده کردیم
تکراری‌تر باشد.</p>
</section>
<h3 id="مزایا-و-معایب-الگوی-وضعیت"><a class="header" href="#مزایا-و-معایب-الگوی-وضعیت">مزایا و معایب الگوی وضعیت</a></h3>
<p>ما نشان داده‌ایم که Rust قادر است الگوی وضعیت شی‌گرا را برای کپسوله کردن رفتارهای مختلف یک پست در هر حالت
پیاده‌سازی کند. متدهای <code>Post</code> هیچ اطلاعی از رفتارهای مختلف ندارند. با روشی که کد را سازمان‌دهی کرده‌ایم، تنها
باید در یک مکان به‌دنبال راه‌های مختلف رفتار یک پست منتشرشده بگردیم: پیاده‌سازی صفت <code>State</code> روی ساختار
<code>Published</code>.</p>
<p>اگر بخواهیم یک پیاده‌سازی جایگزین ایجاد کنیم که از الگوی وضعیت استفاده نمی‌کند، ممکن است به‌جای آن از عبارات
<code>match</code> در متدهای <code>Post</code> یا حتی در کد <code>main</code> استفاده کنیم که وضعیت پست را بررسی کرده و رفتار را در همان مکان‌ها
تغییر می‌دهد. این به این معناست که باید در مکان‌های مختلفی جست‌وجو کنیم تا تمام پیامدهای یک پست در حالت منتشرشده
را بفهمیم! و با اضافه شدن حالت‌های بیشتر، این موضوع فقط بدتر خواهد شد: هر یک از آن عبارات <code>match</code> نیاز به یک
شاخه دیگر خواهند داشت.</p>
<p>با الگوی وضعیت، متدهای <code>Post</code> و مکان‌هایی که از <code>Post</code> استفاده می‌کنیم نیازی به عبارات <code>match</code> ندارند، و برای
اضافه کردن یک حالت جدید، فقط کافی است یک ساختار جدید اضافه کرده و متدهای صفت را روی همان ساختار پیاده‌سازی کنیم.</p>
<p>پیاده‌سازی با استفاده از الگوی وضعیت به‌راحتی قابلیت گسترش برای اضافه کردن عملکردهای بیشتر را دارد. برای دیدن
سادگی نگهداری کدی که از الگوی وضعیت استفاده می‌کند، چند پیشنهاد زیر را امتحان کنید:</p>
<ul>
<li>یک متد <code>reject</code> اضافه کنید که وضعیت پست را از <code>PendingReview</code> به <code>Draft</code> تغییر دهد.</li>
<li>دو فراخوانی به <code>approve</code> نیاز داشته باشید تا وضعیت به <code>Published</code> تغییر کند.</li>
<li>اجازه دهید کاربران فقط زمانی که یک پست در حالت <code>Draft</code> است متن محتوا اضافه کنند. نکته: بگذارید شیء وضعیت
مسئول تغییراتی باشد که ممکن است در محتوا ایجاد شود، اما مسئول اصلاح مستقیم <code>Post</code> نباشد.</li>
</ul>
<p>یکی از معایب الگوی وضعیت این است که به دلیل اینکه وضعیت‌ها انتقال بین حالت‌ها را پیاده‌سازی می‌کنند، برخی از
وضعیت‌ها به یکدیگر وابسته هستند. اگر یک حالت دیگر بین <code>PendingReview</code> و <code>Published</code> اضافه کنیم، مانند
<code>Scheduled</code>، باید کد در <code>PendingReview</code> را تغییر دهیم تا به <code>Scheduled</code> منتقل شود. اگر نیازی نبود که
<code>PendingReview</code> با اضافه شدن یک حالت جدید تغییر کند، کار کمتری می‌داشتیم، اما این به معنای تغییر به یک الگوی
طراحی دیگر خواهد بود.</p>
<p>یکی دیگر از معایب این است که ما برخی از منطق‌ها را تکرار کرده‌ایم. برای حذف برخی از این تکرارها، ممکن است سعی
کنیم برای متدهای <code>request_review</code> و <code>approve</code> در صفت <code>State</code> پیاده‌سازی پیش‌فرضی ایجاد کنیم که <code>self</code> را
بازمی‌گرداند؛ با این حال، این با <code>dyn</code> سازگار نخواهد بود، زیرا صفت دقیقاً نمی‌داند <code>self</code> چه خواهد بود. ما
می‌خواهیم بتوانیم از <code>State</code> به‌عنوان یک شیء صفت استفاده کنیم، بنابراین متدهای آن باید با <code>dyn</code> سازگار باشند.</p>
<p>پیاده‌سازی مشابه متدهای <code>request_review</code> و <code>approve</code> روی <code>Post</code> نیز نوعی تکرار است. هر دو متد اجرای متد مشابه
روی مقدار موجود در فیلد <code>state</code> از <code>Option</code> را به آن واگذار کرده و مقدار جدید فیلد <code>state</code> را به نتیجه تنظیم
می‌کنند. اگر متدهای زیادی روی <code>Post</code> داشته باشیم که این الگو را دنبال می‌کنند، ممکن است تعریف یک ماکرو را برای حذف
این تکرار در نظر بگیریم (بخش <a href="ch20-05-macros.html#macros">“ماکروها”</a><!-- ignore --> در فصل 20 را ببینید).</p>
<p>با پیاده‌سازی الگوی وضعیت دقیقاً همان‌طور که برای زبان‌های شی‌گرا تعریف شده است، به‌طور کامل از نقاط قوت Rust
استفاده نمی‌کنیم. بیایید نگاهی به تغییراتی بیندازیم که می‌توانیم در crate <code>blog</code> ایجاد کنیم تا وضعیت‌ها و
انتقالات نامعتبر به خطاهای زمان کامپایل تبدیل شوند.</p>
<h4 id="کدگذاری-وضعیتها-و-رفتار-بهعنوان-انواع"><a class="header" href="#کدگذاری-وضعیتها-و-رفتار-بهعنوان-انواع">کدگذاری وضعیت‌ها و رفتار به‌عنوان انواع</a></h4>
<p>به شما نشان خواهیم داد که چگونه الگوی وضعیت را دوباره طراحی کنید تا مجموعه‌ای متفاوت از مزایا و معایب به دست
آورید. به‌جای اینکه وضعیت‌ها و انتقالات را کاملاً کپسوله کنیم تا کد خارجی از آن‌ها اطلاعی نداشته باشد، وضعیت‌ها را
به انواع مختلف کدگذاری می‌کنیم. در نتیجه، سیستم بررسی نوع Rust تلاش برای استفاده از پست‌های پیش‌نویس در جاهایی که
فقط پست‌های منتشرشده مجاز هستند را با صدور یک خطای کامپایلر متوقف می‌کند.</p>
<p>ابتدا قسمت اول <code>main</code> در لیستینگ 18-11 را در نظر بگیرید:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</figure>
<p>ما همچنان امکان ایجاد پست‌های جدید در وضعیت پیش‌نویس با استفاده از <code>Post::new</code> و افزودن متن به محتوای پست را فراهم
می‌کنیم. اما به‌جای داشتن متد <code>content</code> روی یک پست پیش‌نویس که یک رشته خالی بازمی‌گرداند، آن را به گونه‌ای طراحی
می‌کنیم که پست‌های پیش‌نویس اصلاً متد <code>content</code> نداشته باشند. به این ترتیب، اگر بخواهیم محتوای یک پست پیش‌نویس
را دریافت کنیم، خطای کامپایلر دریافت خواهیم کرد که به ما می‌گوید این متد وجود ندارد. در نتیجه، نمایش محتوای
پست‌های پیش‌نویس در محیط تولید به‌طور تصادفی غیرممکن می‌شود، زیرا آن کد حتی کامپایل نخواهد شد. لیستینگ 18-19
تعریف یک ساختار <code>Post</code> و یک ساختار <code>DraftPost</code> و همچنین متدهایی روی هرکدام را نشان می‌دهد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<figcaption>Listing 18-19: یک <code>Post</code> با یک متد <code>content</code> و یک <code>DraftPost</code> بدون متد <code>content</code></figcaption>
</figure>
<p>هر دو ساختار <code>Post</code> و <code>DraftPost</code> دارای یک فیلد خصوصی به نام <code>content</code> هستند که متن پست وبلاگ را ذخیره می‌کند. این
ساختارها دیگر فیلد <code>state</code> ندارند زیرا کدگذاری وضعیت را به انواع ساختارها منتقل کرده‌ایم. ساختار <code>Post</code> نماینده
یک پست منتشرشده است و دارای متد <code>content</code> است که مقدار <code>content</code> را بازمی‌گرداند.</p>
<p>ما همچنان یک تابع <code>Post::new</code> داریم، اما به‌جای بازگرداندن نمونه‌ای از <code>Post</code>، یک نمونه از <code>DraftPost</code> بازمی‌گرداند.
از آنجا که <code>content</code> خصوصی است و هیچ تابعی وجود ندارد که <code>Post</code> را بازگرداند، در حال حاضر امکان ایجاد نمونه‌ای از
<code>Post</code> وجود ندارد.</p>
<p>ساختار <code>DraftPost</code> یک متد <code>add_text</code> دارد، بنابراین می‌توانیم همانند قبل متن را به <code>content</code> اضافه کنیم، اما
توجه کنید که <code>DraftPost</code> متد <code>content</code> تعریف‌شده ندارد! بنابراین اکنون برنامه تضمین می‌کند که تمام پست‌ها به‌صورت
پست‌های پیش‌نویس شروع می‌شوند و پست‌های پیش‌نویس محتوای خود را برای نمایش در دسترس ندارند. هر تلاشی برای دور زدن
این محدودیت‌ها منجر به خطای کامپایلر خواهد شد.</p>
<h4 id="پیادهسازی-انتقالها-بهعنوان-تبدیل-به-انواع-مختلف"><a class="header" href="#پیادهسازی-انتقالها-بهعنوان-تبدیل-به-انواع-مختلف">پیاده‌سازی انتقال‌ها به‌عنوان تبدیل به انواع مختلف</a></h4>
<p>چگونه می‌توانیم یک پست منتشرشده داشته باشیم؟ ما می‌خواهیم قانون را اجرا کنیم که یک پست پیش‌نویس باید بررسی و
تأیید شود قبل از اینکه بتواند منتشر شود. یک پست در حالت “در انتظار بررسی” همچنان نباید هیچ محتوایی نمایش دهد. بیایید
این محدودیت‌ها را با اضافه کردن یک ساختار دیگر به نام <code>PendingReviewPost</code>، تعریف متد <code>request_review</code> روی
<code>DraftPost</code> برای بازگرداندن یک <code>PendingReviewPost</code> و تعریف یک متد <code>approve</code> روی <code>PendingReviewPost</code> برای
بازگرداندن یک <code>Post</code>، همان‌طور که در لیستینگ 18-20 نشان داده شده است، پیاده‌سازی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<figcaption>Listing 18-20: یک <code>PendingReviewPost</code> که با فراخوانی <code>request_review</code> روی <code>DraftPost</code> ایجاد می‌شود و یک متد <code>approve</code> که یک <code>PendingReviewPost</code> را به یک <code>Post</code> منتشرشده تبدیل می‌کند</figcaption>
</figure>
<p>متدهای <code>request_review</code> و <code>approve</code> مالکیت <code>self</code> را می‌گیرند، بنابراین نمونه‌های <code>DraftPost</code> و <code>PendingReviewPost</code>
را مصرف کرده و آن‌ها را به‌ترتیب به یک <code>PendingReviewPost</code> و یک <code>Post</code> منتشرشده تبدیل می‌کنند. به این ترتیب،
پس از فراخوانی <code>request_review</code> روی یک <code>DraftPost</code> و به همین ترتیب، هیچ نمونه‌ای از <code>DraftPost</code> باقی نمی‌ماند.
ساختار <code>PendingReviewPost</code> متد <code>content</code> تعریف‌شده‌ای ندارد، بنابراین تلاش برای خواندن محتوای آن منجر به خطای
کامپایلر می‌شود، همان‌طور که در مورد <code>DraftPost</code> اتفاق می‌افتد. چون تنها راه برای گرفتن یک نمونه از <code>Post</code> منتشرشده
که متد <code>content</code> تعریف‌شده‌ای دارد، فراخوانی متد <code>approve</code> روی یک <code>PendingReviewPost</code> است، و تنها راه برای گرفتن
یک <code>PendingReviewPost</code> فراخوانی متد <code>request_review</code> روی یک <code>DraftPost</code> است، ما اکنون فرآیند کاری پست وبلاگ را به
سیستم نوع کدگذاری کرده‌ایم.</p>
<p>اما همچنین باید تغییرات کوچکی در <code>main</code> ایجاد کنیم. متدهای <code>request_review</code> و <code>approve</code> نمونه‌های جدیدی بازمی‌گردانند
به‌جای اینکه ساختاری که روی آن فراخوانی شده‌اند را تغییر دهند، بنابراین باید تخصیص‌های مجدد با <code>let post =</code> اضافه کنیم
تا نمونه‌های بازگشتی را ذخیره کنیم. همچنین نمی‌توانیم تأییدیه‌های مربوط به خالی بودن محتوای پست‌های پیش‌نویس و در
انتظار بررسی را داشته باشیم، و نیازی به آن‌ها نیست: دیگر نمی‌توانیم کدی که سعی می‌کند محتوای پست‌های در این حالت‌ها را
استفاده کند، کامپایل کنیم. کد به‌روزشده در <code>main</code> در لیستینگ 18-21 نشان داده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption>Listing 18-21: تغییرات در <code>main</code> برای استفاده از پیاده‌سازی جدید فرآیند کاری پست وبلاگ</figcaption>
</figure>
<p>تغییراتی که باید در <code>main</code> برای تخصیص مجدد <code>post</code> انجام می‌دادیم، به این معناست که این پیاده‌سازی دیگر کاملاً از
الگوی وضعیت شی‌گرا پیروی نمی‌کند: انتقالات بین حالت‌ها دیگر به‌طور کامل در پیاده‌سازی <code>Post</code> کپسوله نشده‌اند.
اما، مزیت ما این است که اکنون وضعیت‌های نامعتبر به دلیل سیستم نوع و بررسی نوعی که در زمان کامپایل انجام می‌شود،
غیرممکن هستند! این تضمین می‌کند که برخی از باگ‌ها، مانند نمایش محتوای یک پست منتشرنشده، قبل از رسیدن به تولید
کشف شوند.</p>
<p>تکالیف پیشنهادی در ابتدای این بخش را روی crate <code>blog</code> همان‌طور که پس از لیستینگ 18-21 است امتحان کنید تا ببینید
درباره طراحی این نسخه از کد چه نظری دارید. توجه داشته باشید که برخی از تکالیف ممکن است در این طراحی از پیش
انجام شده باشند.</p>
<p>دیدیم که حتی با وجود اینکه Rust قادر به پیاده‌سازی الگوهای طراحی شی‌گرا است، الگوهای دیگر، مانند کدگذاری حالت
در سیستم نوع، نیز در Rust در دسترس هستند. این الگوها مزایا و معایب متفاوتی دارند. اگرچه ممکن است با الگوهای شی‌گرا
بسیار آشنا باشید، بازاندیشی مسئله برای بهره‌بردن از ویژگی‌های Rust می‌تواند مزایایی مانند جلوگیری از برخی باگ‌ها
در زمان کامپایل را فراهم کند. الگوهای شی‌گرا همیشه بهترین راه‌حل در Rust نخواهند بود، به دلیل ویژگی‌هایی مانند
مالکیت که زبان‌های شی‌گرا ندارند.</p>
<h2 id="خلاصه-17"><a class="header" href="#خلاصه-17">خلاصه</a></h2>
<p>فارغ از اینکه پس از خواندن این فصل فکر می‌کنید Rust یک زبان شی‌گرا است یا نه، اکنون می‌دانید که می‌توانید از
اشیای صفت برای دریافت برخی ویژگی‌های شی‌گرایی در Rust استفاده کنید. تخصیص پویا (Dynamic Dispatch) می‌تواند
انعطاف‌پذیری به کد شما بدهد، اما در ازای آن کمی از عملکرد زمان اجرا را قربانی می‌کند. می‌توانید از این انعطاف‌پذیری
برای پیاده‌سازی الگوهای شی‌گرا که می‌توانند به نگه‌داری کد شما کمک کنند، استفاده کنید. Rust همچنین دارای ویژگی‌های
دیگری مانند مالکیت است که زبان‌های شی‌گرا ندارند. یک الگوی شی‌گرا همیشه بهترین راه برای بهره‌بردن از نقاط قوت
Rust نخواهد بود، اما به‌عنوان یک گزینه در دسترس است.</p>
<p>در ادامه، به بررسی الگوها خواهیم پرداخت که یکی دیگر از ویژگی‌های Rust است که انعطاف‌پذیری زیادی را فراهم
می‌کنند. در طول کتاب به‌طور مختصر به آن‌ها اشاره کرده‌ایم، اما هنوز به‌طور کامل توانایی آن‌ها را ندیده‌ایم. برویم!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="الگوها-و-match"><a class="header" href="#الگوها-و-match">الگوها و Match</a></h1>
<p><em>الگوها</em> یک نحو خاص در Rust هستند که برای مطابقت با ساختار انواع، چه پیچیده و چه ساده، استفاده می‌شوند. استفاده از الگوها همراه با عبارات <code>match</code> و سایر سازه‌ها به شما کنترل بیشتری بر جریان کنترل برنامه می‌دهد. یک الگو از ترکیبی از موارد زیر تشکیل شده است:</p>
<div dir="rtl">
    <ul>
        <li>مقادیر ثابت (Literals)</li>
        <li>آرایه‌ها، enumها، structها یا tupleهای تخریب‌شده</li>
        <li>متغیرها</li>
        <li>کاراکترهای عمومی (Wildcards)</li>
        <li>جای‌نگهدارها (Placeholders)</li>
    </ul>
</div>
<p>برخی از نمونه الگوها عبارتند از <code>x</code>، <code>(a, 3)</code> و <code>Some(Color::Red)</code>. در زمینه‌هایی که الگوها معتبر هستند، این مؤلفه‌ها شکل داده‌ها را توصیف می‌کنند. سپس برنامه ما مقادیر را با الگوها مقایسه می‌کند تا مشخص شود آیا داده‌ها شکل درستی دارند تا یک قطعه خاص از کد اجرا شود یا خیر.</p>
<p>برای استفاده از یک الگو، آن را با یک مقدار مقایسه می‌کنیم. اگر الگو با مقدار مطابقت داشته باشد، از قطعات مقدار در کد خود استفاده می‌کنیم. به یاد آورید که در فصل 6 از عبارات <code>match</code> که از الگوها استفاده می‌کردند، مانند مثال ماشین مرتب‌سازی سکه، بحث کردیم. اگر مقدار با شکل الگو تطابق داشته باشد، می‌توانیم از قسمت‌های نام‌گذاری‌شده استفاده کنیم. اگر مطابقت نداشته باشد، کد مرتبط با آن الگو اجرا نخواهد شد.</p>
<p>این فصل یک مرجع جامع در مورد هر چیزی است که به الگوها مربوط می‌شود. ما مکان‌های معتبری که می‌توان از الگوها استفاده کرد، تفاوت بین الگوهای قابل‌رد (refutable) و غیرقابل‌رد (irrefutable)، و انواع مختلف نحوی الگو که ممکن است ببینید را پوشش خواهیم داد. تا پایان فصل، خواهید دانست که چگونه از الگوها برای بیان بسیاری از مفاهیم به روشی واضح استفاده کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="all-the-places-patterns-can-be-used"><a class="header" href="#all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>الگوها در بسیاری از جاها در راست ظاهر می‌شوند، و شما از آن‌ها زیاد استفاده کرده‌اید بدون اینکه متوجه شوید! این بخش تمام جاهایی که الگوها معتبر هستند را بررسی می‌کند.</p>
<h3 id="match-arms"><a class="header" href="#match-arms"><code>match</code> Arms</a></h3>
<p>همان‌طور که در فصل 6 بحث شد، ما از الگوها در بازوهای (arms) عبارات <code>match</code> استفاده می‌کنیم. به‌طور رسمی، عبارات <code>match</code> به‌صورت کلمه کلیدی <code>match</code>، یک مقدار برای مطابقت، و یک یا چند بازوی match که از یک الگو و یک عبارت برای اجرا در صورت مطابقت مقدار با الگوی آن بازو تشکیل شده‌اند، تعریف می‌شوند، مانند این:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>برای مثال، اینجا عبارت <code>match</code> از فهرست 6-5 است که بر روی یک مقدار <code>Option&lt;i32&gt;</code> در متغیر <code>x</code> مطابقت می‌دهد:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>الگوها در این عبارت <code>match</code> شامل <code>None</code> و <code>Some(i)</code> هستند که در سمت چپ هر پیکان قرار دارند.</p>
<p>یکی از نیازمندی‌های عبارات <code>match</code> این است که باید به‌صورت <em>کامل</em> باشند، به این معنا که تمام حالات ممکن برای مقدار در عبارت <code>match</code> باید پوشش داده شوند. یکی از راه‌های اطمینان از اینکه همه حالات را پوشش داده‌اید این است که یک الگوی عمومی (catchall) برای بازوی آخر داشته باشید: برای مثال، یک نام متغیر که هر مقداری را مطابقت می‌دهد هرگز شکست نمی‌خورد و بنابراین تمام موارد باقی‌مانده را پوشش می‌دهد.</p>
<p>الگوی خاص <code>_</code> هر چیزی را مطابقت می‌دهد، اما هرگز به یک متغیر متصل نمی‌شود، بنابراین اغلب در بازوی آخر match استفاده می‌شود. الگوی <code>_</code> می‌تواند زمانی مفید باشد که بخواهید هر مقداری که مشخص نشده است را نادیده بگیرید، برای مثال. ما الگوی <code>_</code> را در بخش <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a Pattern”</a><!-- ignore --> بعداً در این فصل به‌طور مفصل بررسی خواهیم کرد.</p>
<h3 id="conditional-if-let-expressions"><a class="header" href="#conditional-if-let-expressions">Conditional <code>if let</code> Expressions</a></h3>
<p>در فصل 6 بحث کردیم که چگونه از عبارات <code>if let</code> عمدتاً به‌عنوان یک روش کوتاه‌تر برای نوشتن معادل یک <code>match</code> که فقط یک حالت را مطابقت می‌دهد استفاده کنیم. به‌صورت اختیاری، <code>if let</code> می‌تواند یک <code>else</code> متناظر داشته باشد که شامل کدی برای اجرا در صورت عدم مطابقت الگو در <code>if let</code> باشد.</p>
<p>فهرست 19-1 نشان می‌دهد که همچنین ممکن است عبارات <code>if let</code>، <code>else if</code>، و <code>else if let</code> را با هم ترکیب و تطبیق دهید. این کار به ما انعطاف بیشتری نسبت به یک عبارت <code>match</code> می‌دهد، که در آن فقط می‌توانیم یک مقدار برای مقایسه با الگوها بیان کنیم. همچنین، راست نیاز ندارد که شرایط در یک سری از بازوهای <code>if let</code>، <code>else if</code>، <code>else if let</code> به یکدیگر مرتبط باشند.</p>
<p>کد در فهرست 19-1 تعیین می‌کند که بر اساس یک سری بررسی برای چندین شرط، پس‌زمینه شما چه رنگی داشته باشد. برای این مثال، متغیرهایی با مقادیر سخت‌کدشده ایجاد کرده‌ایم که یک برنامه واقعی ممکن است از ورودی کاربر دریافت کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre></pre>
<figcaption>Listing 19-1: ترکیب <code>if let</code>، <code>else if</code>، <code>else if let</code>، و <code>else</code></figcaption>
</figure>
<p>اگر کاربر یک رنگ مورد علاقه مشخص کند، از آن رنگ به‌عنوان پس‌زمینه استفاده می‌شود. اگر هیچ رنگ مورد علاقه‌ای مشخص نشده باشد و امروز سه‌شنبه باشد، رنگ پس‌زمینه سبز است. در غیر این صورت، اگر کاربر سن خود را به‌عنوان یک رشته مشخص کند و بتوانیم آن را با موفقیت به یک عدد تبدیل کنیم، رنگ یا بنفش یا نارنجی است، بسته به مقدار عدد. اگر هیچ‌کدام از این شرایط صدق نکند، رنگ پس‌زمینه آبی خواهد بود.</p>
<p>این ساختار شرطی به ما امکان پشتیبانی از نیازهای پیچیده را می‌دهد. با مقادیر سخت‌کدشده‌ای که در اینجا داریم، این مثال پیام <code>Using purple as the background color</code> را چاپ خواهد کرد.</p>
<p>می‌توانید ببینید که <code>if let</code> نیز می‌تواند متغیرهای جدیدی را معرفی کند که متغیرهای موجود را به همان روشی که بازوهای <code>match</code> انجام می‌دهند، پوشش می‌دهند: خط <code>if let Ok(age) = age</code> یک متغیر جدید به نام <code>age</code> معرفی می‌کند که حاوی مقدار داخل حالت <code>Ok</code> است و متغیر موجود <code>age</code> را پوشش می‌دهد. این بدان معناست که باید شرط <code>if age &gt; 30</code> را در داخل آن بلوک قرار دهیم: نمی‌توانیم این دو شرط را به‌صورت <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> ترکیب کنیم. متغیر جدید <code>age</code> که می‌خواهیم با 30 مقایسه کنیم تا شروع محدوده جدید با آکولاد معتبر نیست.</p>
<p>نقطه ضعف استفاده از عبارات <code>if let</code> این است که کامپایلر بررسی نمی‌کند که آیا همه حالات پوشش داده شده‌اند یا خیر، در حالی که با عبارات <code>match</code> این کار را انجام می‌دهد. اگر بلوک آخر <code>else</code> را حذف کنیم و بنابراین برخی موارد را پوشش ندهیم، کامپایلر به ما در مورد باگ احتمالی منطقی هشدار نمی‌دهد.</p>
<h3 id="while-let-conditional-loops"><a class="header" href="#while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>مشابه با ساختار <code>if let</code>، حلقه شرطی <code>while let</code> به یک حلقه <code>while</code> اجازه می‌دهد تا زمانی که یک الگو همچنان مطابقت دارد، اجرا شود. اولین بار یک حلقه <code>while let</code> را در فصل 17 دیدیم، جایی که از آن برای ادامه حلقه زدن تا زمانی که یک stream مقادیر جدید تولید می‌کرد استفاده کردیم. به‌طور مشابه، در فهرست 19-2 یک حلقه <code>while let</code> نشان داده می‌شود که منتظر پیام‌هایی است که بین نخ‌ها ارسال می‌شود، اما در این مورد یک <code>Result</code> را بررسی می‌کند به‌جای یک <code>Option</code>.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-2: استفاده از یک حلقه <code>while let</code> برای چاپ مقادیر تا زمانی که <code>rx.recv()</code> مقدار <code>Ok</code> را بازمی‌گرداند</figcaption>
</figure>
<p>این مثال مقادیر 1، 2، و 3 را چاپ می‌کند. وقتی که <code>recv</code> را در فصل 16 دیدیم، خطا را مستقیماً unwrap می‌کردیم یا با استفاده از یک حلقه <code>for</code> به‌عنوان یک iterator با آن تعامل داشتیم. با این حال، همان‌طور که فهرست 19-2 نشان می‌دهد، می‌توانیم از <code>while let</code> نیز استفاده کنیم، زیرا متد <code>recv</code> تا زمانی که فرستنده پیام‌ها تولید می‌کند مقدار <code>Ok</code> بازمی‌گرداند و سپس زمانی که طرف فرستنده قطع می‌شود یک مقدار <code>Err</code> تولید می‌کند.</p>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>در یک حلقه <code>for</code>، مقداری که مستقیماً بعد از کلمه کلیدی <code>for</code> می‌آید یک الگو است. برای مثال، در عبارت <code>for x in y</code> مقدار <code>x</code> یک الگو است. فهرست 19-3 نشان می‌دهد که چگونه می‌توان از یک الگو در یک حلقه <code>for</code> برای تخریب (destructure) یا تجزیه یک tuple به‌عنوان بخشی از حلقه <code>for</code> استفاده کرد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-3: Using a pattern in a <code>for</code> loop to destructure a tuple</figcaption>
</figure>
<p>کد در فهرست 19-3 خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>ما یک iterator را با استفاده از متد <code>enumerate</code> تطبیق می‌دهیم تا یک مقدار و شاخص آن مقدار را تولید کند، که در یک tuple قرار می‌گیرد. اولین مقدار تولیدشده tuple <code>(0, 'a')</code> است. وقتی این مقدار با الگوی <code>(index, value)</code> مطابقت داده می‌شود، مقدار <code>index</code> برابر با <code>0</code> و مقدار <code>value</code> برابر با <code>'a'</code> خواهد بود، و اولین خط خروجی چاپ می‌شود.</p>
<h3 id="let-statements"><a class="header" href="#let-statements"><code>let</code> Statements</a></h3>
<p>پیش از این فصل، ما به‌طور خاص فقط درباره استفاده از الگوها با <code>match</code> و <code>if let</code> بحث کرده بودیم، اما در واقع، ما از الگوها در مکان‌های دیگری نیز استفاده کرده‌ایم، از جمله در عبارات <code>let</code>. برای مثال، به این تخصیص ساده متغیر با <code>let</code> توجه کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>هر بار که از یک عبارت <code>let</code> مانند این استفاده کرده‌اید، از الگوها استفاده کرده‌اید، حتی اگر متوجه آن نشده باشید! به‌طور رسمی، یک عبارت <code>let</code> به این شکل است:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>در عبارات مانند <code>let x = 5;</code> با یک نام متغیر در محل <code>PATTERN</code>، نام متغیر فقط یک شکل ساده از یک الگو است. راست عبارت را با الگو مقایسه می‌کند و هر نامی که پیدا می‌کند را تخصیص می‌دهد. بنابراین در مثال <code>let x = 5;</code>، <code>x</code> الگویی است که به این معناست: «هر چیزی که در اینجا مطابقت دارد را به متغیر <code>x</code> اختصاص بده». چون نام <code>x</code> کل الگو است، این الگو به‌طور مؤثر به این معناست: «هر چیزی که هست را به متغیر <code>x</code> اختصاص بده».</p>
<p>برای مشاهده جنبه تطبیق الگو در <code>let</code> به‌صورت واضح‌تر، فهرست 19-4 را در نظر بگیرید، که از یک الگو با <code>let</code> برای تخریب یک tuple استفاده می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-4: Using a pattern to destructure a tuple and create three variables at once</figcaption>
</figure>
<p>اینجا، ما یک tuple را با یک الگو مطابقت می‌دهیم. راست مقدار <code>(1, 2, 3)</code> را با الگوی <code>(x, y, z)</code> مقایسه می‌کند و می‌بیند که مقدار با الگو مطابقت دارد، بنابراین راست <code>1</code> را به <code>x</code>، <code>2</code> را به <code>y</code>، و <code>3</code> را به <code>z</code> اختصاص می‌دهد. می‌توانید این الگوی tuple را به‌عنوان سه الگوی متغیر فردی که درون آن قرار دارند تصور کنید.</p>
<p>اگر تعداد عناصر در الگو با تعداد عناصر در tuple مطابقت نداشته باشد، کل نوع مطابقت نخواهد داشت و یک خطای کامپایلر دریافت خواهیم کرد. برای مثال، فهرست 19-5 یک تلاش برای تخریب یک tuple با سه عنصر به دو متغیر را نشان می‌دهد، که کار نخواهد کرد.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-5: Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple</figcaption>
</figure>
<p>تلاش برای کامپایل این کد منجر به این خطای type می‌شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>برای رفع خطا، می‌توانیم یک یا چند مقدار در tuple را با استفاده از <code>_</code> یا <code>..</code> نادیده بگیریم، همان‌طور که در بخش <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a Pattern”</a><!-- ignore --> خواهید دید. اگر مشکل این است که تعداد متغیرها در الگو بیش از حد است، راه‌حل این است که نوع‌ها را با حذف متغیرها طوری تطبیق دهیم که تعداد متغیرها برابر با تعداد عناصر در tuple شود.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>پارامترهای تابع نیز می‌توانند الگو باشند. کد در فهرست 19-6، که تابعی به نام <code>foo</code> را تعریف می‌کند که یک پارامتر به نام <code>x</code> از نوع <code>i32</code> می‌گیرد، باید تا الان آشنا به نظر برسد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 19-6: یک امضای تابع از الگوها در پارامترها استفاده می‌کند</figcaption>
</figure>
<p>قسمت <code>x</code> یک الگو است! همان‌طور که با <code>let</code> انجام دادیم، می‌توانیم یک tuple را در آرگومان‌های یک تابع با الگو مطابقت دهیم. فهرست 19-7 مقادیر یک tuple را هنگام ارسال به یک تابع تجزیه می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<figcaption>Listing 19-7: یک تابع با پارامترهایی که یک tuple را تخریب می‌کنند</figcaption>
</figure>
<p>این کد پیام <code>Current location: (3, 5)</code> را چاپ می‌کند. مقادیر <code>&amp;(3, 5)</code> با الگوی <code>&amp;(x, y)</code> مطابقت دارند، بنابراین <code>x</code> مقدار <code>3</code> و <code>y</code> مقدار <code>5</code> است.</p>
<p>ما همچنین می‌توانیم از الگوها در لیست پارامترهای closureها به همان روشی که در لیست پارامترهای تابع استفاده می‌کنیم، استفاده کنیم، زیرا closureها شبیه به توابع هستند، همان‌طور که در فصل 13 بحث شد.</p>
<p>تا اینجا، چندین روش برای استفاده از الگوها را دیده‌اید، اما الگوها در هر جایی که از آن‌ها استفاده کنیم به یک شکل کار نمی‌کنند. در برخی مکان‌ها، الگوها باید غیرقابل‌رد (irrefutable) باشند؛ در شرایط دیگر، می‌توانند قابل‌رد (refutable) باشند. در بخش بعدی این دو مفهوم را بررسی خواهیم کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutability-whether-a-pattern-might-fail-to-match"><a class="header" href="#refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match</a></h2>
<p>الگوها به دو شکل هستند: قابل‌رد (refutable) و غیرقابل‌رد (irrefutable). الگوهایی که برای هر مقدار ممکن مطابقت دارند <em>غیرقابل‌رد</em> هستند. به‌عنوان مثال، <code>x</code> در عبارت <code>let x = 5;</code>، زیرا <code>x</code> با هر چیزی مطابقت دارد و بنابراین نمی‌تواند از تطابق باز بماند. الگوهایی که ممکن است برای برخی مقادیر ممکن مطابقت نداشته باشند <em>قابل‌رد</em> هستند. به‌عنوان مثال، <code>Some(x)</code> در عبارت <code>if let Some(x) = a_value</code>، زیرا اگر مقدار در متغیر <code>a_value</code> <code>None</code> باشد به‌جای <code>Some</code>، الگوی <code>Some(x)</code> مطابقت نخواهد داشت.</p>
<p>پارامترهای تابع، عبارات <code>let</code>، و حلقه‌های <code>for</code> فقط می‌توانند الگوهای غیرقابل‌رد بپذیرند، زیرا برنامه نمی‌تواند کاری معنادار انجام دهد وقتی مقادیر مطابقت ندارند. عبارات <code>if let</code> و <code>while let</code> و عبارت <code>let</code>-<code>else</code> الگوهای قابل‌رد و غیرقابل‌رد را می‌پذیرند، اما کامپایلر درباره الگوهای غیرقابل‌رد هشدار می‌دهد زیرا به‌طور تعریف‌شده برای مدیریت شکست احتمالی طراحی شده‌اند: عملکرد شرطی در توانایی آن است که بسته به موفقیت یا شکست به‌طور متفاوت عمل کند.</p>
<p>به‌طور کلی، نباید نیازی به نگرانی در مورد تمایز بین الگوهای قابل‌رد و غیرقابل‌رد داشته باشید؛ با این حال، باید با مفهوم قابل‌رد بودن آشنا باشید تا بتوانید زمانی که آن را در یک پیام خطا می‌بینید، واکنش نشان دهید. در این موارد، باید یا الگو را تغییر دهید یا ساختاری که الگو را با آن استفاده می‌کنید، بسته به رفتار موردنظر کد تغییر دهید.</p>
<p>بیایید به مثالی نگاه کنیم که وقتی سعی می‌کنیم از یک الگوی قابل‌رد جایی که راست نیاز به یک الگوی غیرقابل‌رد دارد استفاده کنیم، و برعکس، چه اتفاقی می‌افتد. فهرست 19-8 یک عبارت <code>let</code> را نشان می‌دهد، اما برای الگو ما <code>Some(x)</code>، یک الگوی قابل‌رد مشخص کرده‌ایم. همان‌طور که ممکن است انتظار داشته باشید، این کد کامپایل نخواهد شد.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-8: تلاش برای استفاده از یک الگوی قابل‌رد با <code>let</code></figcaption>
</figure>
<p>اگر مقدار <code>some_option_value</code> <code>None</code> باشد، مطابقت با الگوی <code>Some(x)</code> شکست خواهد خورد، به این معنا که الگو قابل‌رد است. با این حال، عبارت <code>let</code> فقط می‌تواند یک الگوی غیرقابل‌رد بپذیرد زیرا چیزی معتبر وجود ندارد که کد بتواند با مقدار <code>None</code> انجام دهد. در زمان کامپایل، راست شکایت می‌کند که ما سعی کرده‌ایم از یک الگوی قابل‌رد جایی که یک الگوی غیرقابل‌رد نیاز است استفاده کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>زیرا ما هر مقدار معتبری را با الگوی <code>Some(x)</code> پوشش ندادیم (و نمی‌توانستیم پوشش دهیم!)، راست به‌درستی یک خطای کامپایلر تولید می‌کند.</p>
<p>اگر یک الگوی قابل‌رد داشته باشیم جایی که یک الگوی غیرقابل‌رد نیاز است، می‌توانیم با تغییر کدی که از الگو استفاده می‌کند آن را رفع کنیم: به‌جای استفاده از <code>let</code>، می‌توانیم از <code>if let</code> استفاده کنیم. سپس اگر الگو مطابقت نداشته باشد، کد به‌سادگی از اجرای کد داخل آکولادها صرف‌نظر می‌کند و راهی برای ادامه معتبر فراهم می‌کند. فهرست 19-9 نشان می‌دهد که چگونه کد در فهرست 19-8 را رفع کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!("{x}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-9: استفاده از <code>if let</code> و یک بلوک با الگوهای قابل‌رد به‌جای <code>let</code></figcaption>
</figure>
<p>ما به کد یک مسیر خروجی دادیم! این کد اکنون کاملاً معتبر است. با این حال، اگر به <code>if let</code> یک الگوی غیرقابل‌رد (الگویی که همیشه مطابقت دارد)، مانند <code>x</code>، بدهیم، همان‌طور که در فهرست 19-10 نشان داده شده است، کامپایلر یک هشدار خواهد داد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!("{x}");
    };
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-10: تلاش برای استفاده از یک الگوی غیرقابل‌رد با <code>if let</code></figcaption>
</figure>
<p>راست شکایت می‌کند که استفاده از <code>if let</code> با یک الگوی غیرقابل‌رد منطقی نیست:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>به این دلیل، بازوهای match باید از الگوهای قابل‌رد استفاده کنند، به‌جز بازوی آخر که باید با یک الگوی غیرقابل‌رد هر مقدار باقی‌مانده را مطابقت دهد. راست به ما اجازه می‌دهد از یک الگوی غیرقابل‌رد در یک <code>match</code> با تنها یک بازو استفاده کنیم، اما این نحو به‌ویژه مفید نیست و می‌تواند با یک عبارت ساده‌تر <code>let</code> جایگزین شود.</p>
<p>اکنون که می‌دانید کجا می‌توان از الگوها استفاده کرد و تفاوت بین الگوهای قابل‌رد و غیرقابل‌رد چیست، بیایید تمام نحوهایی که می‌توانیم برای ایجاد الگوها استفاده کنیم را بررسی کنیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>در این بخش، تمام نحوهایی که در الگوها معتبر هستند را جمع‌آوری کرده و بحث می‌کنیم که چرا و چه زمانی ممکن است بخواهید از هر کدام استفاده کنید.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>همان‌طور که در فصل 6 دیدید، می‌توانید الگوها را مستقیماً با مقادیر ثابت (literals) تطبیق دهید. کد زیر برخی از مثال‌ها را نشان می‌دهد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>این کد <code>one</code> را چاپ می‌کند زیرا مقدار در <code>x</code> برابر با 1 است. این نحو زمانی مفید است که بخواهید کد شما در صورت دریافت یک مقدار مشخص خاص اقدامی انجام دهد.</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h3>
<p>متغیرهای نام‌گذاری‌شده الگوهای غیرقابل‌رد هستند که با هر مقداری مطابقت دارند، و ما بارها در این کتاب از آن‌ها استفاده کرده‌ایم. با این حال، زمانی که از متغیرهای نام‌گذاری‌شده در عبارات <code>match</code>، <code>if let</code>، یا <code>while let</code> استفاده می‌کنید، یک پیچیدگی وجود دارد. زیرا هر یک از این نوع عبارات یک دامنه جدید را شروع می‌کنند، متغیرهایی که به‌عنوان بخشی از یک الگو در داخل عبارت تعریف می‌شوند، متغیرهایی با همان نام در خارج را پوشش می‌دهند، همان‌طور که برای همه متغیرها صدق می‌کند. در فهرست 19-11، یک متغیر به نام <code>x</code> با مقدار <code>Some(5)</code> و یک متغیر <code>y</code> با مقدار <code>10</code> تعریف می‌کنیم. سپس یک عبارت <code>match</code> روی مقدار <code>x</code> ایجاد می‌کنیم. به الگوها در بازوهای match و دستور <code>println!</code> در انتها نگاه کنید و سعی کنید قبل از اجرای این کد یا خواندن بیشتر، حدس بزنید که کد چه چیزی را چاپ خواهد کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-11: یک عبارت <code>match</code> با بازویی که یک متغیر جدید معرفی می‌کند که متغیر موجود <code>y</code> را پوشش می‌دهد</figcaption>
</figure>
<p>بیایید بررسی کنیم که وقتی عبارت <code>match</code> اجرا می‌شود چه اتفاقی می‌افتد. الگوی موجود در بازوی اول match با مقدار تعریف‌شده <code>x</code> مطابقت ندارد، بنابراین کد ادامه می‌یابد.</p>
<p>الگوی موجود در بازوی دوم match یک متغیر جدید به نام <code>y</code> معرفی می‌کند که با هر مقداری درون یک <code>Some</code> مطابقت خواهد داشت. از آنجا که ما در یک دامنه جدید داخل عبارت <code>match</code> هستیم، این یک متغیر جدید <code>y</code> است، نه متغیری که در ابتدا با مقدار 10 تعریف کردیم. این binding جدید <code>y</code> با هر مقداری درون یک <code>Some</code> مطابقت دارد، که همان چیزی است که ما در <code>x</code> داریم. بنابراین، این <code>y</code> جدید به مقدار داخلی <code>Some</code> در <code>x</code> متصل می‌شود. آن مقدار <code>5</code> است، بنابراین عبارت برای آن بازو اجرا می‌شود و <code>Matched, y = 5</code> را چاپ می‌کند.</p>
<p>اگر <code>x</code> به جای <code>Some(5)</code> یک مقدار <code>None</code> بود، الگوهای موجود در دو بازوی اول مطابقت نداشتند، بنابراین مقدار به علامت زیرخط (<code>_</code>) مطابقت داده می‌شد. ما متغیر <code>x</code> را در الگوی بازوی زیرخط معرفی نکردیم، بنابراین <code>x</code> در عبارت همچنان همان <code>x</code> خارجی است که پوشش داده نشده است. در این حالت فرضی، عبارت <code>match</code> پیام <code>Default case, x = None</code> را چاپ می‌کرد.</p>
<p>وقتی عبارت <code>match</code> تمام می‌شود، دامنه آن نیز پایان می‌یابد، و همین‌طور دامنه <code>y</code> داخلی. دستور <code>println!</code> آخر پیام <code>at the end: x = Some(5), y = 10</code> را تولید می‌کند.</p>
<p>برای ایجاد یک عبارت <code>match</code> که مقادیر <code>x</code> و <code>y</code> خارجی را مقایسه کند، به جای معرفی یک متغیر جدید که متغیر موجود <code>y</code> را پوشش می‌دهد، باید از یک نگهبان شرطی (match guard) استفاده کنیم. ما درباره نگهبان‌های شرطی در بخش <a href="ch19-03-pattern-syntax.html#extra-conditionals-with-match-guards">“Extra Conditionals with Match Guards”</a><!-- ignore --> صحبت خواهیم کرد.</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">Multiple Patterns</a></h3>
<p>می‌توانید با استفاده از نحو <code>|</code>، که عملگر <em>یا</em> (or) برای الگوها است، چندین الگو را مطابقت دهید. برای مثال، در کد زیر مقدار <code>x</code> را با بازوهای match تطبیق می‌دهیم، که بازوی اول آن یک گزینه <em>یا</em> دارد، به این معنا که اگر مقدار <code>x</code> با هر کدام از مقادیر در آن بازو مطابقت داشته باشد، کد آن بازو اجرا می‌شود:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>این کد <code>one or two</code> را چاپ می‌کند.</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">Matching Ranges of Values with <code>..=</code></a></h3>
<p>نحو <code>..=</code> به ما اجازه می‌دهد یک بازه شامل مقادیر را مطابقت دهیم. در کد زیر، وقتی یک الگو با هر کدام از مقادیر در بازه داده‌شده مطابقت داشته باشد، آن بازو اجرا خواهد شد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>اگر مقدار <code>x</code> برابر با 1، 2، 3، 4 یا 5 باشد، بازوی اول مطابقت خواهد داشت. این نحو برای مقادیر مطابقت چندگانه راحت‌تر از استفاده از عملگر <code>|</code> برای بیان همان ایده است؛ اگر بخواهیم از <code>|</code> استفاده کنیم، باید <code>1 | 2 | 3 | 4 | 5</code> را مشخص کنیم. مشخص کردن یک بازه بسیار کوتاه‌تر است، به‌ویژه اگر بخواهیم، برای مثال، هر عدد بین 1 و 1,000 را مطابقت دهیم!</p>
<p>کامپایلر بررسی می‌کند که بازه در زمان کامپایل خالی نیست، و چون تنها نوع‌هایی که راست می‌تواند تشخیص دهد که آیا یک بازه خالی است یا نه <code>char</code> و مقادیر عددی هستند، بازه‌ها فقط برای مقادیر عددی یا <code>char</code> مجاز هستند.</p>
<p>در اینجا یک مثال با استفاده از بازه‌هایی از مقادیر <code>char</code> آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>راست می‌تواند تشخیص دهد که <code>'c'</code> در بازه الگوی اول است و پیام <code>early ASCII letter</code> را چاپ می‌کند.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>ما همچنین می‌توانیم از الگوها برای تخریب (destructure) ساختارها (structs)، enums، و tuple‌ها استفاده کنیم تا از بخش‌های مختلف این مقادیر استفاده کنیم. بیایید به هر نوع مقدار نگاهی بیندازیم.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>فهرست 19-12 یک struct به نام <code>Point</code> را با دو فیلد، <code>x</code> و <code>y</code> نشان می‌دهد که می‌توانیم با استفاده از یک الگو در یک عبارت <code>let</code> آن را تخریب کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<figcaption>Listing 19-12: تخریب فیلدهای یک struct به متغیرهای جداگانه</figcaption>
</figure>
<p>این کد متغیرهای <code>a</code> و <code>b</code> را ایجاد می‌کند که با مقادیر فیلدهای <code>x</code> و <code>y</code> از struct <code>p</code> مطابقت دارند. این مثال نشان می‌دهد که نام متغیرها در الگو نیازی به مطابقت با نام فیلدهای struct ندارند. با این حال، معمولاً نام متغیرها با نام فیلدها مطابقت داده می‌شوند تا یادآوری اینکه کدام متغیرها از کدام فیلدها آمده‌اند آسان‌تر شود. به‌دلیل این استفاده معمول و به‌دلیل اینکه نوشتن <code>let Point { x: x, y: y } = p;</code> تکرار زیادی دارد، راست یک نحو کوتاه برای الگوهایی که فیلدهای struct را مطابقت می‌دهند فراهم می‌کند: فقط کافی است نام فیلد struct را لیست کنید و متغیرهایی که از الگو ایجاد می‌شوند همان نام‌ها را خواهند داشت. فهرست 19-13 به همان روشی که کد در فهرست 19-12 عمل می‌کند، اما متغیرهای ایجادشده در الگوی <code>let</code> به‌جای <code>a</code> و <code>b</code>، <code>x</code> و <code>y</code> هستند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<figcaption>Listing 19-13: تخریب فیلدهای struct با استفاده از نحو کوتاه فیلد struct</figcaption>
</figure>
<p>این کد متغیرهای <code>x</code> و <code>y</code> را ایجاد می‌کند که با فیلدهای <code>x</code> و <code>y</code> از متغیر <code>p</code> مطابقت دارند. نتیجه این است که متغیرهای <code>x</code> و <code>y</code> مقادیر از ساختار <code>p</code> را شامل می‌شوند.</p>
<p>ما همچنین می‌توانیم با مقادیر ثابت (literals) به‌عنوان بخشی از الگوی struct تخریب کنیم، به‌جای ایجاد متغیرهایی برای همه فیلدها. انجام این کار به ما اجازه می‌دهد برخی از فیلدها را برای مقادیر خاصی تست کنیم، در حالی که متغیرهایی برای تخریب فیلدهای دیگر ایجاد می‌کنیم.</p>
<p>در فهرست 19-14، یک عبارت <code>match</code> داریم که مقادیر <code>Point</code> را به سه حالت تقسیم می‌کند: نقاطی که مستقیماً روی محور <code>x</code> قرار دارند (که در صورتی درست است که <code>y = 0</code>)، روی محور <code>y</code> (<code>x = 0</code>)، یا هیچ‌کدام.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-14: تخریب و تطبیق مقادیر ثابت در یک الگو</figcaption>
</figure>
<p>بازوی اول هر نقطه‌ای که روی محور <code>x</code> قرار دارد را با مشخص کردن اینکه فیلد <code>y</code> در صورتی مطابقت دارد که مقدار آن با مقدار ثابت <code>0</code> مطابقت داشته باشد، تطبیق می‌دهد. الگو همچنان یک متغیر <code>x</code> ایجاد می‌کند که می‌توانیم در کد این بازو از آن استفاده کنیم.</p>
<p>به‌طور مشابه، بازوی دوم هر نقطه روی محور <code>y</code> را با مشخص کردن اینکه فیلد <code>x</code> در صورتی که مقدار آن <code>0</code> باشد مطابقت دارد و یک متغیر <code>y</code> برای مقدار فیلد <code>y</code> ایجاد می‌کند. بازوی سوم هیچ مقدار ثابتی را مشخص نمی‌کند، بنابراین هر <code>Point</code> دیگری را مطابقت می‌دهد و متغیرهایی برای هر دو فیلد <code>x</code> و <code>y</code> ایجاد می‌کند.</p>
<p>در این مثال، مقدار <code>p</code> به لطف <code>x</code> که مقدار <code>0</code> دارد، با بازوی دوم مطابقت دارد، بنابراین این کد پیام <code>On the y axis at 7</code> را چاپ می‌کند.</p>
<p>به یاد داشته باشید که یک عبارت <code>match</code> پس از یافتن اولین الگوی مطابقت متوقف می‌شود، بنابراین حتی اگر <code>Point { x: 0, y: 0 }</code> روی محور <code>x</code> و محور <code>y</code> باشد، این کد فقط پیام <code>On the x axis at 0</code> را چاپ خواهد کرد.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>ما در این کتاب enums را تخریب کرده‌ایم (برای مثال، فهرست 6-5 در فصل 6)، اما هنوز به‌طور خاص بحث نکرده‌ایم که الگوی تخریب یک enum مطابق با نحوه تعریف داده‌های ذخیره‌شده درون enum است. به‌عنوان مثال، در فهرست 19-15 از enum <code>Message</code> از فهرست 6-2 استفاده می‌کنیم و یک <code>match</code> با الگوهایی می‌نویسیم که هر مقدار داخلی را تخریب می‌کنند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-15: تخریب متغیرهای enum که مقادیر مختلفی دارند</figcaption>
</figure>
<p>این کد پیام <code>Change the color to red 0, green 160, and blue 255</code> را چاپ می‌کند. مقدار <code>msg</code> را تغییر دهید تا کد از بازوهای دیگر اجرا شود.</p>
<p>برای متغیرهای enum بدون هیچ داده‌ای، مانند <code>Message::Quit</code>، نمی‌توان مقدار را بیشتر تخریب کرد. فقط می‌توان روی مقدار ثابت <code>Message::Quit</code> مطابقت داد، و هیچ متغیری در آن الگو وجود ندارد.</p>
<p>برای متغیرهای enum شبیه به struct، مانند <code>Message::Move</code>، می‌توانیم از الگویی مشابه الگوی مشخص‌شده برای تطبیق structs استفاده کنیم. پس از نام متغیر، آکولاد باز می‌کنیم و سپس فیلدها را با متغیرها لیست می‌کنیم تا بخش‌ها را برای استفاده در کد این بازو تجزیه کنیم. در اینجا از فرم کوتاه همان‌طور که در فهرست 19-13 استفاده کردیم استفاده می‌کنیم.</p>
<p>برای متغیرهای enum شبیه به tuple، مانند <code>Message::Write</code> که یک tuple با یک عنصر دارد و <code>Message::ChangeColor</code> که یک tuple با سه عنصر دارد، الگو مشابه الگویی است که برای تطبیق tuple‌ها مشخص می‌کنیم. تعداد متغیرها در الگو باید با تعداد عناصر در متغیر که تطبیق می‌دهیم مطابقت داشته باشد.</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>تاکنون، مثال‌های ما همه تطبیق ساختارها یا enums در یک سطح عمیق بوده‌اند، اما تطبیق می‌تواند روی آیتم‌های تو در تو نیز کار کند! برای مثال، می‌توانیم کد در فهرست 19-15 را بازسازی کنیم تا از رنگ‌های RGB و HSV در پیام <code>ChangeColor</code> پشتیبانی کند، همان‌طور که در فهرست 19-16 نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<figcaption>Listing 19-16: تطبیق روی enums تو در تو</figcaption>
</figure>
<p>الگوی بازوی اول در عبارت <code>match</code> یک متغیر enum به نام <code>Message::ChangeColor</code> را تطبیق می‌دهد که شامل یک متغیر <code>Color::Rgb</code> است؛ سپس الگو به سه مقدار داخلی <code>i32</code> متصل می‌شود. الگوی بازوی دوم نیز یک متغیر enum به نام <code>Message::ChangeColor</code> را تطبیق می‌دهد، اما enum داخلی به جای آن <code>Color::Hsv</code> را مطابقت می‌دهد. ما می‌توانیم این شرایط پیچیده را در یک عبارت <code>match</code> مشخص کنیم، حتی اگر دو enum درگیر باشند.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>ما می‌توانیم الگوهای تخریب را به روش‌های پیچیده‌تر ترکیب، تطبیق و تو در تو کنیم. مثال زیر یک تخریب پیچیده را نشان می‌دهد که در آن ساختارها و tuple‌ها را داخل یک tuple تو در تو می‌کنیم و تمام مقادیر اولیه را تخریب می‌کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>این کد به ما اجازه می‌دهد انواع پیچیده را به اجزای سازنده آن‌ها بشکنیم تا بتوانیم مقادیری که به آن‌ها علاقه داریم را جداگانه استفاده کنیم.</p>
<p>تخریب با الگوها یک روش راحت برای استفاده از بخش‌هایی از مقادیر، مانند مقدار هر فیلد در یک ساختار، به‌صورت جداگانه است.</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>گاهی اوقات مفید است که مقادیر را در یک الگو نادیده بگیرید، مانند بازوی آخر یک <code>match</code>، برای دریافت یک catchall که هیچ کاری انجام نمی‌دهد اما تمام مقادیر باقی‌مانده ممکن را در نظر می‌گیرد. چندین روش برای نادیده گرفتن مقادیر کامل یا بخش‌هایی از مقادیر در یک الگو وجود دارد: استفاده از الگوی <code>_</code> (که دیده‌اید)، استفاده از الگوی <code>_</code> درون یک الگوی دیگر، استفاده از نامی که با یک زیرخط شروع می‌شود، یا استفاده از <code>..</code> برای نادیده گرفتن بخش‌های باقی‌مانده یک مقدار. بیایید بررسی کنیم چگونه و چرا از هر یک از این الگوها استفاده کنیم.</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>ما از زیرخط به‌عنوان یک الگوی wildcard استفاده کرده‌ایم که با هر مقداری مطابقت دارد اما به مقدار متصل نمی‌شود. این به‌ویژه به‌عنوان بازوی آخر در یک عبارت <code>match</code> مفید است، اما ما همچنین می‌توانیم آن را در هر الگویی استفاده کنیم، از جمله پارامترهای تابع، همان‌طور که در فهرست 19-17 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<figcaption>Listing 19-17: استفاده از <code>_</code> در یک امضای تابع</figcaption>
</figure>
<p>این کد مقدار <code>3</code> را که به‌عنوان آرگومان اول ارسال شده است، کاملاً نادیده می‌گیرد و پیام <code>This code only uses the y parameter: 4</code> را چاپ می‌کند.</p>
<p>در بیشتر موارد، زمانی که دیگر نیازی به یک پارامتر تابع خاص ندارید، امضای تابع را تغییر می‌دهید تا آن پارامتر استفاده‌نشده را شامل نشود. نادیده گرفتن یک پارامتر تابع می‌تواند به‌ویژه در مواردی مفید باشد که، برای مثال، شما در حال پیاده‌سازی یک trait هستید و به یک امضای خاص نیاز دارید، اما بدنه تابع در پیاده‌سازی شما نیازی به یکی از پارامترها ندارد. در این صورت، از دریافت هشدار کامپایلر درباره پارامترهای استفاده‌نشده جلوگیری می‌کنید، همان‌طور که اگر به جای آن از یک نام استفاده می‌کردید، هشدار دریافت می‌کردید.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>ما همچنین می‌توانیم از <code>_</code> در داخل یک الگوی دیگر استفاده کنیم تا فقط بخشی از یک مقدار را نادیده بگیریم. برای مثال، وقتی می‌خواهیم فقط بخشی از یک مقدار را تست کنیم اما نیازی به استفاده از بخش‌های دیگر در کدی که می‌خواهیم اجرا کنیم نداریم. فهرست 19-18 کدی را نشان می‌دهد که مسئول مدیریت مقدار یک تنظیم است. نیازمندی‌های تجاری این است که کاربر نباید اجازه داشته باشد یک سفارشی‌سازی موجود برای یک تنظیم را بازنویسی کند، اما می‌تواند تنظیم را لغو کند و به آن یک مقدار بدهد اگر در حال حاضر لغو شده باشد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-18: استفاده از یک زیرخط در داخل الگوهایی که با متغیرهای <code>Some</code> مطابقت دارند وقتی نیازی به استفاده از مقدار داخل <code>Some</code> نداریم</figcaption>
</figure>
<p>این کد پیام <code>Can't overwrite an existing customized value</code> را چاپ می‌کند و سپس <code>setting is Some(5)</code> را چاپ می‌کند. در بازوی اول match، نیازی به مطابقت یا استفاده از مقادیر داخل هر یک از متغیرهای <code>Some</code> نداریم، اما باید حالت‌هایی را که در آن‌ها <code>setting_value</code> و <code>new_setting_value</code> در حالت <code>Some</code> هستند، تست کنیم. در این صورت، دلیل تغییر ندادن <code>setting_value</code> را چاپ می‌کنیم و این مقدار تغییر نمی‌کند.</p>
<p>در تمام موارد دیگر (اگر <code>setting_value</code> یا <code>new_setting_value</code> مقدار <code>None</code> داشته باشند) که توسط الگوی <code>_</code> در بازوی دوم بیان شده است، می‌خواهیم اجازه دهیم <code>new_setting_value</code> به <code>setting_value</code> تبدیل شود.</p>
<p>ما همچنین می‌توانیم از زیرخط‌ها در مکان‌های مختلف در یک الگو برای نادیده گرفتن مقادیر خاص استفاده کنیم. فهرست 19-19 مثالی از نادیده گرفتن مقادیر دوم و چهارم در یک tuple پنج آیتمی را نشان می‌دهد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-19: نادیده گرفتن بخش‌های مختلف یک tuple</figcaption>
</figure>
<p>این کد پیام <code>Some numbers: 2, 8, 32</code> را چاپ می‌کند و مقادیر 4 و 16 نادیده گرفته می‌شوند.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>اگر یک متغیر ایجاد کنید اما از آن در هیچ جایی استفاده نکنید، راست معمولاً یک هشدار صادر می‌کند زیرا یک متغیر استفاده‌نشده ممکن است یک باگ باشد. با این حال، گاهی اوقات مفید است که بتوانید متغیری ایجاد کنید که هنوز از آن استفاده نمی‌کنید، مانند زمانی که در حال نمونه‌سازی یا تازه شروع یک پروژه هستید. در این وضعیت، می‌توانید به راست بگویید که درباره متغیر استفاده‌نشده هشدار ندهد، با شروع نام متغیر با یک زیرخط. در فهرست 19-20، دو متغیر استفاده‌نشده ایجاد می‌کنیم، اما وقتی این کد را کامپایل می‌کنیم، باید فقط یک هشدار درباره یکی از آن‌ها دریافت کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<figcaption>Listing 19-20: شروع نام متغیر با یک زیرخط برای جلوگیری از هشدارهای متغیر استفاده‌نشده</figcaption>
</figure>
<p>اینجا درباره استفاده نکردن از متغیر <code>y</code> یک هشدار دریافت می‌کنیم، اما درباره استفاده نکردن از <code>_x</code> هشدار نمی‌گیریم.</p>
<p>توجه داشته باشید که تفاوت ظریفی بین استفاده از فقط <code>_</code> و استفاده از نامی که با یک زیرخط شروع می‌شود وجود دارد. نحو <code>_x</code> همچنان مقدار را به متغیر متصل می‌کند، در حالی که <code>_</code> اصلاً متصل نمی‌شود. برای نشان دادن موردی که این تفاوت اهمیت دارد، فهرست 19-21 به ما یک خطا ارائه می‌دهد.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-21: یک متغیر استفاده‌نشده که با یک زیرخط شروع می‌شود همچنان مقدار را متصل می‌کند، که ممکن است مالکیت مقدار را بگیرد</figcaption>
</figure>
<p>ما یک خطا دریافت خواهیم کرد زیرا مقدار <code>s</code> همچنان به <code>_s</code> منتقل می‌شود، که مانع از استفاده دوباره از <code>s</code> می‌شود. با این حال، استفاده از زیرخط به‌تنهایی هرگز به مقدار متصل نمی‌شود. فهرست 19-22 بدون هیچ خطایی کامپایل خواهد شد زیرا <code>s</code> به <code>_</code> منتقل نمی‌شود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-22: استفاده از یک زیرخط مقدار را متصل نمی‌کند</figcaption>
</figure>
<p>این کد به‌خوبی کار می‌کند زیرا ما هرگز <code>s</code> را به چیزی متصل نمی‌کنیم؛ بنابراین انتقال داده نمی‌شود.</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>برای مقادیری که بخش‌های زیادی دارند، می‌توانیم از نحو <code>..</code> برای استفاده از بخش‌های خاص و نادیده گرفتن باقی بخش‌ها استفاده کنیم، و نیازی به لیست کردن زیرخط‌ها برای هر مقدار نادیده گرفته‌شده نخواهیم داشت. الگوی <code>..</code> هر بخشی از یک مقدار را که به‌طور صریح در بقیه الگو مطابقت داده نشده نادیده می‌گیرد. در فهرست 19-23، یک struct به نام <code>Point</code> داریم که یک مختصات در فضای سه‌بعدی نگه می‌دارد. در عبارت <code>match</code>، می‌خواهیم فقط روی مختصات <code>x</code> عمل کنیم و مقادیر موجود در فیلدهای <code>y</code> و <code>z</code> را نادیده بگیریم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-23: نادیده گرفتن تمام فیلدهای یک <code>Point</code> به‌جز <code>x</code> با استفاده از <code>..</code></figcaption>
</figure>
<p>ما مقدار <code>x</code> را فهرست می‌کنیم و سپس فقط الگوی <code>..</code> را اضافه می‌کنیم. این سریع‌تر از این است که <code>y: _</code> و <code>z: _</code> را فهرست کنیم، به‌ویژه زمانی که با ساختارهایی کار می‌کنیم که فیلدهای زیادی دارند و فقط یکی یا دو فیلد مهم هستند.</p>
<p>نحو <code>..</code> به هر تعداد مقداری که نیاز باشد گسترش می‌یابد. فهرست 19-24 نشان می‌دهد که چگونه از <code>..</code> با یک tuple استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-24: تطبیق فقط اولین و آخرین مقادیر در یک tuple و نادیده گرفتن تمام مقادیر دیگر</figcaption>
</figure>
<p>در این کد، مقدار اول و آخر با <code>first</code> و <code>last</code> مطابقت داده می‌شوند. الگوی <code>..</code> تمام مقادیر میانی را مطابقت داده و نادیده می‌گیرد.</p>
<p>با این حال، استفاده از <code>..</code> باید بدون ابهام باشد. اگر مشخص نباشد کدام مقادیر برای تطبیق و کدام برای نادیده گرفتن در نظر گرفته شده‌اند، راست به ما خطا می‌دهد. فهرست 19-25 مثالی از استفاده از <code>..</code> به شکلی مبهم را نشان می‌دهد، بنابراین کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption>Listing 19-25: تلاشی برای استفاده از <code>..</code> به شکلی مبهم</figcaption>
</figure>
<p>وقتی این مثال را کامپایل می‌کنیم، این خطا را دریافت می‌کنیم:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>برای راست امکان‌پذیر نیست که تعیین کند چند مقدار در tuple باید نادیده گرفته شود قبل از اینکه یک مقدار را با <code>second</code> تطبیق دهد و سپس چند مقدار دیگر را بعد از آن نادیده بگیرد. این کد می‌تواند به این معنا باشد که می‌خواهیم <code>2</code> را نادیده بگیریم، <code>second</code> را به <code>4</code> متصل کنیم، و سپس <code>8</code>، <code>16</code> و <code>32</code> را نادیده بگیریم؛ یا اینکه می‌خواهیم <code>2</code> و <code>4</code> را نادیده بگیریم، <code>second</code> را به <code>8</code> متصل کنیم، و سپس <code>16</code> و <code>32</code> را نادیده بگیریم؛ و غیره. نام متغیر <code>second</code> برای راست معنی خاصی ندارد، بنابراین به دلیل استفاده از <code>..</code> در دو مکان به این شکل مبهم، خطای کامپایل دریافت می‌کنیم.</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>یک <em>match guard</em> یک شرط اضافی <code>if</code> است که پس از الگو در یک بازوی <code>match</code> مشخص می‌شود و باید برای انتخاب آن بازو نیز مطابقت داشته باشد. Match guardها برای بیان ایده‌های پیچیده‌تر از آنچه که یک الگو به‌تنهایی اجازه می‌دهد، مفید هستند. این قابلیت فقط در عبارات <code>match</code> در دسترس است، نه در عبارات <code>if let</code> یا <code>while let</code>.</p>
<p>شرط می‌تواند از متغیرهایی که در الگو ایجاد شده‌اند استفاده کند. فهرست 19-26 یک <code>match</code> را نشان می‌دهد که بازوی اول آن دارای الگوی <code>Some(x)</code> است و همچنین دارای یک match guard <code>if x % 2 == 0</code> است (که در صورتی که عدد زوج باشد، true خواهد بود).</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-26: افزودن یک match guard به یک الگو</figcaption>
</figure>
<p>این مثال پیام <code>The number 4 is even</code> را چاپ می‌کند. وقتی <code>num</code> با الگوی بازوی اول مقایسه می‌شود، مطابقت دارد، زیرا <code>Some(4)</code> با <code>Some(x)</code> مطابقت دارد. سپس match guard بررسی می‌کند که آیا باقی‌مانده تقسیم <code>x</code> بر 2 برابر با 0 است یا نه، و چون این شرط برقرار است، بازوی اول انتخاب می‌شود.</p>
<p>اگر مقدار <code>num</code> برابر با <code>Some(5)</code> بود، match guard در بازوی اول false می‌شد زیرا باقی‌مانده تقسیم 5 بر 2 برابر با 1 است که برابر با 0 نیست. راست سپس به بازوی دوم می‌رود که مطابقت دارد زیرا بازوی دوم match guard ندارد و بنابراین با هر متغیر <code>Some</code> مطابقت دارد.</p>
<p>هیچ راهی برای بیان شرط <code>if x % 2 == 0</code> در داخل یک الگو وجود ندارد، بنابراین match guard به ما امکان بیان این منطق را می‌دهد. نقطه ضعف این قابلیت اضافی این است که کامپایلر سعی نمی‌کند بررسی کند که آیا تمام موارد پوشش داده شده‌اند یا نه وقتی که match guardها درگیر هستند.</p>
<p>در فهرست 19-11 اشاره کردیم که می‌توانیم از match guardها برای حل مشکل shadowing الگو استفاده کنیم. به یاد بیاورید که ما یک متغیر جدید در داخل الگو در عبارت <code>match</code> ایجاد کردیم به جای استفاده از متغیر بیرون از <code>match</code>. آن متغیر جدید به این معنا بود که نمی‌توانستیم مقدار متغیر بیرونی را تست کنیم. فهرست 19-27 نشان می‌دهد که چگونه می‌توانیم از یک match guard برای رفع این مشکل استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<figcaption>Listing 19-27: استفاده از یک match guard برای آزمایش برابری با یک متغیر بیرونی</figcaption>
</figure>
<p>این کد اکنون پیام <code>Default case, x = Some(5)</code> را چاپ می‌کند. الگوی بازوی دوم match یک متغیر جدید <code>y</code> که متغیر بیرونی <code>y</code> را shadow کند معرفی نمی‌کند، به این معنا که می‌توانیم از متغیر بیرونی <code>y</code> در match guard استفاده کنیم. به جای مشخص کردن الگو به‌عنوان <code>Some(y)</code> که متغیر بیرونی <code>y</code> را shadow می‌کرد، ما <code>Some(n)</code> را مشخص می‌کنیم. این یک متغیر جدید <code>n</code> ایجاد می‌کند که هیچ چیزی را shadow نمی‌کند زیرا هیچ متغیر <code>n</code> در خارج از <code>match</code> وجود ندارد.</p>
<p>Match guard <code>if n == y</code> یک الگو نیست و بنابراین متغیرهای جدیدی را معرفی نمی‌کند. این <code>y</code> <em>همان</em> متغیر بیرونی <code>y</code> است و یک متغیر جدید که آن را shadow کند نیست، و می‌توانیم با مقایسه <code>n</code> با <code>y</code> به دنبال مقداری باشیم که با مقدار بیرونی <code>y</code> یکسان باشد.</p>
<p>همچنین می‌توانید از عملگر <em>یا</em> <code>|</code> در یک match guard استفاده کنید تا چندین الگو مشخص کنید؛ شرط match guard برای تمام الگوها اعمال خواهد شد. فهرست 19-28 تقدم هنگام ترکیب یک الگو که از <code>|</code> استفاده می‌کند با یک match guard را نشان می‌دهد. بخش مهم این مثال این است که match guard <code>if y</code> برای <code>4</code>، <code>5</code>، <em>و</em> <code>6</code> اعمال می‌شود، حتی اگر ممکن است به نظر برسد که <code>if y</code> فقط برای <code>6</code> اعمال می‌شود.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-28: ترکیب چندین الگو با یک match guard</figcaption>
</figure>
<p>شرط مطابقت بیان می‌کند که بازو فقط زمانی مطابقت دارد که مقدار <code>x</code> برابر با <code>4</code>، <code>5</code>، یا <code>6</code> <em>و</em> مقدار <code>y</code> برابر با <code>true</code> باشد. وقتی این کد اجرا می‌شود، الگوی بازوی اول مطابقت دارد زیرا <code>x</code> برابر با <code>4</code> است، اما match guard <code>if y</code> برابر با false است، بنابراین بازوی اول انتخاب نمی‌شود. کد به بازوی دوم می‌رود که مطابقت دارد، و این برنامه <code>no</code> را چاپ می‌کند. دلیل این است که شرط <code>if</code> برای کل الگوی <code>4 | 5 | 6</code> اعمال می‌شود، نه فقط برای مقدار آخر <code>6</code>. به عبارت دیگر، تقدم یک match guard نسبت به یک الگو به این شکل رفتار می‌کند:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>و نه به این شکل:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>بعد از اجرای کد، رفتار تقدم آشکار می‌شود: اگر match guard فقط برای مقدار نهایی در لیست مقادیر مشخص‌شده با استفاده از عملگر <code>|</code> اعمال می‌شد، بازو مطابقت می‌داشت و برنامه پیام <code>yes</code> را چاپ می‌کرد.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>عملگر <em>at</em> (<code>@</code>) به ما امکان می‌دهد یک متغیر ایجاد کنیم که یک مقدار را نگه می‌دارد و همزمان آن مقدار را برای تطبیق با الگو آزمایش می‌کند. در فهرست 19-29، ما می‌خواهیم بررسی کنیم که آیا فیلد <code>id</code> در <code>Message::Hello</code> در بازه <code>3..=7</code> قرار دارد یا نه. همچنین می‌خواهیم مقدار را به متغیر <code>id_variable</code> متصل کنیم تا بتوانیم در کد مرتبط با بازو از آن استفاده کنیم. می‌توانستیم این متغیر را <code>id</code> بنامیم، مشابه فیلد، اما برای این مثال از نام متفاوتی استفاده خواهیم کرد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-29: استفاده از <code>@</code> برای اتصال به یک مقدار در یک الگو و همزمان آزمایش آن</figcaption>
</figure>
<p>این مثال پیام <code>Found an id in range: 5</code> را چاپ می‌کند. با مشخص کردن <code>id_variable @</code> قبل از بازه <code>3..=7</code>، ما هر مقداری که با بازه مطابقت داشت را ذخیره می‌کنیم و همزمان بررسی می‌کنیم که آیا مقدار با الگوی بازه مطابقت دارد.</p>
<p>در بازوی دوم، جایی که فقط یک بازه در الگو مشخص شده است، کدی که با بازو مرتبط است متغیری ندارد که مقدار واقعی فیلد <code>id</code> را شامل شود. مقدار فیلد <code>id</code> می‌توانست 10، 11، یا 12 باشد، اما کدی که با آن الگو مرتبط است نمی‌داند مقدار چیست. کد بازو نمی‌تواند از مقدار فیلد <code>id</code> استفاده کند، زیرا ما مقدار <code>id</code> را در یک متغیر ذخیره نکرده‌ایم.</p>
<p>در بازوی آخر، جایی که یک متغیر بدون بازه مشخص کرده‌ایم، مقدار برای استفاده در کد بازو در متغیری به نام <code>id</code> در دسترس است. دلیل این است که ما از نحو کوتاه فیلدهای struct استفاده کرده‌ایم. اما در این بازو هیچ آزمایشی برای مقدار در فیلد <code>id</code> اعمال نکرده‌ایم، همان‌طور که در دو بازوی اول انجام دادیم: هر مقداری با این الگو مطابقت خواهد داشت.</p>
<p>استفاده از <code>@</code> به ما امکان می‌دهد یک مقدار را آزمایش کنیم و همزمان آن را در یک متغیر ذخیره کنیم، همه در یک الگو.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>الگوهای راست در تشخیص بین انواع مختلف داده بسیار مفید هستند. وقتی در عبارات <code>match</code> استفاده می‌شوند، راست اطمینان حاصل می‌کند که الگوهای شما تمام مقادیر ممکن را پوشش می‌دهند، وگرنه برنامه شما کامپایل نخواهد شد. الگوها در عبارات <code>let</code> و پارامترهای تابع این ساختارها را مفیدتر می‌کنند و تخریب مقادیر به بخش‌های کوچک‌تر را همزمان با تخصیص به متغیرها ممکن می‌سازند. ما می‌توانیم الگوهای ساده یا پیچیده‌ای ایجاد کنیم که نیازهای ما را برآورده کنند.</p>
<p>در فصل ماقبل آخر این کتاب، به برخی از جنبه‌های پیشرفته از ویژگی‌های مختلف راست خواهیم پرداخت.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>تا اینجا، شما با رایج‌ترین بخش‌های زبان برنامه‌نویسی راست آشنا شده‌اید. پیش از اینکه در فصل 21 یک پروژه دیگر انجام دهیم، به برخی از جنبه‌های زبان می‌پردازیم که ممکن است هر از گاهی با آن‌ها روبرو شوید، اما شاید هر روز از آن‌ها استفاده نکنید. می‌توانید از این فصل به‌عنوان مرجعی استفاده کنید زمانی که با موارد ناشناخته‌ای روبرو می‌شوید. ویژگی‌هایی که اینجا پوشش داده می‌شوند در موقعیت‌های بسیار خاص مفید هستند. اگرچه ممکن است اغلب به آن‌ها نیاز نداشته باشید، ما می‌خواهیم اطمینان حاصل کنیم که شما درک خوبی از تمام ویژگی‌هایی که راست ارائه می‌دهد دارید.</p>
<p>در این فصل، ما به موضوعات زیر خواهیم پرداخت:</p>
<ul>
<li>Unsafe Rust: چگونه می‌توان از برخی از تضمین‌های راست چشم‌پوشی کرد و مسئولیت تضمین دستی این موارد را بر عهده گرفت.</li>
<li>Advanced traits: نوع‌های مرتبط (associated types)، پارامترهای نوع پیش‌فرض، نحو کاملاً واجد شرایط، ابر traits (supertraits)، و الگوی newtype در رابطه با traits.</li>
<li>Advanced types: بیشتر درباره الگوی newtype، نام مستعار نوع (type aliases)، نوع never، و نوع‌های با اندازه پویا.</li>
<li>Advanced functions and closures: اشاره‌گر (Pointer)های تابع و بازگرداندن closures.</li>
<li>Macros: روش‌هایی برای تعریف کدی که در زمان کامپایل کد بیشتری تعریف می‌کند.</li>
</ul>
<p>این یک مجموعه گسترده از ویژگی‌های راست است که برای همه چیزی در آن وجود دارد! بیایید شروع کنیم!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>تمام کدی که تا به حال بررسی کرده‌ایم دارای تضمین‌های ایمنی حافظه راست بوده است که در زمان کامپایل اعمال می‌شوند. با این حال، راست دارای یک زبان دوم مخفی درون خود است که این تضمین‌های ایمنی حافظه را اعمال نمی‌کند: این زبان <em>Unsafe Rust</em> نامیده می‌شود و درست مانند راست معمولی کار می‌کند، اما به ما قدرت‌های فوق‌العاده‌ای می‌دهد.</p>
<p>وجود Unsafe Rust به این دلیل است که تحلیل ایستا ذاتاً محافظه‌کارانه است. وقتی کامپایلر سعی می‌کند تعیین کند که آیا کد تضمین‌ها را رعایت می‌کند یا نه، بهتر است برخی از برنامه‌های معتبر را رد کند تا اینکه برخی از برنامه‌های نامعتبر را بپذیرد. اگرچه ممکن است کد <em>درست</em> باشد، اما اگر کامپایلر راست اطلاعات کافی برای اطمینان نداشته باشد، کد را رد خواهد کرد. در این موارد، می‌توانید از کد ناامن برای گفتن به کامپایلر استفاده کنید: «به من اعتماد کن، من می‌دانم چه کار می‌کنم.» اما هشدار داده شود که شما از کد ناامن به مسئولیت خودتان استفاده می‌کنید: اگر از کد ناامن به‌طور نادرست استفاده کنید، مشکلاتی ممکن است به دلیل ناامنی حافظه ایجاد شوند، مانند dereferencing اشاره‌گر (Pointer) null.</p>
<p>دلیل دیگر وجود یک همزاد ناامن برای راست این است که سخت‌افزار کامپیوتر در ذات خود ناامن است. اگر راست به شما اجازه انجام عملیات ناامن را نمی‌داد، نمی‌توانستید برخی از وظایف را انجام دهید. راست باید به شما اجازه دهد تا برنامه‌نویسی سطح پایین سیستم، مانند تعامل مستقیم با سیستم‌عامل یا حتی نوشتن سیستم‌عامل خودتان را انجام دهید. کار با برنامه‌نویسی سطح پایین سیستم یکی از اهداف این زبان است. بیایید بررسی کنیم که با Unsafe Rust چه می‌توانیم انجام دهیم و چگونه باید این کار را انجام دهیم.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>برای تغییر به Unsafe Rust، از کلیدواژه <code>unsafe</code> استفاده کنید و سپس یک بلوک جدید که کد ناامن را نگه می‌دارد شروع کنید. در Unsafe Rust می‌توانید پنج عمل را انجام دهید که در راست امن نمی‌توانید، و ما این‌ها را <em>قدرت‌های فوق‌العاده ناامن</em> می‌نامیم. این قدرت‌ها شامل توانایی‌های زیر هستند:</p>
<ul>
<li>Dereference یک اشاره‌گر (Pointer) خام</li>
<li>فراخوانی یک تابع یا متد ناامن</li>
<li>دسترسی یا تغییر یک متغیر static قابل تغییر</li>
<li>پیاده‌سازی یک trait ناامن</li>
<li>دسترسی به فیلدهای یک <code>union</code></li>
</ul>
<p>مهم است که بفهمید <code>unsafe</code> سیستم borrow checker یا سایر بررسی‌های ایمنی راست را خاموش نمی‌کند: اگر از یک reference در کد ناامن استفاده کنید، همچنان بررسی خواهد شد. کلیدواژه <code>unsafe</code> فقط به شما دسترسی به این پنج ویژگی می‌دهد که سپس توسط کامپایلر برای ایمنی حافظه بررسی نمی‌شوند. شما همچنان درجه‌ای از ایمنی را در داخل یک بلوک ناامن خواهید داشت.</p>
<p>علاوه بر این، <code>unsafe</code> به این معنا نیست که کد داخل بلوک لزوماً خطرناک است یا اینکه حتماً مشکلات ایمنی حافظه خواهد داشت: قصد این است که به‌عنوان برنامه‌نویس، شما اطمینان حاصل کنید که کد داخل یک بلوک <code>unsafe</code> به روشی معتبر به حافظه دسترسی خواهد داشت.</p>
<p>از آنجا که انسان‌ها دچار اشتباه می‌شوند، ممکن است اشتباهاتی رخ دهد، اما با الزام این پنج عملیات ناامن به اینکه در بلوک‌هایی که با <code>unsafe</code> حاشیه‌نویسی شده‌اند قرار گیرند، شما می‌دانید که هر خطایی مرتبط با ایمنی حافظه باید در داخل یک بلوک ناامن باشد. بلوک‌های <code>unsafe</code> را کوچک نگه دارید؛ بعداً زمانی که به بررسی باگ‌های حافظه می‌پردازید، از این کار سپاسگزار خواهید بود.</p>
<p>برای ایزوله کردن کد ناامن تا حد ممکن، بهتر است کد ناامن را درون یک انتزاع امن قرار دهید و یک API امن ارائه دهید، که در ادامه فصل وقتی توابع و متدهای ناامن را بررسی می‌کنیم، در این مورد بحث خواهیم کرد. بخش‌هایی از کتابخانه استاندارد به‌عنوان انتزاعات امن روی کد ناامن که مورد بازبینی قرار گرفته‌اند پیاده‌سازی شده‌اند. محصور کردن کد ناامن در یک انتزاع امن از نشت استفاده‌های <code>unsafe</code> به تمام مکان‌هایی که شما یا کاربران‌تان ممکن است بخواهند از قابلیت‌هایی که با کد ناامن پیاده‌سازی شده‌اند استفاده کنند، جلوگیری می‌کند، زیرا استفاده از یک انتزاع امن، امن است.</p>
<p>بیایید به هر یک از پنج قدرت فوق‌العاده ناامن به‌نوبت نگاه کنیم. همچنین به برخی از انتزاعات که یک رابط امن برای کد ناامن فراهم می‌کنند نگاهی خواهیم انداخت.</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>در فصل 4، در بخش <a href="ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a><!-- ignore -->، اشاره کردیم که کامپایلر تضمین می‌کند که ارجاعات همیشه معتبر هستند. Unsafe Rust دو نوع جدید به نام <em>اشاره‌گر (Pointer)های خام</em> (raw pointers) دارد که مشابه ارجاعات هستند. مانند ارجاعات، اشاره‌گر (Pointer)های خام می‌توانند immutable یا mutable باشند و به‌ترتیب به‌شکل <code>*const T</code> و <code>*mut T</code> نوشته می‌شوند. ستاره (<code>*</code>) عملگر dereference نیست؛ بلکه بخشی از نام نوع است. در زمینه اشاره‌گر (Pointer)های خام، <em>immutable</em> به این معناست که اشاره‌گر (Pointer) نمی‌تواند پس از dereference مستقیماً مقداردهی شود.</p>
<p>در مقایسه با ارجاعات و اشاره‌گر های هوشمند (smart pointers)، اشاره‌گر (Pointer)های خام:</p>
<ul>
<li>مجاز به نادیده گرفتن قوانین borrowing هستند، به این صورت که می‌توانند هم اشاره‌گر (Pointer)های immutable و هم اشاره‌گر (Pointer)های mutable به همان مکان داشته باشند.</li>
<li>تضمینی برای اشاره به حافظه معتبر ندارند.</li>
<li>می‌توانند null باشند.</li>
<li>هیچ پاکسازی خودکاری را پیاده‌سازی نمی‌کنند.</li>
</ul>
<p>با صرف‌نظر از تضمین‌های اجباری راست، می‌توانید ایمنی تضمین‌شده را با عملکرد بهتر یا توانایی ارتباط با یک زبان یا سخت‌افزار دیگر که تضمین‌های راست در آن‌ها اعمال نمی‌شود، مبادله کنید.</p>
<p>فهرست 20-1 نشان می‌دهد که چگونه یک اشاره‌گر (Pointer) خام immutable و یک اشاره‌گر (Pointer) خام mutable ایجاد کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-1: ایجاد اشاره‌گر (Pointer)های خام با عملگرهای raw borrow</figcaption>
</figure>
<p>توجه داشته باشید که ما در این کد از کلیدواژه <code>unsafe</code> استفاده نکرده‌ایم. می‌توانیم اشاره‌گر (Pointer)های خام را در کد امن ایجاد کنیم؛ فقط نمی‌توانیم خارج از یک بلوک <code>unsafe</code> اشاره‌گر (Pointer)های خام را dereference کنیم، همان‌طور که در ادامه خواهید دید.</p>
<p>ما اشاره‌گر (Pointer)های خام را با استفاده از عملگرهای raw borrow ایجاد کرده‌ایم: <code>&amp;raw const num</code> یک اشاره‌گر (Pointer) خام immutable از نوع <code>*const i32</code> ایجاد می‌کند، و <code>&amp;raw mut num</code> یک اشاره‌گر (Pointer) خام mutable از نوع <code>*mut i32</code> ایجاد می‌کند. چون آن‌ها را مستقیماً از یک متغیر محلی ایجاد کرده‌ایم، می‌دانیم که این اشاره‌گر (Pointer)های خام خاص معتبر هستند، اما نمی‌توانیم این فرض را برای هر اشاره‌گر (Pointer) خامی داشته باشیم.</p>
<p>برای نشان دادن این موضوع، در ادامه یک اشاره‌گر (Pointer) خام ایجاد می‌کنیم که نمی‌توانیم به‌طور قطع از اعتبار آن مطمئن باشیم، با استفاده از <code>as</code> برای تبدیل یک مقدار به‌جای استفاده از عملگرهای raw reference. فهرست 20-2 نشان می‌دهد که چگونه یک اشاره‌گر (Pointer) خام به یک مکان دلخواه در حافظه ایجاد کنیم. تلاش برای استفاده از حافظه دلخواه تعریف‌نشده است: ممکن است داده‌ای در آن آدرس باشد یا نباشد، کامپایلر ممکن است کد را بهینه‌سازی کند تا هیچ دسترسی حافظه‌ای وجود نداشته باشد، یا برنامه ممکن است با یک خطای segmentation fault مواجه شود. معمولاً دلیل خوبی برای نوشتن کدی مانند این وجود ندارد، به‌ویژه در مواردی که می‌توانید از عملگر raw borrow استفاده کنید، اما این کار امکان‌پذیر است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-2: ایجاد یک اشاره‌گر (Pointer) خام به یک آدرس حافظه دلخواه</figcaption>
</figure>
<p>به یاد داشته باشید که می‌توانیم اشاره‌گر (Pointer)های خام را در کد امن ایجاد کنیم، اما نمی‌توانیم اشاره‌گر (Pointer)های خام را <em>dereference</em> کنیم و داده‌ای که به آن اشاره شده را بخوانیم. در فهرست 20-3، ما از عملگر dereference (<code>*</code>) روی یک اشاره‌گر (Pointer) خام استفاده می‌کنیم که به یک بلوک <code>unsafe</code> نیاز دارد.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-3: Dereferencing اشاره‌گر (Pointer)های خام درون یک بلوک <code>unsafe</code></figcaption>
</figure>
<p>ایجاد یک اشاره‌گر (Pointer) آسیبی نمی‌رساند؛ فقط وقتی سعی می‌کنیم به مقداری که به آن اشاره می‌کند دسترسی پیدا کنیم ممکن است با یک مقدار نامعتبر سر و کار داشته باشیم.</p>
<p>همچنین توجه داشته باشید که در فهرست 20-1 و 20-3، ما اشاره‌گر (Pointer)های خام <code>*const i32</code> و <code>*mut i32</code> ایجاد کردیم که هر دو به همان مکان حافظه که <code>num</code> در آن ذخیره شده بود اشاره می‌کردند. اگر به‌جای این کار، سعی می‌کردیم یک ارجاع immutable و یک ارجاع mutable به <code>num</code> ایجاد کنیم، کد کامپایل نمی‌شد، زیرا قوانین مالکیت راست اجازه نمی‌دهند که یک ارجاع mutable همزمان با هر ارجاع immutable دیگری وجود داشته باشد. با اشاره‌گر (Pointer)های خام، می‌توانیم یک اشاره‌گر (Pointer) mutable و یک اشاره‌گر (Pointer) immutable به همان مکان ایجاد کنیم و داده‌ها را از طریق اشاره‌گر (Pointer) mutable تغییر دهیم، که ممکن است یک data race ایجاد کند. مراقب باشید!</p>
<p>با وجود تمام این خطرات، چرا باید از اشاره‌گر (Pointer)های خام استفاده کنید؟ یکی از موارد استفاده اصلی هنگام تعامل با کد C است، همان‌طور که در بخش بعدی <a href="ch20-01-unsafe-rust.html#calling-an-unsafe-function-or-method">“Calling an Unsafe Function or Method.”</a><!-- ignore --> خواهید دید. مورد دیگر زمانی است که انتزاعات امنی ایجاد می‌کنید که سیستم borrow checker آن را نمی‌فهمد. ابتدا توابع ناامن را معرفی می‌کنیم و سپس به یک مثال از یک انتزاع امن که از کد ناامن استفاده می‌کند، می‌پردازیم.</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>دومین نوع عملیاتی که می‌توانید در یک بلوک ناامن انجام دهید، فراخوانی توابع ناامن است. توابع و متدهای ناامن دقیقاً شبیه توابع و متدهای عادی به نظر می‌رسند، اما قبل از بقیه تعریف یک <code>unsafe</code> اضافه دارند. کلیدواژه <code>unsafe</code> در این زمینه نشان می‌دهد که تابع دارای الزاماتی است که هنگام فراخوانی این تابع باید رعایت کنیم، زیرا راست نمی‌تواند تضمین کند که این الزامات را رعایت کرده‌ایم. با فراخوانی یک تابع ناامن در یک بلوک <code>unsafe</code>، ما می‌گوییم که مستندات این تابع را خوانده‌ایم و مسئولیت رعایت قراردادهای تابع را بر عهده می‌گیریم.</p>
<p>در اینجا یک تابع ناامن به نام <code>dangerous</code> آورده شده است که در بدنه خود کاری انجام نمی‌دهد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>ما باید تابع <code>dangerous</code> را در یک بلوک <code>unsafe</code> جداگانه فراخوانی کنیم. اگر سعی کنیم بدون بلوک <code>unsafe</code> تابع <code>dangerous</code> را فراخوانی کنیم، با خطا مواجه خواهیم شد:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>با استفاده از بلوک <code>unsafe</code>، ما به راست اعلام می‌کنیم که مستندات تابع را خوانده‌ایم، می‌دانیم چگونه به‌درستی از آن استفاده کنیم، و تأیید کرده‌ایم که قرارداد تابع را رعایت می‌کنیم.</p>
<p>برای انجام عملیات ناایمن (<em>unsafe</em>) در بدنه یک تابع ناایمن، همچنان باید از یک بلوک <code>unsafe</code> استفاده کنید، همان‌طور که در یک تابع معمولی این کار را می‌کنید، و اگر این کار را فراموش کنید، کامپایلر به شما هشدار خواهد داد. این امر به کوچک نگه داشتن بلوک‌های <code>unsafe</code> کمک می‌کند، زیرا ممکن است عملیات ناایمن در کل بدنه تابع مورد نیاز نباشد.</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>فقط به این دلیل که یک تابع حاوی کد ناامن است به این معنا نیست که باید کل تابع را به‌عنوان ناامن علامت‌گذاری کنیم. در واقع، محصور کردن کد ناامن در یک تابع ایمن یک انتزاع رایج است. به‌عنوان مثال، بیایید تابع <code>split_at_mut</code> از کتابخانه استاندارد را بررسی کنیم که به کد ناامن نیاز دارد. ما بررسی خواهیم کرد که چگونه ممکن است آن را پیاده‌سازی کنیم. این متد ایمن روی برش‌های قابل تغییر (mutable slices) تعریف شده است: این تابع یک برش را می‌گیرد و آن را به دو قسمت تقسیم می‌کند با تقسیم کردن برش در ایندکسی که به‌عنوان آرگومان داده شده است. فهرست 20-4 نشان می‌دهد که چگونه از <code>split_at_mut</code> استفاده کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-4: استفاده از تابع ایمن <code>split_at_mut</code></figcaption>
</figure>
<p>ما نمی‌توانیم این تابع را فقط با استفاده از راست ایمن پیاده‌سازی کنیم. یک تلاش ممکن است چیزی شبیه به فهرست 20-5 باشد، که کامپایل نخواهد شد. برای سادگی، ما <code>split_at_mut</code> را به‌عنوان یک تابع پیاده‌سازی می‌کنیم نه یک متد، و فقط برای برش‌های <code>i32</code> به‌جای یک نوع generic <code>T</code>.</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 20-5: تلاش برای پیاده‌سازی <code>split_at_mut</code> فقط با استفاده از راست ایمن</figcaption>
</figure>
<p>این تابع ابتدا طول کل برش را به دست می‌آورد. سپس تأیید می‌کند که ایندکسی که به‌عنوان پارامتر داده شده در محدوده برش قرار دارد، با بررسی اینکه آیا کمتر از یا برابر طول است. این تأیید به این معناست که اگر ایندکسی بزرگ‌تر از طول برای تقسیم برش داده شود، تابع قبل از تلاش برای استفاده از آن ایندکس دچار panic خواهد شد.</p>
<p>سپس دو برش قابل تغییر را در یک tuple بازمی‌گردانیم: یکی از ابتدای برش اصلی تا ایندکس <code>mid</code> و دیگری از <code>mid</code> تا انتهای برش.</p>
<p>وقتی سعی می‌کنیم کد در فهرست 20-5 را کامپایل کنیم، با خطا مواجه خواهیم شد.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Rust’s borrow checker نمی‌تواند بفهمد که ما در حال قرض گرفتن قسمت‌های مختلفی از یک برش هستیم؛ تنها چیزی که می‌داند این است که ما دو بار از همان برش قرض گرفته‌ایم. قرض گرفتن قسمت‌های مختلف یک برش اصولاً اشکالی ندارد، زیرا این دو برش با یکدیگر هم‌پوشانی ندارند، اما Rust به‌اندازه کافی هوشمند نیست که این موضوع را بداند. وقتی می‌دانیم کد مشکلی ندارد، اما Rust نمی‌داند، زمان استفاده از کد ناامن فرا می‌رسد.</p>
<p>فهرست 20-6 نشان می‌دهد که چگونه از یک بلوک <code>unsafe</code>، یک اشاره‌گر (Pointer) خام، و چند فراخوانی به توابع ناامن برای اجرای تابع <code>split_at_mut</code> استفاده کنیم.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-6: استفاده از کد ناامن در پیاده‌سازی تابع <code>split_at_mut</code></figcaption>
</figure>
<p>به یاد بیاورید از بخش <a href="ch04-03-slices.html#the-slice-type">“The Slice Type”</a><!-- ignore --> در فصل 4 که برش‌ها یک اشاره‌گر (Pointer) به برخی داده‌ها و طول آن برش هستند. ما از متد <code>len</code> برای دریافت طول یک برش و از متد <code>as_mut_ptr</code> برای دسترسی به اشاره‌گر (Pointer) خام یک برش استفاده می‌کنیم. در این مورد، چون ما یک برش قابل تغییر به مقادیر <code>i32</code> داریم، <code>as_mut_ptr</code> یک اشاره‌گر (Pointer) خام با نوع <code>*mut i32</code> بازمی‌گرداند که آن را در متغیر <code>ptr</code> ذخیره کرده‌ایم.</p>
<p>ما تأیید می‌کنیم که ایندکس <code>mid</code> در محدوده برش است. سپس به کد ناامن می‌رسیم: تابع <code>slice::from_raw_parts_mut</code> یک اشاره‌گر (Pointer) خام و یک طول را می‌گیرد و یک برش ایجاد می‌کند. ما از این تابع برای ایجاد یک برش که از <code>ptr</code> شروع می‌شود و <code>mid</code> آیتم طول دارد استفاده می‌کنیم. سپس متد <code>add</code> را روی <code>ptr</code> با آرگومان <code>mid</code> فراخوانی می‌کنیم تا یک اشاره‌گر (Pointer) خام که از <code>mid</code> شروع می‌شود دریافت کنیم، و با استفاده از آن اشاره‌گر (Pointer) و تعداد آیتم‌های باقی‌مانده بعد از <code>mid</code> به‌عنوان طول، یک برش ایجاد می‌کنیم.</p>
<p>تابع <code>slice::from_raw_parts_mut</code> ناامن است زیرا یک اشاره‌گر (Pointer) خام می‌گیرد و باید اعتماد کند که این اشاره‌گر (Pointer) معتبر است. متد <code>add</code> روی اشاره‌گر (Pointer)های خام نیز ناامن است، زیرا باید اعتماد کند که موقعیت آفست نیز یک اشاره‌گر (Pointer) معتبر است. بنابراین، ما مجبور شدیم یک بلوک <code>unsafe</code> در اطراف فراخوانی‌های خود به <code>slice::from_raw_parts_mut</code> و <code>add</code> قرار دهیم تا بتوانیم آن‌ها را فراخوانی کنیم. با نگاه به کد و با افزودن تأییدیه‌ای که <code>mid</code> باید کمتر از یا برابر با <code>len</code> باشد، می‌توانیم بگوییم که تمام اشاره‌گر (Pointer)های خام استفاده‌شده در بلوک <code>unsafe</code> اشاره‌گر (Pointer)های معتبری به داده‌های درون برش خواهند بود. این یک استفاده قابل‌قبول و مناسب از <code>unsafe</code> است.</p>
<p>توجه داشته باشید که نیازی به علامت‌گذاری تابع <code>split_at_mut</code> به‌عنوان <code>unsafe</code> نداریم و می‌توانیم این تابع را از کد امن Rust فراخوانی کنیم. ما یک انتزاع امن برای کد ناامن با پیاده‌سازی تابعی که از کد ناامن به روش ایمن استفاده می‌کند ایجاد کرده‌ایم، زیرا فقط اشاره‌گر (Pointer)های معتبری از داده‌هایی که این تابع به آن‌ها دسترسی دارد ایجاد می‌کند.</p>
<p>در مقابل، استفاده از <code>slice::from_raw_parts_mut</code> در فهرست 20-7 احتمالاً هنگام استفاده از برش باعث کرش کردن می‌شود. این کد یک مکان حافظه دلخواه می‌گیرد و یک برش با طول 10,000 آیتم ایجاد می‌کند.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-7: ایجاد یک برش از یک مکان حافظه دلخواه</figcaption>
</figure>
<p>ما مالک حافظه در این مکان دلخواه نیستیم و هیچ تضمینی وجود ندارد که برشی که این کد ایجاد می‌کند حاوی مقادیر معتبر <code>i32</code> باشد. تلاش برای استفاده از <code>values</code> به‌عنوان اینکه یک برش معتبر است منجر به رفتار تعریف‌نشده می‌شود.</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>گاهی اوقات، کد Rust شما ممکن است نیاز به تعامل با کدی که به زبان دیگری نوشته شده دارد. برای این منظور، راست کلیدواژه <code>extern</code> را ارائه می‌دهد که امکان ایجاد و استفاده از یک <em>رابط تابع خارجی (FFI)</em> را فراهم می‌کند. یک FFI راهی است برای یک زبان برنامه‌نویسی برای تعریف توابع و امکان فراخوانی آن توابع توسط یک زبان برنامه‌نویسی دیگر (خارجی).</p>
<p>فهرست 20-8 نشان می‌دهد که چگونه یک یکپارچه‌سازی با تابع <code>abs</code> از کتابخانه استاندارد C تنظیم کنیم. توابعی که درون بلوک‌های <code>extern</code> اعلام می‌شوند معمولاً از کد راست ناامن برای فراخوانی استفاده می‌شوند، بنابراین باید با <code>unsafe</code> نیز علامت‌گذاری شوند. دلیل این است که زبان‌های دیگر قوانین و تضمین‌های راست را اعمال نمی‌کنند، و راست نمی‌تواند آن‌ها را بررسی کند، بنابراین مسئولیت بر عهده برنامه‌نویس است که ایمنی را تضمین کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<figcaption>Listing 20-8: اعلام و فراخوانی یک تابع <code>extern</code> تعریف‌شده در زبان دیگر</figcaption>
</figure>
<p>درون بلوک <code>unsafe extern "C"</code>، ما نام‌ها و امضاهای توابع خارجی از یک زبان دیگر که می‌خواهیم فراخوانی کنیم را فهرست می‌کنیم. بخش <code>"C"</code> مشخص می‌کند که کدام <em>رابط دودویی برنامه (ABI)</em> توسط تابع خارجی استفاده می‌شود: ABI تعریف می‌کند که چگونه تابع در سطح اسمبلی فراخوانی شود. ABI <code>"C"</code> رایج‌ترین است و از ABI زبان برنامه‌نویسی C پیروی می‌کند.</p>
<p>این تابع خاص هیچ ملاحظات ایمنی حافظه‌ای ندارد. در واقع، ما می‌دانیم که هر فراخوانی به <code>abs</code> همیشه برای هر <code>i32</code> ایمن خواهد بود، بنابراین می‌توانیم از کلیدواژه <code>safe</code> استفاده کنیم تا بگوییم که این تابع خاص حتی با وجود اینکه در یک بلوک <code>unsafe extern</code> است، ایمن است. هنگامی که این تغییر را اعمال کنیم، فراخوانی آن دیگر نیاز به یک بلوک <code>unsafe</code> ندارد، همان‌طور که در فهرست 20-9 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
<figcaption>Listing 20-9: علامت‌گذاری صریح یک تابع به‌عنوان <code>safe</code> درون یک بلوک <code>unsafe extern</code> و فراخوانی ایمن آن</figcaption>
</figure>
<p>علامت‌گذاری یک تابع به‌عنوان <code>safe</code> ذاتاً آن را ایمن نمی‌کند! در عوض، این مانند یک وعده‌ای است که شما به راست می‌دهید که ایمن <em>است</em>. همچنان مسئولیت شماست که اطمینان حاصل کنید این وعده رعایت شود!</p>
<section class="note" aria-role="note">
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>ما همچنین می‌توانیم از <code>extern</code> برای ایجاد یک رابط استفاده کنیم که به زبان‌های دیگر اجازه دهد توابع راست را فراخوانی کنند. به جای ایجاد یک بلوک <code>extern</code> کامل، ما کلیدواژه <code>extern</code> را اضافه می‌کنیم و ABI مورد استفاده را درست قبل از کلیدواژه <code>fn</code> برای تابع مربوطه مشخص می‌کنیم. همچنین باید یک حاشیه‌نویسی <code>#[unsafe(no_mangle)]</code> اضافه کنیم تا به کامپایلر راست بگوییم نام این تابع را تغییر ندهد. <em>Mangling</em> زمانی است که یک کامپایلر نامی را که به یک تابع داده‌ایم به نامی متفاوت تغییر می‌دهد که حاوی اطلاعات بیشتری برای سایر بخش‌های فرآیند کامپایل باشد اما کمتر قابل خواندن برای انسان باشد. هر کامپایلر زبان برنامه‌نویسی نام‌ها را کمی متفاوت mangling می‌کند، بنابراین برای اینکه یک تابع راست توسط زبان‌های دیگر قابل نام‌گذاری باشد، باید mangling نام کامپایلر راست را غیرفعال کنیم. این ناامن است زیرا ممکن است در میان کتابخانه‌ها تضاد نام رخ دهد بدون mangling داخلی، بنابراین مسئولیت ماست که اطمینان حاصل کنیم نامی که صادر کرده‌ایم برای صدور بدون mangling ایمن است.</p>
<p>در مثال زیر، ما تابع <code>call_from_c</code> را برای کد C در دسترس قرار می‌دهیم، پس از اینکه به یک کتابخانه مشترک کامپایل و از C لینک شد:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>این استفاده از <code>extern</code> نیازی به <code>unsafe</code> ندارد.</p>
</section>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>در این کتاب، هنوز در مورد <em>متغیرهای جهانی</em> صحبت نکرده‌ایم، که راست از آن‌ها پشتیبانی می‌کند اما ممکن است با قوانین مالکیت راست مشکل‌ساز شوند. اگر دو thread به یک متغیر جهانی قابل تغییر دسترسی داشته باشند، ممکن است یک data race ایجاد شود.</p>
<p>در راست، متغیرهای جهانی <em>static</em> نامیده می‌شوند. فهرست 20-10 یک مثال از اعلام و استفاده از یک متغیر static با یک string slice به‌عنوان مقدار را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {HELLO_WORLD}");
}</code></pre></pre>
<figcaption>Listing 20-10: تعریف و استفاده از یک متغیر static غیرقابل تغییر</figcaption>
</figure>
<p>متغیرهای static مشابه ثابت‌ها هستند، که در بخش <a href="ch03-01-variables-and-mutability.html#constants">“Constants”</a><!-- ignore --> در فصل 3 در مورد آن‌ها صحبت کردیم. نام متغیرهای static طبق قرارداد به‌صورت <code>SCREAMING_SNAKE_CASE</code> نوشته می‌شود. متغیرهای static فقط می‌توانند ارجاع‌هایی با lifetime <code>'static</code> ذخیره کنند، به این معنا که کامپایلر راست می‌تواند lifetime را مشخص کند و نیازی نیست که آن را صراحتاً حاشیه‌نویسی کنیم. دسترسی به یک متغیر static غیرقابل تغییر ایمن است.</p>
<p>یک تفاوت ظریف بین ثابت‌ها و متغیرهای static غیرقابل تغییر این است که مقادیر در یک متغیر static دارای یک آدرس ثابت در حافظه هستند. استفاده از مقدار همیشه به همان داده دسترسی خواهد داشت. از سوی دیگر، ثابت‌ها مجاز هستند داده‌های خود را هر زمان که استفاده می‌شوند تکرار کنند. تفاوت دیگر این است که متغیرهای static می‌توانند قابل تغییر باشند. دسترسی و تغییر متغیرهای static قابل تغییر <em>ناامن</em> است. فهرست 20-11 نشان می‌دهد که چگونه یک متغیر static قابل تغییر به نام <code>COUNTER</code> را اعلام، دسترسی و تغییر دهیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
<figcaption>Listing 20-11: خواندن از یا نوشتن به یک متغیر static قابل تغییر ناامن است</figcaption>
</figure>
<p>همانند متغیرهای معمولی، ما با استفاده از کلمه کلیدی <code>mut</code> قابلیت تغییرپذیری را مشخص می‌کنیم. هر کدی که بخواهد از <code>COUNTER</code> بخواند یا در آن بنویسد، باید در یک بلوک <code>unsafe</code> باشد. کدی که در لیست ۲۰-۱۱ نشان داده شده است کامپایل می‌شود و مقدار <code>COUNTER: 3</code> را همان‌طور که انتظار می‌رود چاپ می‌کند، زیرا این کد تک‌ریسمانی (<em>single-threaded</em>) است. دسترسی چندین ریسمان به <code>COUNTER</code> به احتمال زیاد منجر به رقابت داده‌ای (<em>data race</em>) می‌شود و این رفتار تعریف‌نشده (<em>undefined behavior</em>) خواهد بود. بنابراین، نیاز است کل تابع را به عنوان <code>unsafe</code> علامت‌گذاری کنیم و محدودیت ایمنی را مستند کنیم، تا هرکسی که تابع را فراخوانی می‌کند بداند چه کارهایی را می‌تواند با اطمینان انجام دهد و چه کارهایی را نمی‌تواند.</p>
<p>هر زمان که یک تابع ناامن می‌نویسیم، به صورت قراردادی کامنتی با <code>SAFETY</code> شروع می‌کنیم و توضیح می‌دهیم که فراخوانی تابع چه چیزی نیاز دارد تا ایمن باشد. به همین ترتیب، هر زمان که یک عملیات ناامن انجام می‌دهیم، نوشتن یک کامنت که با <code>SAFETY</code> شروع شود برای توضیح اینکه چگونه قوانین ایمنی رعایت می‌شوند، قراردادی است.</p>
<p>علاوه بر این، کامپایلر به شما اجازه نمی‌دهد که مراجع به یک متغیر استاتیک تغییرپذیر ایجاد کنید. تنها می‌توانید از طریق یک اشاره‌گر خام (<em>raw pointer</em>) که با یکی از عملگرهای قرض خام ایجاد می‌شود به آن دسترسی پیدا کنید. این شامل مواردی است که مرجع به صورت نامرئی ایجاد می‌شود، مانند زمانی که در <code>println!</code> در این لیست کد استفاده می‌شود. الزام اینکه مراجع به متغیرهای استاتیک تغییرپذیر فقط از طریق اشاره‌گرهای خام ایجاد شوند، به وضوح بیشتر نیازهای ایمنی در استفاده از آن‌ها کمک می‌کند.</p>
<p>با داده‌های تغییرپذیری که به صورت جهانی قابل دسترسی هستند، اطمینان از اینکه رقابت داده‌ای (<em>data race</em>) رخ نمی‌دهد دشوار است، به همین دلیل Rust متغیرهای استاتیک تغییرپذیر را ناایمن در نظر می‌گیرد. در صورت امکان، ترجیح داده می‌شود از تکنیک‌های همزمانی (<em>concurrency techniques</em>) و اشاره‌گرهای هوشمند ایمن برای ریسمان‌ها (<em>thread-safe smart pointers</em>) که در فصل ۱۶ مورد بحث قرار گرفتند استفاده کنید تا کامپایلر بررسی کند که دسترسی به داده‌ها از ریسمان‌های مختلف به صورت ایمن انجام می‌شود.</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>می‌توانیم از <code>unsafe</code> برای پیاده‌سازی یک trait ناامن استفاده کنیم. یک trait زمانی ناامن است که حداقل یکی از متدهای آن دارای یک قاعده (invariant) باشد که کامپایلر نمی‌تواند آن را تأیید کند. ما با افزودن کلیدواژه <code>unsafe</code> قبل از <code>trait</code> اعلام می‌کنیم که یک trait ناامن است و پیاده‌سازی آن trait را نیز به‌عنوان <code>unsafe</code> علامت‌گذاری می‌کنیم، همان‌طور که در فهرست 20-12 نشان داده شده است.</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
<figcaption>Listing 20-12: تعریف و پیاده‌سازی یک trait ناامن</figcaption>
</figure>
<p>با استفاده از <code>unsafe impl</code>، ما قول می‌دهیم که قاعده‌هایی را که کامپایلر نمی‌تواند تأیید کند، رعایت کنیم.</p>
<p>به‌عنوان مثال، به marker traitهای <code>Sync</code> و <code>Send</code> که در بخش <a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits”</a><!-- ignore --> در فصل 16 بررسی کردیم، بازگردید: کامپایلر این traitها را به‌صورت خودکار پیاده‌سازی می‌کند اگر نوع‌های ما به‌طور کامل از نوع‌های <code>Send</code> و <code>Sync</code> تشکیل شده باشند. اگر نوعی پیاده‌سازی کنیم که حاوی نوعی است که <code>Send</code> یا <code>Sync</code> نیست، مانند اشاره‌گر (Pointer)های خام، و بخواهیم آن نوع را به‌عنوان <code>Send</code> یا <code>Sync</code> علامت‌گذاری کنیم، باید از <code>unsafe</code> استفاده کنیم. راست نمی‌تواند تأیید کند که نوع ما تضمین‌های لازم برای ارسال ایمن بین ریسمان‌ها یا دسترسی ایمن از ریسمان‌های متعدد را رعایت می‌کند؛ بنابراین، ما باید این بررسی‌ها را به‌صورت دستی انجام دهیم و این را با <code>unsafe</code> نشان دهیم.</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h3>
<p>آخرین عملی که تنها با <code>unsafe</code> کار می‌کند، دسترسی به فیلدهای یک <em>union</em> است. یک <code>union</code> شبیه به یک <code>struct</code> است، اما تنها یکی از فیلدهای اعلام‌شده در یک نمونه در هر زمان خاص استفاده می‌شود. unions عمدتاً برای تعامل با unions در کد C استفاده می‌شوند. دسترسی به فیلدهای union ناامن است زیرا راست نمی‌تواند نوع داده‌ای که در حال حاضر در نمونه union ذخیره شده را تضمین کند. می‌توانید اطلاعات بیشتری درباره unions در <a href="../reference/items/unions.html">مرجع راست</a> بیاموزید.</p>
<h3 id="using-miri-to-check-unsafe-code"><a class="header" href="#using-miri-to-check-unsafe-code">Using Miri to check unsafe code</a></h3>
<p>هنگام نوشتن کد ناامن، ممکن است بخواهید بررسی کنید که چیزی که نوشته‌اید واقعاً ایمن و درست است. یکی از بهترین روش‌ها برای این کار استفاده از <a href="https://github.com/rust-lang/miri">Miri</a>، یک ابزار رسمی راست برای شناسایی رفتارهای تعریف‌نشده است. در حالی که borrow checker یک ابزار <em>استاتیک</em> است که در زمان کامپایل کار می‌کند، Miri یک ابزار <em>داینامیک</em> است که در زمان اجرا کار می‌کند. این ابزار کد شما را با اجرای برنامه یا مجموعه تست آن بررسی می‌کند و زمانی که قوانین مربوط به نحوه کار راست را نقض کنید، آن را تشخیص می‌دهد.</p>
<p>استفاده از Miri نیاز به یک نسخه nightly از راست دارد (که در <a href="appendix-07-nightly-rust.html">ضمیمه ی: How Rust is Made and “Nightly Rust”</a> بیشتر درباره آن صحبت کرده‌ایم). می‌توانید یک نسخه nightly از راست و ابزار Miri را با تایپ کردن <code>rustup +nightly component add miri</code> نصب کنید. این کار نسخه راست پروژه شما را تغییر نمی‌دهد؛ فقط ابزار را به سیستم شما اضافه می‌کند تا هر زمان که بخواهید از آن استفاده کنید. می‌توانید Miri را روی یک پروژه با تایپ کردن <code>cargo +nightly miri run</code> یا <code>cargo +nightly miri test</code> اجرا کنید.</p>
<p>برای مثالی از اینکه این ابزار چقدر می‌تواند مفید باشد، به خروجی اجرای آن روی فهرست 20-11 توجه کنید:</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/Users/chris/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: creating a shared reference to mutable static is discouraged
  --&gt; src/main.rs:14:33
   |
14 |         println!("COUNTER: {}", COUNTER);
   |                                 ^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` on by default

COUNTER: 3
</code></pre>
<p>این ابزار به‌درستی متوجه می‌شود که ما به داده‌های قابل تغییر ارجاعات مشترک داده‌ایم و در این مورد هشدار می‌دهد. در این مورد، ابزار به ما نمی‌گوید که چگونه مشکل را برطرف کنیم، اما به ما اطلاع می‌دهد که ممکن است یک مشکل وجود داشته باشد و می‌توانیم به این فکر کنیم که چگونه مطمئن شویم که ایمن است. در موارد دیگر، ممکن است به ما بگوید که بخشی از کد قطعاً اشتباه است و توصیه‌هایی برای رفع آن ارائه دهد.</p>
<p>Miri همه چیزهایی را که ممکن است در هنگام نوشتن کد ناامن اشتباه باشد، شناسایی نمی‌کند. اولاً، چون این ابزار یک بررسی داینامیک است، فقط مشکلات کدی را که واقعاً اجرا می‌شود شناسایی می‌کند. این بدان معناست که باید از آن همراه با تکنیک‌های تست خوب استفاده کنید تا اطمینان بیشتری درباره کد ناامن خود داشته باشید. ثانیاً، این ابزار تمام راه‌های ممکن برای ناسالم بودن کد شما را پوشش نمی‌دهد. اگر Miri مشکلی را شناسایی کند، می‌دانید که یک باگ وجود دارد، اما فقط به این دلیل که Miri باگی را شناسایی نمی‌کند، به این معنا نیست که مشکلی وجود ندارد. با این حال، Miri می‌تواند بسیاری از مشکلات را شناسایی کند. آن را روی سایر مثال‌های کد ناامن در این فصل اجرا کنید و ببینید چه می‌گوید!</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>استفاده از <code>unsafe</code> برای انجام یکی از پنج عمل (ابرقدرت) که در اینجا بحث شد، اشتباه یا حتی نامناسب نیست. اما درست کردن کد <code>unsafe</code> سخت‌تر است، زیرا کامپایلر نمی‌تواند به حفظ ایمنی حافظه کمک کند. وقتی دلیلی برای استفاده از کد <code>unsafe</code> دارید، می‌توانید این کار را انجام دهید، و داشتن حاشیه‌نویسی صریح <code>unsafe</code> ردیابی منبع مشکلات را زمانی که اتفاق می‌افتند آسان‌تر می‌کند. هر زمان که کد ناامن می‌نویسید، می‌توانید از Miri استفاده کنید تا اطمینان بیشتری داشته باشید که کدی که نوشته‌اید قوانین راست را رعایت می‌کند.</p>
<p>برای یک بررسی عمیق‌تر درباره نحوه کار مؤثر با راست ناامن، راهنمای رسمی راست در این موضوع، یعنی <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> را بخوانید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h2>
<p>ما در بخش <a href="ch10-02-traits.html#traits-defining-shared-behavior">“Traits: Defining Shared Behavior”</a><!-- ignore --> از فصل 10 به بررسی traits پرداختیم، اما جزئیات پیشرفته‌تر آن را مورد بحث قرار ندادیم. اکنون که اطلاعات بیشتری در مورد راست دارید، می‌توانیم به عمق موضوع بپردازیم.</p>
<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>نوع‌های مرتبط</em> (Associated types) یک نوع جایگزین را با یک trait متصل می‌کنند، به‌گونه‌ای که تعریف‌های متد trait می‌توانند از این نوع‌های جایگزین در امضاهای خود استفاده کنند. پیاده‌ساز یک trait نوع خاصی را برای جایگزینی نوع جایگزین برای پیاده‌سازی خاص مشخص می‌کند. به این ترتیب، می‌توانیم یک trait تعریف کنیم که از برخی نوع‌ها استفاده می‌کند بدون اینکه نیاز داشته باشیم دقیقاً بدانیم این نوع‌ها چه هستند تا زمانی که trait پیاده‌سازی شود.</p>
<p>بیشتر ویژگی‌های پیشرفته‌ای که در این فصل توضیح داده شده است، به‌ندرت مورد نیاز هستند. نوع‌های مرتبط در حد وسط قرار دارند: آن‌ها کمتر از ویژگی‌های توضیح داده‌شده در بقیه کتاب استفاده می‌شوند، اما بیشتر از بسیاری از ویژگی‌های دیگر مورد بحث در این فصل به کار می‌روند.</p>
<p>یکی از مثال‌های یک trait با یک نوع مرتبط، trait <code>Iterator</code> است که کتابخانه استاندارد فراهم می‌کند. نوع مرتبط با نام <code>Item</code> مشخص شده و به‌جای نوع مقادیری که نوع پیاده‌سازی‌کننده <code>Iterator</code> از روی آن‌ها تکرار می‌کند قرار می‌گیرد. تعریف trait <code>Iterator</code> همان‌طور که در فهرست 20-13 نشان داده شده است:</p>
<figure class="listing">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<figcaption>Listing 20-13: تعریف trait <code>Iterator</code> که دارای یک نوع مرتبط به نام <code>Item</code> است</figcaption>
</figure>
<p>نوع <code>Item</code> یک جایگزین است و تعریف متد <code>next</code> نشان می‌دهد که مقادیری از نوع <code>Option&lt;Self::Item&gt;</code> را بازمی‌گرداند. پیاده‌سازان trait <code>Iterator</code> نوع خاصی را برای <code>Item</code> مشخص می‌کنند و متد <code>next</code> یک <code>Option</code> حاوی مقدار از آن نوع خاص بازمی‌گرداند.</p>
<p>نوع‌های مرتبط ممکن است مفهومی مشابه با genericها به نظر برسند، به این معنا که genericها به ما اجازه می‌دهند یک تابع بدون مشخص کردن نوع‌هایی که می‌تواند با آن‌ها کار کند، تعریف کنیم. برای بررسی تفاوت بین این دو مفهوم، به یک پیاده‌سازی trait <code>Iterator</code> روی یک نوع به نام <code>Counter</code> نگاه خواهیم کرد که نوع <code>Item</code> را به‌عنوان <code>u32</code> مشخص می‌کند:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>این سینتکس با سینتکس genericها قابل مقایسه به نظر می‌رسد. پس چرا به جای این کار، trait <code>Iterator</code> را با استفاده از genericها تعریف نکنیم، همان‌طور که در فهرست 20-14 نشان داده شده است؟</p>
<figure class="listing">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<figcaption>Listing 20-14: یک تعریف فرضی از trait <code>Iterator</code> با استفاده از genericها</figcaption>
</figure>
<p>تفاوت این است که هنگام استفاده از genericها، همان‌طور که در فهرست 20-14 نشان داده شده است، ما باید نوع‌ها را در هر پیاده‌سازی حاشیه‌نویسی کنیم. زیرا می‌توانیم همچنین <code>Iterator&lt;String&gt; for Counter</code> یا هر نوع دیگری را پیاده‌سازی کنیم، به‌طوری که بتوانیم پیاده‌سازی‌های متعددی از <code>Iterator</code> برای <code>Counter</code> داشته باشیم. به عبارت دیگر، زمانی که یک trait یک پارامتر generic دارد، می‌تواند برای یک نوع چندین بار پیاده‌سازی شود و نوع‌های خاص پارامترهای generic را هر بار تغییر دهد. زمانی که ما از متد <code>next</code> بر روی <code>Counter</code> استفاده می‌کنیم، باید حاشیه‌نویسی نوع ارائه دهیم تا مشخص کنیم کدام پیاده‌سازی <code>Iterator</code> را می‌خواهیم استفاده کنیم.</p>
<p>با استفاده از نوع‌های مرتبط، نیازی به حاشیه‌نویسی نوع‌ها نداریم زیرا نمی‌توانیم یک trait را بر روی یک نوع چندین بار پیاده‌سازی کنیم. در فهرست 20-13 با تعریفی که از نوع‌های مرتبط استفاده می‌کند، ما فقط می‌توانیم نوع <code>Item</code> را یک بار انتخاب کنیم، زیرا تنها یک <code>impl Iterator for Counter</code> می‌تواند وجود داشته باشد. ما نیازی نداریم که مشخص کنیم می‌خواهیم یک iterator از مقادیر <code>u32</code> داشته باشیم در هر جایی که <code>next</code> را بر روی <code>Counter</code> فراخوانی می‌کنیم.</p>
<p>نوع‌های مرتبط همچنین بخشی از قرارداد trait می‌شوند: پیاده‌سازان trait باید یک نوع ارائه دهند تا جایگزین نوع جایگزین مرتبط شود. نوع‌های مرتبط اغلب نامی دارند که توصیف می‌کند چگونه نوع استفاده خواهد شد و مستندسازی نوع مرتبط در مستندات API یک عمل خوب است.</p>
<h3 id="default-generic-type-parameters-and-operator-overloading"><a class="header" href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>وقتی که از پارامترهای generic type استفاده می‌کنیم، می‌توانیم یک نوع خاص پیش‌فرض برای پارامتر generic تعیین کنیم. این نیاز به مشخص کردن یک نوع خاص توسط پیاده‌سازان trait را در صورتی که نوع پیش‌فرض کار کند، از بین می‌برد. شما می‌توانید هنگام اعلام یک نوع generic، یک نوع پیش‌فرض با سینتکس <code>&lt;PlaceholderType=ConcreteType&gt;</code> مشخص کنید.</p>
<p>یک مثال عالی از وضعیتی که این تکنیک مفید است، <em>بارگذاری مجدد عملگرها</em> است، جایی که شما رفتار یک عملگر (مانند <code>+</code>) را در شرایط خاص شخصی‌سازی می‌کنید.</p>
<p>راست به شما اجازه نمی‌دهد عملگرهای خود را ایجاد کنید یا عملگرهای دلخواه را بارگذاری مجدد کنید. اما می‌توانید عملیات‌ها و traits مربوط به آن‌ها را که در <code>std::ops</code> فهرست شده‌اند با پیاده‌سازی traits مرتبط با عملگر، بارگذاری مجدد کنید. برای مثال، در فهرست 20-15 ما عملگر <code>+</code> را برای اضافه کردن دو نمونه <code>Point</code> به یکدیگر بارگذاری مجدد می‌کنیم. ما این کار را با پیاده‌سازی trait <code>Add</code> بر روی struct <code>Point</code> انجام می‌دهیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<figcaption>Listing 20-15: پیاده‌سازی trait <code>Add</code> برای بارگذاری مجدد عملگر <code>+</code> برای نمونه‌های <code>Point</code></figcaption>
</figure>
<p>متد <code>add</code> مقادیر <code>x</code> دو نمونه <code>Point</code> و مقادیر <code>y</code> دو نمونه <code>Point</code> را اضافه می‌کند تا یک نمونه جدید از <code>Point</code> ایجاد کند. trait <code>Add</code> دارای یک نوع مرتبط با نام <code>Output</code> است که نوع بازگشتی از متد <code>add</code> را تعیین می‌کند.</p>
<p>نوع generic پیش‌فرض در این کد در داخل trait <code>Add</code> است. در اینجا تعریف آن آمده است:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>این کد باید به طور کلی آشنا به نظر برسد: یک trait با یک متد و یک نوع مرتبط. بخش جدید <code>Rhs=Self</code> است: این سینتکس به <em>default type parameters</em> یا “پارامترهای نوع پیش‌فرض” معروف است. پارامتر generic نوع <code>Rhs</code> (مخفف “right hand side” یا “سمت راست”) نوع پارامتر <code>rhs</code> را در متد <code>add</code> تعریف می‌کند. اگر هنگام پیاده‌سازی trait <code>Add</code> یک نوع خاص برای <code>Rhs</code> مشخص نکنیم، نوع <code>Rhs</code> به طور پیش‌فرض به <code>Self</code> تنظیم می‌شود، که نوعی خواهد بود که ما <code>Add</code> را بر روی آن پیاده‌سازی می‌کنیم.</p>
<p>هنگامی که <code>Add</code> را برای <code>Point</code> پیاده‌سازی کردیم، از پیش‌فرض برای <code>Rhs</code> استفاده کردیم زیرا می‌خواستیم دو نمونه <code>Point</code> را به هم اضافه کنیم. حال، بیایید به مثالی از پیاده‌سازی trait <code>Add</code> نگاه کنیم که در آن می‌خواهیم نوع <code>Rhs</code> را شخصی‌سازی کنیم و از پیش‌فرض استفاده نکنیم.</p>
<p>ما دو struct به نام‌های <code>Millimeters</code> و <code>Meters</code> داریم که مقادیر را در واحدهای مختلف نگه می‌دارند. این نوع نازک‌سازی یک نوع موجود در یک struct دیگر به‌عنوان الگوی <em>newtype pattern</em> شناخته می‌شود که ما آن را در بخش <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Using the Newtype Pattern to Implement External Traits on External Types”</a><!-- ignore --> به‌طور مفصل توضیح می‌دهیم. ما می‌خواهیم مقادیر میلی‌متر را به مقادیر متر اضافه کنیم و پیاده‌سازی <code>Add</code> تبدیل را به‌درستی انجام دهد. می‌توانیم <code>Add</code> را برای <code>Millimeters</code> با <code>Meters</code> به‌عنوان <code>Rhs</code> همان‌طور که در فهرست 20-16 نشان داده شده است، پیاده‌سازی کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<figcaption>Listing 20-16: پیاده‌سازی trait <code>Add</code> برای <code>Millimeters</code> جهت افزودن <code>Millimeters</code> به <code>Meters</code></figcaption>
</figure>
<p>برای افزودن <code>Millimeters</code> و <code>Meters</code>، ما <code>impl Add&lt;Meters&gt;</code> را مشخص می‌کنیم تا مقدار پارامتر نوع <code>Rhs</code> را به جای استفاده از پیش‌فرض <code>Self</code> تنظیم کنیم.</p>
<p>شما از پارامترهای نوع پیش‌فرض در دو حالت اصلی استفاده خواهید کرد:</p>
<ul>
<li>برای گسترش یک نوع بدون شکستن کد موجود</li>
<li>برای اجازه دادن به شخصی‌سازی در موارد خاص که اکثر کاربران به آن نیازی ندارند</li>
</ul>
<p>trait <code>Add</code> در کتابخانه استاندارد یک مثال از هدف دوم است: معمولاً شما دو نوع مشابه را اضافه خواهید کرد، اما trait <code>Add</code> قابلیت شخصی‌سازی فراتر از آن را فراهم می‌کند. استفاده از پارامتر نوع پیش‌فرض در تعریف trait <code>Add</code> به این معناست که شما بیشتر اوقات نیازی به مشخص کردن پارامتر اضافی ندارید. به عبارت دیگر، مقدار کمی از کد اضافی حذف می‌شود و استفاده از trait آسان‌تر می‌شود.</p>
<p>هدف اول مشابه هدف دوم است، اما به‌صورت معکوس: اگر بخواهید یک پارامتر نوع را به یک trait موجود اضافه کنید، می‌توانید برای گسترش قابلیت‌های trait بدون شکستن کد پیاده‌سازی موجود، یک مقدار پیش‌فرض برای آن تنظیم کنید.</p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>در راست هیچ محدودیتی برای داشتن یک متد با همان نام در یک trait و در نوعی دیگر وجود ندارد و همچنین راست مانع نمی‌شود که هر دو trait را بر روی یک نوع پیاده‌سازی کنید. همچنین می‌توانید متدی را مستقیماً بر روی نوعی پیاده‌سازی کنید که همان نام متدهای مربوط به traits را دارد.</p>
<p>هنگام فراخوانی متدهایی با همان نام، باید به راست بگویید که کدام یک را می‌خواهید استفاده کنید. کد زیر در فهرست 20-17 را در نظر بگیرید که در آن دو trait به نام‌های <code>Pilot</code> و <code>Wizard</code> تعریف شده‌اند که هر دو دارای متدی به نام <code>fly</code> هستند. سپس هر دو trait بر روی نوع <code>Human</code> پیاده‌سازی می‌شوند که قبلاً متدی به نام <code>fly</code> نیز بر روی آن پیاده‌سازی شده است. هر متد <code>fly</code> کاری متفاوت انجام می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-17: دو trait تعریف شده‌اند که یک متد مشترک دارند و بر روی نوع <code>Human</code> پیاده‌سازی شده‌اند، و یک متد <code>fly</code> به‌طور مستقیم بر روی <code>Human</code> پیاده‌سازی شده است</figcaption>
</figure>
<p>وقتی متد <code>fly</code> را بر روی یک نمونه از <code>Human</code> فراخوانی می‌کنیم، کامپایلر به طور پیش‌فرض متدی را که مستقیماً بر روی نوع پیاده‌سازی شده است، فراخوانی می‌کند، همان‌طور که در فهرست 20-18 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<figcaption>Listing 20-18: فراخوانی <code>fly</code> بر روی یک نمونه از <code>Human</code></figcaption>
</figure>
<p>اجرای این کد متن <code>*waving arms furiously*</code> را چاپ می‌کند و نشان می‌دهد که راست متد <code>fly</code> پیاده‌سازی‌شده بر روی <code>Human</code> را مستقیماً فراخوانی کرده است.</p>
<p>برای فراخوانی متدهای <code>fly</code> از <code>Pilot</code> یا <code>Wizard</code>، باید از سینتکس صریح‌تری برای مشخص کردن متدی که منظور ماست، استفاده کنیم. فهرست 20-19 این سینتکس را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<figcaption>Listing 20-19: مشخص کردن متد <code>fly</code> مربوط به کدام trait را می‌خواهیم فراخوانی کنیم</figcaption>
</figure>
<p>مشخص کردن نام trait قبل از نام متد، به راست مشخص می‌کند که کدام پیاده‌سازی متد <code>fly</code> را می‌خواهیم فراخوانی کنیم. همچنین می‌توانیم <code>Human::fly(&amp;person)</code> بنویسیم که معادل با <code>person.fly()</code> است که در فهرست 20-19 استفاده کرده‌ایم، اما اگر نیازی به رفع ابهام نباشد، این روش کمی طولانی‌تر است.</p>
<p>اجرای این کد خروجی زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>از آنجا که متد <code>fly</code> یک پارامتر <code>self</code> می‌گیرد، اگر دو <em>نوع</em> داشته باشیم که یک <em>trait</em> را پیاده‌سازی کنند، راست می‌تواند بر اساس نوع <code>self</code> مشخص کند که کدام پیاده‌سازی trait را باید استفاده کند.</p>
<p>با این حال، توابع مرتبطی که متد نیستند، پارامتر <code>self</code> ندارند. وقتی چندین نوع یا trait توابع غیر متد با یک نام مشترک تعریف می‌کنند، راست همیشه نمی‌داند که منظور شما کدام نوع است، مگر اینکه از <em>fully qualified syntax</em> استفاده کنید. به عنوان مثال، در فهرست 20-20 ما یک trait برای یک پناهگاه حیوانات ایجاد می‌کنیم که می‌خواهد تمام سگ‌های کوچک را به نام <em>Spot</em> نام‌گذاری کند. ما یک trait به نام <code>Animal</code> با یک تابع غیر متد مرتبط به نام <code>baby_name</code> تعریف می‌کنیم. trait <code>Animal</code> برای ساختار <code>Dog</code> پیاده‌سازی می‌شود، و همچنین یک تابع غیر متد مرتبط به نام <code>baby_name</code> مستقیماً بر روی <code>Dog</code> فراهم می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
<figcaption>Listing 20-20: یک trait با یک تابع مرتبط و یک نوع با یک تابع مرتبط با همان نام که همچنین trait را پیاده‌سازی می‌کند</figcaption>
</figure>
<p>ما کدی برای نام‌گذاری تمام سگ‌های کوچک به نام Spot در تابع مرتبط <code>baby_name</code> که بر روی <code>Dog</code> تعریف شده است، پیاده‌سازی می‌کنیم. نوع <code>Dog</code> همچنین trait <code>Animal</code> را پیاده‌سازی می‌کند، که ویژگی‌هایی که تمام حیوانات دارند را توصیف می‌کند. سگ‌های کوچک به نام puppy شناخته می‌شوند و این در پیاده‌سازی trait <code>Animal</code> بر روی <code>Dog</code> در تابع <code>baby_name</code> مرتبط با trait <code>Animal</code> بیان شده است.</p>
<p>در تابع <code>main</code>، ما تابع <code>Dog::baby_name</code> را فراخوانی می‌کنیم، که تابع مرتبط تعریف شده بر روی <code>Dog</code> را مستقیماً فراخوانی می‌کند. این کد خروجی زیر را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>این خروجی آن چیزی نیست که ما می‌خواستیم. ما می‌خواهیم تابع <code>baby_name</code> که بخشی از trait <code>Animal</code> است و بر روی <code>Dog</code> پیاده‌سازی شده است را فراخوانی کنیم تا کد <code>A baby dog is called a puppy</code> را چاپ کند. تکنیکی که در فهرست 20-19 برای مشخص کردن نام trait استفاده کردیم، اینجا کمکی نمی‌کند. اگر <code>main</code> را به کد موجود در فهرست 20-21 تغییر دهیم، خطای کامپایل دریافت خواهیم کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<figcaption>Listing 20-21: تلاش برای فراخوانی تابع <code>baby_name</code> از trait <code>Animal</code>، اما راست نمی‌داند که از کدام پیاده‌سازی استفاده کند</figcaption>
</figure>
<p>از آنجا که <code>Animal::baby_name</code> پارامتر <code>self</code> ندارد، و ممکن است انواع دیگری وجود داشته باشند که trait <code>Animal</code> را پیاده‌سازی کرده باشند، راست نمی‌تواند تشخیص دهد که کدام پیاده‌سازی از <code>Animal::baby_name</code> مورد نظر ما است. در نتیجه این خطای کامپایلر را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>برای رفع ابهام و مشخص کردن اینکه ما می‌خواهیم از پیاده‌سازی trait <code>Animal</code> برای <code>Dog</code> استفاده کنیم، به جای پیاده‌سازی trait <code>Animal</code> برای نوع دیگری، باید از fully qualified syntax استفاده کنیم. فهرست 20-22 نشان می‌دهد چگونه از fully qualified syntax استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<figcaption>Listing 20-22: استفاده از fully qualified syntax برای مشخص کردن اینکه می‌خواهیم تابع <code>baby_name</code> از trait <code>Animal</code> که بر روی <code>Dog</code> پیاده‌سازی شده است، فراخوانی کنیم</figcaption>
</figure>
<p>ما با استفاده از یک اعلان نوع در داخل angle brackets به راست می‌گوییم که می‌خواهیم متد <code>baby_name</code> از trait <code>Animal</code> که بر روی <code>Dog</code> پیاده‌سازی شده است، فراخوانی شود، با این کار مشخص می‌کنیم که می‌خواهیم نوع <code>Dog</code> را برای این فراخوانی تابع به‌عنوان یک <code>Animal</code> در نظر بگیریم. این کد اکنون خروجی مورد نظر ما را چاپ می‌کند:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>به طور کلی، fully qualified syntax به صورت زیر تعریف می‌شود:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>برای توابع مرتبطی که متد نیستند، <code>receiver</code> وجود نخواهد داشت: فقط لیستی از آرگومان‌های دیگر خواهد بود. شما می‌توانید fully qualified syntax را در هر جایی که توابع یا متدها را فراخوانی می‌کنید، استفاده کنید. با این حال، مجاز هستید هر بخشی از این سینتکس را که راست می‌تواند از اطلاعات دیگر برنامه تشخیص دهد، حذف کنید. شما فقط در مواردی که چندین پیاده‌سازی با نام یکسان وجود دارد و راست به کمک نیاز دارد تا مشخص کند کدام پیاده‌سازی را می‌خواهید فراخوانی کنید، نیاز به استفاده از این سینتکس دقیق‌تر دارید.</p>
<h3 id="استفاده-از-supertraits-برای-نیاز-به-قابلیتهای-یک-trait-درون-trait-دیگر"><a class="header" href="#استفاده-از-supertraits-برای-نیاز-به-قابلیتهای-یک-trait-درون-trait-دیگر">استفاده از Supertraits برای نیاز به قابلیت‌های یک trait درون trait دیگر</a></h3>
<p>گاهی اوقات ممکن است یک تعریف trait بنویسید که به یک trait دیگر وابسته باشد: برای اینکه یک نوع بتواند اولین trait را پیاده‌سازی کند، می‌خواهید که آن نوع همچنین دومین trait را نیز پیاده‌سازی کند. این کار را انجام می‌دهید تا تعریف trait شما بتواند از آیتم‌های مرتبط trait دوم استفاده کند. trait‌ای که تعریف trait شما به آن متکی است، <em>supertrait</em> نامیده می‌شود.</p>
<p>برای مثال، فرض کنید می‌خواهید یک trait به نام <code>OutlinePrint</code> بسازید که یک متد <code>outline_print</code> داشته باشد که یک مقدار داده شده را با فرمت مشخصی که در قاب ستاره‌ها قرار گرفته است، چاپ کند. به این صورت که اگر یک ساختار <code>Point</code> داشته باشیم که trait کتابخانه استاندارد <code>Display</code> را پیاده‌سازی کرده و نتیجه آن به شکل <code>(x, y)</code> باشد، وقتی متد <code>outline_print</code> را روی یک نمونه از <code>Point</code> که <code>1</code> برای <code>x</code> و <code>3</code> برای <code>y</code> دارد فراخوانی کنیم، باید خروجی زیر را چاپ کند:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>در پیاده‌سازی متد <code>outline_print</code>، می‌خواهیم از قابلیت‌های trait <code>Display</code> استفاده کنیم. بنابراین، نیاز داریم مشخص کنیم که trait <code>OutlinePrint</code> فقط برای انواعی کار خواهد کرد که همچنین trait <code>Display</code> را پیاده‌سازی کرده باشند و قابلیت‌های مورد نیاز <code>OutlinePrint</code> را ارائه دهند. می‌توانیم این کار را در تعریف trait با مشخص کردن <code>OutlinePrint: Display</code> انجام دهیم. این تکنیک شبیه به اضافه کردن یک محدودیت trait به trait است. فهرست 20-23 یک پیاده‌سازی از trait <code>OutlinePrint</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-23: پیاده‌سازی trait <code>OutlinePrint</code> که نیاز به قابلیت‌های <code>Display</code> دارد</figcaption>
</figure>
<p>از آنجایی که مشخص کرده‌ایم که <code>OutlinePrint</code> به trait <code>Display</code> نیاز دارد، می‌توانیم از تابع <code>to_string</code> استفاده کنیم که به طور خودکار برای هر نوعی که <code>Display</code> را پیاده‌سازی کرده باشد، پیاده‌سازی شده است. اگر سعی کنیم <code>to_string</code> را بدون اضافه کردن دو نقطه و مشخص کردن trait <code>Display</code> بعد از نام trait استفاده کنیم، خطایی دریافت خواهیم کرد که می‌گوید هیچ متدی به نام <code>to_string</code> برای نوع <code>&amp;Self</code> در محدوده فعلی یافت نشد.</p>
<p>حالا ببینیم چه اتفاقی می‌افتد اگر بخواهیم <code>OutlinePrint</code> را برای یک نوعی که <code>Display</code> را پیاده‌سازی نکرده است، مانند ساختار <code>Point</code>، پیاده‌سازی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>خطایی دریافت می‌کنیم که می‌گوید <code>Display</code> مورد نیاز است ولی پیاده‌سازی نشده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>برای رفع این مشکل، باید <code>Display</code> را برای <code>Point</code> پیاده‌سازی کنیم و محدودیت مورد نیاز <code>OutlinePrint</code> را برآورده کنیم، به این صورت:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>سپس با پیاده‌سازی trait <code>OutlinePrint</code> بر روی <code>Point</code>، کد با موفقیت کامپایل خواهد شد و می‌توانیم متد <code>outline_print</code> را روی یک نمونه از <code>Point</code> فراخوانی کنیم تا آن را در یک قاب ستاره‌ای نمایش دهد.</p>
<h3 id="استفاده-از-الگوی-newtype-برای-پیادهسازی-traits-خارجی-روی-انواع-خارجی"><a class="header" href="#استفاده-از-الگوی-newtype-برای-پیادهسازی-traits-خارجی-روی-انواع-خارجی">استفاده از الگوی Newtype برای پیاده‌سازی Traits خارجی روی انواع خارجی</a></h3>
<p>در فصل ۱۰ در بخش <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“پیاده‌سازی یک Trait روی یک
نوع”</a><!-- ignore -->، به قانون orphan اشاره کردیم که بیان می‌کند ما فقط مجاز هستیم یک trait را روی یک نوع پیاده‌سازی کنیم اگر یا trait یا نوع به crate ما تعلق داشته باشد. با این حال، می‌توان با استفاده از <em>الگوی newtype</em>، این محدودیت را دور زد. این الگو شامل ایجاد یک نوع جدید در یک tuple struct است. (ما tuple struct‌ها را در بخش <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“استفاده از Tuple Structs بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف”</a><!-- ignore --> در فصل ۵ پوشش دادیم.) tuple struct یک فیلد خواهد داشت و یک wrapper نازک دور نوعی خواهد بود که می‌خواهیم trait را برای آن پیاده‌سازی کنیم. سپس، نوع wrapper به crate ما تعلق دارد و می‌توانیم trait را روی wrapper پیاده‌سازی کنیم. اصطلاح <em>Newtype</em> از زبان برنامه‌نویسی Haskell منشأ گرفته است. هیچ جریمه عملکردی در زمان اجرا برای استفاده از این الگو وجود ندارد و نوع wrapper در زمان کامپایل حذف می‌شود.</p>
<p>به‌عنوان مثال، فرض کنید می‌خواهیم <code>Display</code> را روی <code>Vec&lt;T&gt;</code> پیاده‌سازی کنیم، که قانون orphan مانع انجام این کار به‌صورت مستقیم می‌شود زیرا trait <code>Display</code> و نوع <code>Vec&lt;T&gt;</code> خارج از crate ما تعریف شده‌اند. می‌توانیم یک ساختار <code>Wrapper</code> بسازیم که شامل یک نمونه از <code>Vec&lt;T&gt;</code> باشد؛ سپس می‌توانیم <code>Display</code> را روی <code>Wrapper</code> پیاده‌سازی کنیم و از مقدار <code>Vec&lt;T&gt;</code> استفاده کنیم، همانطور که در فهرست 20-24 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
<figcaption>Listing 20-24: ایجاد نوع <code>Wrapper</code> دور <code>Vec&lt;String&gt;</code> برای پیاده‌سازی <code>Display</code></figcaption>
</figure>
<p>پیاده‌سازی <code>Display</code> از <code>self.0</code> برای دسترسی به <code>Vec&lt;T&gt;</code> داخلی استفاده می‌کند، زیرا <code>Wrapper</code> یک tuple struct است و <code>Vec&lt;T&gt;</code> آیتمی در index صفر tuple است. سپس می‌توانیم از قابلیت‌های trait <code>Display</code> روی <code>Wrapper</code> استفاده کنیم.</p>
<p>عیب استفاده از این تکنیک این است که <code>Wrapper</code> یک نوع جدید است، بنابراین متدهای نوعی که درون خود نگه می‌دارد را ندارد. باید تمام متدهای <code>Vec&lt;T&gt;</code> را مستقیماً روی <code>Wrapper</code> پیاده‌سازی کنیم به طوری که متدها به <code>self.0</code> ارجاع دهند، که به ما اجازه می‌دهد <code>Wrapper</code> را دقیقاً مانند <code>Vec&lt;T&gt;</code> رفتار دهیم. اگر بخواهیم نوع جدید تمام متدهایی که نوع داخلی دارد را داشته باشد، پیاده‌سازی trait <code>Deref</code> (که در فصل ۱۵ در بخش <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“رفتار با اشاره‌گر (Pointer)های هوشمند به‌عنوان ارجاعات معمولی با استفاده از trait <code>Deref</code>”</a><!-- ignore --> بحث شد) روی <code>Wrapper</code> به‌گونه‌ای که نوع داخلی را بازگرداند، راه‌حلی خواهد بود. اگر نخواهیم نوع <code>Wrapper</code> تمام متدهای نوع داخلی را داشته باشد—برای مثال، برای محدود کردن رفتار نوع <code>Wrapper</code>—باید متدهایی که واقعاً نیاز داریم را به صورت دستی پیاده‌سازی کنیم.</p>
<p>این الگوی newtype حتی زمانی که traits درگیر نیستند نیز مفید است. حالا بیایید تمرکز خود را تغییر دهیم و به برخی از روش‌های پیشرفته برای تعامل با سیستم نوع Rust بپردازیم.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="انواع-typeهای-پیشرفته"><a class="header" href="#انواع-typeهای-پیشرفته">انواع (Typeهای) پیشرفته</a></h2>
<p>سیستم نوع‌بندی Rust شامل ویژگی‌هایی است که تاکنون فقط به آن‌ها اشاره کرده‌ایم و هنوز به‌طور کامل مورد بحث قرار نگرفته‌اند. ابتدا به بررسی الگوی newtype می‌پردازیم تا بفهمیم چرا این الگو به‌عنوان انواع مفید است. سپس به aliasهای نوع می‌پردازیم، که ویژگی مشابهی با newtype دارند اما با تفاوت‌هایی در معناشناسی. همچنین، نوع <code>!</code> و انواع پویا (dynamically sized types) را نیز بررسی خواهیم کرد.</p>
<h3 id="استفاده-از-الگوی-newtype-برای-ایمنی-نوع-و-انتزاع"><a class="header" href="#استفاده-از-الگوی-newtype-برای-ایمنی-نوع-و-انتزاع">استفاده از الگوی Newtype برای ایمنی نوع و انتزاع</a></h3>
<blockquote>
<p>توجه: این بخش فرض می‌کند که قبلاً بخش <a href="ch20-02-advanced-traits.html#%D8%A7%D8%B3%D8%AA%D9%81%D8%A7%D8%AF%D9%87-%D8%A7%D8%B2-%D8%A7%D9%84%DA%AF%D9%88%DB%8C-newtype-%D8%A8%D8%B1%D8%A7%DB%8C-%D9%BE%DB%8C%D8%A7%D8%AF%D9%87%D8%B3%D8%A7%D8%B2%DB%8C-traits-%D8%AE%D8%A7%D8%B1%D8%AC%DB%8C-%D8%B1%D9%88%DB%8C-%D8%A7%D9%86%D9%88%D8%A7%D8%B9-%D8%AE%D8%A7%D8%B1%D8%AC%DB%8C">“استفاده از الگوی Newtype برای پیاده‌سازی Traits خارجی روی انواع خارجی”</a><!-- ignore --> را مطالعه کرده‌اید.</p>
</blockquote>
<p>الگوی newtype علاوه بر مواردی که تاکنون بحث کردیم، برای وظایف دیگری مانند اعمال محدودیت‌های استاتیک برای جلوگیری از اشتباه و نمایش واحدهای یک مقدار نیز مفید است. شما یک مثال از استفاده از newtype برای نمایش واحدها را در مثال 20-16 دیدید: در آنجا، ساختارهای <code>Millimeters</code> و <code>Meters</code> مقادیر نوع <code>u32</code> را در یک newtype بسته‌بندی می‌کردند. اگر تابعی با پارامتری از نوع <code>Millimeters</code> بنویسیم، برنامه‌ای که به‌طور اشتباه بخواهد این تابع را با مقدار نوع <code>Meters</code> یا یک <code>u32</code> ساده فراخوانی کند، کامپایل نخواهد شد.</p>
<p>ما همچنین می‌توانیم از الگوی newtype برای انتزاع جزئیات پیاده‌سازی یک نوع استفاده کنیم: نوع جدید می‌تواند یک API عمومی ارائه دهد که با API نوع داخلی خصوصی متفاوت است.</p>
<p>الگوی newtype همچنین می‌تواند پیاده‌سازی داخلی را مخفی کند. به‌عنوان مثال، می‌توانیم نوعی به نام <code>People</code> ارائه دهیم که یک <code>HashMap&lt;i32, String&gt;</code> را برای ذخیره ID افراد با نام آن‌ها بسته‌بندی کند. کدی که از <code>People</code> استفاده می‌کند، فقط با API عمومی که ارائه می‌دهیم تعامل خواهد داشت، مانند متدی برای افزودن یک رشته نام به مجموعه <code>People</code>. این کد نیازی ندارد که بداند ما به‌صورت داخلی یک ID نوع <code>i32</code> به نام‌ها اختصاص می‌دهیم. الگوی newtype یک روش سبک‌وزن برای دستیابی به کپسوله‌سازی برای مخفی کردن جزئیات پیاده‌سازی است، که در بخش <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“کپسوله‌سازی برای مخفی کردن جزئیات پیاده‌سازی”</a><!-- ignore --> فصل ۱۸ بحث شد.</p>
<h3 id="ایجاد-مترادفهای-نوع-با-استفاده-از-type-aliases"><a class="header" href="#ایجاد-مترادفهای-نوع-با-استفاده-از-type-aliases">ایجاد مترادف‌های نوع با استفاده از Type Aliases</a></h3>
<p>Rust قابلیت تعریف <em>alias نوع</em> را برای ارائه یک نام دیگر برای یک نوع موجود فراهم می‌کند. برای این کار از کلمه‌کلیدی <code>type</code> استفاده می‌کنیم. به‌عنوان مثال، می‌توانیم alias‌ای به نام <code>Kilometers</code> برای نوع <code>i32</code> ایجاد کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>اکنون، alias <code>Kilometers</code> یک <em>مترادف</em> برای <code>i32</code> است. برخلاف انواع <code>Millimeters</code> و <code>Meters</code> که در مثال 20-16 ایجاد کردیم، <code>Kilometers</code> یک نوع جدید و جداگانه نیست. مقادیری که نوع آن‌ها <code>Kilometers</code> باشد، دقیقاً همانند مقادیر نوع <code>i32</code> رفتار می‌کنند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>از آنجا که <code>Kilometers</code> و <code>i32</code> یک نوع هستند، می‌توانیم مقادیر این دو نوع را با هم جمع کنیم و می‌توانیم مقادیر <code>Kilometers</code> را به توابعی که پارامترهای نوع <code>i32</code> دارند، ارسال کنیم. با این حال، با استفاده از این روش، مزایای بررسی نوعی که از الگوی newtype برخوردار بودیم را از دست می‌دهیم. به عبارت دیگر، اگر مقادیر <code>Kilometers</code> و <code>i32</code> را در جایی اشتباه بگیریم، کامپایلر خطایی نشان نخواهد داد.</p>
<p>استفاده اصلی از مترادف‌های نوع برای کاهش تکرار است. به‌عنوان مثال، ممکن است یک نوع طولانی مانند این داشته باشیم:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>نوشتن این نوع طولانی در امضاهای توابع و به‌عنوان توضیحات نوع در سراسر کد می‌تواند خسته‌کننده و مستعد خطا باشد. تصور کنید پروژه‌ای پر از کدی مانند آنچه در فهرست 20-25 نشان داده شده است.</p>
<p>&lt;فهرست شماره=“20-25” عنوان=“استفاده از یک نوع طولانی در مکان‌های متعدد”&gt;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p>&lt;/فهرست&gt;</p>
<p>یک <strong>نوع مستعار</strong> (type alias) این کد را با کاهش تکرار خواناتر و مدیریت‌پذیرتر می‌کند. در فهرست 20-26، ما یک مستعار به نام <code>Thunk</code> برای نوع طولانی معرفی کرده‌ایم و می‌توانیم همه استفاده‌ها از این نوع را با مستعار کوتاه‌تر <code>Thunk</code> جایگزین کنیم.</p>
<p>&lt;فهرست شماره=“20-26” عنوان=“معرفی نوع مستعار <code>Thunk</code> برای کاهش تکرار”&gt;</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p>&lt;/فهرست&gt;</p>
<p>این کد بسیار خواناتر و نوشتن آن آسان‌تر است! انتخاب یک نام معنادار برای نوع مستعار می‌تواند به انتقال مقصود شما کمک کند. (برای مثال، <em>thunk</em> کلمه‌ای است که به کدی اشاره دارد که قرار است در آینده اجرا شود، بنابراین برای اشاره به یک closure که ذخیره می‌شود، مناسب است).</p>
<p>نوع‌های مستعار همچنین معمولاً با نوع <code>Result&lt;T, E&gt;</code> برای کاهش تکرار استفاده می‌شوند. به‌عنوان نمونه، ماژول <code>std::io</code> در کتابخانه استاندارد را در نظر بگیرید. عملیات I/O اغلب یک <code>Result&lt;T, E&gt;</code> برمی‌گرداند تا مواقعی که عملیات با شکست مواجه می‌شود مدیریت شود. این کتابخانه یک ساختار <code>std::io::Error</code> دارد که تمامی خطاهای ممکن در I/O را نمایش می‌دهد. بسیاری از توابع در <code>std::io</code> <code>Result&lt;T, E&gt;</code> را برمی‌گردانند که در آن <code>E</code> برابر با <code>std::io::Error</code> است، مانند این توابع در trait <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>عبارت <code>Result&lt;..., Error&gt;</code> به دفعات تکرار شده است. به همین دلیل، در ماژول <code>std::io</code> یک نوع مستعار (type alias) به این شکل تعریف شده است:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>از آنجا که این تعریف در ماژول <code>std::io</code> قرار دارد، می‌توانیم از نوع مستعار <code>std::io::Result&lt;T&gt;</code> استفاده کنیم؛ به این معنی که <code>Result&lt;T, E&gt;</code> با مقدار <code>E</code> برابر با <code>std::io::Error</code> است. امضای توابع موجود در trait <code>Write</code> به این شکل خواهد بود:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>این نوع مستعار از دو جنبه کمک‌کننده است: نوشتن کد را ساده‌تر می‌کند <em>و</em> یک رابط کاربری یکپارچه در تمام بخش‌های <code>std::io</code> فراهم می‌آورد. از آنجا که این یک مستعار است، همچنان یک <code>Result&lt;T, E&gt;</code> معمولی است؛ به این معنی که می‌توانیم از تمام متدهایی که روی <code>Result&lt;T, E&gt;</code> کار می‌کنند استفاده کنیم، همچنین از نحو خاص مانند عملگر <code>?</code>.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust دارای یک نوع ویژه به نام <code>!</code> است که در نظریه نوع‌ها به عنوان <em>نوع خالی</em> (empty type) شناخته می‌شود، زیرا هیچ مقداری ندارد. ما ترجیح می‌دهیم آن را <em>نوعی که هرگز بازنمی‌گردد</em> (never type) بنامیم، زیرا به‌جای نوع بازگشتی قرار می‌گیرد زمانی که یک تابع هرگز بازنمی‌گردد. به مثال زیر توجه کنید:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>این کد به این صورت خوانده می‌شود: “تابع <code>bar</code> هرگز باز نمی‌گردد.” توابعی که هرگز بازنمی‌گردند، <em>توابع انحرافی</em> (diverging functions) نامیده می‌شوند. نمی‌توانیم مقداری از نوع <code>!</code> ایجاد کنیم، بنابراین تابع <code>bar</code> هرگز نمی‌تواند بازگردد.</p>
<p>اما استفاده از نوعی که هرگز نمی‌توان مقداری برای آن ایجاد کرد، چیست؟ کد مربوط به Listing 2-5 را به خاطر بیاورید که بخشی از بازی حدس عدد بود. ما بخشی از آن را اینجا در Listing 20-27 بازتولید کرده‌ایم.</p>
<figure class="listing">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 20-27: یک <code>match</code> با بازوی پایانی که به <code>continue</code> ختم می‌شود</figcaption>
</figure>
<p>در آن زمان، برخی از جزئیات در این کد را رد کردیم. در فصل ۶ در بخش <a href="ch06-02-match.html#the-match-control-flow-operator">“اپراتور جریان کنترلی <code>match</code>”</a><!-- ignore -->، بحث کردیم که تمام بازوهای <code>match</code> باید یک نوع داده یکسان را برگردانند. به عنوان مثال، کد زیر کار نخواهد کرد:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>نوع <code>guess</code> در این کد باید هم عدد صحیح (<em>integer</em>) و هم رشته (<em>string</em>) باشد، و Rust نیاز دارد که <code>guess</code> تنها یک نوع داده داشته باشد. بنابراین، دستور <code>continue</code> چه مقداری را برمی‌گرداند؟ چگونه توانستیم از یک بازو مقدار <code>u32</code> بازگردانیم و در بازوی دیگر <code>continue</code> را قرار دهیم که در لیست ۲۰-۲۷ آورده شده است؟</p>
<p>همان‌طور که احتمالاً حدس زده‌اید، دستور <code>continue</code> دارای نوع <code>!</code> است. یعنی، وقتی Rust نوع <code>guess</code> را محاسبه می‌کند، به هر دو بازوی <code>match</code> نگاه می‌کند: بازوی اول مقداری از نوع <code>u32</code> دارد و بازوی دوم مقداری از نوع <code>!</code>. از آنجا که <code>!</code> نمی‌تواند هیچ مقداری داشته باشد، Rust نتیجه‌گیری می‌کند که نوع <code>guess</code> برابر با <code>u32</code> است.</p>
<p>روش رسمی برای توصیف این رفتار این است که عبارت‌های نوع <code>!</code> می‌توانند به هر نوع دیگری تبدیل شوند (<em>coerce</em>). ما می‌توانیم بازوی <code>match</code> را با دستور <code>continue</code> پایان دهیم زیرا <code>continue</code> مقداری باز نمی‌گرداند؛ بلکه کنترل را به بالای حلقه بازمی‌گرداند، بنابراین در حالت <code>Err</code>، هیچ مقداری به <code>guess</code> اختصاص داده نمی‌شود.</p>
<p>نوع <code>!</code> در ماکرو <code>panic!</code> نیز مفید است. به یاد بیاورید تابع <code>unwrap</code> که روی مقادیر <code>Option&lt;T&gt;</code> فراخوانی می‌کنیم تا مقداری را تولید کند یا با استفاده از این تعریف متوقف شود:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>در این کد، همان چیزی که در <code>match</code> لیست ۲۰-۲۷ رخ داد اتفاق می‌افتد: Rust می‌بیند که <code>val</code> از نوع <code>T</code> است و <code>panic!</code> از نوع <code>!</code> است، بنابراین نتیجه کلی عبارت <code>match</code> برابر با <code>T</code> است. این کد کار می‌کند زیرا <code>panic!</code> هیچ مقداری تولید نمی‌کند؛ بلکه برنامه را متوقف می‌کند. در حالت <code>None</code>، ما مقداری از <code>unwrap</code> بازنمی‌گردانیم، بنابراین این کد معتبر است.</p>
<p>یک عبارت نهایی که نوع <code>!</code> دارد، حلقه <code>loop</code> است:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>اینجا، حلقه هیچ‌گاه متوقف نمی‌شود، بنابراین نوع <code>!</code> مقدار عبارت خواهد بود. با این حال، اگر <code>break</code> درون حلقه باشد، این موضوع درست نخواهد بود، زیرا حلقه وقتی به <code>break</code> می‌رسد، متوقف می‌شود.</p>
<p>فایل تکمیل شد.</p>
<h3 id="typeها-با-اندازه-پویا-dynamic-و-ویژگی-sized"><a class="header" href="#typeها-با-اندازه-پویا-dynamic-و-ویژگی-sized">typeها با اندازه پویا (dynamic) و ویژگی <code>Sized</code></a></h3>
<p>زبان Rust نیاز دارد تا جزئیاتی درباره انواع خود بداند، مانند اینکه چقدر فضا برای ذخیره‌سازی یک مقدار از یک نوع خاص تخصیص دهد. این امر یکی از گوشه‌های سیستم انواع این زبان را کمی گیج‌کننده می‌کند: مفهوم <em>انواع با اندازه دایتانیک (پویا)</em> (<em>dynamically sized types</em>). گاهی اوقات به این نوع‌ها <em>DST</em> یا <em>انواع بدون اندازه</em> (<em>unsized types</em>) نیز گفته می‌شود. این نوع‌ها به ما اجازه می‌دهند تا کدی بنویسیم که با مقادیری کار کند که اندازه آن‌ها تنها در زمان اجرا مشخص می‌شود.</p>
<p>بیایید به جزئیات یک نوع با اندازه دایتانیک به نام <code>str</code> بپردازیم که در طول کتاب از آن استفاده کرده‌ایم. درست است، نه <code>&amp;str</code>، بلکه خود <code>str</code> یک DST است. ما نمی‌توانیم بدانیم که طول یک رشته چقدر است تا زمانی که کد اجرا شود، به این معنی که نمی‌توانیم متغیری از نوع <code>str</code> ایجاد کنیم و همچنین نمی‌توانیم آرگومانی از نوع <code>str</code> بپذیریم. کد زیر را در نظر بگیرید که کار نمی‌کند:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust نیاز دارد که بداند چقدر حافظه برای هر مقدار از یک نوع خاص تخصیص دهد، و تمام مقادیر یک نوع باید از همان مقدار حافظه استفاده کنند. اگر Rust اجازه می‌داد این کد را بنویسیم، این دو مقدار <code>str</code> باید از یک مقدار فضا استفاده می‌کردند. اما آن‌ها طول‌های متفاوتی دارند: <code>s1</code> به ۱۲ بایت فضای ذخیره‌سازی نیاز دارد و <code>s2</code> به ۱۵ بایت. به همین دلیل است که ایجاد یک متغیر که یک نوع با اندازه دایتانیک داشته باشد ممکن نیست.</p>
<p>پس چه کاری می‌توانیم انجام دهیم؟ در این حالت، شما قبلاً پاسخ را می‌دانید: ما نوع‌های <code>s1</code> و <code>s2</code> را به جای <code>str</code> از نوع <code>&amp;str</code> می‌سازیم. به یاد بیاورید که در بخش <a href="ch04-03-slices.html#string-slices">“برش‌های رشته‌ای”</a><!-- ignore --> از فصل ۴ گفته شد که ساختار داده برش تنها موقعیت شروع و طول برش را ذخیره می‌کند. بنابراین، اگرچه یک <code>&amp;T</code> تنها یک مقدار است که آدرس حافظه‌ای که <code>T</code> در آن قرار دارد را ذخیره می‌کند، یک <code>&amp;str</code> <em>دو</em> مقدار دارد: آدرس <code>str</code> و طول آن. بنابراین، ما می‌توانیم اندازه یک مقدار <code>&amp;str</code> را در زمان کامپایل بدانیم: اندازه آن دو برابر طول یک <code>usize</code> است. به عبارت دیگر، ما همیشه اندازه یک <code>&amp;str</code> را می‌دانیم، بدون توجه به اینکه رشته‌ای که به آن اشاره می‌کند چقدر طولانی است. به طور کلی، این روش استفاده از انواع با اندازه دایتانیک در Rust است: آن‌ها یک بخش اضافی از متادیتا دارند که اندازه اطلاعات دایتانیک را ذخیره می‌کند. قانون طلایی انواع با اندازه دایتانیک این است که باید همیشه مقادیر این نوع‌ها را پشت یک نوع اشاره‌گر (Pointer) قرار دهیم.</p>
<p>ما می‌توانیم <code>str</code> را با انواع مختلف اشاره‌گر (Pointer) ترکیب کنیم: به عنوان مثال، <code>Box&lt;str&gt;</code> یا <code>Rc&lt;str&gt;</code>. در واقع، قبلاً این مورد را دیده‌اید اما با یک نوع با اندازه دایتانیک متفاوت: ویژگی‌ها (<em>Traits</em>). هر ویژگی یک نوع با اندازه دایتانیک است که می‌توانیم با استفاده از نام ویژگی به آن ارجاع دهیم. در فصل ۱۸ در بخش <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“استفاده از اشیاء ویژگی که امکان مقادیر با تایپ‌های مختلف را فراهم می‌کنند”</a><!-- ignore --> اشاره کردیم که برای استفاده از ویژگی‌ها به عنوان اشیاء ویژگی، باید آن‌ها را پشت یک اشاره‌گر (Pointer) قرار دهیم، مانند <code>&amp;dyn Trait</code> یا <code>Box&lt;dyn Trait&gt;</code> (حتی <code>Rc&lt;dyn Trait&gt;</code> نیز کار خواهد کرد).</p>
<p>برای کار با تایپ‌های دایتانیک، Rust ویژگی <code>Sized</code> را فراهم می‌کند تا تعیین کند که آیا اندازه یک نوع در زمان کامپایل مشخص است یا خیر. این ویژگی به طور خودکار برای هر چیزی که اندازه آن در زمان کامپایل مشخص باشد پیاده‌سازی می‌شود. علاوه بر این، Rust به طور ضمنی یک محدودیت روی <code>Sized</code> را به هر تابع جنریک اضافه می‌کند. یعنی یک تعریف تابع جنریک به این صورت:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>در واقع، به گونه‌ای رفتار می‌شود که گویی این را نوشته‌ایم:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>به طور پیش‌فرض، توابع جنریک فقط روی نوع‌هایی کار خواهند کرد که اندازه آن‌ها در زمان کامپایل مشخص باشد. با این حال، می‌توانید از سینتکس خاص زیر برای کاهش این محدودیت استفاده کنید:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>یک محدودیت ویژگی روی <code>?Sized</code> به این معنی است که “<code>T</code> ممکن است <code>Sized</code> باشد یا نباشد” و این یادداشت، پیش‌فرضی که نوع‌های جنریک باید اندازه مشخصی در زمان کامپایل داشته باشند را لغو می‌کند. سینتکس <code>?Trait</code> با این معنا تنها برای <code>Sized</code> در دسترس است، نه برای هیچ ویژگی دیگری.</p>
<p>همچنین توجه داشته باشید که نوع پارامتر <code>t</code> را از <code>T</code> به <code>&amp;T</code> تغییر دادیم. از آنجایی که نوع ممکن است <code>Sized</code> نباشد، باید از آن پشت یک نوع اشاره‌گر (Pointer) استفاده کنیم. در این مورد، یک ارجاع انتخاب کرده‌ایم.</p>
<p>در ادامه، درباره توابع و closureها صحبت خواهیم کرد!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="توابع-پیشرفته-و-closureها"><a class="header" href="#توابع-پیشرفته-و-closureها">توابع پیشرفته و Closureها</a></h2>
<p>این بخش به بررسی برخی از ویژگی‌های پیشرفته مربوط به توابع و Closureها می‌پردازد، از جمله Pointerهای تابع و بازگرداندن Closureها.</p>
<h3 id="pointerهای-تابع"><a class="header" href="#pointerهای-تابع">Pointerهای تابع</a></h3>
<p>قبلاً در مورد چگونگی ارسال Closureها به توابع صحبت کردیم؛ شما همچنین می‌توانید توابع معمولی را به توابع دیگر ارسال کنید! این تکنیک زمانی مفید است که بخواهید تابعی که قبلاً تعریف کرده‌اید را ارسال کنید به جای اینکه یک Closureها جدید تعریف کنید. توابع به نوع <code>fn</code> (با f کوچک) تبدیل می‌شوند، که نباید با ویژگی Closureها <code>Fn</code> اشتباه گرفته شود. نوع <code>fn</code> به عنوان یک <em>اشاره‌گر (Pointer) تابع</em> شناخته می‌شود. ارسال توابع با استفاده از Pointerهای تابع به شما این امکان را می‌دهد که از توابع به عنوان آرگومان برای توابع دیگر استفاده کنید.</p>
<p>سینتکس مشخص کردن اینکه یک پارامتر یک اشاره‌گر (Pointer) تابع است، مشابه Closureها است، همان‌طور که در لیست ۲۰-۲۸ نشان داده شده است. در این مثال، تابعی به نام <code>add_one</code> تعریف کرده‌ایم که یک واحد به پارامتر خود اضافه می‌کند. تابع <code>do_twice</code> دو پارامتر می‌گیرد: یک اشاره‌گر (Pointer) تابع به هر تابعی که یک پارامتر <code>i32</code> بگیرد و یک مقدار <code>i32</code> برگرداند، و یک مقدار <code>i32</code>. تابع <code>do_twice</code> تابع <code>f</code> را دو بار فراخوانی می‌کند، مقدار <code>arg</code> را به آن می‌فرستد و سپس نتایج دو فراخوانی را با هم جمع می‌کند. تابع <code>main</code> تابع <code>do_twice</code> را با آرگومان‌های <code>add_one</code> و <code>5</code> فراخوانی می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<figcaption>Listing 20-28: استفاده از نوع <code>fn</code> برای پذیرش یک اشاره‌گر (Pointer) تابع به عنوان آرگومان</figcaption>
</figure>
<p>این کد مقدار <code>The answer is: 12</code> را چاپ می‌کند. ما مشخص کرده‌ایم که پارامتر <code>f</code> در <code>do_twice</code> یک <code>fn</code> است که یک پارامتر از نوع <code>i32</code> می‌گیرد و یک <code>i32</code> باز می‌گرداند. سپس می‌توانیم <code>f</code> را در بدنه تابع <code>do_twice</code> فراخوانی کنیم. در <code>main</code>، می‌توانیم نام تابع <code>add_one</code> را به عنوان آرگومان اول به <code>do_twice</code> ارسال کنیم.</p>
<p>برخلاف Closureها <code>fn</code> یک نوع است و نه یک ویژگی، بنابراین ما <code>fn</code> را به طور مستقیم به عنوان نوع پارامتر مشخص می‌کنیم، به جای اعلام یک پارامتر جنریک با یکی از ویژگی‌های <code>Fn</code> به عنوان محدودیت ویژگی.</p>
<p>Pointerهای تابع تمام سه ویژگی Closureها (<code>Fn</code>، <code>FnMut</code>، و <code>FnOnce</code>) را پیاده‌سازی می‌کنند، به این معنی که شما همیشه می‌توانید یک اشاره‌گر (Pointer) تابع را به عنوان آرگومان برای یک تابع که انتظار یک Closureها را دارد ارسال کنید. بهتر است توابع را با استفاده از یک نوع جنریک و یکی از ویژگی‌های Closureها بنویسید تا توابع شما بتوانند هم توابع و هم Closureها را بپذیرند.</p>
<p>با این حال، یک مثال از جایی که ممکن است بخواهید فقط <code>fn</code> را بپذیرید و نه Closureها زمانی است که با کد خارجی که Closureها ندارد تعامل می‌کنید: توابع C می‌توانند توابع را به عنوان آرگومان بپذیرند، اما C Closureها ندارد.</p>
<p>به عنوان مثالی از جایی که می‌توانید از یک Closureها تعریف‌شده درون‌خطی یا یک تابع نام‌گذاری‌شده استفاده کنید، بیایید به استفاده از متد <code>map</code> که توسط ویژگی <code>Iterator</code> در کتابخانه استاندارد ارائه شده است نگاهی بیندازیم. برای استفاده از تابع <code>map</code> برای تبدیل یک بردار اعداد به یک بردار رشته‌ها، می‌توانیم از یک Closureها به این صورت استفاده کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>یا می‌توانیم به جای کلوزر، نام یک تابع را به عنوان آرگومان به <code>map</code> ارسال کنیم، به این صورت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>توجه داشته باشید که باید از سینتکس کاملاً مشخصی که قبلاً در بخش <a href="ch20-02-advanced-traits.html#advanced-traits">“ویژگی‌های پیشرفته”</a><!-- ignore --> توضیح داده شد استفاده کنیم، زیرا چندین تابع با نام <code>to_string</code> در دسترس هستند. در اینجا، ما از تابع <code>to_string</code> که در ویژگی <code>ToString</code> تعریف شده است استفاده می‌کنیم، که کتابخانه استاندارد برای هر نوعی که ویژگی <code>Display</code> را پیاده‌سازی کند، آن را پیاده‌سازی کرده است.</p>
<p>به یاد بیاورید که در بخش <a href="ch06-01-defining-an-enum.html#enum-values">“مقادیر Enum”</a><!-- ignore --> از فصل ۶ گفته شد که نام هر واریانت enum که تعریف می‌کنیم، همچنین به یک تابع مقداردهی اولیه تبدیل می‌شود. می‌توانیم از این توابع مقداردهی اولیه به عنوان اشاره‌گر (Pointer)های تابع که ویژگی‌های کلوزر را پیاده‌سازی می‌کنند استفاده کنیم، به این معنی که می‌توانیم توابع مقداردهی اولیه را به عنوان آرگومان برای متدهایی که کلوزرها (closures) را می‌پذیرند مشخص کنیم، به این صورت:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>در اینجا با استفاده از تابع مقداردهی اولیه <code>Status::Value</code>، نمونه‌هایی از <code>Status::Value</code> ایجاد می‌کنیم که از هر مقدار <code>u32</code> در محدوده‌ای که <code>map</code> روی آن فراخوانی می‌شود استفاده می‌کند. برخی افراد این سبک را ترجیح می‌دهند و برخی دیگر ترجیح می‌دهند از کلوزرها (closures) استفاده کنند. این‌ها به کدی یکسان کامپایل می‌شوند، بنابراین هر سبکی که برای شما واضح‌تر است را انتخاب کنید.</p>
<h3 id="بازگرداندن-کلوزرها-closures-returning-closures"><a class="header" href="#بازگرداندن-کلوزرها-closures-returning-closures">بازگرداندن کلوزرها (closures) (Returning Closures)</a></h3>
<p>کلوزرها (closures) با ویژگی‌ها نمایش داده می‌شوند، به این معنی که نمی‌توانید مستقیماً کلوزرها (closures) را بازگردانید. در بیشتر مواردی که ممکن است بخواهید یک ویژگی را بازگردانید، می‌توانید به جای آن از نوع مشخصی که ویژگی را پیاده‌سازی می‌کند به عنوان مقدار بازگشتی تابع استفاده کنید. با این حال، نمی‌توانید این کار را با کلوزرها (closures) انجام دهید زیرا آن‌ها نوع مشخصی که قابل بازگشت باشد ندارند؛ به عنوان مثال، نمی‌توانید از اشاره‌گر (Pointer) تابع <code>fn</code> به عنوان نوع بازگشتی استفاده کنید.</p>
<p>در عوض، معمولاً از سینتکس <code>impl Trait</code> که در فصل ۱۰ یاد گرفتیم استفاده می‌کنید. می‌توانید هر نوع تابعی را با استفاده از <code>Fn</code>، <code>FnOnce</code> و <code>FnMut</code> بازگردانید. برای مثال، این کد به خوبی کار می‌کند:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>با این حال، همان‌طور که در بخش <a href="ch13-01-closures.html#closure-type-inference-and-annotation">“استنتاج نوع کلوزر و حاشیه‌نویسی”</a><!-- ignore --> از فصل ۱۳ اشاره کردیم، هر کلوزر نوع مشخص خود را دارد. اگر نیاز داشته باشید با چندین تابع که امضای یکسانی دارند اما پیاده‌سازی‌های متفاوتی دارند کار کنید، باید از یک شیء ویژگی (<em>trait object</em>) برای آن‌ها استفاده کنید:</p>
<pre><code class="language-rust noplayground">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre>
<p>این کد به خوبی کامپایل می‌شود—اما اگر تلاش می‌کردیم از <code>impl Fn(i32) -&gt; i32</code> استفاده کنیم، کامپایل نمی‌شد. برای اطلاعات بیشتر در مورد اشیاء ویژگی، به بخش <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“استفاده از اشیاء ویژگی که امکان مقادیر با تایپ‌های مختلف را فراهم می‌کنند”</a><!-- ignore --> در فصل ۱۸ مراجعه کنید.</p>
<p>در ادامه، بیایید نگاهی به ماکروها بیندازیم!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ماکروها-macros"><a class="header" href="#ماکروها-macros">ماکروها (Macros)</a></h2>
<p>ما در طول این کتاب از ماکروهایی مانند <code>println!</code> استفاده کرده‌ایم، اما هنوز به طور کامل بررسی نکرده‌ایم که یک ماکرو چیست و چگونه کار می‌کند. اصطلاح <em>ماکرو</em> به مجموعه‌ای از قابلیت‌ها در Rust اشاره دارد: ماکروهای <em>اعلانی</em> (declarative) با <code>macro_rules!</code> و سه نوع ماکرو <em>رویه‌ای</em> (procedural):</p>
<ul>
<li>ماکروهای سفارشی <code>#[derive]</code> که کدی را که با ویژگی <code>derive</code> برای ساختارها (structs) و شمارش‌ها (enums) اضافه می‌شود مشخص می‌کنند.</li>
<li>ماکروهای شبیه ویژگی (Attribute-like) که ویژگی‌های سفارشی تعریف می‌کنند که می‌توانند روی هر آیتمی استفاده شوند.</li>
<li>ماکروهای شبیه تابع (Function-like) که مانند فراخوانی تابع به نظر می‌رسند اما روی توکن‌هایی که به عنوان آرگومان مشخص شده‌اند عمل می‌کنند.</li>
</ul>
<p>ما به نوبت درباره هر یک از این‌ها صحبت خواهیم کرد، اما ابتدا بیایید نگاهی بیندازیم که چرا اصلاً به ماکروها نیاز داریم وقتی قبلاً توابع را داریم.</p>
<h3 id="تفاوت-بین-ماکروها-و-توابع"><a class="header" href="#تفاوت-بین-ماکروها-و-توابع">تفاوت بین ماکروها و توابع</a></h3>
<p>در اصل، ماکروها روشی برای نوشتن کدی هستند که کد دیگری را می‌نویسد، که به عنوان <em>فرابرنامه‌نویسی</em> (metaprogramming) شناخته می‌شود. در پیوست C، ما ویژگی <code>derive</code> را بررسی می‌کنیم که پیاده‌سازی ویژگی‌های مختلف را برای شما تولید می‌کند. همچنین ما از ماکروهای <code>println!</code> و <code>vec!</code> در طول کتاب استفاده کرده‌ایم. همه این ماکروها <em>توسعه</em> پیدا می‌کنند تا کدی بیشتر از کدی که به صورت دستی نوشته‌اید تولید کنند.</p>
<p>فرابرنامه‌نویسی برای کاهش مقدار کدی که باید بنویسید و نگهداری کنید مفید است، که یکی از نقش‌های توابع نیز هست. با این حال، ماکروها توانایی‌های اضافی دارند که توابع ندارند.</p>
<p>یک امضای تابع باید تعداد و نوع پارامترهایی که تابع دارد را مشخص کند. از سوی دیگر، ماکروها می‌توانند تعداد متغیری از پارامترها را بپذیرند: می‌توانیم <code>println!("hello")</code> را با یک آرگومان یا <code>println!("hello {}", name)</code> را با دو آرگومان فراخوانی کنیم. همچنین، ماکروها قبل از اینکه کامپایلر معنی کد را تفسیر کند گسترش می‌یابند، بنابراین یک ماکرو می‌تواند، به عنوان مثال، یک ویژگی را روی یک نوع مشخص پیاده‌سازی کند. اما یک تابع نمی‌تواند، زیرا در زمان اجرا فراخوانی می‌شود و یک ویژگی باید در زمان کامپایل پیاده‌سازی شود.</p>
<p>عیب پیاده‌سازی یک ماکرو به جای یک تابع این است که تعریف ماکروها پیچیده‌تر از تعریف توابع است زیرا شما در حال نوشتن کدی در Rust هستید که کد دیگری را در Rust می‌نویسد. به دلیل این واسطه‌گری، تعریف ماکروها به طور کلی سخت‌تر از توابع خوانده می‌شود، فهمیده می‌شود و نگهداری می‌شود.</p>
<p>یکی دیگر از تفاوت‌های مهم بین ماکروها و توابع این است که شما باید ماکروها را <em>قبل</em> از فراخوانی آن‌ها در یک فایل تعریف کنید یا به دامنه بیاورید، برخلاف توابع که می‌توانید آن‌ها را در هر جایی تعریف کرده و در هر جایی فراخوانی کنید.</p>
<h3 id="ماکروهای-اعلانی-با-macro_rules-برای-فرابرنامهنویسی-عمومی"><a class="header" href="#ماکروهای-اعلانی-با-macro_rules-برای-فرابرنامهنویسی-عمومی">ماکروهای اعلانی با <code>macro_rules!</code> برای فرابرنامه‌نویسی عمومی</a></h3>
<p>پرکاربردترین شکل ماکروها در Rust، <em>ماکروهای اعلانی</em> هستند. به این ماکروها گاهی اوقات “ماکروهای با مثال”، “ماکروهای <code>macro_rules!</code>” یا فقط “ماکروها” گفته می‌شود. در هسته خود، ماکروهای اعلانی به شما اجازه می‌دهند چیزی مشابه یک عبارت <code>match</code> در Rust بنویسید. همان‌طور که در فصل ۶ بحث شد، عبارات <code>match</code> ساختارهای کنترلی هستند که یک عبارت را می‌گیرند، مقدار حاصل از عبارت را با الگوها مقایسه می‌کنند و سپس کدی که با الگوی تطابق یافته مرتبط است را اجرا می‌کنند. ماکروها نیز مقدار را با الگوهایی که با کدی خاص مرتبط هستند مقایسه می‌کنند: در این حالت، مقدار کد منبع Rust است که به ماکرو ارسال شده است؛ الگوها با ساختار آن کد منبع مقایسه می‌شوند؛ و کدی که با هر الگو مرتبط است، وقتی تطابق یافت، جایگزین کدی می‌شود که به ماکرو ارسال شده است. همه این‌ها در طول کامپایل اتفاق می‌افتد.</p>
<p>برای تعریف یک ماکرو، از ساختار <code>macro_rules!</code> استفاده می‌کنید. بیایید بررسی کنیم چگونه از <code>macro_rules!</code> استفاده کنیم با نگاهی به نحوه تعریف ماکروی <code>vec!</code>. فصل ۸ پوشش داد که چگونه می‌توانیم از ماکروی <code>vec!</code> برای ایجاد یک بردار جدید با مقادیر خاص استفاده کنیم. به عنوان مثال، ماکروی زیر یک بردار جدید حاوی سه عدد صحیح ایجاد می‌کند:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>ما همچنین می‌توانیم از ماکروی <code>vec!</code> برای ساخت یک بردار شامل دو عدد صحیح یا یک بردار شامل پنج برش رشته استفاده کنیم. نمی‌توانیم از یک تابع برای انجام همین کار استفاده کنیم زیرا نمی‌دانیم تعداد یا نوع مقادیر از پیش چیست.</p>
<p>لیست ۲۰-۲۹ یک تعریف کمی ساده‌شده از ماکروی <code>vec!</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<figcaption>Listing 20-29: یک نسخه ساده‌شده از تعریف ماکروی <code>vec!</code></figcaption>
</figure>
<blockquote>
<p>نکته: تعریف واقعی ماکروی <code>vec!</code> در کتابخانه استاندارد شامل کدی است که مقدار حافظه مناسب را از پیش تخصیص می‌دهد. آن کد بهینه‌سازی‌ای است که در اینجا برای ساده‌تر شدن مثال شامل نشده است.</p>
</blockquote>
<p>حاشیه‌نویسی <code>#[macro_export]</code> نشان می‌دهد که این ماکرو باید هر زمان که crate‌ای که ماکرو در آن تعریف شده است به دامنه آورده شود، در دسترس قرار گیرد. بدون این حاشیه‌نویسی، ماکرو نمی‌تواند به دامنه آورده شود.</p>
<p>سپس تعریف ماکرو را با <code>macro_rules!</code> و نام ماکرویی که تعریف می‌کنیم <em>بدون</em> علامت تعجب شروع می‌کنیم. نام، که در اینجا <code>vec</code> است، با آکولادهایی دنبال می‌شود که بدنه تعریف ماکرو را مشخص می‌کنند.</p>
<p>ساختار بدنه <code>vec!</code> مشابه ساختار یک عبارت <code>match</code> است. در اینجا یک بازو با الگوی <code>( $( $x:expr ),* )</code> داریم، که با <code>=&gt;</code> و بلوک کدی که با این الگو مرتبط است دنبال می‌شود. اگر الگو تطابق یابد، بلوک کد مرتبط گسترش می‌یابد. با توجه به اینکه این تنها الگو در این ماکرو است، تنها یک روش معتبر برای تطابق وجود دارد؛ هر الگوی دیگری باعث خطا خواهد شد. ماکروهای پیچیده‌تر ممکن است بیش از یک بازو داشته باشند.</p>
<p>سینتکس الگوی معتبر در تعریف ماکروها با سینتکسی که در فصل ۱۹ برای الگوها پوشش داده شد متفاوت است زیرا الگوهای ماکروها بر اساس ساختار کد Rust و نه مقادیر تطابق داده می‌شوند. بیایید مرور کنیم که قسمت‌های الگوی لیست ۲۰-۲۹ چه معنایی دارند؛ برای مشاهده کامل سینتکس الگوهای ماکرو، به <a href="../reference/macros-by-example.html">مستندات مرجع Rust</a> مراجعه کنید.</p>
<p>ابتدا، مجموعه‌ای از پرانتزها را برای شامل کردن کل الگو استفاده می‌کنیم. از علامت دلار (<code>$</code>) برای اعلام یک متغیر در سیستم ماکرو استفاده می‌کنیم که کد Rust تطابق‌یافته با الگو را در خود جای می‌دهد. علامت دلار مشخص می‌کند که این یک متغیر ماکرو است، نه یک متغیر معمولی Rust. سپس مجموعه‌ای از پرانتزها می‌آیند که مقادیری را که با الگو درون پرانتزها تطابق دارند، برای استفاده در کد جایگزین ثبت می‌کنند. درون <code>$()</code>، <code>$x:expr</code> قرار دارد که با هر عبارت Rust تطابق دارد و به آن عبارت نام <code>$x</code> می‌دهد.</p>
<p>کامای بعد از <code>$()</code> نشان می‌دهد که یک کاراکتر کامای جداکننده باید بین هر نمونه از کدی که با کد درون <code>$()</code> تطابق دارد ظاهر شود. علامت <code>*</code> مشخص می‌کند که الگو با صفر یا بیشتر از هر چیزی که قبل از <code>*</code> است، تطابق دارد.</p>
<p>وقتی این ماکرو را با <code>vec![1, 2, 3];</code> فراخوانی می‌کنیم، الگوی <code>$x</code> سه بار با سه عبارت <code>1</code>، <code>2</code> و <code>3</code> تطابق پیدا می‌کند.</p>
<p>حالا بیایید به الگویی که در بدنه کد مرتبط با این بازو وجود دارد نگاه کنیم: <code>temp_vec.push()</code> درون <code>$()*</code> برای هر بخشی که با <code>$()</code> در الگو تطابق دارد، صفر یا بیشتر بار بسته به اینکه الگو چند بار تطابق پیدا می‌کند، تولید می‌شود. <code>$x</code> با هر عبارتی که تطابق پیدا کند جایگزین می‌شود. وقتی این ماکرو را با <code>vec![1, 2, 3];</code> فراخوانی می‌کنیم، کدی که جایگزین این فراخوانی ماکرو می‌شود به شکل زیر خواهد بود:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>ما یک ماکرو تعریف کرده‌ایم که می‌تواند هر تعداد آرگومان از هر نوعی را بپذیرد و کدی برای ایجاد یک بردار که شامل عناصر مشخص‌شده است تولید کند.</p>
<p>برای یادگیری بیشتر در مورد نحوه نوشتن ماکروها، به مستندات آنلاین یا منابع دیگر مانند <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust Macros”</a> که توسط Daniel Keep آغاز و توسط Lukas Wirth ادامه داده شده است، مراجعه کنید.</p>
<h3 id="ماکروهای-رویهای-procedural-برای-تولید-کد-از-ویژگیها-attributes"><a class="header" href="#ماکروهای-رویهای-procedural-برای-تولید-کد-از-ویژگیها-attributes">ماکروهای رویه‌ای (Procedural) برای تولید کد از ویژگی‌ها (Attributes)</a></h3>
<p>دومین شکل ماکروها، <em>ماکروی رویه‌ای</em> (procedural macro) است که بیشتر شبیه به یک تابع عمل می‌کند (و نوعی رویه است). ماکروهای رویه‌ای کدی را به عنوان ورودی می‌پذیرند، روی آن کد عمل می‌کنند و به جای تطابق با الگوها و جایگزین کردن کد با کدی دیگر مانند ماکروهای اعلانی، کدی را به عنوان خروجی تولید می‌کنند. سه نوع ماکروی رویه‌ای شامل <code>derive</code> سفارشی، شبیه ویژگی (attribute-like) و شبیه تابع (function-like) هستند و همه به شیوه‌ای مشابه عمل می‌کنند.</p>
<p>هنگام ایجاد ماکروهای رویه‌ای، تعاریف باید در یک crate مجزا با نوع crate خاص خود قرار گیرند. این به دلایل فنی پیچیده‌ای است که امیدواریم در آینده برطرف شود. در لیست ۲۰-۳۰، نحوه تعریف یک ماکروی رویه‌ای را نشان می‌دهیم که در آن <code>some_attribute</code> به عنوان جایگزین برای استفاده از نوع خاصی از ماکرو است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<figcaption>Listing 20-30: یک مثال از تعریف یک ماکروی رویه‌ای</figcaption>
</figure>
<p>تابعی که یک ماکروی رویه‌ای را تعریف می‌کند، یک <code>TokenStream</code> را به عنوان ورودی می‌گیرد و یک <code>TokenStream</code> را به عنوان خروجی تولید می‌کند. نوع <code>TokenStream</code> توسط crate به نام <code>proc_macro</code> تعریف شده است که با Rust همراه است و نمایانگر یک توالی از توکن‌ها است. این هسته ماکرو است: کد منبعی که ماکرو روی آن عمل می‌کند ورودی <code>TokenStream</code> را تشکیل می‌دهد و کدی که ماکرو تولید می‌کند خروجی <code>TokenStream</code> است. این تابع همچنین دارای یک ویژگی (attribute) متصل به خود است که مشخص می‌کند کدام نوع از ماکروی رویه‌ای را ایجاد می‌کنیم. ما می‌توانیم چندین نوع از ماکروهای رویه‌ای را در یک crate داشته باشیم.</p>
<p>بیایید به تایپ‌های مختلف ماکروهای رویه‌ای نگاهی بیندازیم. با یک ماکروی <code>derive</code> سفارشی شروع می‌کنیم و سپس تفاوت‌های کوچک بین اشکال دیگر را توضیح می‌دهیم.</p>
<h3 id="نحوه-نوشتن-یک-ماکروی-derive-سفارشی"><a class="header" href="#نحوه-نوشتن-یک-ماکروی-derive-سفارشی">نحوه نوشتن یک ماکروی <code>derive</code> سفارشی</a></h3>
<p>بیایید یک crate به نام <code>hello_macro</code> ایجاد کنیم که یک ویژگی به نام <code>HelloMacro</code> را با یک تابع وابسته به نام <code>hello_macro</code> تعریف کند. به جای اینکه کاربران ما ویژگی <code>HelloMacro</code> را برای هر یک از انواع خود پیاده‌سازی کنند، ما یک ماکروی رویه‌ای فراهم می‌کنیم تا کاربران بتوانند نوع خود را با <code>#[derive(HelloMacro)]</code> حاشیه‌نویسی کنند و یک پیاده‌سازی پیش‌فرض برای تابع <code>hello_macro</code> دریافت کنند. پیاده‌سازی پیش‌فرض متن <code>Hello, Macro! My name is TypeName!</code> را چاپ می‌کند که در آن <code>TypeName</code> نام نوعی است که این ویژگی روی آن تعریف شده است. به عبارت دیگر، ما crateای خواهیم نوشت که به برنامه‌نویس دیگری امکان می‌دهد کدی مانند لیست ۲۰-۳۱ را با استفاده از crate ما بنویسد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption>Listing 20-31: کدی که کاربر crate ما می‌تواند هنگام استفاده از ماکروی رویه‌ای ما بنویسد</figcaption>
</figure>
<p>این کد متن <code>Hello, Macro! My name is Pancakes!</code> را چاپ می‌کند وقتی کار ما تمام شود. اولین قدم این است که یک crate جدید از نوع کتابخانه بسازیم، به این صورت:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>سپس، ویژگی <code>HelloMacro</code> و تابع وابسته به آن را تعریف می‌کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
</figure>
<p>ما اکنون یک ویژگی و تابع وابسته به آن داریم. در این مرحله، کاربر crate ما می‌تواند ویژگی را پیاده‌سازی کند تا به عملکرد مورد نظر برسد، به این صورت:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>با این حال، آن‌ها باید بلوک پیاده‌سازی را برای هر نوعی که می‌خواهند با <code>hello_macro</code> استفاده کنند بنویسند؛ ما می‌خواهیم آن‌ها را از انجام این کار بی‌نیاز کنیم.</p>
<p>علاوه بر این، ما هنوز نمی‌توانیم برای تابع <code>hello_macro</code> یک پیاده‌سازی پیش‌فرض ارائه دهیم که نام نوعی که ویژگی روی آن پیاده‌سازی شده است را چاپ کند: Rust قابلیت‌های بازتاب (reflection) ندارد، بنابراین نمی‌تواند نام نوع را در زمان اجرا جستجو کند. ما به یک ماکرو نیاز داریم تا کد را در زمان کامپایل تولید کند.</p>
<p>مرحله بعدی این است که ماکروی رویه‌ای را تعریف کنیم. در زمان نگارش این متن، ماکروهای رویه‌ای باید در یک crate جداگانه قرار گیرند. این محدودیت ممکن است در آینده برداشته شود. روش استاندارد برای ساختاردهی جعبه‌ها (crates) و جعبه‌ها (crates)ی ماکرو به این صورت است: برای یک crate به نام <code>foo</code>، یک ماکروی رویه‌ای سفارشی <code>derive</code> به نام <code>foo_derive</code> نام‌گذاری می‌شود. بیایید یک crate جدید به نام <code>hello_macro_derive</code> در پروژه <code>hello_macro</code> ایجاد کنیم:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>دو crate ما به شدت به هم مرتبط هستند، بنابراین ما crate ماکروی رویه‌ای را درون دایرکتوری crate <code>hello_macro</code> ایجاد می‌کنیم. اگر تعریف ویژگی را در <code>hello_macro</code> تغییر دهیم، باید پیاده‌سازی ماکروی رویه‌ای در <code>hello_macro_derive</code> را نیز تغییر دهیم. این دو crate باید به طور جداگانه منتشر شوند و برنامه‌نویسانی که از این جعبه‌ها (crates) استفاده می‌کنند باید هر دو را به عنوان وابستگی اضافه کرده و آن‌ها را به دامنه بیاورند. در عوض، می‌توانستیم crate <code>hello_macro</code> از <code>hello_macro_derive</code> به عنوان یک وابستگی استفاده کند و کد ماکروی رویه‌ای را دوباره صادر کند. با این حال، روشی که پروژه را ساختاربندی کرده‌ایم، این امکان را فراهم می‌کند که برنامه‌نویسان از <code>hello_macro</code> حتی اگر عملکرد <code>derive</code> را نخواهند، استفاده کنند.</p>
<p>ما باید crate <code>hello_macro_derive</code> را به عنوان یک crate ماکروی رویه‌ای اعلام کنیم. همچنین به عملکردهایی از جعبه‌ها (crates)ی <code>syn</code> و <code>quote</code> نیاز خواهیم داشت، همان‌طور که به زودی خواهید دید، بنابراین باید آن‌ها را به عنوان وابستگی اضافه کنیم. موارد زیر را به فایل <em>Cargo.toml</em> برای <code>hello_macro_derive</code> اضافه کنید:</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/Cargo.toml</span>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</figure>
<p>برای شروع تعریف ماکروی رویه‌ای، کد لیست ۲۰-۳۲ را در فایل <em>src/lib.rs</em> برای crate <code>hello_macro_derive</code> قرار دهید. توجه داشته باشید که این کد تا زمانی که تعریف تابع <code>impl_hello_macro</code> را اضافه نکنیم کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<figcaption>Listing 20-32: کدی که اکثر جعبه‌ها (crates)ی ماکروی رویه‌ای برای پردازش کد Rust نیاز دارند</figcaption>
</figure>
<p>توجه کنید که کد را به دو تابع تقسیم کرده‌ایم: <code>hello_macro_derive</code> که مسئول پردازش <code>TokenStream</code> است، و <code>impl_hello_macro</code> که مسئول تبدیل درخت نحوی است. این کار نوشتن یک ماکروی رویه‌ای را آسان‌تر می‌کند. کد تابع بیرونی (<code>hello_macro_derive</code> در اینجا) تقریباً برای تمام جعبه‌ها (crates)ی ماکروی رویه‌ای که می‌بینید یا ایجاد می‌کنید یکسان خواهد بود. کدی که در بدنه تابع داخلی (<code>impl_hello_macro</code> در اینجا) مشخص می‌کنید بسته به هدف ماکروی رویه‌ای شما متفاوت خواهد بود.</p>
<p>ما سه crate جدید معرفی کرده‌ایم: <code>proc_macro</code>، <a href="https://crates.io/crates/syn"><code>syn</code></a>، و <a href="https://crates.io/crates/quote"><code>quote</code></a>. crate <code>proc_macro</code> همراه با Rust ارائه می‌شود، بنابراین نیازی به افزودن آن به وابستگی‌ها در <em>Cargo.toml</em> نداریم. crate <code>proc_macro</code> API کامپایلر است که به ما اجازه می‌دهد کد Rust را از کد خود بخوانیم و دستکاری کنیم.</p>
<p>crate <code>syn</code> کد Rust را از یک رشته به یک ساختار داده‌ای تبدیل می‌کند که می‌توانیم عملیات روی آن انجام دهیم. crate <code>quote</code> ساختارهای داده <code>syn</code> را دوباره به کد Rust تبدیل می‌کند. این جعبه‌ها (crates) پردازش هر نوع کد Rust که بخواهیم مدیریت کنیم را بسیار ساده‌تر می‌کنند: نوشتن یک تجزیه‌کننده کامل برای کد Rust کار ساده‌ای نیست.</p>
<p>تابع <code>hello_macro_derive</code> زمانی فراخوانی می‌شود که یک کاربر از کتابخانه ما ویژگی <code>#[derive(HelloMacro)]</code> را روی یک نوع مشخص کند. این امر به این دلیل ممکن است که ما تابع <code>hello_macro_derive</code> را با <code>proc_macro_derive</code> حاشیه‌نویسی کرده‌ایم و نام <code>HelloMacro</code> را مشخص کرده‌ایم، که با نام ویژگی ما مطابقت دارد؛ این روش معمولی‌ای است که بیشتر ماکروهای رویه‌ای دنبال می‌کنند.</p>
<p>تابع <code>hello_macro_derive</code> ابتدا <code>input</code> را از یک <code>TokenStream</code> به یک ساختار داده تبدیل می‌کند که سپس می‌توانیم آن را تفسیر کرده و عملیات‌هایی روی آن انجام دهیم. اینجاست که crate <code>syn</code> به کار می‌آید. تابع <code>parse</code> در <code>syn</code> یک <code>TokenStream</code> می‌گیرد و یک ساختار <code>DeriveInput</code> را که نمایانگر کد Rust تجزیه‌شده است، بازمی‌گرداند. لیست ۲۰-۳۳ بخش‌های مرتبط از ساختار <code>DeriveInput</code> را نشان می‌دهد که هنگام تجزیه کد <code>struct Pancakes;</code> دریافت می‌کنیم:</p>
<figure class="listing">
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<figcaption>Listing 20-33: نمونه‌ای از <code>DeriveInput</code> که هنگام تجزیه کدی که ویژگی ماکرو در لیست ۲۰-۳۱ را دارد، دریافت می‌کنیم</figcaption>
</figure>
<p>فیلدهای این ساختار نشان می‌دهند که کد Rust که تجزیه کرده‌ایم یک ساختار واحد (<em>unit struct</em>) با شناسه (<code>ident</code>) به نام <code>Pancakes</code> است. این ساختار فیلدهای بیشتری برای توصیف انواع مختلف کد Rust دارد؛ برای اطلاعات بیشتر به <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html">مستندات <code>syn</code> برای <code>DeriveInput</code></a> مراجعه کنید.</p>
<p>به زودی تابع <code>impl_hello_macro</code> را تعریف خواهیم کرد، جایی که کد جدیدی که می‌خواهیم اضافه کنیم را تولید خواهیم کرد. اما قبل از این کار، توجه داشته باشید که خروجی ماکروی <code>derive</code> ما نیز یک <code>TokenStream</code> است. <code>TokenStream</code> بازگردانده شده به کدی که کاربران crate ما می‌نویسند اضافه می‌شود، بنابراین وقتی crate آن‌ها کامپایل می‌شود، قابلیت‌های اضافی‌ای که ما در <code>TokenStream</code> تغییر داده‌شده فراهم کرده‌ایم را دریافت خواهند کرد.</p>
<p>ممکن است متوجه شده باشید که ما از <code>unwrap</code> استفاده می‌کنیم تا در صورتی که فراخوانی تابع <code>syn::parse</code> شکست بخورد، تابع <code>hello_macro_derive</code> به وحشت بیفتد (<em>panic</em>). لازم است ماکروی رویه‌ای ما در صورت بروز خطا به وحشت بیفتد، زیرا توابع <code>proc_macro_derive</code> باید به جای <code>Result</code> یک <code>TokenStream</code> بازگردانند تا با API ماکروهای رویه‌ای سازگار باشند. برای ساده کردن این مثال از <code>unwrap</code> استفاده کرده‌ایم؛ در کد تولیدی، بهتر است پیام‌های خطای خاص‌تری درباره مشکل ایجاد شده با استفاده از <code>panic!</code> یا <code>expect</code> ارائه دهید.</p>
<p>اکنون که کدی داریم که کد Rust حاشیه‌نویسی‌شده را از یک <code>TokenStream</code> به یک نمونه <code>DeriveInput</code> تبدیل می‌کند، بیایید کدی که ویژگی <code>HelloMacro</code> را روی نوع حاشیه‌نویسی‌شده پیاده‌سازی می‌کند، تولید کنیم، همان‌طور که در لیست ۲۰-۳۴ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<figcaption>Listing 20-34: پیاده‌سازی ویژگی <code>HelloMacro</code> با استفاده از کد Rust تجزیه‌شده</figcaption>
</figure>
<p>ما با استفاده از <code>ast.ident</code> یک نمونه از ساختار <code>Ident</code> که شامل نام (شناسه) نوع حاشیه‌نویسی‌شده است، دریافت می‌کنیم. ساختار موجود در لیست ۲۰-۳۳ نشان می‌دهد که وقتی تابع <code>impl_hello_macro</code> را روی کد لیست ۲۰-۳۱ اجرا می‌کنیم، فیلد <code>ident</code> با مقدار <code>"Pancakes"</code> پر خواهد شد. بنابراین، متغیر <code>name</code> در لیست ۲۰-۳۴ یک نمونه از ساختار <code>Ident</code> را شامل می‌شود که وقتی چاپ می‌شود، رشته <code>"Pancakes"</code>، یعنی نام ساختار در لیست ۲۰-۳۱، خواهد بود.</p>
<p>ماکروی <code>quote!</code> به ما اجازه می‌دهد کد Rust مورد نظر خود برای بازگرداندن را تعریف کنیم. کامپایلر به چیزی متفاوت از نتیجه مستقیم اجرای ماکروی <code>quote!</code> نیاز دارد، بنابراین باید آن را به یک <code>TokenStream</code> تبدیل کنیم. این کار را با فراخوانی متد <code>into</code> انجام می‌دهیم که این نمایش میانی را مصرف کرده و مقداری از نوع <code>TokenStream</code> مورد نیاز بازمی‌گرداند.</p>
<p>ماکروی <code>quote!</code> همچنین برخی قابلیت‌های جالب الگوگذاری (templating) ارائه می‌دهد: می‌توانیم <code>#name</code> را وارد کنیم و <code>quote!</code> آن را با مقدار موجود در متغیر <code>name</code> جایگزین می‌کند. حتی می‌توانید تکرارهایی مشابه با نحوه کار ماکروهای معمولی انجام دهید. برای مقدمه‌ای جامع به <a href="https://docs.rs/quote">مستندات crate <code>quote</code></a> مراجعه کنید.</p>
<p>ما می‌خواهیم ماکروی رویه‌ای ما یک پیاده‌سازی از ویژگی <code>HelloMacro</code> برای نوعی که کاربر حاشیه‌نویسی کرده است تولید کند، که می‌توانیم با استفاده از <code>#name</code> به آن دسترسی پیدا کنیم. پیاده‌سازی ویژگی شامل یک تابع به نام <code>hello_macro</code> است که بدنه آن قابلیت مورد نظر ما، یعنی چاپ <code>Hello, Macro! My name is</code> و سپس نام نوع حاشیه‌نویسی‌شده، را ارائه می‌دهد.</p>
<p>ماکروی <code>stringify!</code> که در اینجا استفاده شده است، به صورت داخلی در Rust ساخته شده است. این ماکرو یک عبارت Rust، مانند <code>1 + 2</code>، را گرفته و در زمان کامپایل آن را به یک رشته ثابت، مانند <code>"1 + 2"</code>، تبدیل می‌کند. این با ماکروهایی مانند <code>format!</code> یا <code>println!</code> که عبارت را ارزیابی کرده و سپس نتیجه را به یک <code>String</code> تبدیل می‌کنند، متفاوت است. احتمال دارد ورودی <code>#name</code> یک عبارتی برای چاپ باشد، بنابراین از <code>stringify!</code> استفاده می‌کنیم. استفاده از <code>stringify!</code> همچنین با تبدیل <code>#name</code> به یک رشته ثابت در زمان کامپایل، یک تخصیص را صرفه‌جویی می‌کند.</p>
<p>در این مرحله، دستور <code>cargo build</code> باید با موفقیت در هر دو crate <code>hello_macro</code> و <code>hello_macro_derive</code> اجرا شود. بیایید این جعبه‌ها (crates) را به کد موجود در لیست ۲۰-۳۱ متصل کنیم تا ماکروی رویه‌ای را در عمل ببینیم! یک پروژه باینری جدید در دایرکتوری <em>projects</em> خود با استفاده از دستور <code>cargo new pancakes</code> ایجاد کنید. باید <code>hello_macro</code> و <code>hello_macro_derive</code> را به عنوان وابستگی در فایل <em>Cargo.toml</em> crate <code>pancakes</code> اضافه کنیم. اگر نسخه‌های خود از <code>hello_macro</code> و <code>hello_macro_derive</code> را در <a href="https://crates.io/">crates.io</a> منتشر می‌کنید، آن‌ها به عنوان وابستگی‌های معمولی خواهند بود؛ در غیر این صورت، می‌توانید آن‌ها را به صورت وابستگی‌های <code>path</code> به شکل زیر مشخص کنید:</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>کد موجود در لیست ۲۰-۳۱ را در فایل <em>src/main.rs</em> قرار دهید و دستور <code>cargo run</code> را اجرا کنید: باید عبارت <code>Hello, Macro! My name is Pancakes!</code> را چاپ کند. پیاده‌سازی ویژگی <code>HelloMacro</code> که از ماکروی رویه‌ای آمده بود، بدون نیاز به پیاده‌سازی آن توسط crate <code>pancakes</code> اضافه شد؛ ویژگی <code>#[derive(HelloMacro)]</code> پیاده‌سازی ویژگی را اضافه کرد.</p>
<p>در ادامه، بیایید بررسی کنیم که انواع دیگر ماکروهای رویه‌ای چه تفاوتی با ماکروهای سفارشی <code>derive</code> دارند.</p>
<h3 id="ماکروهای-شبیه-ویژگی-attribute-like-macros"><a class="header" href="#ماکروهای-شبیه-ویژگی-attribute-like-macros">ماکروهای شبیه ویژگی (Attribute-like macros)</a></h3>
<p>ماکروهای شبیه ویژگی مشابه ماکروهای سفارشی <code>derive</code> هستند، اما به جای تولید کد برای ویژگی <code>derive</code>، به شما امکان می‌دهند ویژگی‌های جدید ایجاد کنید. آن‌ها همچنین انعطاف‌پذیرتر هستند: <code>derive</code> فقط برای ساختارها (<em>structs</em>) و شمارش‌ها (<em>enums</em>) کار می‌کند؛ اما ویژگی‌ها می‌توانند به آیتم‌های دیگر نیز اعمال شوند، مانند توابع. در اینجا یک مثال از استفاده از یک ماکروی شبیه ویژگی آورده شده است: فرض کنید یک ویژگی به نام <code>route</code> دارید که توابع را هنگام استفاده از یک فریم‌ورک برنامه وب حاشیه‌نویسی می‌کند:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>این ویژگی <code>#[route]</code> توسط فریم‌ورک به عنوان یک ماکروی رویه‌ای تعریف می‌شود. امضای تابع تعریف ماکرو به این صورت خواهد بود:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>در اینجا، دو پارامتر از نوع <code>TokenStream</code> داریم. پارامتر اول برای محتوای ویژگی است: بخش <code>GET, "/"</code>. پارامتر دوم برای بدنه آیتمی است که ویژگی به آن متصل شده است: در این مورد، <code>fn index() {}</code> و باقی بدنه تابع.</p>
<p>علاوه بر این، ماکروهای شبیه ویژگی به همان شیوه ماکروهای سفارشی <code>derive</code> کار می‌کنند: شما یک crate با نوع <code>proc-macro</code> ایجاد می‌کنید و تابعی را پیاده‌سازی می‌کنید که کدی را که می‌خواهید تولید می‌کند!</p>
<h3 id="ماکروهای-شبیه-تابع"><a class="header" href="#ماکروهای-شبیه-تابع">ماکروهای شبیه تابع</a></h3>
<p>ماکروهای شبیه تابع، ماکروهایی را تعریف می‌کنند که شبیه به فراخوانی توابع به نظر می‌رسند. مشابه با ماکروهای <code>macro_rules!</code>، این ماکروها انعطاف‌پذیرتر از توابع هستند؛ برای مثال، می‌توانند تعداد نامشخصی از آرگومان‌ها را بپذیرند. با این حال، ماکروهای <code>macro_rules!</code> فقط می‌توانند با استفاده از سینتکس شبیه به <code>match</code> که در بخش <a href="ch20-05-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">“ماکروهای اعلانی با <code>macro_rules!</code> برای فرابرنامه‌نویسی عمومی”</a><!-- ignore --> بحث شد تعریف شوند. ماکروهای شبیه تابع یک پارامتر <code>TokenStream</code> می‌گیرند و تعریف آن‌ها این <code>TokenStream</code> را با استفاده از کد Rust مانند دو نوع دیگر ماکروهای رویه‌ای دستکاری می‌کند. مثالی از یک ماکروی شبیه تابع، ماکروی <code>sql!</code> است که ممکن است به این صورت فراخوانی شود:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>این ماکرو عبارت SQL داخل خود را تجزیه کرده و بررسی می‌کند که از نظر نحوی درست باشد، که پردازش بسیار پیچیده‌تری نسبت به آنچه یک ماکروی <code>macro_rules!</code> می‌تواند انجام دهد، دارد. ماکروی <code>sql!</code> به این صورت تعریف می‌شود:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>این تعریف مشابه امضای ماکروی سفارشی <code>derive</code> است: ما توکن‌هایی که داخل پرانتزها قرار دارند را دریافت می‌کنیم و کدی را که می‌خواهیم تولید کنیم بازمی‌گردانیم.</p>
<h2 id="خلاصه-18"><a class="header" href="#خلاصه-18">خلاصه</a></h2>
<p>وای! اکنون شما برخی از ویژگی‌های Rust را در ابزار خود دارید که احتمالاً به ندرت از آن‌ها استفاده می‌کنید، اما می‌دانید که در شرایط خاصی در دسترس هستند. ما موضوعات پیچیده متعددی را معرفی کردیم تا زمانی که با پیشنهادات پیام‌های خطا یا کدهای دیگران مواجه شدید، بتوانید این مفاهیم و سینتکس را بشناسید. از این فصل به عنوان مرجعی برای یافتن راه‌حل‌ها استفاده کنید.</p>
<p>در ادامه، همه چیزهایی که در طول کتاب بحث کردیم را در عمل پیاده‌سازی می‌کنیم و یک پروژه دیگر انجام خواهیم داد!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="پروژه-نهایی-ساخت-یک-وب-سرور-چندنخی"><a class="header" href="#پروژه-نهایی-ساخت-یک-وب-سرور-چندنخی">پروژه نهایی: ساخت یک وب سرور چندنخی</a></h1>
<p>مسیر طولانی‌ای را طی کرده‌ایم، اما اکنون به انتهای کتاب رسیده‌ایم. در این فصل، یک پروژه دیگر را با هم می‌سازیم تا برخی از مفاهیمی که در فصل‌های پایانی پوشش داده‌ایم را نشان دهیم و همچنین درس‌های قبلی را مرور کنیم.</p>
<p>برای پروژه نهایی، یک وب سرور ایجاد می‌کنیم که عبارت “hello” را نمایش دهد و در یک مرورگر وب شبیه شکل 21-1 به نظر برسد.</p>
<p><img src="img/trpl21-01.png" alt="hello from rust" /></p>
<p><span class="caption">شکل 21-1: پروژه نهایی ما</span></p>
<p>برنامه ما برای ساخت وب سرور به این صورت است:</p>
<div dir="rtl">
    <ul>
        <li>کمی درباره TCP و HTTP یاد می‌گیریم.</li>
        <li>گوش دادن به اتصالات TCP روی یک سوکت را پیاده‌سازی می‌کنیم.</li>
        <li>تعداد کمی از درخواست‌های HTTP را تجزیه می‌کنیم.</li>
        <li>یک پاسخ HTTP مناسب ایجاد می‌کنیم.</li>
        <li>با استفاده از یک مجموعه نخ (thread pool) توان عملیاتی سرور را بهبود می‌بخشیم.</li>
    </ul>
</div>
<p>قبل از شروع، باید به دو نکته اشاره کنیم: اول، روشی که استفاده خواهیم کرد بهترین روش برای ساخت یک وب سرور با Rust نخواهد بود. اعضای جامعه Rust تعداد زیادی crate آماده تولید در <a href="https://crates.io/">crates.io</a> منتشر کرده‌اند که پیاده‌سازی‌های کامل‌تری از وب سرور و مجموعه نخ نسبت به آنچه که ما خواهیم ساخت ارائه می‌دهند. با این حال، هدف ما در این فصل کمک به یادگیری شماست، نه انتخاب مسیر آسان. از آنجا که Rust یک زبان برنامه‌نویسی سیستمی است، می‌توانیم سطح انتزاعی که می‌خواهیم با آن کار کنیم را انتخاب کنیم و به سطح پایین‌تری از آنچه در زبان‌های دیگر ممکن یا عملی است برویم.</p>
<p>دوم، ما اینجا از async و await استفاده نخواهیم کرد. ساخت یک مجموعه نخ به اندازه کافی چالش‌برانگیز است، بدون اینکه به ایجاد یک runtime async اضافه شود! با این حال، اشاره خواهیم کرد که async و await چگونه ممکن است برای برخی از همان مشکلاتی که در این فصل خواهیم دید کاربرد داشته باشند. در نهایت، همان‌طور که در فصل 17 ذکر کردیم، بسیاری از runtime‌های async از مجموعه نخ برای مدیریت کارهای خود استفاده می‌کنند.</p>
<p>بنابراین، سرور HTTP ساده و مجموعه نخ را به صورت دستی خواهیم نوشت تا بتوانید ایده‌ها و تکنیک‌های کلی پشت جعبه‌ها (crates)یی که ممکن است در آینده استفاده کنید را یاد بگیرید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ساخت-یک-وب-سرور-single-threaded"><a class="header" href="#ساخت-یک-وب-سرور-single-threaded">ساخت یک وب سرور Single-Threaded</a></h2>
<p>ما با راه‌اندازی یک وب سرور Single-Threaded شروع خواهیم کرد. پیش از شروع، بیایید یک مرور سریع بر پروتکل‌های مرتبط با ساخت وب سرورها داشته باشیم. جزئیات این پروتکل‌ها خارج از محدوده این کتاب است، اما یک نمای کلی اطلاعات لازم را به شما می‌دهد.</p>
<p>دو پروتکل اصلی که در وب سرورها درگیر هستند، <em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> و <em>Transmission Control Protocol</em> <em>(TCP)</em> هستند. هر دو پروتکل <em>request-response</em> هستند، به این معنی که یک <em>client</em> درخواست‌ها را آغاز می‌کند و یک <em>server</em> به درخواست‌ها گوش می‌دهد و پاسخی به client ارائه می‌دهد. محتوای این درخواست‌ها و پاسخ‌ها توسط پروتکل‌ها تعریف شده است.</p>
<p>TCP یک پروتکل سطح پایین‌تر است که جزئیات چگونگی انتقال اطلاعات از یک سرور به سرور دیگر را توصیف می‌کند اما مشخص نمی‌کند که آن اطلاعات چیست. HTTP بر روی TCP ساخته شده است و محتوای درخواست‌ها و پاسخ‌ها را تعریف می‌کند. از لحاظ فنی امکان استفاده از HTTP با سایر پروتکل‌ها وجود دارد، اما در اکثر موارد، HTTP داده‌های خود را بر روی TCP ارسال می‌کند. ما با بایت‌های خام درخواست‌ها و پاسخ‌های TCP و HTTP کار خواهیم کرد.</p>
<h3 id="گوش-دادن-به-اتصال-tcp"><a class="header" href="#گوش-دادن-به-اتصال-tcp">گوش دادن به اتصال TCP</a></h3>
<p>وب سرور ما نیاز دارد به اتصال TCP گوش دهد، بنابراین این اولین بخشی است که روی آن کار می‌کنیم. کتابخانه استاندارد یک ماژول <code>std::net</code> ارائه می‌دهد که به ما این امکان را می‌دهد این کار را انجام دهیم. بیایید یک پروژه جدید به روش معمول ایجاد کنیم:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>حالا کد لیست ۲۱-۱ را در فایل <em>src/main.rs</em> وارد کنید تا شروع کنیم. این کد به آدرس محلی <code>127.0.0.1:7878</code> برای جریان‌های ورودی TCP گوش می‌دهد. وقتی یک جریان ورودی دریافت می‌کند، پیام <code>Connection established!</code> را چاپ می‌کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
<figcaption>Listing 21-1: گوش دادن به جریان‌های ورودی و چاپ یک پیام هنگام دریافت یک جریان</figcaption>
</figure>
<p>با استفاده از <code>TcpListener</code>، می‌توانیم به اتصالات TCP در آدرس <code>127.0.0.1:7878</code> گوش دهیم. در این آدرس، بخش قبل از دونقطه یک آدرس IP است که نمایانگر کامپیوتر شما است (این آدرس روی همه کامپیوترها یکسان است و نمایانگر کامپیوتر نویسندگان نیست) و <code>7878</code> پورت است. این پورت را به دو دلیل انتخاب کرده‌ایم: HTTP معمولاً روی این پورت پذیرفته نمی‌شود، بنابراین احتمالاً سرور ما با هیچ وب سرور دیگری که ممکن است روی دستگاه شما اجرا شود تداخل نخواهد داشت، و 7878 روی تلفن به صورت <em>rust</em> تایپ می‌شود.</p>
<p>تابع <code>bind</code> در این سناریو مانند تابع <code>new</code> عمل می‌کند به این صورت که یک نمونه جدید از <code>TcpListener</code> بازمی‌گرداند. این تابع <code>bind</code> نامیده می‌شود زیرا در شبکه، اتصال به یک پورت برای گوش دادن به آن به عنوان “binding to a port” شناخته می‌شود.</p>
<p>تابع <code>bind</code> یک <code>Result&lt;T, E&gt;</code> بازمی‌گرداند که نشان می‌دهد امکان دارد فرآیند binding شکست بخورد. به عنوان مثال، اتصال به پورت 80 نیاز به دسترسی مدیر (<em>administrator</em>) دارد (کاربران عادی فقط می‌توانند به پورت‌های بالاتر از 1023 گوش دهند)، بنابراین اگر تلاش کنیم بدون دسترسی مدیر به پورت 80 متصل شویم، فرآیند binding کار نخواهد کرد. همچنین اگر دو نمونه از برنامه خود اجرا کنیم و در نتیجه دو برنامه به همان پورت گوش دهند، فرآیند binding شکست خواهد خورد. از آنجا که ما یک سرور ساده فقط برای اهداف آموزشی می‌نویسیم، نگرانی‌ای در مورد مدیریت این نوع خطاها نخواهیم داشت؛ در عوض از <code>unwrap</code> استفاده می‌کنیم تا در صورت بروز خطا برنامه متوقف شود.</p>
<p>متد <code>incoming</code> روی <code>TcpListener</code> یک iterator بازمی‌گرداند که به ما دنباله‌ای از جریان‌ها (<em>streams</em>) می‌دهد (به طور خاص، جریان‌هایی از نوع <code>TcpStream</code>). یک <em>stream</em> نشان‌دهنده یک اتصال باز بین client و server است. یک <em>connection</em> به فرآیند کامل درخواست و پاسخ گفته می‌شود که در آن یک client به سرور متصل می‌شود، سرور یک پاسخ تولید می‌کند، و سپس اتصال توسط سرور بسته می‌شود. بنابراین، ما از <code>TcpStream</code> برای خواندن آنچه client ارسال کرده استفاده می‌کنیم و سپس پاسخ خود را به جریان می‌نویسیم تا داده‌ها را به client بازگردانیم. به طور کلی، این حلقه <code>for</code> هر اتصال را به نوبت پردازش کرده و یک سری جریان‌ها را برای مدیریت به ما می‌دهد.</p>
<p>فعلاً، مدیریت ما روی جریان به فراخوانی <code>unwrap</code> محدود می‌شود تا در صورتی که جریان دارای خطا باشد، برنامه متوقف شود. اگر خطایی وجود نداشته باشد، برنامه یک پیام چاپ می‌کند. در لیست بعدی، عملکرد بیشتری برای حالت موفقیت اضافه خواهیم کرد. دلیل اینکه ممکن است از متد <code>incoming</code> هنگام اتصال یک client به سرور خطا دریافت کنیم این است که ما در واقع روی اتصالات تکرار نمی‌کنیم، بلکه روی <em>تلاش‌های اتصال</em> تکرار می‌کنیم. اتصال ممکن است به دلایل مختلف موفقیت‌آمیز نباشد که بسیاری از آن‌ها مربوط به سیستم‌عامل هستند. برای مثال، بسیاری از سیستم‌عامل‌ها محدودیتی برای تعداد اتصالات همزمان باز دارند؛ تلاش‌های اتصال جدیدی که بیش از این تعداد باشند، تا زمانی که برخی از اتصالات باز بسته نشوند، خطا تولید خواهند کرد.</p>
<p>بیایید این کد را اجرا کنیم! دستور <code>cargo run</code> را در ترمینال اجرا کنید و سپس آدرس <em>127.0.0.1:7878</em> را در یک مرورگر وب باز کنید. مرورگر باید پیامی خطا مانند “Connection reset” را نشان دهد، زیرا سرور در حال حاضر هیچ داده‌ای باز نمی‌گرداند. اما وقتی به ترمینال خود نگاه کنید، باید چندین پیامی که هنگام اتصال مرورگر به سرور چاپ شده‌اند را ببینید:</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>گاهی ممکن است برای یک درخواست مرورگر چندین پیام چاپ شود؛ دلیل آن می‌تواند این باشد که مرورگر علاوه بر درخواست صفحه، درخواست‌هایی برای منابع دیگر نیز ارسال می‌کند، مانند آیکون <em>favicon.ico</em> که در تب مرورگر ظاهر می‌شود.</p>
<p>همچنین ممکن است مرورگر تلاش کند چندین بار به سرور متصل شود زیرا سرور هیچ داده‌ای باز نمی‌گرداند. وقتی <code>stream</code> از محدوده خارج می‌شود و در انتهای حلقه حذف می‌شود، اتصال به عنوان بخشی از پیاده‌سازی <code>drop</code> بسته می‌شود. مرورگرها گاهی با اتصالات بسته شده با تلاش مجدد مقابله می‌کنند، زیرا ممکن است مشکل موقتی باشد. نکته مهم این است که ما با موفقیت به یک اتصال TCP دست پیدا کرده‌ایم!</p>
<p>به یاد داشته باشید که برنامه را با فشار دادن کلیدهای <kbd>ctrl</kbd>-<kbd>c</kbd> متوقف کنید وقتی که اجرای نسخه خاصی از کد تمام شد. سپس برنامه را با اجرای دستور <code>cargo run</code> پس از ایجاد هر مجموعه از تغییرات کد، مجدداً راه‌اندازی کنید تا مطمئن شوید که جدیدترین کد اجرا می‌شود.</p>
<h3 id="خواندن-درخواست"><a class="header" href="#خواندن-درخواست">خواندن درخواست</a></h3>
<p>بیایید عملکرد خواندن درخواست از مرورگر را پیاده‌سازی کنیم! برای جدا کردن نگرانی‌ها از اتصال اولیه و سپس انجام برخی اقدامات با اتصال، یک تابع جدید برای پردازش اتصالات ایجاد می‌کنیم. در این تابع جدید <code>handle_connection</code>، داده‌ها را از جریان TCP می‌خوانیم و آن‌ها را چاپ می‌کنیم تا بتوانیم داده‌هایی که از مرورگر ارسال می‌شوند را ببینیم. کد را تغییر دهید تا شبیه لیست ۲۱-۲ شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<figcaption>Listing 21-2: خواندن از <code>TcpStream</code> و چاپ داده‌ها</figcaption>
</figure>
<p>ما <code>std::io::prelude</code> و <code>std::io::BufReader</code> را وارد دامنه می‌کنیم تا به ویژگی‌ها و نوع‌هایی که به ما اجازه خواندن و نوشتن از جریان را می‌دهند دسترسی داشته باشیم. در حلقه <code>for</code> در تابع <code>main</code>، به جای چاپ یک پیام که می‌گوید یک اتصال برقرار کردیم، حالا تابع جدید <code>handle_connection</code> را فراخوانی می‌کنیم و <code>stream</code> را به آن ارسال می‌کنیم.</p>
<p>در تابع <code>handle_connection</code>، یک نمونه جدید از <code>BufReader</code> ایجاد می‌کنیم که یک ارجاع به <code>stream</code> را در خود نگه می‌دارد. <code>BufReader</code> با مدیریت فراخوانی متدهای ویژگی <code>std::io::Read</code> برای ما، بافر را اضافه می‌کند.</p>
<p>ما یک متغیر به نام <code>http_request</code> ایجاد می‌کنیم تا خطوط درخواست ارسالی مرورگر به سرور را جمع‌آوری کنیم. مشخص می‌کنیم که می‌خواهیم این خطوط را در یک بردار جمع‌آوری کنیم با اضافه کردن نوع <code>Vec&lt;_&gt;</code> به عنوان حاشیه‌نویسی.</p>
<p><code>BufReader</code> ویژگی <code>std::io::BufRead</code> را پیاده‌سازی می‌کند که متد <code>lines</code> را ارائه می‌دهد. متد <code>lines</code> یک iterator از نوع <code>Result&lt;String, std::io::Error&gt;</code> بازمی‌گرداند، که با هر بار مشاهده یک بایت newline جریان داده را تقسیم می‌کند. برای دریافت هر <code>String</code>، هر <code>Result</code> را map و <code>unwrap</code> می‌کنیم. اگر داده‌ها UTF-8 معتبری نباشند یا اگر مشکلی در خواندن از جریان وجود داشته باشد، ممکن است <code>Result</code> خطایی باشد. باز هم، یک برنامه تولیدی باید این خطاها را به صورت کارآمدتری مدیریت کند، اما برای سادگی، ما انتخاب می‌کنیم که در حالت خطا برنامه متوقف شود.</p>
<p>مرورگر پایان یک درخواست HTTP را با ارسال دو کاراکتر newline متوالی نشان می‌دهد، بنابراین برای دریافت یک درخواست از جریان، خطوط را می‌گیریم تا زمانی که به یک خط خالی برسیم. پس از جمع‌آوری خطوط در بردار، آن‌ها را با استفاده از فرمت دیباگ زیبا چاپ می‌کنیم تا بتوانیم دستورالعمل‌هایی که مرورگر وب به سرور ما ارسال می‌کند را ببینیم.</p>
<p>بیایید این کد را امتحان کنیم! برنامه را اجرا کنید و دوباره یک درخواست در مرورگر وب ارسال کنید. توجه داشته باشید که همچنان در مرورگر یک صفحه خطا خواهیم دید، اما خروجی برنامه در ترمینال اکنون مشابه این خواهد بود:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>بسته به مرورگری که استفاده می‌کنید، ممکن است خروجی کمی متفاوت دریافت کنید. اکنون که داده‌های درخواست را چاپ می‌کنیم، می‌توانیم دلیل دریافت چندین اتصال از یک درخواست مرورگر را با نگاه کردن به مسیر بعد از <code>GET</code> در خط اول درخواست متوجه شویم. اگر اتصالات تکراری همه <em>/</em> را درخواست کنند، می‌دانیم که مرورگر سعی دارد <em>/</em> را بارها و بارها درخواست کند زیرا پاسخی از برنامه ما دریافت نمی‌کند.</p>
<p>بیایید این داده‌های درخواست را تجزیه کنیم تا متوجه شویم مرورگر از برنامه ما چه چیزی می‌خواهد.</p>
<h3 id="نگاهی-دقیقتر-به-یک-درخواست-http"><a class="header" href="#نگاهی-دقیقتر-به-یک-درخواست-http">نگاهی دقیق‌تر به یک درخواست HTTP</a></h3>
<p>HTTP یک پروتکل مبتنی بر متن است و یک درخواست فرمت زیر را دارد:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>خط اول <em>خط درخواست</em> است که اطلاعاتی درباره آنچه client درخواست می‌کند را نگه می‌دارد. قسمت اول خط درخواست، <em>method</em> استفاده‌شده را نشان می‌دهد، مانند <code>GET</code> یا <code>POST</code>، که توضیح می‌دهد client چگونه این درخواست را انجام می‌دهد. client ما از یک درخواست <code>GET</code> استفاده کرده است، به این معنی که در حال درخواست اطلاعات است.</p>
<p>قسمت بعدی خط درخواست، <em>/</em> است که نشان‌دهنده <em>شناسه منبع یکسان</em> <em>(Uniform Resource Identifier یا URI)</em> است که client درخواست می‌کند: یک URI تقریباً اما نه کاملاً همان <em>مکان‌نمای منبع یکسان</em> <em>(Uniform Resource Locator یا URL)</em> است. تفاوت بین URIs و URLs برای اهداف ما در این فصل مهم نیست، اما استاندارد HTTP از اصطلاح URI استفاده می‌کند، بنابراین می‌توانیم ذهنی URL را به جای URI در نظر بگیریم.</p>
<p>قسمت آخر نسخه HTTP است که client استفاده می‌کند، و سپس خط درخواست با یک <em>دنباله CRLF</em> پایان می‌یابد. (CRLF به معنای <em>بازگشت حامل</em> و <em>تغذیه خط</em> است که اصطلاحاتی از روزهای ماشین تایپ هستند!) دنباله CRLF همچنین می‌تواند به صورت <code>\r\n</code> نوشته شود، جایی که <code>\r</code> یک بازگشت حامل و <code>\n</code> یک تغذیه خط است. دنباله CRLF خط درخواست را از بقیه داده‌های درخواست جدا می‌کند. توجه داشته باشید که وقتی CRLF چاپ می‌شود، به جای <code>\r\n</code>، یک خط جدید شروع می‌شود.</p>
<p>با نگاه کردن به داده‌های خط درخواست که تاکنون از اجرای برنامه خود دریافت کرده‌ایم، می‌بینیم که <code>GET</code> متد است، <em>/</em> شناسه URI درخواست‌شده است، و <code>HTTP/1.1</code> نسخه است.</p>
<p>بعد از خط درخواست، خطوط باقی‌مانده از <code>Host:</code> به بعد هدرها هستند. درخواست‌های <code>GET</code> بدنه ندارند.</p>
<p>سعی کنید یک درخواست از مرورگری دیگر یا آدرسی متفاوت، مانند <em>127.0.0.1:7878/test</em>، ارسال کنید تا ببینید داده‌های درخواست چگونه تغییر می‌کنند.</p>
<p>اکنون که می‌دانیم مرورگر چه چیزی می‌خواهد، بیایید داده‌ای را به آن بازگردانیم!</p>
<h3 id="نوشتن-یک-پاسخ"><a class="header" href="#نوشتن-یک-پاسخ">نوشتن یک پاسخ</a></h3>
<p>ما قصد داریم ارسال داده در پاسخ به یک درخواست client را پیاده‌سازی کنیم. پاسخ‌ها فرمت زیر را دارند:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>خط اول یک <em>خط وضعیت</em> است که شامل نسخه HTTP استفاده‌شده در پاسخ، یک کد وضعیت عددی که نتیجه درخواست را خلاصه می‌کند، و یک عبارت دلیل که توضیح متنی برای کد وضعیت ارائه می‌دهد. پس از دنباله CRLF، هر هدر و سپس یک دنباله CRLF دیگر و بدنه پاسخ قرار می‌گیرد.</p>
<p>در اینجا یک مثال پاسخ آورده شده است که از نسخه HTTP 1.1 استفاده می‌کند، کد وضعیت 200 دارد، عبارت دلیل “OK” است، هیچ هدر و بدنه‌ای ندارد:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>کد وضعیت 200 پاسخ استاندارد موفقیت است. این متن یک پاسخ HTTP کوچک و موفقیت‌آمیز است. بیایید این را به عنوان پاسخ خود به یک درخواست موفق به جریان بنویسیم! از تابع <code>handle_connection</code>، <code>println!</code> که داده‌های درخواست را چاپ می‌کرد، حذف کنید و آن را با کد موجود در لیست ۲۱-۳ جایگزین کنید.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption>Listing 21-3: نوشتن یک پاسخ HTTP کوچک و موفقیت‌آمیز به جریان</figcaption>
</figure>
<p>خط جدید اول متغیر <code>response</code> را تعریف می‌کند که داده پیام موفقیت را در خود نگه می‌دارد. سپس با فراخوانی <code>as_bytes</code> روی <code>response</code> داده رشته‌ای را به بایت‌ها تبدیل می‌کنیم. متد <code>write_all</code> روی <code>stream</code> یک <code>&amp;[u8]</code> می‌گیرد و آن بایت‌ها را مستقیماً به اتصال ارسال می‌کند. از آنجا که عملیات <code>write_all</code> ممکن است شکست بخورد، مانند قبل، روی هر نتیجه خطا از <code>unwrap</code> استفاده می‌کنیم. باز هم، در یک برنامه واقعی باید اینجا مدیریت خطا اضافه کنید.</p>
<p>با این تغییرات، بیایید کد خود را اجرا کنیم و یک درخواست ارسال کنیم. دیگر هیچ داده‌ای به ترمینال چاپ نمی‌کنیم، بنابراین هیچ خروجی‌ای به غیر از خروجی Cargo نخواهید دید. وقتی آدرس <em>127.0.0.1:7878</em> را در یک مرورگر وب بارگذاری می‌کنید، باید یک صفحه خالی به جای یک خطا دریافت کنید. شما اکنون دریافت یک درخواست HTTP و ارسال یک پاسخ را به صورت دستی کدنویسی کرده‌اید!</p>
<h3 id="بازگرداندن-html-واقعی-returning-real-html"><a class="header" href="#بازگرداندن-html-واقعی-returning-real-html">بازگرداندن HTML واقعی (Returning Real HTML)</a></h3>
<p>بیایید عملکرد بازگرداندن چیزی بیش از یک صفحه خالی را پیاده‌سازی کنیم. فایل جدیدی به نام <em>hello.html</em> در ریشه دایرکتوری پروژه خود ایجاد کنید، نه در دایرکتوری <em>src</em>. می‌توانید هر HTML که می‌خواهید وارد کنید؛ لیست ۲۱-۴ یک نمونه را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: hello.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption>Listing 21-4: یک فایل نمونه HTML برای بازگرداندن در پاسخ</figcaption>
</figure>
<p>این یک سند HTML5 حداقلی با یک عنوان و مقداری متن است. برای بازگرداندن این فایل از سرور هنگام دریافت یک درخواست، کد <code>handle_connection</code> را همان‌طور که در لیست ۲۱-۵ نشان داده شده است تغییر می‌دهیم تا فایل HTML را بخواند، آن را به عنوان بدنه پاسخ اضافه کند و ارسال کند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption>Listing 21-5: ارسال محتوای <em>hello.html</em> به عنوان بدنه پاسخ</figcaption>
</figure>
<p>ما <code>fs</code> را به دستور <code>use</code> اضافه کرده‌ایم تا ماژول سیستم فایل کتابخانه استاندارد را وارد دامنه کنیم. کدی که محتوای یک فایل را به یک رشته می‌خواند باید آشنا به نظر برسد؛ ما در فصل ۱۲ زمانی که محتوای یک فایل را برای پروژه ورودی/خروجی خود خواندیم از آن استفاده کردیم (لیست ۱۲-۴).</p>
<p>سپس، از <code>format!</code> برای اضافه کردن محتوای فایل به عنوان بدنه پاسخ موفقیت استفاده می‌کنیم. برای اطمینان از یک پاسخ HTTP معتبر، هدر <code>Content-Length</code> را اضافه می‌کنیم که به اندازه بدنه پاسخ ما تنظیم شده است، که در این مورد اندازه فایل <code>hello.html</code> است.</p>
<p>این کد را با دستور <code>cargo run</code> اجرا کنید و آدرس <em>127.0.0.1:7878</em> را در مرورگر خود بارگذاری کنید؛ باید HTML خود را که به درستی رندر شده است ببینید!</p>
<p>در حال حاضر، ما داده‌های درخواست در <code>http_request</code> را نادیده می‌گیریم و فقط محتوای فایل HTML را بدون شرط بازمی‌گردانیم. این بدان معناست که اگر در مرورگر خود آدرس <em>127.0.0.1:7878/something-else</em> را درخواست کنید، همچنان همین پاسخ HTML را دریافت خواهید کرد. در این لحظه، سرور ما بسیار محدود است و کارهایی که اکثر وب سرورها انجام می‌دهند را انجام نمی‌دهد. ما می‌خواهیم پاسخ‌های خود را بر اساس درخواست سفارشی کنیم و فقط فایل HTML را برای یک درخواست خوش‌ساخت به <em>/</em> بازگردانیم.</p>
<h3 id="اعتبارسنجی-درخواست-و-پاسخدهی-انتخابی"><a class="header" href="#اعتبارسنجی-درخواست-و-پاسخدهی-انتخابی">اعتبارسنجی درخواست و پاسخ‌دهی انتخابی</a></h3>
<p>در حال حاضر، وب سرور ما محتوای فایل HTML را بدون توجه به درخواست client بازمی‌گرداند. بیایید عملکردی اضافه کنیم تا بررسی کند که مرورگر <em>/</em> را درخواست کرده باشد، سپس فایل HTML را بازگرداند و اگر مرورگر چیز دیگری درخواست کرد، یک خطا بازگرداند. برای این کار باید تابع <code>handle_connection</code> را همان‌طور که در لیست ۲۱-۶ نشان داده شده است تغییر دهیم. این کد جدید محتوای درخواست دریافتی را با آنچه که می‌دانیم یک درخواست برای <em>/</em> باید به نظر برسد مقایسه می‌کند و بلوک‌های <code>if</code> و <code>else</code> را اضافه می‌کند تا درخواست‌ها به صورت متفاوتی مدیریت شوند.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<figcaption>Listing 21-6: مدیریت درخواست‌های <em>/</em> به صورت متفاوت با سایر درخواست‌ها</figcaption>
</figure>
<p>ما فقط به خط اول درخواست HTTP نگاه خواهیم کرد، بنابراین به جای خواندن کل درخواست در یک بردار، از <code>next</code> استفاده می‌کنیم تا اولین آیتم از iterator را بگیریم. اولین <code>unwrap</code> مقدار <code>Option</code> را مدیریت می‌کند و اگر iterator هیچ آیتمی نداشته باشد برنامه را متوقف می‌کند. دومین <code>unwrap</code> مقدار <code>Result</code> را مدیریت می‌کند و همان اثری را دارد که <code>unwrap</code> در <code>map</code> اضافه‌شده در لیست ۲۱-۲ داشت.</p>
<p>سپس، مقدار <code>request_line</code> را بررسی می‌کنیم تا ببینیم آیا برابر با خط درخواست یک درخواست GET به مسیر <em>/</em> است یا خیر. اگر این‌طور باشد، بلوک <code>if</code> محتوای فایل HTML ما را بازمی‌گرداند.</p>
<p>اگر مقدار <code>request_line</code> برابر با درخواست GET به مسیر <em>/</em> نباشد، به این معنی است که یک درخواست دیگر دریافت کرده‌ایم. در بلوک <code>else</code> کدی اضافه خواهیم کرد تا به سایر درخواست‌ها پاسخ دهد.</p>
<p>این کد را اجرا کنید و آدرس <em>127.0.0.1:7878</em> را درخواست کنید؛ باید HTML موجود در فایل <em>hello.html</em> را دریافت کنید. اگر درخواست دیگری مانند <em>127.0.0.1:7878/something-else</em> ارسال کنید، یک خطای اتصال مشابه آنچه در اجرای کدهای لیست ۲۱-۱ و ۲۱-۲ دیدید دریافت خواهید کرد.</p>
<p>حالا کد موجود در لیست ۲۱-۷ را به بلوک <code>else</code> اضافه کنید تا پاسخی با کد وضعیت 404 بازگرداند، که نشان می‌دهد محتوای درخواست‌شده پیدا نشد. همچنین مقداری HTML برای یک صفحه خطا بازمی‌گردانیم تا در مرورگر به کاربر نهایی نمایش داده شود.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 21-7: پاسخ‌دهی با کد وضعیت 404 و یک صفحه خطا اگر چیزی به غیر از <em>/</em> درخواست شود</figcaption>
</figure>
<p>در اینجا، پاسخ ما یک خط وضعیت با کد وضعیت 404 و عبارت دلیل <code>NOT FOUND</code> دارد. بدنه پاسخ HTML موجود در فایل <em>404.html</em> خواهد بود. باید فایل <em>404.html</em> را در کنار فایل <em>hello.html</em> برای صفحه خطا ایجاد کنید؛ باز هم، می‌توانید هر HTML که می‌خواهید استفاده کنید یا از HTML نمونه موجود در لیست ۲۱-۸ استفاده کنید.</p>
<figure class="listing">
<span class="file-name">Filename: 404.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption>Listing 21-8: محتوای نمونه برای صفحه‌ای که با هر پاسخ 404 بازگردانده می‌شود</figcaption>
</figure>
<p>با این تغییرات، سرور خود را دوباره اجرا کنید. درخواست آدرس <em>127.0.0.1:7878</em> باید محتوای فایل <em>hello.html</em> را بازگرداند، و هر درخواست دیگری مانند <em>127.0.0.1:7878/foo</em> باید HTML خطا از فایل <em>404.html</em> را بازگرداند.</p>
<h3 id="کمی-بازسازی-refactoring"><a class="header" href="#کمی-بازسازی-refactoring">کمی بازسازی (Refactoring)</a></h3>
<p>در حال حاضر، بلوک‌های <code>if</code> و <code>else</code> مقدار زیادی تکرار دارند: هر دو فایل‌ها را می‌خوانند و محتوای فایل‌ها را به جریان می‌نویسند. تنها تفاوت‌ها خط وضعیت و نام فایل هستند. بیایید کد را مختصرتر کنیم و این تفاوت‌ها را به خطوط جداگانه <code>if</code> و <code>else</code> انتقال دهیم که مقادیر خط وضعیت و نام فایل را به متغیرها اختصاص دهند؛ سپس می‌توانیم از این متغیرها به طور شرطی برای خواندن فایل و نوشتن پاسخ استفاده کنیم. لیست ۲۱-۹ کد نتیجه‌شده پس از جایگزینی بلوک‌های بزرگ <code>if</code> و <code>else</code> را نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption>Listing 21-9: بازسازی بلوک‌های <code>if</code> و <code>else</code> برای شامل شدن تنها کدی که بین دو حالت متفاوت است</figcaption>
</figure>
<p>اکنون بلوک‌های <code>if</code> و <code>else</code> تنها مقادیر مناسب برای خط وضعیت و نام فایل را در یک تاپل بازمی‌گردانند؛ سپس با استفاده از یک الگو در دستور <code>let</code>، این دو مقدار به <code>status_line</code> و <code>filename</code> تخصیص داده می‌شوند، همان‌طور که در فصل ۱۹ بحث شد.</p>
<p>کدی که قبلاً تکراری بود اکنون خارج از بلوک‌های <code>if</code> و <code>else</code> قرار دارد و از متغیرهای <code>status_line</code> و <code>filename</code> استفاده می‌کند. این کار تشخیص تفاوت بین دو حالت را آسان‌تر می‌کند و به این معنی است که اگر بخواهیم نحوه خواندن فایل و نوشتن پاسخ را تغییر دهیم، تنها یک مکان برای به‌روزرسانی کد داریم. رفتار کد در لیست ۲۱-۹ با لیست ۲۱-۷ یکسان خواهد بود.</p>
<p>عالی! اکنون یک وب سرور ساده با تقریباً ۴۰ خط کد Rust داریم که به یک درخواست با یک صفحه محتوا پاسخ می‌دهد و به تمام درخواست‌های دیگر یک پاسخ 404 می‌دهد.</p>
<p>در حال حاضر، سرور ما در یک Thread اجرا می‌شود، به این معنی که تنها می‌تواند یک درخواست را در یک زمان سرویس دهد. بیایید بررسی کنیم که چگونه این موضوع می‌تواند مشکل‌ساز شود، با شبیه‌سازی برخی درخواست‌های کند. سپس سرور را طوری بهبود می‌دهیم که بتواند چندین درخواست را همزمان مدیریت کند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="تبدیل-سرور-single-threaded-به-یک-سرور-multithreaded"><a class="header" href="#تبدیل-سرور-single-threaded-به-یک-سرور-multithreaded">تبدیل سرور Single-Threaded به یک سرور Multithreaded</a></h2>
<p>در حال حاضر، سرور هر درخواست را به نوبت پردازش می‌کند، به این معنی که تا زمانی که پردازش اولین اتصال تمام نشده باشد، اتصال دوم پردازش نمی‌شود. اگر سرور درخواست‌های بیشتری دریافت کند، این اجرای سریال کمتر و کمتر بهینه خواهد بود. اگر سرور درخواستی دریافت کند که پردازش آن زمان زیادی می‌برد، درخواست‌های بعدی باید منتظر بمانند تا درخواست طولانی تمام شود، حتی اگر بتوان درخواست‌های جدید را به سرعت پردازش کرد. ما باید این مشکل را رفع کنیم، اما ابتدا به این مشکل در عمل نگاه می‌کنیم.</p>
<h3 id="شبیهسازی-یک-درخواست-کند-در-پیادهسازی-فعلی-سرور"><a class="header" href="#شبیهسازی-یک-درخواست-کند-در-پیادهسازی-فعلی-سرور">شبیه‌سازی یک درخواست کند در پیاده‌سازی فعلی سرور</a></h3>
<p>ما بررسی می‌کنیم که چگونه یک درخواست با پردازش کند می‌تواند بر سایر درخواست‌های ارسال‌شده به پیاده‌سازی فعلی سرور تأثیر بگذارد. لیست ۲۱-۱۰ پیاده‌سازی مدیریت یک درخواست به <em>/sleep</em> را نشان می‌دهد که یک پاسخ کند شبیه‌سازی‌شده است و باعث می‌شود سرور قبل از پاسخ دادن به مدت ۵ ثانیه بخوابد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<figcaption>Listing 21-10: شبیه‌سازی یک درخواست کند با خوابیدن سرور به مدت ۵ ثانیه</figcaption>
</figure>
<p>ما از <code>if</code> به <code>match</code> تغییر داده‌ایم زیرا اکنون سه حالت داریم. باید به‌طور صریح روی یک برش از <code>request_line</code> الگو تطابق ایجاد کنیم تا مقادیر رشته‌ای را تطابق دهیم؛ <code>match</code> به طور خودکار مرجع‌دهی و عدم مرجع‌دهی را مانند متد برابری انجام نمی‌دهد.</p>
<p>بازوی اول همان بلوک <code>if</code> از لیست ۲۱-۹ است. بازوی دوم یک درخواست به <em>/sleep</em> را تطابق می‌دهد. وقتی آن درخواست دریافت شود، سرور به مدت ۵ ثانیه می‌خوابد قبل از اینکه صفحه HTML موفقیت‌آمیز را نمایش دهد. بازوی سوم همان بلوک <code>else</code> از لیست ۲۱-۹ است.</p>
<p>می‌توانید ببینید که سرور ما چقدر ابتدایی است: کتابخانه‌های واقعی مدیریت تشخیص درخواست‌های متعدد را به روشی بسیار کمتر پرحرف انجام می‌دهند!</p>
<p>سرور را با استفاده از <code>cargo run</code> اجرا کنید. سپس دو پنجره مرورگر باز کنید: یکی برای آدرس <em>http://127.0.0.1:7878/</em> و دیگری برای آدرس <em>http://127.0.0.1:7878/sleep</em>. اگر چند بار آدرس <em>/</em> را وارد کنید، می‌بینید که سریع پاسخ می‌دهد. اما اگر آدرس <em>/sleep</em> را وارد کنید و سپس <em>/</em> را بارگذاری کنید، خواهید دید که <em>/</em> منتظر می‌ماند تا درخواست <em>/sleep</em> برای ۵ ثانیه کامل بخوابد و سپس بارگذاری شود.</p>
<h3 id="بهبود-توان-عملیاتی-با-یک-thread-pool"><a class="header" href="#بهبود-توان-عملیاتی-با-یک-thread-pool">بهبود توان عملیاتی با یک Thread Pool</a></h3>
<p>یک <em>Thread Pool</em> گروهی از Threadهای ایجادشده است که منتظر و آماده برای مدیریت یک وظیفه هستند. وقتی برنامه یک وظیفه جدید دریافت می‌کند، یکی از Threadهای موجود در Pool به وظیفه اختصاص داده می‌شود و آن Thread وظیفه را پردازش می‌کند. Threadهای باقی‌مانده در Pool در دسترس هستند تا هر وظیفه دیگری که وارد شود را در حالی که Thread اول وظیفه خود را پردازش می‌کند، مدیریت کنند. وقتی Thread اول پردازش وظیفه خود را به پایان می‌رساند، به Pool Threadهای بیکار بازمی‌گردد و آماده برای مدیریت یک وظیفه جدید است. یک Thread Pool به شما امکان می‌دهد اتصالات را به صورت همزمان پردازش کنید و توان عملیاتی سرور خود را افزایش دهید.</p>
<p>ما تعداد Threadهای موجود در Pool را به یک عدد کوچک محدود خواهیم کرد تا از حملات Denial of Service (DoS) محافظت کنیم؛ اگر برنامه ما برای هر درخواست جدید یک Thread ایجاد کند، کسی که ۱۰ میلیون درخواست به سرور ما ارسال کند می‌تواند با استفاده از تمام منابع سرور، پردازش درخواست‌ها را متوقف کند.</p>
<p>به جای ایجاد تعداد نامحدودی از Threadها، تعداد ثابتی از Threadها را در Pool خواهیم داشت که منتظر پردازش وظایف هستند. درخواست‌هایی که وارد می‌شوند به Pool ارسال می‌شوند. Pool یک صف از درخواست‌های ورودی را مدیریت خواهد کرد. هر یک از Threadها در Pool یک درخواست از صف برداشته، درخواست را پردازش می‌کند و سپس درخواست دیگری از صف درخواست می‌کند. با این طراحی، می‌توانیم حداکثر تا <code>N</code> درخواست را به صورت همزمان پردازش کنیم، جایی که <code>N</code> تعداد Threadها است. اگر هر Thread به یک درخواست طولانی پاسخ دهد، درخواست‌های بعدی ممکن است در صف پشتیبانی شوند، اما تعداد درخواست‌های طولانی که می‌توانیم قبل از رسیدن به این نقطه مدیریت کنیم افزایش یافته است.</p>
<p>این تکنیک تنها یکی از راه‌های بهبود توان عملیاتی یک وب سرور است. گزینه‌های دیگری که ممکن است بررسی کنید شامل <em>مدل fork/join</em>، <em>مدل I/O async تک‌Threaded</em>، یا <em>مدل I/O async چندThreaded</em> هستند. اگر به این موضوع علاقه دارید، می‌توانید بیشتر در مورد راه‌حل‌های دیگر بخوانید و آن‌ها را پیاده‌سازی کنید؛ با یک زبان سطح پایین مانند Rust، همه این گزینه‌ها ممکن هستند.</p>
<p>پیش از آنکه پیاده‌سازی یک Thread Pool را شروع کنیم، بیایید در مورد نحوه استفاده از Pool صحبت کنیم. وقتی قصد طراحی کدی را دارید، ابتدا نوشتن رابط کاربری (client interface) می‌تواند به طراحی شما کمک کند. API کد را به گونه‌ای بنویسید که ساختاری برای نحوه فراخوانی آن داشته باشد؛ سپس قابلیت‌ها را در آن ساختار پیاده‌سازی کنید به جای اینکه ابتدا قابلیت‌ها را پیاده‌سازی کنید و سپس API عمومی را طراحی کنید.</p>
<p>مشابه روش توسعه مبتنی بر تست که در پروژه فصل ۱۲ استفاده کردیم، اینجا از توسعه مبتنی بر کامپایلر استفاده می‌کنیم. کدی را که توابع مورد نظرمان را فراخوانی می‌کند، می‌نویسیم و سپس به خطاهای کامپایلر نگاه می‌کنیم تا مشخص کنیم چه تغییراتی باید انجام دهیم تا کد کار کند. با این حال، پیش از انجام این کار، روش دیگری را که قرار نیست استفاده کنیم، به عنوان نقطه شروع بررسی خواهیم کرد.</p>
<h4 id="ایجاد-یک-thread-جدید-برای-هر-درخواست"><a class="header" href="#ایجاد-یک-thread-جدید-برای-هر-درخواست">ایجاد یک Thread جدید برای هر درخواست</a></h4>
<p>ابتدا، بیایید بررسی کنیم که اگر کد ما برای هر اتصال یک Thread جدید ایجاد کند، چگونه به نظر می‌رسد. همان‌طور که قبلاً ذکر شد، این طرح نهایی ما نیست به دلیل مشکلاتی که ممکن است با ایجاد تعداد نامحدودی از Threadها پیش بیاید، اما این یک نقطه شروع برای ایجاد یک سرور Multithreaded کارا است. سپس Thread Pool را به عنوان یک بهبود اضافه خواهیم کرد، و مقایسه این دو راه‌حل آسان‌تر خواهد بود. لیست ۲۱-۱۱ تغییراتی را که باید در <code>main</code> انجام دهیم تا برای هر جریان در حلقه <code>for</code> یک Thread جدید ایجاد کنیم، نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 21-11: ایجاد یک Thread جدید برای هر جریان</figcaption>
</figure>
<p>همان‌طور که در فصل ۱۶ یاد گرفتید، <code>thread::spawn</code> یک Thread جدید ایجاد کرده و سپس کد موجود در کلوزر را در Thread جدید اجرا می‌کند. اگر این کد را اجرا کنید و در مرورگر خود <em>/sleep</em> را باز کنید، سپس <em>/</em> را در دو تب دیگر باز کنید، خواهید دید که درخواست‌های <em>/</em> لازم نیست منتظر پایان درخواست <em>/sleep</em> باشند. با این حال، همان‌طور که ذکر شد، این روش در نهایت سیستم را تحت فشار قرار می‌دهد زیرا شما تعداد نامحدودی Thread بدون محدودیت ایجاد می‌کنید.</p>
<p>ممکن است به یاد بیاورید که این دقیقاً همان شرایطی است که async و await در آن می‌درخشند! این نکته را در ذهن داشته باشید در حالی که Thread Pool را می‌سازیم و به این فکر کنید که چگونه این شرایط با async متفاوت یا مشابه خواهد بود.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="creating-a-finite-number-of-threads"><a class="header" href="#creating-a-finite-number-of-threads">Creating a Finite Number of Threads</a></h4>
<p>ما می‌خواهیم Thread Pool ما به روشی مشابه و آشنا کار کند، به طوری که تغییر از استفاده از Threadها به Thread Pool نیاز به تغییرات زیادی در کدی که از API ما استفاده می‌کند نداشته باشد. لیست ۲۱-۱۲ رابط فرضی برای یک ساختار <code>ThreadPool</code> را نشان می‌دهد که می‌خواهیم به جای <code>thread::spawn</code> استفاده کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-12: رابط ایده‌آل برای <code>ThreadPool</code></figcaption>
</figure>
<p>ما از <code>ThreadPool::new</code> برای ایجاد یک Thread Pool جدید با تعداد قابل تنظیم Threadها استفاده می‌کنیم، که در اینجا چهار است. سپس، در حلقه <code>for</code>، متد <code>pool.execute</code> رابطی مشابه با <code>thread::spawn</code> دارد، به طوری که یک Closure را می‌گیرد که Pool باید برای هر جریان اجرا کند. ما نیاز داریم <code>pool.execute</code> را پیاده‌سازی کنیم تا Closure را بگیرد و به یکی از Threadهای موجود در Pool برای اجرا بدهد. این کد هنوز کامپایل نمی‌شود، اما آن را امتحان می‌کنیم تا کامپایلر راهنمایی کند که چگونه آن را اصلاح کنیم.</p>
<h4 id="ساخت-threadpool-با-استفاده-از-توسعه-مبتنی-بر-کامپایلر"><a class="header" href="#ساخت-threadpool-با-استفاده-از-توسعه-مبتنی-بر-کامپایلر">ساخت <code>ThreadPool</code> با استفاده از توسعه مبتنی بر کامپایلر</a></h4>
<p>تغییرات لیست ۲۱-۱۲ را در فایل <em>src/main.rs</em> اعمال کنید و سپس از خطاهای کامپایلر که توسط <code>cargo check</code> ارائه می‌شود برای هدایت توسعه استفاده کنید. اولین خطایی که دریافت می‌کنیم به صورت زیر است:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>عالی! این خطا به ما می‌گوید که به یک نوع یا ماژول <code>ThreadPool</code> نیاز داریم، بنابراین اکنون آن را خواهیم ساخت. پیاده‌سازی <code>ThreadPool</code> ما مستقل از نوع کاری است که وب سرور ما انجام می‌دهد. بنابراین، بیایید crate <code>hello</code> را از یک crate باینری به یک crate کتابخانه‌ای تغییر دهیم تا پیاده‌سازی <code>ThreadPool</code> خود را در آن قرار دهیم. پس از تغییر به یک crate کتابخانه‌ای، می‌توانیم از کتابخانه Thread Pool جداگانه برای هر کاری که می‌خواهیم با استفاده از Thread Pool انجام دهیم استفاده کنیم، نه فقط برای سرویس‌دهی به درخواست‌های وب.</p>
<p>فایلی به نام <em>src/lib.rs</em> ایجاد کنید که شامل تعریف زیر باشد، که ساده‌ترین تعریف ممکن برای یک ساختار <code>ThreadPool</code> است:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</figure>
<p>سپس فایل <em>main.rs</em> را ویرایش کنید تا <code>ThreadPool</code> را از crate کتابخانه‌ای وارد دامنه کنید. برای این کار کد زیر را به بالای فایل <em>src/main.rs</em> اضافه کنید:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</figure>
<p>این کد همچنان کار نخواهد کرد، اما بیایید دوباره آن را بررسی کنیم تا خطای بعدی که باید برطرف کنیم را ببینیم:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>این خطا نشان می‌دهد که باید تابع وابسته‌ای به نام <code>new</code> برای <code>ThreadPool</code> ایجاد کنیم. همچنین می‌دانیم که <code>new</code> باید یک پارامتر داشته باشد که بتواند مقدار <code>4</code> را به عنوان آرگومان بپذیرد و یک نمونه از <code>ThreadPool</code> بازگرداند. بیایید ساده‌ترین تابع <code>new</code> که این خصوصیات را دارد پیاده‌سازی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</figure>
<p>ما نوع <code>usize</code> را برای پارامتر <code>size</code> انتخاب کردیم، زیرا می‌دانیم که تعداد منفی Threadها منطقی نیست. همچنین می‌دانیم که این مقدار <code>4</code> را به عنوان تعداد عناصر در یک مجموعه از Threadها استفاده خواهیم کرد، که نوع <code>usize</code> برای آن مناسب است، همان‌طور که در بخش <a href="ch03-02-data-types.html#integer-types">“نوع‌های عدد صحیح”</a><!-- ignore --> از فصل ۳ توضیح داده شد.</p>
<p>بیایید دوباره کد را بررسی کنیم:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>اکنون خطا به این دلیل است که متد <code>execute</code> روی <code>ThreadPool</code> تعریف نشده است. به یاد بیاورید که در بخش <a href="ch21-02-multithreaded.html#creating-a-finite-number-of-threads">“ایجاد تعداد محدودی از Threadها”</a><!-- ignore --> تصمیم گرفتیم که Thread Pool ما باید رابطی مشابه <code>thread::spawn</code> داشته باشد. علاوه بر این، متد <code>execute</code> را طوری پیاده‌سازی خواهیم کرد که Closure داده شده را بگیرد و آن را به یک Thread بیکار در Pool برای اجرا بدهد.</p>
<p>ما متد <code>execute</code> را روی <code>ThreadPool</code> تعریف می‌کنیم تا یک Closure را به عنوان پارامتر بپذیرد. به یاد بیاورید که در بخش <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">“انتقال مقادیر گرفته‌شده از Closure و ویژگی‌های <code>Fn</code>”</a><!-- ignore --> از فصل ۱۳ توضیح داده شد که می‌توانیم Closureها را با سه ویژگی مختلف به عنوان پارامتر بپذیریم: <code>Fn</code>، <code>FnMut</code>، و <code>FnOnce</code>. باید تصمیم بگیریم که در اینجا از کدام نوع Closure استفاده کنیم. می‌دانیم که چیزی مشابه با پیاده‌سازی <code>thread::spawn</code> در کتابخانه استاندارد انجام خواهیم داد، بنابراین می‌توانیم به محدودیت‌های امضای <code>thread::spawn</code> روی پارامترش نگاه کنیم. مستندات به ما موارد زیر را نشان می‌دهد:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>نوع پارامتر <code>F</code> همان چیزی است که در اینجا به آن توجه داریم؛ پارامتر نوع <code>T</code> مربوط به مقدار بازگشتی است و ما به آن توجه نداریم. می‌توانیم ببینیم که <code>spawn</code> از <code>FnOnce</code> به عنوان محدودیت ویژگی روی <code>F</code> استفاده می‌کند. این احتمالاً چیزی است که ما نیز می‌خواهیم، زیرا در نهایت آرگومان دریافتی در <code>execute</code> را به <code>spawn</code> پاس می‌دهیم. ما اطمینان بیشتری داریم که <code>FnOnce</code> همان ویژگی مورد نظر ما است، زیرا Thread برای اجرای یک درخواست فقط Closure مربوط به آن درخواست را یک بار اجرا می‌کند، که با “Once” در <code>FnOnce</code> مطابقت دارد.</p>
<p>پارامتر نوع <code>F</code> همچنین دارای محدودیت ویژگی <code>Send</code> و محدودیت طول عمر <code>'static</code> است، که در وضعیت ما مفید هستند: ما به <code>Send</code> نیاز داریم تا Closure را از یک Thread به Thread دیگر منتقل کنیم و به <code>'static</code> نیاز داریم زیرا نمی‌دانیم اجرای Thread چه مدت طول می‌کشد. بیایید یک متد <code>execute</code> روی <code>ThreadPool</code> ایجاد کنیم که یک پارامتر عمومی از نوع <code>F</code> با این محدودیت‌ها بپذیرد:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</figure>
<p>ما همچنان از <code>()</code> پس از <code>FnOnce</code> استفاده می‌کنیم زیرا این <code>FnOnce</code> نشان‌دهنده یک Closure است که هیچ پارامتری نمی‌گیرد و نوع <code>()</code> را بازمی‌گرداند. درست مانند تعریف توابع، می‌توان نوع بازگشتی را از امضا حذف کرد، اما حتی اگر هیچ پارامتری نداشته باشیم، همچنان به پرانتزها نیاز داریم.</p>
<p>دوباره، این ساده‌ترین پیاده‌سازی ممکن برای متد <code>execute</code> است: این متد هیچ کاری انجام نمی‌دهد، اما ما فقط تلاش می‌کنیم کد خود را کامپایل کنیم. بیایید دوباره کد را بررسی کنیم:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>کد کامپایل می‌شود! اما توجه داشته باشید که اگر <code>cargo run</code> را اجرا کنید و در مرورگر یک درخواست ارسال کنید، خطاهایی را در مرورگر خواهید دید که در ابتدای فصل دیده بودیم. کتابخانه ما هنوز Closure پاس‌داده‌شده به <code>execute</code> را فراخوانی نمی‌کند!</p>
<blockquote>
<p>نکته: یک ضرب‌المثل درباره زبان‌هایی با کامپایلرهای سخت‌گیر، مانند Haskell و Rust، این است که “اگر کد کامپایل شود، کار می‌کند.” اما این ضرب‌المثل همیشه درست نیست. پروژه ما کامپایل می‌شود، اما هیچ کاری انجام نمی‌دهد! اگر در حال ساخت یک پروژه واقعی و کامل بودیم، اکنون زمان خوبی برای شروع نوشتن تست‌های واحد بود تا بررسی کنیم که کد هم کامپایل می‌شود <em>و</em> رفتار مورد نظر ما را دارد.</p>
</blockquote>
<p><strong>توجه:</strong> اگر قصد داشتیم به جای یک Closure، یک <em>future</em> اجرا کنیم، چه تفاوتی در اینجا وجود داشت؟</p>
<h4 id="اعتبارسنجی-تعداد-threadها-در-new"><a class="header" href="#اعتبارسنجی-تعداد-threadها-در-new">اعتبارسنجی تعداد Threadها در <code>new</code></a></h4>
<p>در حال حاضر، ما هیچ کاری با پارامترهای <code>new</code> و <code>execute</code> انجام نمی‌دهیم. بیایید بدنه این توابع را با رفتار مورد نظر خود پیاده‌سازی کنیم. ابتدا، به تابع <code>new</code> فکر کنیم. قبلاً یک نوع عدد صحیح بدون علامت برای پارامتر <code>size</code> انتخاب کردیم، زیرا یک Pool با تعداد منفی Thread منطقی نیست. با این حال، یک Pool با صفر Thread نیز منطقی نیست، اما صفر یک مقدار معتبر برای <code>usize</code> است. کدی اضافه خواهیم کرد تا بررسی کند که مقدار <code>size</code> بیشتر از صفر باشد قبل از اینکه یک نمونه از <code>ThreadPool</code> بازگردانیم و در صورت دریافت مقدار صفر، برنامه با استفاده از ماکروی <code>assert!</code> متوقف شود، همان‌طور که در لیست ۲۱-۱۳ نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<figcaption>Listing 21-13: پیاده‌سازی <code>ThreadPool::new</code> برای توقف برنامه در صورت صفر بودن <code>size</code></figcaption>
</figure>
<p>ما همچنین برخی مستندات برای <code>ThreadPool</code> خود با استفاده از نظرات داکیومنت (<em>doc comments</em>) اضافه کرده‌ایم. توجه داشته باشید که ما از اصول خوب مستندسازی پیروی کرده‌ایم و بخشی را اضافه کرده‌ایم که شرایطی که تابع ما ممکن است به وحشت بیفتد (<em>panic</em>) را توضیح می‌دهد، همان‌طور که در فصل ۱۴ مورد بحث قرار گرفت. دستور <code>cargo doc --open</code> را اجرا کنید و روی ساختار <code>ThreadPool</code> کلیک کنید تا ببینید مستندات تولیدشده برای <code>new</code> چگونه به نظر می‌رسند!</p>
<p>به جای اضافه کردن ماکروی <code>assert!</code> همان‌طور که اینجا انجام دادیم، می‌توانستیم <code>new</code> را به <code>build</code> تغییر دهیم و یک <code>Result</code> بازگردانیم، مانند آنچه با <code>Config::build</code> در پروژه I/O در لیست ۱۲-۹ انجام دادیم. اما در این مورد تصمیم گرفته‌ایم که تلاش برای ایجاد یک Thread Pool بدون هیچ Threadی باید یک خطای غیرقابل بازیابی باشد. اگر احساس جاه‌طلبی می‌کنید، سعی کنید تابعی به نام <code>build</code> با امضای زیر بنویسید تا با تابع <code>new</code> مقایسه کنید:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="ایجاد-فضایی-برای-ذخیره-threadها"><a class="header" href="#ایجاد-فضایی-برای-ذخیره-threadها">ایجاد فضایی برای ذخیره Threadها</a></h4>
<p>اکنون که روشی برای اطمینان از تعداد معتبر Threadهایی که در Pool ذخیره می‌شوند داریم، می‌توانیم این Threadها را ایجاد کرده و آن‌ها را در ساختار <code>ThreadPool</code> قبل از بازگرداندن ساختار ذخیره کنیم. اما چگونه می‌توانیم یک Thread را “ذخیره” کنیم؟ بیایید دوباره به امضای <code>thread::spawn</code> نگاه کنیم:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>تابع <code>spawn</code> یک <code>JoinHandle&lt;T&gt;</code> بازمی‌گرداند، جایی که <code>T</code> نوعی است که Closure بازمی‌گرداند. بیایید ما هم از <code>JoinHandle</code> استفاده کنیم و ببینیم چه اتفاقی می‌افتد. در مورد ما، Closureهایی که به Thread Pool ارسال می‌کنیم اتصال را مدیریت کرده و چیزی بازنمی‌گردانند، بنابراین <code>T</code> برابر با نوع واحد <code>()</code> خواهد بود.</p>
<p>کد موجود در لیست ۲۱-۱۴ کامپایل می‌شود اما هنوز هیچ Threadی ایجاد نمی‌کند. ما تعریف <code>ThreadPool</code> را تغییر داده‌ایم تا یک بردار از نمونه‌های <code>thread::JoinHandle&lt;()&gt;</code> را نگه دارد، بردار را با ظرفیتی برابر با <code>size</code> مقداردهی اولیه کرده‌ایم، یک حلقه <code>for</code> تنظیم کرده‌ایم که کدی برای ایجاد Threadها اجرا می‌کند، و یک نمونه از <code>ThreadPool</code> که آن‌ها را در خود دارد بازمی‌گرداند.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<figcaption>Listing 21-14: ایجاد یک بردار برای <code>ThreadPool</code> برای نگهداری Threadها</figcaption>
</figure>
<p>ما <code>std::thread</code> را در crate کتابخانه‌ای وارد دامنه کرده‌ایم، زیرا از <code>thread::JoinHandle</code> به عنوان نوع آیتم‌های موجود در بردار در <code>ThreadPool</code> استفاده می‌کنیم.</p>
<p>هنگامی که یک مقدار معتبر برای <code>size</code> دریافت شود، <code>ThreadPool</code> ما یک بردار جدید ایجاد می‌کند که می‌تواند <code>size</code> آیتم را در خود جای دهد. تابع <code>with_capacity</code> همان کار <code>Vec::new</code> را انجام می‌دهد اما با یک تفاوت مهم: فضای لازم را از قبل در بردار تخصیص می‌دهد. چون می‌دانیم که باید <code>size</code> عنصر را در بردار ذخیره کنیم، انجام این تخصیص از ابتدا کمی کارآمدتر از استفاده از <code>Vec::new</code> است که خودش در حین اضافه شدن عناصر تغییر اندازه می‌دهد.</p>
<p>وقتی دوباره <code>cargo check</code> را اجرا کنید، باید با موفقیت انجام شود.</p>
<h4 id="ساختار-worker-مسئول-ارسال-کد-از-threadpool-به-یک-thread"><a class="header" href="#ساختار-worker-مسئول-ارسال-کد-از-threadpool-به-یک-thread">ساختار <code>Worker</code> مسئول ارسال کد از <code>ThreadPool</code> به یک Thread</a></h4>
<p>در حلقه <code>for</code> در لیست ۲۱-۱۴، نظری در مورد ایجاد Threadها گذاشتیم. در اینجا بررسی خواهیم کرد که چگونه واقعاً Threadها را ایجاد می‌کنیم. کتابخانه استاندارد <code>thread::spawn</code> را به عنوان روشی برای ایجاد Threadها ارائه می‌دهد، و <code>thread::spawn</code> انتظار دارد کدی دریافت کند که Thread بلافاصله پس از ایجاد اجرا کند. با این حال، در مورد ما، می‌خواهیم Threadها را ایجاد کنیم و آن‌ها را منتظر نگه داریم تا کدی که بعداً ارسال می‌کنیم را اجرا کنند. پیاده‌سازی Threadها در کتابخانه استاندارد هیچ راهی برای انجام این کار ارائه نمی‌دهد؛ بنابراین باید آن را به صورت دستی پیاده‌سازی کنیم.</p>
<p>ما این رفتار را با معرفی یک ساختار داده جدید بین <code>ThreadPool</code> و Threadها که این رفتار جدید را مدیریت می‌کند، پیاده‌سازی خواهیم کرد. این ساختار داده جدید را <em>Worker</em> می‌نامیم که یک اصطلاح رایج در پیاده‌سازی‌های Pool است. Worker کدی را که باید اجرا شود دریافت می‌کند و آن را در Thread مربوط به Worker اجرا می‌کند. می‌توانید به افرادی که در آشپزخانه یک رستوران کار می‌کنند فکر کنید: Workerها منتظر می‌مانند تا سفارش‌هایی از مشتریان دریافت کنند، و سپس مسئول گرفتن این سفارش‌ها و انجام آن‌ها هستند.</p>
<p>به جای ذخیره یک بردار از نمونه‌های <code>JoinHandle&lt;()&gt;</code> در Thread Pool، ما نمونه‌هایی از ساختار <code>Worker</code> را ذخیره خواهیم کرد. هر <code>Worker</code> یک نمونه <code>JoinHandle&lt;()&gt;</code> را نگه می‌دارد. سپس یک متد روی <code>Worker</code> پیاده‌سازی خواهیم کرد که یک Closure از کد برای اجرا بگیرد و آن را به Thread در حال اجرای Worker برای اجرا ارسال کند. همچنین به هر Worker یک <code>id</code> اختصاص می‌دهیم تا هنگام ثبت لاگ یا اشکال‌زدایی بتوانیم بین Workerهای مختلف در Pool تمایز قائل شویم.</p>
<p>این فرآیند جدیدی است که هنگام ایجاد یک <code>ThreadPool</code> اتفاق می‌افتد. کدی که Closure را به Thread ارسال می‌کند، پس از تنظیم <code>Worker</code> به این شکل پیاده‌سازی خواهد شد:</p>
<ol>
<li>تعریف یک ساختار <code>Worker</code> که یک <code>id</code> و یک <code>JoinHandle&lt;()&gt;</code> نگه می‌دارد.</li>
<li>تغییر <code>ThreadPool</code> به طوری که یک بردار از نمونه‌های <code>Worker</code> را ذخیره کند.</li>
<li>تعریف یک تابع <code>Worker::new</code> که یک عدد <code>id</code> می‌گیرد و یک نمونه <code>Worker</code> بازمی‌گرداند که شامل <code>id</code> و یک Thread ایجادشده با یک Closure خالی است.</li>
<li>در <code>ThreadPool::new</code>، از شمارنده حلقه <code>for</code> برای تولید یک <code>id</code> استفاده کرده، یک <code>Worker</code> جدید با آن <code>id</code> ایجاد کرده و Worker را در بردار ذخیره می‌کنیم.</li>
</ol>
<p>اگر آماده یک چالش هستید، سعی کنید این تغییرات را خودتان پیاده‌سازی کنید قبل از اینکه به کد موجود در لیست ۲۱-۱۵ نگاه کنید.</p>
<p>آماده‌اید؟ در اینجا لیست ۲۱-۱۵ با یک روش برای انجام اصلاحات قبلی آورده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<figcaption>Listing 21-15: تغییر <code>ThreadPool</code> برای نگهداری نمونه‌های <code>Worker</code> به جای نگهداری مستقیم Threadها</figcaption>
</figure>
<p>ما نام فیلد موجود در <code>ThreadPool</code> را از <code>threads</code> به <code>workers</code> تغییر داده‌ایم زیرا اکنون نمونه‌های <code>Worker</code> را نگه می‌دارد، نه نمونه‌های <code>JoinHandle&lt;()&gt;</code>. از شمارنده حلقه <code>for</code> به عنوان آرگومان برای <code>Worker::new</code> استفاده می‌کنیم و هر <code>Worker</code> جدید را در بردار به نام <code>workers</code> ذخیره می‌کنیم.</p>
<p>کد خارجی (مانند سرور ما در <em>src/main.rs</em>) نیازی ندارد جزئیات پیاده‌سازی مربوط به استفاده از ساختار <code>Worker</code> در داخل <code>ThreadPool</code> را بداند، بنابراین ساختار <code>Worker</code> و تابع <code>new</code> آن را خصوصی می‌کنیم. تابع <code>Worker::new</code> از <code>id</code> داده‌شده استفاده کرده و یک نمونه <code>JoinHandle&lt;()&gt;</code> ایجاد می‌کند که با ایجاد یک Thread جدید با یک Closure خالی تولید می‌شود.</p>
<blockquote>
<p>نکته: اگر سیستم‌عامل نتواند به دلیل کمبود منابع سیستم، یک Thread ایجاد کند، <code>thread::spawn</code> به وحشت خواهد افتاد (<em>panic</em>). این باعث می‌شود کل سرور ما به وحشت بیفتد، حتی اگر ایجاد برخی Threadها موفق باشد. برای سادگی، این رفتار مشکلی ندارد، اما در یک پیاده‌سازی تولیدی برای Thread Pool، احتمالاً از <a href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> و متد <a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> که یک <code>Result</code> بازمی‌گرداند، استفاده می‌کنید.</p>
</blockquote>
<p>این کد کامپایل خواهد شد و تعداد نمونه‌های <code>Worker</code> را که به عنوان آرگومان به <code>ThreadPool::new</code> مشخص کرده‌ایم ذخیره می‌کند. اما ما <em>هنوز</em> Closureی که در <code>execute</code> دریافت می‌کنیم را پردازش نمی‌کنیم. بیایید بررسی کنیم چگونه این کار را انجام دهیم.</p>
<h4 id="ارسال-درخواستها-به-threadها-از-طریق-channelها"><a class="header" href="#ارسال-درخواستها-به-threadها-از-طریق-channelها">ارسال درخواست‌ها به Threadها از طریق Channelها</a></h4>
<p>مشکل بعدی که به آن می‌پردازیم این است که Closureهایی که به <code>thread::spawn</code> داده شده‌اند، هیچ کاری انجام نمی‌دهند. در حال حاضر، Closureی که می‌خواهیم اجرا کنیم را در متد <code>execute</code> دریافت می‌کنیم. اما نیاز داریم که یک Closure به <code>thread::spawn</code> بدهیم تا در هنگام ایجاد هر <code>Worker</code> در حین ایجاد <code>ThreadPool</code> اجرا شود.</p>
<p>می‌خواهیم ساختارهای <code>Worker</code> که به تازگی ایجاد کرده‌ایم، کدی را که باید اجرا شود از یک صف که در <code>ThreadPool</code> نگهداری می‌شود دریافت کرده و آن کد را به Thread خود برای اجرا ارسال کنند.</p>
<p>Channelهایی که در فصل ۱۶ یاد گرفتیم—راهی ساده برای ارتباط بین دو Thread—برای این مورد استفاده مناسب هستند. ما از یک Channel به عنوان صف کارها استفاده خواهیم کرد و <code>execute</code> یک کار را از <code>ThreadPool</code> به نمونه‌های <code>Worker</code> ارسال می‌کند، که این کار را به Thread خود ارسال می‌کنند. برنامه به شرح زیر خواهد بود:</p>
<ol>
<li><code>ThreadPool</code> یک Channel ایجاد کرده و نگهدارنده sender آن خواهد بود.</li>
<li>هر <code>Worker</code> نگهدارنده receiver خواهد بود.</li>
<li>یک ساختار <code>Job</code> جدید ایجاد خواهیم کرد که Closureهایی که می‌خواهیم از طریق Channel ارسال کنیم را نگه می‌دارد.</li>
<li>متد <code>execute</code> کاری که می‌خواهد اجرا کند را از طریق sender ارسال خواهد کرد.</li>
<li>در Thread خود، <code>Worker</code> بر receiver خود حلقه زده و Closureهای هر کاری که دریافت می‌کند را اجرا خواهد کرد.</li>
</ol>
<p>بیایید با ایجاد یک Channel در <code>ThreadPool::new</code> و نگهداری sender در نمونه <code>ThreadPool</code> شروع کنیم، همان‌طور که در لیست ۲۱-۱۶ نشان داده شده است. ساختار <code>Job</code> در حال حاضر چیزی نگه نمی‌دارد، اما نوع آیتمی خواهد بود که از طریق Channel ارسال می‌کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-16: تغییر <code>ThreadPool</code> برای ذخیره sender یک Channel که نمونه‌های <code>Job</code> را منتقل می‌کند</figcaption>
</figure>
<p>در <code>ThreadPool::new</code>، یک Channel جدید ایجاد می‌کنیم و Pool نگهدارنده sender خواهد بود. این کد با موفقیت کامپایل می‌شود.</p>
<p>بیایید تلاش کنیم یک receiver از Channel را به هر Worker در هنگام ایجاد Channel توسط Thread Pool ارسال کنیم. می‌دانیم که می‌خواهیم receiver را در Threadی که Workerها ایجاد می‌کنند استفاده کنیم، بنابراین به پارامتر <code>receiver</code> در Closure ارجاع می‌دهیم. کد موجود در لیست ۲۱-۱۷ هنوز کاملاً کامپایل نخواهد شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption>Listing 21-17: ارسال receiver به Workerها</figcaption>
</figure>
<p>ما تغییرات کوچک و واضحی ایجاد کرده‌ایم: receiver را به <code>Worker::new</code> ارسال کرده‌ایم و سپس از آن در داخل Closure استفاده کرده‌ایم.</p>
<p>هنگامی که تلاش می‌کنیم این کد را بررسی کنیم، با این خطا مواجه می‌شویم:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>کد در تلاش است <code>receiver</code> را به چندین نمونه <code>Worker</code> منتقل کند. این کار امکان‌پذیر نیست، همان‌طور که در فصل ۱۶ بحث شد: پیاده‌سازی کانال (channel) که Rust ارائه می‌دهد، از نوع چند تولیدکننده (<em>multiple producer</em>) و یک مصرف‌کننده (<em>single consumer</em>) است. این به این معنی است که نمی‌توانیم به سادگی بخش مصرف‌کننده کانال را برای رفع این کد کپی کنیم. همچنین نمی‌خواهیم یک پیام را چندین بار به چند مصرف‌کننده ارسال کنیم؛ بلکه می‌خواهیم یک لیست از پیام‌ها داشته باشیم که چندین Worker آن را پردازش کنند به‌گونه‌ای که هر پیام فقط یک بار پردازش شود.</p>
<p>علاوه بر این، برداشتن یک کار از صف کانال شامل تغییر <code>receiver</code> می‌شود، بنابراین Threadها به یک روش امن برای اشتراک و تغییر <code>receiver</code> نیاز دارند؛ در غیر این صورت، ممکن است با شرایط رقابتی (<em>race conditions</em>) مواجه شویم (همان‌طور که در فصل ۱۶ توضیح داده شد).</p>
<p>با یادآوری اشاره‌گر (Pointer)های هوشمند ایمن برای Threadها که در فصل ۱۶ معرفی شدند: برای اشتراک مالکیت میان چندین Thread و اجازه تغییر مقدار، نیاز به استفاده از <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> داریم. نوع <code>Arc</code> به چندین Worker اجازه می‌دهد مالکیت <code>receiver</code> را به اشتراک بگذارند و <code>Mutex</code> تضمین می‌کند که فقط یک Worker در هر لحظه یک کار را از <code>receiver</code> دریافت کند. لیست ۲۱-۱۸ تغییراتی را که باید اعمال کنیم نشان می‌دهد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<figcaption>Listing 21-18: اشتراک‌گذاری <code>receiver</code> بین Workerها با استفاده از <code>Arc</code> و <code>Mutex</code></figcaption>
</figure>
<p>در <code>ThreadPool::new</code>، <code>receiver</code> را در یک <code>Arc</code> و یک <code>Mutex</code> قرار می‌دهیم. برای هر Worker جدید، <code>Arc</code> را کپی می‌کنیم تا شمارنده مرجع افزایش یابد و Workerها بتوانند مالکیت <code>receiver</code> را به اشتراک بگذارند.</p>
<p>با این تغییرات، کد کامپایل می‌شود! به نتیجه نزدیک‌تر می‌شویم!</p>
<h4 id="پیادهسازی-متد-execute"><a class="header" href="#پیادهسازی-متد-execute">پیاده‌سازی متد <code>execute</code></a></h4>
<p>در نهایت، بیایید متد <code>execute</code> را روی <code>ThreadPool</code> پیاده‌سازی کنیم. همچنین <code>Job</code> را از یک ساختار به یک نام مستعار نوع (<em>type alias</em>) برای یک شیء ویژگی تغییر خواهیم داد که نوع Closureی که <code>execute</code> دریافت می‌کند را نگه می‌دارد. همان‌طور که در بخش <a href="ch20-03-advanced-types.html#creating-type-synonyms-with-type-aliases">“ایجاد مترادف‌های نوع با نام مستعار”</a><!-- ignore --> از فصل ۲۰ بحث شد، نام‌های مستعار نوع به ما امکان می‌دهند تایپ‌های طولانی را برای استفاده آسان‌تر کوتاه کنیم. به لیست ۲۱-۱۹ نگاه کنید.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-19: ایجاد یک نام مستعار <code>Job</code> برای یک <code>Box</code> که هر Closure را نگه می‌دارد و سپس ارسال کار از طریق کانال</figcaption>
</figure>
<p>پس از ایجاد یک نمونه جدید <code>Job</code> با استفاده از Closureی که در <code>execute</code> دریافت می‌کنیم، آن کار را از طریق بخش ارسال‌کننده کانال ارسال می‌کنیم. ما برای حالتی که ارسال شکست بخورد، روی <code>send</code> از <code>unwrap</code> استفاده می‌کنیم. این حالت ممکن است رخ دهد، اگر مثلاً همه Threadهای ما از اجرا متوقف شوند، به این معنی که بخش دریافت‌کننده دیگر پیام‌های جدید را دریافت نمی‌کند. در حال حاضر، نمی‌توانیم Threadهای خود را از اجرا متوقف کنیم: Threadهای ما تا زمانی که Pool وجود دارد اجرا می‌شوند. دلیل استفاده از <code>unwrap</code> این است که می‌دانیم حالت شکست رخ نخواهد داد، اما کامپایلر این موضوع را نمی‌داند.</p>
<p>اما هنوز کاملاً کار تمام نشده است! در Worker، Closureی که به <code>thread::spawn</code> ارسال می‌شود همچنان فقط به بخش دریافت‌کننده کانال <em>اشاره می‌کند</em>. در عوض، باید Closure به طور مداوم حلقه بزند، از بخش دریافت‌کننده کانال درخواست یک کار کند و کار را هنگام دریافت اجرا کند. بیایید تغییرات نشان داده‌شده در لیست ۲۱-۲۰ را به <code>Worker::new</code> اعمال کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption>Listing 21-20: دریافت و اجرای کارها در Thread مربوط به Worker</figcaption>
</figure>
<p>در اینجا، ابتدا <code>lock</code> را روی <code>receiver</code> فراخوانی می‌کنیم تا mutex را به دست آوریم، و سپس <code>unwrap</code> را فراخوانی می‌کنیم تا در صورت بروز هرگونه خطا، برنامه متوقف شود. به دست آوردن یک قفل ممکن است شکست بخورد اگر mutex در یک وضعیت <em>poisoned</em> باشد، که ممکن است اتفاق بیفتد اگر یک Thread دیگر در حالی که قفل را نگه داشته است به جای آزاد کردن آن متوقف شده باشد. در این شرایط، فراخوانی <code>unwrap</code> برای متوقف کردن این Thread اقدام درستی است. می‌توانید این <code>unwrap</code> را به یک <code>expect</code> با یک پیام خطای معنادار برای خود تغییر دهید.</p>
<p>اگر قفل روی mutex را به دست آوریم، <code>recv</code> را فراخوانی می‌کنیم تا یک <code>Job</code> را از کانال دریافت کنیم. یک <code>unwrap</code> نهایی نیز در اینجا هر گونه خطا را برطرف می‌کند، که ممکن است رخ دهد اگر Threadی که sender را نگه داشته است خاموش شود، مشابه نحوه‌ای که متد <code>send</code> در صورت خاموش شدن receiver یک <code>Err</code> بازمی‌گرداند.</p>
<p>فراخوانی <code>recv</code> مسدود می‌شود، بنابراین اگر هنوز هیچ کاری وجود نداشته باشد، Thread فعلی منتظر می‌ماند تا یک کار در دسترس قرار گیرد. <code>Mutex&lt;T&gt;</code> تضمین می‌کند که در هر لحظه فقط یک Thread <code>Worker</code> در تلاش برای درخواست یک کار است.</p>
<p>Thread Pool ما اکنون در وضعیت کاری قرار دارد! دستور <code>cargo run</code> را اجرا کنید و چندین درخواست ارسال کنید:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>موفقیت! اکنون یک Thread Pool داریم که اتصالات را به صورت همزمان اجرا می‌کند. هرگز بیش از چهار Thread ایجاد نمی‌شود، بنابراین اگر سرور درخواست‌های زیادی دریافت کند، سیستم ما بارگذاری بیش از حد نخواهد شد. اگر یک درخواست به <em>/sleep</em> ارسال کنیم، سرور می‌تواند با استفاده از یک Thread دیگر به سایر درخواست‌ها پاسخ دهد.</p>
<blockquote>
<p>نکته: اگر <em>/sleep</em> را به طور همزمان در چندین پنجره مرورگر باز کنید، ممکن است یکی پس از دیگری در فواصل ۵ ثانیه‌ای بارگذاری شوند. برخی مرورگرهای وب به دلایل مربوط به کش، چندین نمونه از همان درخواست را به صورت متوالی اجرا می‌کنند. این محدودیت توسط وب سرور ما ایجاد نشده است.</p>
</blockquote>
<p>این زمان خوبی است که مکث کنیم و بررسی کنیم چگونه کدهای لیست‌های ۲۱-۱۸، ۲۱-۱۹ و ۲۱-۲۰ اگر به جای Closure از futures برای انجام کار استفاده می‌کردیم، متفاوت می‌بود. چه نوع‌هایی تغییر می‌کردند؟ آیا امضاهای متدها تغییر می‌کردند؟ کدام بخش‌های کد همان‌گونه باقی می‌ماندند؟</p>
<p>پس از یادگیری حلقه <code>while let</code> در فصل‌های ۱۷ و ۱۸، ممکن است تعجب کنید چرا کد Thread Worker را مانند لیست ۲۱-۲۱ ننوشتیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption>Listing 21-21: یک پیاده‌سازی جایگزین برای <code>Worker::new</code> با استفاده از <code>while let</code></figcaption>
</figure>
<p>این کد کامپایل می‌شود و اجرا می‌شود، اما منجر به رفتار مورد نظر برای threading نمی‌شود: یک درخواست کند همچنان باعث می‌شود سایر درخواست‌ها برای پردازش منتظر بمانند. دلیل آن کمی ظریف است: ساختار <code>Mutex</code> متد عمومی <code>unlock</code> ندارد، زیرا مالکیت قفل بر اساس طول عمر <code>MutexGuard&lt;T&gt;</code> درون <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> که متد <code>lock</code> بازمی‌گرداند است. در زمان کامپایل، بررسی‌کننده وام می‌تواند این قانون را اعمال کند که منبعی که توسط یک <code>Mutex</code> محافظت می‌شود نمی‌تواند دسترسی پیدا کند مگر اینکه قفل را نگه داشته باشیم. با این حال، این پیاده‌سازی همچنین می‌تواند منجر به نگه‌داشتن قفل بیش از حد انتظار شود اگر به طول عمر <code>MutexGuard&lt;T&gt;</code> توجه نکنیم.</p>
<p>کد موجود در لیست ۲۱-۲۰ که از <code>let job = receiver.lock().unwrap().recv().unwrap();</code> استفاده می‌کند کار می‌کند زیرا با <code>let</code>، هر مقدار موقتی استفاده‌شده در عبارت سمت راست علامت برابر بلافاصله پس از پایان دستور <code>let</code> حذف می‌شود. با این حال، <code>while let</code> (و همچنین <code>if let</code> و <code>match</code>) مقادیر موقتی را تا پایان بلوک مرتبط حذف نمی‌کند. در لیست ۲۱-۲۱، قفل در طول فراخوانی به <code>job()</code> نگه داشته می‌شود، به این معنی که سایر Workerها نمی‌توانند کار دریافت کنند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="خاموشی-و-پاکسازی-منظم"><a class="header" href="#خاموشی-و-پاکسازی-منظم">خاموشی و پاک‌سازی منظم</a></h2>
<p>کدی که در لیستینگ 21-20 وجود دارد، همان‌طور که انتظار داشتیم، با استفاده از یک مجموعه نخ (thread pool) به درخواست‌ها به صورت غیرهمزمان پاسخ می‌دهد. ما هشدارهایی در مورد فیلدهای <code>workers</code>، <code>id</code> و <code>thread</code> دریافت می‌کنیم که به طور مستقیم از آن‌ها استفاده نمی‌کنیم و به ما یادآوری می‌کنند که هیچ چیزی را پاک‌سازی نمی‌کنیم. وقتی از روش کم‌ظرافت <kbd>ctrl</kbd>-<kbd>c</kbd> برای متوقف کردن نخ اصلی استفاده می‌کنیم، تمام نخ‌های دیگر نیز بلافاصله متوقف می‌شوند، حتی اگر در میانه ارائه یک درخواست باشند.</p>
<p>سپس، ما <code>Drop</code> trait را پیاده‌سازی خواهیم کرد تا <code>join</code> را روی هر یک از نخ‌های موجود در مجموعه نخ فراخوانی کنیم تا بتوانند درخواست‌هایی که در حال کار روی آن‌ها هستند را قبل از بسته‌شدن تکمیل کنند. سپس روشی برای اطلاع به نخ‌ها که نباید درخواست‌های جدید بپذیرند و باید خاموش شوند، پیاده‌سازی خواهیم کرد. برای مشاهده عملکرد این کد، سرور خود را تغییر می‌دهیم تا فقط دو درخواست را قبل از خاموشی منظم مجموعه نخ‌ها بپذیرد.</p>
<p>چیزی که باید توجه داشته باشید این است که هیچ‌کدام از این موارد بخش‌هایی از کد را که مدیریت اجرای closureها را بر عهده دارند، تحت تأثیر قرار نمی‌دهند، بنابراین همه چیز در اینجا همان‌طور باقی می‌ماند اگر از یک مجموعه نخ برای یک runtime غیرهمزمان استفاده می‌کردیم.</p>
<h3 id="پیادهسازی-drop-trait-روی-threadpool"><a class="header" href="#پیادهسازی-drop-trait-روی-threadpool">پیاده‌سازی <code>Drop</code> Trait روی <code>ThreadPool</code></a></h3>
<p>بیایید با پیاده‌سازی <code>Drop</code> روی مجموعه نخ شروع کنیم. وقتی مجموعه نخ حذف می‌شود، تمام نخ‌های ما باید به یکدیگر ملحق شوند تا مطمئن شویم کار خود را تکمیل می‌کنند. لیستینگ 21-22 اولین تلاش برای پیاده‌سازی <code>Drop</code> را نشان می‌دهد؛ این کد هنوز به درستی کار نخواهد کرد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-22: ملحق کردن هر نخ وقتی مجموعه نخ از محدوده خارج می‌شود</figcaption>
</figure>
<p>ابتدا، ما از میان هر یک از <code>workers</code> موجود در مجموعه نخ حلقه می‌زنیم. ما برای این کار از <code>&amp;mut</code> استفاده می‌کنیم زیرا <code>self</code> یک ارجاع قابل تغییر است و ما همچنین نیاز داریم که بتوانیم <code>worker</code> را تغییر دهیم. برای هر <code>worker</code>، پیامی چاپ می‌کنیم که نشان می‌دهد این <code>worker</code> خاص در حال خاموش‌شدن است، و سپس <code>join</code> را روی نخ آن <code>worker</code> فراخوانی می‌کنیم. اگر فراخوانی <code>join</code> شکست بخورد، از <code>unwrap</code> استفاده می‌کنیم تا باعث panic شود و خاموشی غیرمنظم اتفاق بیفتد.</p>
<p>اینجا خطایی که هنگام کامپایل این کد دریافت می‌کنیم آمده است:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
    --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:1763:17
     |
1763 |     pub fn join(self) -&gt; Result&lt;T&gt; {
     |                 ^^^^

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>این خطا به ما می‌گوید که نمی‌توانیم <code>join</code> را فراخوانی کنیم زیرا فقط یک قرض قابل تغییر از هر <code>worker</code> داریم و <code>join</code> مالکیت آرگومان خود را می‌گیرد. برای حل این مشکل، باید نخ را از نمونه <code>Worker</code> که مالک <code>thread</code> است خارج کنیم تا <code>join</code> بتواند نخ را مصرف کند. یک راه برای انجام این کار استفاده از همان رویکردی است که در لیستینگ 18-15 استفاده کردیم. اگر <code>Worker</code> یک <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> نگه می‌داشت، می‌توانستیم با استفاده از متد <code>take</code> مقدار را از نوع <code>Some</code> به نوع <code>None</code> منتقل کنیم.</p>
<p>با این حال، تنها زمانی که این مسئله مطرح می‌شود زمانی است که <code>Worker</code> حذف می‌شود. در عوض، باید با یک <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> در همه جا سر و کار داشته باشیم. Rust ایدئوماتیک اغلب از <code>Option</code> استفاده می‌کند، اما زمانی که متوجه شوید چیزی را در <code>Option</code> قرار می‌دهید به عنوان یک راه‌حل موقت، حتی اگر بدانید آن مورد همیشه حضور دارد، ایده خوبی است که به دنبال روش‌های جایگزین باشید.</p>
<p>در این حالت، یک جایگزین بهتر استفاده از متد <code>Vec::drain</code> است. این متد یک پارامتر محدوده می‌گیرد تا مشخص کند کدام آیتم‌ها باید از <code>Vec</code> حذف شوند و یک تکرارگر از آن آیتم‌ها بازمی‌گرداند. استفاده از <code>..</code> برای محدوده تمام مقادیر را از <code>Vec</code> حذف خواهد کرد.</p>
<p>بنابراین باید پیاده‌سازی <code>drop</code> در <code>ThreadPool</code> را به این صورت به‌روزرسانی کنیم:</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>این تغییر خطای کامپایلر را برطرف می‌کند و نیازی به تغییرات دیگر در کد ما ندارد.</p>
<h3 id="علامتدهی-به-نخها-برای-توقف-گوش-دادن-به-وظایف"><a class="header" href="#علامتدهی-به-نخها-برای-توقف-گوش-دادن-به-وظایف">علامت‌دهی به نخ‌ها برای توقف گوش دادن به وظایف</a></h3>
<p>با تمام تغییراتی که اعمال کرده‌ایم، کد ما بدون هیچ هشداری کامپایل می‌شود. با این حال، خبر بد این است که این کد هنوز به درستی کار نمی‌کند. کلید مشکل در منطق موجود در closureهایی است که توسط نخ‌های نمونه‌های <code>Worker</code> اجرا می‌شوند: در حال حاضر، ما <code>join</code> را فراخوانی می‌کنیم، اما این کار نخ‌ها را خاموش نمی‌کند زیرا آن‌ها برای همیشه در جستجوی وظایف <code>loop</code> می‌زنند. اگر با پیاده‌سازی فعلی <code>drop</code>، <code>ThreadPool</code> خود را حذف کنیم، نخ اصلی برای همیشه منتظر می‌ماند تا اولین نخ تکمیل شود.</p>
<p>برای حل این مشکل، باید تغییری در پیاده‌سازی <code>drop</code> در <code>ThreadPool</code> و سپس تغییری در حلقه <code>Worker</code> ایجاد کنیم.</p>
<p>ابتدا، پیاده‌سازی <code>drop</code> در <code>ThreadPool</code> را تغییر می‌دهیم تا <code>sender</code> را قبل از منتظر ماندن برای تکمیل نخ‌ها به صورت صریح حذف کنیم. لیستینگ 21-23 تغییرات در <code>ThreadPool</code> برای حذف صریح <code>sender</code> را نشان می‌دهد. برخلاف <code>workers</code>، اینجا ما باید از یک <code>Option</code> استفاده کنیم تا بتوانیم <code>sender</code> را با <code>Option::take</code> از <code>ThreadPool</code> منتقل کنیم.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-23: حذف صریح <code>sender</code> قبل از ملحق کردن نخ‌های worker</figcaption>
</figure>
<p>حذف <code>sender</code> کانال را می‌بندد، که نشان می‌دهد دیگر هیچ پیامی ارسال نخواهد شد. وقتی این اتفاق می‌افتد، تمام فراخوانی‌های <code>recv</code> که workers در حلقه بی‌نهایت انجام می‌دهند یک خطا برمی‌گرداند. در لیستینگ 21-24، حلقه <code>Worker</code> را تغییر می‌دهیم تا در چنین حالتی به صورت منظم از حلقه خارج شود، که به این معناست که نخ‌ها وقتی پیاده‌سازی <code>drop</code> در <code>ThreadPool</code> روی آن‌ها <code>join</code> را فراخوانی می‌کند تکمیل خواهند شد.</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption>Listing 21-24: خروج صریح از حلقه وقتی <code>recv</code> یک خطا برمی‌گرداند</figcaption>
</figure>
<p>برای دیدن این کد در عمل، بیایید <code>main</code> را تغییر دهیم تا فقط دو درخواست را قبل از خاموش‌شدن منظم سرور بپذیرد، همان‌طور که در لیستینگ 21-25 نشان داده شده است.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 21-25: خاموش‌کردن سرور پس از ارائه دو درخواست با خروج از حلقه</figcaption>
</figure>
<p>شما نمی‌خواهید یک سرور وب واقعی پس از فقط دو درخواست خاموش شود. این کد فقط نشان می‌دهد که خاموشی منظم و پاک‌سازی به درستی کار می‌کند.</p>
<p>متد <code>take</code> که در trait <code>Iterator</code> تعریف شده است، تکرار را به حداکثر دو آیتم محدود می‌کند. <code>ThreadPool</code> در انتهای <code>main</code> از محدوده خارج می‌شود و پیاده‌سازی <code>drop</code> اجرا خواهد شد.</p>
<p>سرور را با دستور <code>cargo run</code> راه‌اندازی کنید و سه درخواست ارسال کنید. درخواست سوم باید با خطا مواجه شود و در ترمینال خود باید خروجی مشابه زیر را ببینید:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>ممکن است ترتیب متفاوتی از کارگران و پیام‌های چاپ‌شده را مشاهده کنید. از پیام‌ها می‌توان فهمید که این کد چگونه کار می‌کند: کارگران 0 و 3 اولین دو درخواست را دریافت کردند. سرور پس از اتصال دوم دیگر اتصال‌ها را نمی‌پذیرد و پیاده‌سازی <code>Drop</code> روی <code>ThreadPool</code> شروع به اجرا می‌کند قبل از اینکه کارگر 3 حتی کار خود را شروع کند. حذف <code>sender</code> تمام کارگران را قطع کرده و به آن‌ها می‌گوید که خاموش شوند. هر کارگر هنگام قطع شدن یک پیام چاپ می‌کند و سپس مجموعه نخ (thread pool) <code>join</code> را فراخوانی می‌کند تا منتظر تکمیل هر نخ کارگر بماند.</p>
<p>به یک جنبه جالب از این اجرای خاص توجه کنید: <code>ThreadPool</code> فرستنده را حذف کرد، و قبل از اینکه هر کارگری خطایی دریافت کند، ما سعی کردیم به کارگر 0 ملحق شویم. کارگر 0 هنوز از <code>recv</code> خطایی دریافت نکرده بود، بنابراین نخ اصلی منتظر ماند تا کارگر 0 کار خود را به پایان برساند. در همین حال، کارگر 3 یک کار دریافت کرد و سپس تمام نخ‌ها خطا دریافت کردند. وقتی کارگر 0 تمام شد، نخ اصلی منتظر ماند تا بقیه کارگران کار خود را تمام کنند. در آن زمان، همه آن‌ها از حلقه‌های خود خارج شده و متوقف شده بودند.</p>
<p>تبریک می‌گویم! پروژه خود را کامل کردید؛ ما یک سرور وب ساده داریم که از یک مجموعه نخ برای پاسخ‌دهی غیرهمزمان استفاده می‌کند. ما توانستیم سرور را به صورت منظم خاموش کنیم و تمام نخ‌ها در مجموعه را پاک‌سازی کنیم.</p>
<p>در اینجا کد کامل برای مرجع آورده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</figure>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</figure>
<p>می‌توانستیم بیشتر اینجا انجام دهیم! اگر می‌خواهید این پروژه را بیشتر گسترش دهید، اینجا چند ایده آمده است:</p>
<ul>
<li>مستندات بیشتری به <code>ThreadPool</code> و متدهای عمومی آن اضافه کنید.</li>
<li>تست‌هایی برای عملکرد کتابخانه اضافه کنید.</li>
<li>فراخوانی‌های <code>unwrap</code> را به مدیریت خطای قوی‌تر تغییر دهید.</li>
<li>از <code>ThreadPool</code> برای انجام برخی کارها به غیر از ارائه درخواست‌های وب استفاده کنید.</li>
<li>یک crate مجموعه نخ از <a href="https://crates.io/">crates.io</a> پیدا کنید و یک سرور وب مشابه با استفاده از آن crate پیاده‌سازی کنید. سپس API و مقاومت آن را با مجموعه نخی که ما پیاده‌سازی کردیم مقایسه کنید.</li>
</ul>
<h2 id="خلاصه-19"><a class="header" href="#خلاصه-19">خلاصه</a></h2>
<p>آفرین! شما به انتهای این کتاب رسیدید! از شما بابت پیوستن به ما در این سفر با Rust سپاسگزاریم. اکنون آماده‌اید که پروژه‌های Rust خود را پیاده‌سازی کنید و به پروژه‌های دیگران کمک کنید. به یاد داشته باشید که جامعه‌ای خوش‌آمدگوی از Rustaceans وجود دارد که مشتاقانه منتظر کمک به شما در هر چالشی هستند که در مسیر Rust خود با آن مواجه می‌شوید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ضمیمه"><a class="header" href="#ضمیمه">ضمیمه</a></h1>
<p>بخش‌های زیر حاوی مطالب مرجعی هستند که ممکن است در مسیر یادگیری Rust برای شما مفید باشند.</p>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-الف-کلمات-کلیدی"><a class="header" href="#ضمیمه-الف-کلمات-کلیدی">ضمیمه الف: کلمات کلیدی</a></h2>
<p>لیست زیر شامل کلمات کلیدی است که برای استفاده فعلی یا آینده توسط زبان Rust رزرو شده‌اند. به همین دلیل، نمی‌توان از آن‌ها به عنوان شناسه استفاده کرد (مگر به عنوان شناسه خام، همان‌طور که در بخش “<a href="appendix-01-keywords.html#raw-identifiers">شناسه‌های خام</a>” توضیح داده خواهد شد). شناسه‌ها نام‌هایی هستند که برای توابع، متغیرها، پارامترها، فیلدهای ساختار، ماژول‌ها، جعبه‌ها (crates)، ثابت‌ها، ماکروها، مقادیر استاتیک، ویژگی‌ها، انواع، ویژگی‌ها، یا طول عمرها استفاده می‌شوند.</p>
<h3 id="کلمات-کلیدی-در-حال-استفاده"><a class="header" href="#کلمات-کلیدی-در-حال-استفاده">کلمات کلیدی در حال استفاده</a></h3>
<p>فهرست زیر شامل کلمات کلیدی است که در حال حاضر استفاده می‌شوند، همراه با توضیح عملکرد آن‌ها:</p>
<ul>
<li><code>as</code> - انجام تبدیل اولیه، مشخص کردن ویژگی خاص حاوی یک آیتم، یا تغییر نام آیتم‌ها در دستورات <code>use</code></li>
<li><code>async</code> - بازگرداندن یک <code>Future</code> به جای مسدود کردن Thread فعلی</li>
<li><code>await</code> - متوقف کردن اجرا تا زمانی که نتیجه یک <code>Future</code> آماده شود</li>
<li><code>break</code> - خروج فوری از یک حلقه</li>
<li><code>const</code> - تعریف آیتم‌های ثابت یا اشاره‌گرهای خام ثابت</li>
<li><code>continue</code> - ادامه به تکرار بعدی حلقه</li>
<li><code>crate</code> - در مسیر ماژول، به ریشه crate اشاره دارد</li>
<li><code>dyn</code> - توزیع داینامیک به یک شیء ویژگی</li>
<li><code>else</code> - حالت جایگزین برای سازه‌های جریان کنترلی <code>if</code> و <code>if let</code></li>
<li><code>enum</code> - تعریف یک شمارش</li>
<li><code>extern</code> - لینک کردن یک تابع یا متغیر خارجی</li>
<li><code>false</code> - مقدار بولی <code>false</code></li>
<li><code>fn</code> - تعریف یک تابع یا نوع اشاره‌گر تابع</li>
<li><code>for</code> - حلقه بر روی آیتم‌های یک iterator، پیاده‌سازی یک ویژگی، یا مشخص کردن طول عمر سطح بالاتر</li>
<li><code>if</code> - انشعاب بر اساس نتیجه یک عبارت شرطی</li>
<li><code>impl</code> - پیاده‌سازی قابلیت‌های ذاتی یا ویژگی</li>
<li><code>in</code> - بخشی از سینتکس حلقه <code>for</code></li>
<li><code>let</code> - متصل کردن یک متغیر</li>
<li><code>loop</code> - حلقه بدون شرط</li>
<li><code>match</code> - تطابق یک مقدار با الگوها</li>
<li><code>mod</code> - تعریف یک ماژول</li>
<li><code>move</code> - مالکیت متغیرهای گرفته‌شده توسط Closure را منتقل می‌کند</li>
<li><code>mut</code> - نشان دادن قابلیت تغییر در مراجع، اشاره‌گرهای خام، یا بایندینگ الگوها</li>
<li><code>pub</code> - نشان دادن قابلیت مشاهده عمومی در فیلدهای struct، بلوک‌های <code>impl</code>، یا ماژول‌ها</li>
<li><code>ref</code> - بایند کردن با مرجع</li>
<li><code>return</code> - بازگرداندن از تابع</li>
<li><code>Self</code> - یک نام مستعار برای نوعی که در حال تعریف یا پیاده‌سازی آن هستیم</li>
<li><code>self</code> - موضوع متد یا ماژول فعلی</li>
<li><code>static</code> - متغیر جهانی یا طول عمر طولانی تا زمان اجرای کامل برنامه</li>
<li><code>struct</code> - تعریف یک ساختار</li>
<li><code>super</code> - ماژول والد ماژول فعلی</li>
<li><code>trait</code> - تعریف یک ویژگی</li>
<li><code>true</code> - مقدار بولی <code>true</code></li>
<li><code>type</code> - تعریف یک نام مستعار نوع یا نوع وابسته</li>
<li><code>union</code> - تعریف یک <a href="../reference/items/unions.html">union</a><!-- ignore -->؛ فقط هنگام استفاده در یک اعلان union یک کلمه کلیدی است</li>
<li><code>unsafe</code> - نشان دادن کد، توابع، ویژگی‌ها یا پیاده‌سازی‌های ناامن</li>
<li><code>use</code> - آوردن نمادها به دامنه؛ مشخص کردن برداشت دقیق برای محدودیت‌های عمومی و طول عمر</li>
<li><code>where</code> - مشخص کردن بندهایی که یک نوع را محدود می‌کنند</li>
<li><code>while</code> - حلقه شرطی بر اساس نتیجه یک عبارت</li>
</ul>
<h3 id="کلمات-کلیدی-رزرو-شده-برای-استفاده-در-آینده"><a class="header" href="#کلمات-کلیدی-رزرو-شده-برای-استفاده-در-آینده">کلمات کلیدی رزرو شده برای استفاده در آینده</a></h3>
<p>کلمات کلیدی زیر هنوز هیچ کاربردی ندارند اما توسط Rust برای استفاده احتمالی در آینده رزرو شده‌اند:</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="شناسههای-خام"><a class="header" href="#شناسههای-خام">شناسه‌های خام</a></h3>
<p><em>شناسه‌های خام</em> سینتکسی هستند که به شما اجازه می‌دهند از کلمات کلیدی در جایی که معمولاً مجاز نیستند استفاده کنید. برای استفاده از یک شناسه خام، یک <code>r#</code> قبل از کلمه کلیدی اضافه کنید.</p>
<p>برای مثال، <code>match</code> یک کلمه کلیدی است. اگر بخواهید تابع زیر را که از <code>match</code> به عنوان نام خود استفاده می‌کند کامپایل کنید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>شما این خطا را دریافت خواهید کرد:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>این خطا نشان می‌دهد که نمی‌توانید از کلمه کلیدی <code>match</code> به عنوان شناسه تابع استفاده کنید. برای استفاده از <code>match</code> به عنوان نام تابع، باید از سینتکس شناسه خام به این شکل استفاده کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>این کد بدون هیچ خطایی کامپایل خواهد شد. به پیشوند <code>r#</code> روی نام تابع در تعریف آن و همچنین جایی که تابع در <code>main</code> فراخوانی می‌شود، توجه کنید.</p>
<p>شناسه‌های خام (<em>Raw identifiers</em>) به شما این امکان را می‌دهند که از هر کلمه‌ای که انتخاب می‌کنید به عنوان شناسه استفاده کنید، حتی اگر آن کلمه به‌طور معمول یک کلمه کلیدی رزرو‌شده باشد. این ویژگی آزادی بیشتری برای انتخاب نام شناسه‌ها فراهم می‌کند و همچنین امکان ادغام با برنامه‌هایی که به زبانی نوشته شده‌اند که این کلمات در آن زبان کلمات کلیدی نیستند، را می‌دهد. علاوه بر این، شناسه‌های خام به شما اجازه می‌دهند از کتابخانه‌هایی استفاده کنید که با نسخه‌ای از Rust نوشته شده‌اند که با نسخه مورد استفاده شما متفاوت است.</p>
<p>برای مثال، <code>try</code> در نسخه ۲۰۱۵ کلمه کلیدی نیست، اما در نسخه‌های ۲۰۱۸، ۲۰۲۱ و ۲۰۲۴ کلمه کلیدی است. اگر به کتابخانه‌ای وابسته باشید که با نسخه ۲۰۱۵ نوشته شده و یک تابع به نام <code>try</code> دارد، باید از سینتکس شناسه خام، یعنی <code>r#try</code>، برای فراخوانی آن تابع از کد نسخه ۲۰۱۸ خود استفاده کنید. برای اطلاعات بیشتر در مورد نسخه‌ها به <a href="appendix-05-editions.html">ضمیمه ه</a><!-- ignore --> مراجعه کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-ب-عملگرها-و-نمادها"><a class="header" href="#ضمیمه-ب-عملگرها-و-نمادها">ضمیمه ب: عملگرها و نمادها</a></h2>
<p>این ضمیمه شامل واژه‌نامه‌ای از سینتکس زبان Rust است، از جمله عملگرها و سایر نمادهایی که به تنهایی یا در زمینه مسیرها، جنریک‌ها، محدودیت‌های ویژگی، ماکروها، ویژگی‌ها، نظرات، تاپل‌ها و براکت‌ها ظاهر می‌شوند.</p>
<h3 id="عملگرها"><a class="header" href="#عملگرها">عملگرها</a></h3>
<p>جدول B-1 عملگرهای موجود در Rust، یک مثال از چگونگی ظاهر شدن عملگر در زمینه، توضیح کوتاه و اینکه آیا آن عملگر قابل اضافه‌بارگذاری است یا نه را نشان می‌دهد. اگر یک عملگر قابل اضافه‌بارگذاری باشد، ویژگی مرتبط برای اضافه‌بارگذاری آن عملگر ذکر شده است.</p>
<p><span class="caption">جدول B-1: عملگرها</span></p>
<div class="table-wrapper"><table><thead><tr><th>عملگر</th><th>مثال</th><th>توضیح</th><th>Overloadable؟</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>گسترش ماکرو</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>مکمل بیتی یا منطقی</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>مقایسه نابرابری</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>باقی‌مانده حسابی</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>باقی‌مانده حسابی و انتساب</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>ارجاع</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>نوع اشاره‌گر (Pointer) ارجاعی</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>AND بیتی</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>AND بیتی و انتساب</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>AND منطقی کوتاه</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>ضرب حسابی</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>ضرب حسابی و انتساب</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>رفع ارجاع</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>اشاره‌گر (Pointer) خام</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>محدودیت نوع ترکیبی</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>جمع حسابی</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>جمع حسابی و انتساب</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>جداکننده آرگومان و عنصر</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>نفی حسابی</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>تفریق حسابی</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>تفریق حسابی و انتساب</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|…| -&gt; type</code></td><td>نوع بازگشت تابع و closure</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>دسترسی به عضو</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>محدوده راست‌انحصاری</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>محدوده راست‌شامل</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>سینتکس به‌روزرسانی literal ساختار</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>الگوی “و بقیه”</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(منسوخ‌شده، از <code>..=</code> به جای آن استفاده کنید) محدوده شامل در الگو</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>تقسیم حسابی</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>تقسیم حسابی و انتساب</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>محدودیت‌ها</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>مقداردهی اولیه فیلد ساختار</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>برچسب حلقه</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>پایان‌دهنده عبارت و آیتم</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>بخشی از سینتکس آرایه با اندازه ثابت</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>شیفت به چپ</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>شیفت به چپ و انتساب</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>مقایسه کوچکتر</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>مقایسه کوچکتر یا مساوی</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>انتساب/برابری</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>مقایسه برابری</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>بخشی از سینتکس بازوی match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>مقایسه بزرگتر</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>مقایسه بزرگتر یا مساوی</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>شیفت به راست</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>شیفت به راست و انتساب</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>بایند الگو</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>XOR بیتی</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>XOR بیتی و انتساب</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>جایگزین‌های الگو</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>OR بیتی</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>OR بیتی و انتساب</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>OR منطقی کوتاه</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>انتشار خطا</td><td></td></tr>
</tbody></table>
</div>
<h3 id="نمادهای-غیرعملگری"><a class="header" href="#نمادهای-غیرعملگری">نمادهای غیرعملگری</a></h3>
<p>لیست زیر شامل تمام نمادهایی است که به عنوان عملگر عمل نمی‌کنند؛ یعنی مانند یک تابع یا فراخوانی متد رفتار نمی‌کنند.</p>
<p>جدول B-2 نمادهایی را نشان می‌دهد که به تنهایی ظاهر می‌شوند و در مکان‌های مختلف معتبر هستند.</p>
<p><span class="caption">جدول B-2: سینتکس مستقل</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>طول عمر نام‌گذاری‌شده یا برچسب حلقه</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>لیترال عددی با نوع مشخص</td></tr>
<tr><td><code>"..."</code></td><td>لیترال رشته</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>, etc.</td><td>لیترال رشته خام، کاراکترهای escape پردازش نمی‌شوند</td></tr>
<tr><td><code>b"..."</code></td><td>لیترال رشته بایتی؛ آرایه‌ای از بایت‌ها به جای رشته می‌سازد</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>لیترال رشته خام بایتی، ترکیبی از رشته خام و رشته بایتی</td></tr>
<tr><td><code>'...'</code></td><td>لیترال کاراکتر</td></tr>
<tr><td><code>b'...'</code></td><td>لیترال بایت ASCII</td></tr>
<tr><td><code>|…| expr</code></td><td>closure</td></tr>
<tr><td><code>!</code></td><td>همیشه خالی، نوع bottom برای توابع واگرا</td></tr>
<tr><td><code>_</code></td><td>بایند الگوی “نادیده‌گرفته‌شده”؛ همچنین برای خواناتر کردن لیترال‌های عددی استفاده می‌شود</td></tr>
</tbody></table>
</div>
<p>جدول B-3 نمادهایی را نشان می‌دهد که در زمینه مسیریابی از سلسله‌مراتب ماژول به یک آیتم ظاهر می‌شوند.</p>
<p><span class="caption">جدول B-3: سینتکس مرتبط با مسیر</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>مسیر فضای نام</td></tr>
<tr><td><code>::path</code></td><td>مسیر نسبی به پیش‌لود خارجی، جایی که تمام جعبه‌ها (crates)ی دیگر ریشه دارند (یعنی یک مسیر مطلق که به وضوح شامل نام جعبه (crate) است)</td></tr>
<tr><td><code>self::path</code></td><td>مسیر نسبی به ماژول جاری (یعنی یک مسیر نسبی به وضوح مشخص‌شده).</td></tr>
<tr><td><code>super::path</code></td><td>مسیر نسبی به والد ماژول جاری</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>ثابت‌ها، توابع، و انواع مرتبط</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>آیتم مرتبط برای نوعی که نمی‌توان به طور مستقیم آن را نام‌گذاری کرد (مثلاً <code>&lt;&amp;T&gt;::...</code>، <code>&lt;[T]&gt;::...</code>، و غیره)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>مشخص کردن فراخوانی متد با نام‌گذاری ویژگی‌ای که آن را تعریف کرده است</td></tr>
<tr><td><code>type::method(...)</code></td><td>مشخص کردن فراخوانی متد با نام‌گذاری نوعی که برای آن تعریف شده است</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>مشخص کردن فراخوانی متد با نام‌گذاری ویژگی و نوع</td></tr>
</tbody></table>
</div>
<p>جدول B-4 نمادهایی را نشان می‌دهد که در زمینه استفاده از پارامترهای نوع جنریک ظاهر می‌شوند.</p>
<p><span class="caption">جدول B-4: جنریک‌ها</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>مشخص کردن پارامترها برای نوع جنریک در یک نوع (مثلاً <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>مشخص کردن پارامترها برای نوع جنریک، تابع، یا متد در یک عبارت؛ که معمولاً به آن turbofish می‌گویند (مثلاً <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>تعریف تابع جنریک</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>تعریف ساختار جنریک</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>تعریف شمارش جنریک</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>تعریف پیاده‌سازی جنریک</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>محدودیت طول عمر با رتبه بالاتر</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>نوع جنریک که یک یا چند نوع مرتبط با آن دارای مقادیر مشخصی هستند (مثلاً <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>جدول B-5 نمادهایی را نشان می‌دهد که در زمینه محدود کردن پارامترهای نوع جنریک با محدودیت‌های ویژگی ظاهر می‌شوند.</p>
<p><span class="caption">جدول B-5: محدودیت‌های ویژگی</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>پارامتر جنریک <code>T</code> محدود به انواع که <code>U</code> را پیاده‌سازی می‌کنند</td></tr>
<tr><td><code>T: 'a</code></td><td>نوع جنریک <code>T</code> باید طول عمر بیشتری از طول عمر <code>'a</code> داشته باشد (یعنی نوع نمی‌تواند به صورت گذرا شامل ارجاعاتی با طول عمر کوتاه‌تر از <code>'a</code> باشد)</td></tr>
<tr><td><code>T: 'static</code></td><td>نوع جنریک <code>T</code> شامل ارجاعات قرض‌گرفته‌شده‌ای به جز ارجاعات <code>'static</code> نیست</td></tr>
<tr><td><code>'b: 'a</code></td><td>طول عمر جنریک <code>'b</code> باید طول عمر بیشتری از طول عمر <code>'a</code> داشته باشد</td></tr>
<tr><td><code>T: ?Sized</code></td><td>اجازه دادن به پارامتر نوع جنریک برای اینکه نوعی با اندازه پویا باشد</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>محدودیت نوع ترکیبی</td></tr>
</tbody></table>
</div>
<p><span class="caption">جدول B-6: ماکروها و ویژگی‌ها</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>ویژگی خارجی</td></tr>
<tr><td><code>#![meta]</code></td><td>ویژگی داخلی</td></tr>
<tr><td><code>$ident</code></td><td>جایگزینی ماکرو</td></tr>
<tr><td><code>$ident:kind</code></td><td>گرفتن ماکرو</td></tr>
<tr><td><code>$(…)…</code></td><td>تکرار ماکرو</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>فراخوانی ماکرو</td></tr>
</tbody></table>
</div>
<p><span class="caption">جدول B-7: نظرات</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>نظر تک‌خطی</td></tr>
<tr><td><code>//!</code></td><td>نظر مستند داخلی تک‌خطی</td></tr>
<tr><td><code>///</code></td><td>نظر مستند خارجی تک‌خطی</td></tr>
<tr><td><code>/*...*/</code></td><td>نظر بلوکی</td></tr>
<tr><td><code>/*!...*/</code></td><td>نظر مستند داخلی بلوکی</td></tr>
<tr><td><code>/**...*/</code></td><td>نظر مستند خارجی بلوکی</td></tr>
</tbody></table>
</div>
<p><span class="caption">جدول B-8: تاپل‌ها</span></p>
<div class="table-wrapper"><table><thead><tr><th>نماد</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>تاپل خالی (معروف به واحد)، هم به عنوان لیترال و هم نوع</td></tr>
<tr><td><code>(expr)</code></td><td>عبارت پرانتزدار</td></tr>
<tr><td><code>(expr,)</code></td><td>عبارت تاپل تک‌عنصری</td></tr>
<tr><td><code>(type,)</code></td><td>نوع تاپل تک‌عنصری</td></tr>
<tr><td><code>(expr, ...)</code></td><td>عبارت تاپل</td></tr>
<tr><td><code>(type, ...)</code></td><td>نوع تاپل</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>عبارت فراخوانی تابع؛ همچنین برای مقداردهی اولیه به <code>struct</code>‌های تاپلی و واریانت‌های <code>enum</code> تاپلی استفاده می‌شود</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>اندیس‌گذاری تاپل</td></tr>
</tbody></table>
</div>
<p><span class="caption">جدول B-9: کروشه‌ها</span></p>
<div class="table-wrapper"><table><thead><tr><th>زمینه</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>عبارت بلوک</td></tr>
<tr><td><code>Type {...}</code></td><td>لیترال <code>struct</code></td></tr>
</tbody></table>
</div>
<p><span class="caption">جدول B-10: براکت‌ها</span></p>
<div class="table-wrapper"><table><thead><tr><th>زمینه</th><th>توضیح</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>لیترال آرایه</td></tr>
<tr><td><code>[expr; len]</code></td><td>لیترال آرایه که شامل <code>len</code> نسخه از <code>expr</code> است</td></tr>
<tr><td><code>[type; len]</code></td><td>نوع آرایه که شامل <code>len</code> نمونه از <code>type</code> است</td></tr>
<tr><td><code>expr[expr]</code></td><td>اندیس‌گذاری مجموعه. قابل اضافه‌بارگذاری (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>اندیس‌گذاری مجموعه که شبیه به برش مجموعه عمل می‌کند، با استفاده از <code>Range</code>، <code>RangeFrom</code>، <code>RangeTo</code>، یا <code>RangeFull</code> به عنوان “اندیس”</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-ج-ویژگیهای-قابل-اشتقاق"><a class="header" href="#ضمیمه-ج-ویژگیهای-قابل-اشتقاق">ضمیمه ج: ویژگی‌های قابل اشتقاق</a></h2>
<p>در بخش‌های مختلف کتاب، ما درباره ویژگی <code>derive</code> صحبت کردیم که می‌توانید آن را به تعریف یک struct یا enum اعمال کنید. ویژگی <code>derive</code> کدی تولید می‌کند که یک ویژگی را با پیاده‌سازی پیش‌فرض خود روی نوعی که با سینتکس <code>derive</code> حاشیه‌نویسی کرده‌اید، پیاده‌سازی می‌کند.</p>
<p>در این ضمیمه، مرجعی از تمام ویژگی‌های موجود در کتابخانه استاندارد که می‌توانید با <code>derive</code> استفاده کنید ارائه می‌شود. هر بخش شامل موارد زیر است:</p>
<ul>
<li>چه عملگرها و متدهایی با مشتق‌سازی این ویژگی فعال می‌شوند</li>
<li>پیاده‌سازی ویژگی که توسط <code>derive</code> ارائه می‌شود چه می‌کند</li>
<li>پیاده‌سازی ویژگی چه مفهومی درباره نوع دارد</li>
<li>شرایطی که در آن اجازه یا عدم اجازه پیاده‌سازی ویژگی داده می‌شود</li>
<li>مثال‌هایی از عملیات‌هایی که به این ویژگی نیاز دارند</li>
</ul>
<p>اگر رفتار متفاوتی از آنچه ویژگی <code>derive</code> ارائه می‌دهد می‌خواهید، به مستندات <a href="https://doc.rust-lang.org/std/index.html">کتابخانه استاندارد</a><!-- ignore --> برای هر ویژگی مراجعه کنید تا جزئیات مربوط به نحوه پیاده‌سازی دستی آن را بیابید.</p>
<p>این ویژگی‌هایی که در اینجا فهرست شده‌اند تنها ویژگی‌هایی هستند که توسط کتابخانه استاندارد تعریف شده‌اند و می‌توانند روی انواع شما با استفاده از <code>derive</code> پیاده‌سازی شوند. ویژگی‌های دیگر تعریف‌شده در کتابخانه استاندارد رفتار پیش‌فرض معقولی ندارند، بنابراین شما باید آن‌ها را به نحوی پیاده‌سازی کنید که با آنچه می‌خواهید انجام دهید مطابقت داشته باشد.</p>
<p>مثالی از یک ویژگی که نمی‌تواند مشتق شود، <code>Display</code> است که فرمت‌دهی برای کاربران نهایی را مدیریت می‌کند. شما باید همیشه راه مناسب برای نمایش یک نوع به کاربر نهایی را در نظر بگیرید. چه بخش‌هایی از نوع باید به کاربر نهایی نشان داده شود؟ چه بخش‌هایی برای او مرتبط است؟ چه فرمتی از داده برای او بیشترین اهمیت را دارد؟ کامپایلر Rust این بینش را ندارد، بنابراین نمی‌تواند رفتار پیش‌فرض مناسب را برای شما فراهم کند.</p>
<p>لیست ویژگی‌های قابل اشتقاق ارائه‌شده در این ضمیمه جامع نیست: کتابخانه‌ها می‌توانند <code>derive</code> را برای ویژگی‌های خود پیاده‌سازی کنند و لیست ویژگی‌هایی که می‌توانید با <code>derive</code> استفاده کنید را به‌طور واقعی باز بگذارند. پیاده‌سازی <code>derive</code> شامل استفاده از یک ماکروی فرآیندی است که در بخش <a href="ch20-05-macros.html#macros">“ماکروها”</a><!-- ignore --> از فصل 20 پوشش داده شده است.</p>
<h3 id="debug-برای-خروجی-برنامهنویسی"><a class="header" href="#debug-برای-خروجی-برنامهنویسی"><code>Debug</code> برای خروجی برنامه‌نویسی</a></h3>
<p>ویژگی <code>Debug</code> فرمت‌دهی دیباگ را در رشته‌های فرمت فعال می‌کند که با افزودن <code>:?</code> درون نگه‌دارنده‌های <code>{}</code> مشخص می‌کنید.</p>
<p>ویژگی <code>Debug</code> به شما اجازه می‌دهد نمونه‌هایی از یک نوع را برای مقاصد دیباگ چاپ کنید، به‌طوری‌که شما و سایر برنامه‌نویسانی که از نوع شما استفاده می‌کنند بتوانید نمونه‌ای را در یک نقطه خاص از اجرای برنامه بررسی کنید.</p>
<p>ویژگی <code>Debug</code>، برای مثال، در استفاده از ماکروی <code>assert_eq!</code> مورد نیاز است. این ماکرو مقادیر نمونه‌های داده‌شده به‌عنوان آرگومان‌ها را چاپ می‌کند اگر ادعای برابری شکست بخورد تا برنامه‌نویسان بتوانند ببینند چرا دو نمونه برابر نیستند.</p>
<h3 id="partialeq-و-eq-برای-مقایسه-برابری"><a class="header" href="#partialeq-و-eq-برای-مقایسه-برابری"><code>PartialEq</code> و <code>Eq</code> برای مقایسه برابری</a></h3>
<p>ویژگی <code>PartialEq</code> به شما اجازه می‌دهد نمونه‌های یک نوع را برای بررسی برابری مقایسه کنید و استفاده از عملگرهای <code>==</code> و <code>!=</code> را ممکن می‌سازد.</p>
<p>مشتق‌سازی <code>PartialEq</code> متد <code>eq</code> را پیاده‌سازی می‌کند. وقتی <code>PartialEq</code> روی struct‌ها مشتق می‌شود، دو نمونه فقط زمانی برابر هستند که <em>تمام</em> فیلدها برابر باشند و نمونه‌ها برابر نیستند اگر هر یک از فیلدها برابر نباشند. وقتی روی enum‌ها مشتق می‌شود، هر واریانت با خودش برابر است و با سایر واریانت‌ها برابر نیست.</p>
<p>ویژگی <code>PartialEq</code>، برای مثال، با استفاده از ماکروی <code>assert_eq!</code> مورد نیاز است که باید بتواند دو نمونه از یک نوع را برای برابری مقایسه کند.</p>
<p>ویژگی <code>Eq</code> هیچ متدی ندارد. هدف آن این است که نشان دهد برای هر مقدار از نوع حاشیه‌نویسی‌شده، مقدار با خودش برابر است. ویژگی <code>Eq</code> فقط می‌تواند به نوع‌هایی اعمال شود که همچنین <code>PartialEq</code> را پیاده‌سازی کرده باشند، اگرچه همه نوع‌هایی که <code>PartialEq</code> را پیاده‌سازی کرده‌اند نمی‌توانند <code>Eq</code> را پیاده‌سازی کنند. مثالی از این مورد نوع‌های عدد ممیز شناور هستند: پیاده‌سازی اعداد ممیز شناور بیان می‌کند که دو نمونه از مقدار غیرعدد (<code>NaN</code>) برابر نیستند.</p>
<p>مثالی از زمانی که <code>Eq</code> مورد نیاز است، برای کلیدها در <code>HashMap&lt;K, V&gt;</code> است تا <code>HashMap&lt;K, V&gt;</code> بتواند تعیین کند که آیا دو کلید یکسان هستند یا نه.</p>
<h3 id="partialord-و-ord-برای-مقایسه-مرتبسازی"><a class="header" href="#partialord-و-ord-برای-مقایسه-مرتبسازی"><code>PartialOrd</code> و <code>Ord</code> برای مقایسه مرتب‌سازی</a></h3>
<p>ویژگی <code>PartialOrd</code> به شما امکان می‌دهد نمونه‌های یک نوع را برای اهداف مرتب‌سازی مقایسه کنید. نوعی که ویژگی <code>PartialOrd</code> را پیاده‌سازی می‌کند می‌تواند با عملگرهای <code>&lt;</code>، <code>&gt;</code>، <code>&lt;=</code> و <code>&gt;=</code> استفاده شود. شما فقط می‌توانید ویژگی <code>PartialOrd</code> را به نوع‌هایی اعمال کنید که همچنین <code>PartialEq</code> را پیاده‌سازی کرده باشند.</p>
<p>مشتق‌سازی <code>PartialOrd</code> متد <code>partial_cmp</code> را پیاده‌سازی می‌کند، که یک <code>Option&lt;Ordering&gt;</code> را برمی‌گرداند که در صورتی که مقادیر داده‌شده ترتیب‌بندی تولید نکنند، <code>None</code> خواهد بود. مثالی از مقداری که ترتیب‌بندی تولید نمی‌کند، حتی اگر بیشتر مقادیر آن نوع قابل مقایسه باشند، مقدار نقطه شناور غیرعدد (<code>NaN</code>) است. فراخوانی <code>partial_cmp</code> با هر عدد شناور و مقدار <code>NaN</code> نقطه شناور <code>None</code> را برمی‌گرداند.</p>
<p>وقتی روی struct‌ها مشتق می‌شود، <code>PartialOrd</code> دو نمونه را با مقایسه مقدار هر فیلد به ترتیب ظاهر شدن فیلدها در تعریف struct مقایسه می‌کند. وقتی روی enum‌ها مشتق می‌شود، واریانت‌های enum که زودتر در تعریف enum اعلام شده‌اند، کمتر از واریانت‌هایی در نظر گرفته می‌شوند که بعداً فهرست شده‌اند.</p>
<p>ویژگی <code>PartialOrd</code>، برای مثال، برای متد <code>gen_range</code> از crate <code>rand</code> مورد نیاز است که یک مقدار تصادفی در محدوده مشخص‌شده توسط یک عبارت محدوده تولید می‌کند.</p>
<p>ویژگی <code>Ord</code> به شما امکان می‌دهد بدانید که برای هر دو مقدار از نوع حاشیه‌نویسی‌شده، یک ترتیب‌بندی معتبر وجود خواهد داشت. ویژگی <code>Ord</code> متد <code>cmp</code> را پیاده‌سازی می‌کند، که به جای <code>Option&lt;Ordering&gt;</code>، یک <code>Ordering</code> را برمی‌گرداند زیرا یک ترتیب‌بندی معتبر همیشه ممکن خواهد بود. شما فقط می‌توانید ویژگی <code>Ord</code> را به نوع‌هایی اعمال کنید که همچنین <code>PartialOrd</code> و <code>Eq</code> را پیاده‌سازی کرده باشند (و <code>Eq</code> نیازمند <code>PartialEq</code> است). وقتی روی struct‌ها و enum‌ها مشتق می‌شود، <code>cmp</code> به همان شکلی عمل می‌کند که پیاده‌سازی مشتق‌شده برای <code>partial_cmp</code> در <code>PartialOrd</code> عمل می‌کند.</p>
<p>مثالی از زمانی که <code>Ord</code> مورد نیاز است، هنگام ذخیره مقادیر در <code>BTreeSet&lt;T&gt;</code> است، یک ساختار داده که داده‌ها را بر اساس ترتیب مرتب‌سازی مقادیر ذخیره می‌کند.</p>
<h3 id="clone-و-copy-برای-تکثیر-مقادیر"><a class="header" href="#clone-و-copy-برای-تکثیر-مقادیر"><code>Clone</code> و <code>Copy</code> برای تکثیر مقادیر</a></h3>
<p>ویژگی <code>Clone</code> به شما امکان می‌دهد به طور صریح یک کپی عمیق از یک مقدار ایجاد کنید، و فرایند تکثیر ممکن است شامل اجرای کد دلخواه و کپی داده‌های heap باشد. برای اطلاعات بیشتر درباره <code>Clone</code>، به بخش <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">“راه‌های تعامل متغیرها و داده‌ها: Clone”</a><!-- ignore --> در فصل 4 مراجعه کنید.</p>
<p>مشتق‌سازی <code>Clone</code> متد <code>clone</code> را پیاده‌سازی می‌کند، که هنگام پیاده‌سازی برای کل نوع، متد <code>clone</code> را روی هر یک از بخش‌های نوع فراخوانی می‌کند. این بدان معناست که تمام فیلدها یا مقادیر در نوع نیز باید <code>Clone</code> را برای مشتق‌سازی <code>Clone</code> پیاده‌سازی کنند.</p>
<p>مثالی از زمانی که <code>Clone</code> مورد نیاز است، هنگام فراخوانی متد <code>to_vec</code> روی یک slice است. slice مالک نمونه‌های نوعی که شامل است را ندارد، اما وکتوری که از <code>to_vec</code> برگردانده می‌شود باید مالک نمونه‌های خود باشد، بنابراین <code>to_vec</code> روی هر آیتم <code>clone</code> را فراخوانی می‌کند. بنابراین، نوع ذخیره‌شده در slice باید <code>Clone</code> را پیاده‌سازی کند.</p>
<p>ویژگی <code>Copy</code> به شما امکان می‌دهد یک مقدار را با کپی کردن بیت‌های ذخیره‌شده روی stack تکثیر کنید؛ هیچ کد دلخواهی لازم نیست. برای اطلاعات بیشتر درباره <code>Copy</code>، به بخش <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“داده‌های فقط stack: Copy”</a><!-- ignore --> در فصل 4 مراجعه کنید.</p>
<p>ویژگی <code>Copy</code> هیچ متدی را تعریف نمی‌کند تا از اضافه‌بارگذاری آن متدها توسط برنامه‌نویسان و نقض فرضی که هیچ کد دلخواهی اجرا نمی‌شود جلوگیری کند. به این ترتیب، تمام برنامه‌نویسان می‌توانند فرض کنند که کپی کردن یک مقدار بسیار سریع خواهد بود.</p>
<p>شما می‌توانید <code>Copy</code> را روی هر نوعی مشتق کنید که تمام اجزای آن <code>Copy</code> را پیاده‌سازی می‌کنند. نوعی که <code>Copy</code> را پیاده‌سازی می‌کند باید همچنین <code>Clone</code> را پیاده‌سازی کند، زیرا نوعی که <code>Copy</code> را پیاده‌سازی می‌کند دارای پیاده‌سازی ساده‌ای از <code>Clone</code> است که همان وظیفه را به عنوان <code>Copy</code> انجام می‌دهد.</p>
<p>ویژگی <code>Copy</code> به ندرت مورد نیاز است؛ نوع‌هایی که <code>Copy</code> را پیاده‌سازی می‌کنند بهینه‌سازی‌هایی در دسترس دارند، به این معنا که شما نیازی به فراخوانی <code>clone</code> ندارید، که کد را مختصرتر می‌کند.</p>
<p>هر چیزی که با <code>Copy</code> ممکن است را می‌توانید با <code>Clone</code> نیز انجام دهید، اما کد ممکن است کندتر باشد یا نیاز به استفاده از <code>clone</code> در مکان‌های مختلف داشته باشد.</p>
<h3 id="hash-برای-نگاشت-مقدار-به-مقدار-با-اندازه-ثابت"><a class="header" href="#hash-برای-نگاشت-مقدار-به-مقدار-با-اندازه-ثابت"><code>Hash</code> برای نگاشت مقدار به مقدار با اندازه ثابت</a></h3>
<p>ویژگی <code>Hash</code> به شما امکان می‌دهد یک نمونه از نوعی با اندازه دلخواه بگیرید و آن نمونه را با استفاده از یک تابع هش به مقدار با اندازه ثابت نگاشت کنید. مشتق‌سازی <code>Hash</code> متد <code>hash</code> را پیاده‌سازی می‌کند. پیاده‌سازی مشتق‌شده متد <code>hash</code> نتیجه فراخوانی <code>hash</code> روی هر یک از بخش‌های نوع را ترکیب می‌کند، به این معنی که تمام فیلدها یا مقادیر نیز باید <code>Hash</code> را پیاده‌سازی کنند تا <code>Hash</code> مشتق شود.</p>
<p>مثالی از زمانی که <code>Hash</code> مورد نیاز است، هنگام ذخیره کلیدها در <code>HashMap&lt;K, V&gt;</code> برای ذخیره داده‌ها به صورت کارآمد است.</p>
<h3 id="default-برای-مقادیر-پیشفرض"><a class="header" href="#default-برای-مقادیر-پیشفرض"><code>Default</code> برای مقادیر پیش‌فرض</a></h3>
<p>ویژگی <code>Default</code> به شما امکان می‌دهد یک مقدار پیش‌فرض برای یک نوع ایجاد کنید. مشتق‌سازی <code>Default</code> تابع <code>default</code> را پیاده‌سازی می‌کند. پیاده‌سازی مشتق‌شده تابع <code>default</code> تابع <code>default</code> را روی هر بخش از نوع فراخوانی می‌کند، به این معنی که تمام فیلدها یا مقادیر در نوع نیز باید <code>Default</code> را پیاده‌سازی کنند تا <code>Default</code> مشتق شود.</p>
<p>تابع <code>Default::default</code> معمولاً به همراه سینتکس به‌روزرسانی ساختار که در بخش <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">“ایجاد نمونه‌ها از نمونه‌های دیگر با سینتکس به‌روزرسانی ساختار”</a><!-- ignore --> در فصل 5 مورد بحث قرار گرفته است، استفاده می‌شود. می‌توانید چند فیلد از یک ساختار را سفارشی کنید و سپس یک مقدار پیش‌فرض برای بقیه فیلدها با استفاده از <code>..Default::default()</code> تنظیم و استفاده کنید.</p>
<p>ویژگی <code>Default</code>، برای مثال، زمانی مورد نیاز است که از متد <code>unwrap_or_default</code> روی نمونه‌های <code>Option&lt;T&gt;</code> استفاده می‌کنید. اگر <code>Option&lt;T&gt;</code> برابر با <code>None</code> باشد، متد <code>unwrap_or_default</code> نتیجه <code>Default::default</code> را برای نوع <code>T</code> ذخیره‌شده در <code>Option&lt;T&gt;</code> برمی‌گرداند.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-د---ابزارهای-مفید-توسعه"><a class="header" href="#ضمیمه-د---ابزارهای-مفید-توسعه">ضمیمه د - ابزارهای مفید توسعه</a></h2>
<p>در این ضمیمه، ما درباره برخی ابزارهای مفید توسعه که پروژه Rust ارائه می‌دهد صحبت می‌کنیم. به فرمت‌دهی خودکار، روش‌های سریع برای اعمال اصلاحات هشدارها، یک تحلیلگر کد (linter) و یکپارچه‌سازی با محیط‌های توسعه یکپارچه (IDE) خواهیم پرداخت.</p>
<h3 id="فرمتدهی-خودکار-با-rustfmt"><a class="header" href="#فرمتدهی-خودکار-با-rustfmt">فرمت‌دهی خودکار با <code>rustfmt</code></a></h3>
<p>ابزار <code>rustfmt</code> کد شما را بر اساس سبک کدنویسی جامعه فرمت می‌کند. بسیاری از پروژه‌های مشترک از <code>rustfmt</code> استفاده می‌کنند تا از بحث در مورد سبک کدنویسی در هنگام نوشتن کدهای Rust جلوگیری شود: همه کدهای خود را با استفاده از این ابزار فرمت می‌کنند.</p>
<p>برای نصب <code>rustfmt</code>، دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>این دستور ابزارهای <code>rustfmt</code> و <code>cargo-fmt</code> را به شما می‌دهد، مشابه به اینکه Rust ابزارهای <code>rustc</code> و <code>cargo</code> را ارائه می‌دهد. برای فرمت کردن هر پروژه‌ای که از Cargo استفاده می‌کند، دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>اجرای این دستور تمام کدهای Rust در crate فعلی را مجدداً فرمت می‌کند. این کار باید فقط سبک کدنویسی را تغییر دهد، نه معنای کد را. برای اطلاعات بیشتر در مورد <code>rustfmt</code>، به <a href="https://github.com/rust-lang/rustfmt">مستندات آن</a> مراجعه کنید.</p>
<h3 id="اصلاح-کد-شما-با-rustfix"><a class="header" href="#اصلاح-کد-شما-با-rustfix">اصلاح کد شما با <code>rustfix</code></a></h3>
<p>ابزار <code>rustfix</code> که همراه با نصب‌های Rust ارائه می‌شود، می‌تواند به طور خودکار هشدارهای کامپایلر را که یک راه حل واضح برای رفع مشکل دارند و احتمالاً همان چیزی است که می‌خواهید، اصلاح کند. احتمالاً قبلاً هشدارهای کامپایلر را دیده‌اید. به عنوان مثال، کد زیر را در نظر بگیرید:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>در اینجا، ما تابع <code>do_something</code> را 100 بار فراخوانی می‌کنیم، اما هرگز متغیر <code>i</code> را در بدنه حلقه <code>for</code> استفاده نمی‌کنیم. Rust در این مورد به ما هشدار می‌دهد:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>هشدار پیشنهاد می‌دهد که به جای آن از نام <code>_i</code> استفاده کنیم: خط زیرنویس نشان می‌دهد که قصد داریم این متغیر استفاده نشده باقی بماند. ما می‌توانیم به طور خودکار این پیشنهاد را با استفاده از ابزار <code>rustfix</code> و اجرای دستور <code>cargo fix</code> اعمال کنیم:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>وقتی دوباره فایل <em>src/main.rs</em> را بررسی کنیم، خواهیم دید که <code>cargo fix</code> کد را تغییر داده است:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>اکنون متغیر حلقه <code>for</code> به نام <code>_i</code> تغییر یافته است و هشدار دیگر نمایش داده نمی‌شود.</p>
<p>همچنین می‌توانید از دستور <code>cargo fix</code> برای انتقال کد خود بین نسخه‌های مختلف Rust استفاده کنید. نسخه‌ها در <a href="appendix-05-editions.html">ضمیمه ه</a> پوشش داده شده‌اند.</p>
<h3 id="لینتهای-بیشتر-با-clippy"><a class="header" href="#لینتهای-بیشتر-با-clippy">لینت‌های بیشتر با Clippy</a></h3>
<p>ابزار Clippy مجموعه‌ای از تحلیلگرهای کد (لینت‌ها) است که کد شما را تحلیل می‌کنند تا بتوانید اشتباهات رایج را پیدا کرده و کد Rust خود را بهبود دهید.</p>
<p>برای نصب Clippy، دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>برای اجرای تحلیلگرهای Clippy روی هر پروژه Cargo، دستور زیر را وارد کنید:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>به عنوان مثال، فرض کنید برنامه‌ای می‌نویسید که از یک مقدار تقریبی برای یک ثابت ریاضی، مانند pi، استفاده می‌کند، همانطور که این برنامه انجام می‌دهد:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>اجرای <code>cargo clippy</code> روی این پروژه به این خطا منجر می‌شود:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>این خطا به شما اطلاع می‌دهد که Rust از قبل یک ثابت دقیق‌تر <code>PI</code> تعریف کرده است و برنامه شما اگر از این ثابت استفاده کند، صحیح‌تر خواهد بود. سپس کد خود را تغییر می‌دهید تا از ثابت <code>PI</code> استفاده کنید. کد زیر هیچ خطا یا هشداری از Clippy تولید نمی‌کند:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>برای اطلاعات بیشتر درباره Clippy، به <a href="https://github.com/rust-lang/rust-clippy">مستندات آن</a> مراجعه کنید.</p>
<h3 id="یکپارچهسازی-ide-با-استفاده-از-rust-analyzer"><a class="header" href="#یکپارچهسازی-ide-با-استفاده-از-rust-analyzer">یکپارچه‌سازی IDE با استفاده از <code>rust-analyzer</code></a></h3>
<p>برای کمک به یکپارچه‌سازی با IDE، جامعه Rust استفاده از <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore --> را توصیه می‌کند. این ابزار مجموعه‌ای از ابزارهای متمرکز بر کامپایلر است که با <a href="http://langserver.org/">پروتکل زبان سرور</a><!-- ignore --> کار می‌کند، که یک مشخصه برای ارتباط IDEها و زبان‌های برنامه‌نویسی با یکدیگر است. مشتری‌های مختلف می‌توانند از <code>rust-analyzer</code> استفاده کنند، مانند <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">پلاگین Rust analyzer برای Visual Studio Code</a>.</p>
<p>برای دستورالعمل‌های نصب، به <a href="https://rust-analyzer.github.io">صفحه اصلی پروژه <code>rust-analyzer</code></a><!-- ignore --> مراجعه کنید، سپس پشتیبانی از سرور زبان را در IDE خاص خود نصب کنید. IDE شما قابلیت‌هایی مانند تکمیل خودکار، پرش به تعریف و نمایش خطاها به صورت درون‌خطی را به دست خواهد آورد.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-ه---نسخهها"><a class="header" href="#ضمیمه-ه---نسخهها">ضمیمه ه - نسخه‌ها</a></h2>
<p>در فصل 1 دیدید که <code>cargo new</code> کمی متاداده به فایل <em>Cargo.toml</em> شما اضافه می‌کند که درباره نسخه است. این ضمیمه توضیح می‌دهد که این به چه معناست!</p>
<p>زبان Rust و کامپایلر آن یک چرخه انتشار شش‌هفته‌ای دارند، به این معنی که کاربران به طور مداوم به ویژگی‌های جدید دسترسی پیدا می‌کنند. زبان‌های برنامه‌نویسی دیگر تغییرات بزرگ را کمتر منتشر می‌کنند؛ در حالی که Rust به طور مرتب به‌روزرسانی‌های کوچک ارائه می‌دهد. پس از مدتی، همه این تغییرات کوچک جمع می‌شوند. اما از انتشار به انتشار، ممکن است سخت باشد که بگویید: «وای، بین Rust 1.10 و Rust 1.31، Rust خیلی تغییر کرده است!»</p>
<p>هر دو یا سه سال، تیم Rust یک نسخه جدید از Rust ارائه می‌دهد. هر نسخه ویژگی‌هایی که ارائه شده‌اند را در یک بسته‌بندی واضح با مستندات و ابزارهای کاملاً به‌روزشده جمع می‌کند. نسخه‌های جدید به‌عنوان بخشی از فرآیند انتشار معمول شش‌هفته‌ای منتشر می‌شوند.</p>
<p>نسخه‌ها اهداف مختلفی برای افراد مختلف دارند:</p>
<ul dir="rtl">
  <li>برای کاربران فعال Rust، یک نسخه جدید تغییرات تدریجی را در یک بسته آسان برای درک جمع می‌کند.</li>
  <li>برای غیرکاربران، یک نسخه جدید نشان‌دهنده این است که پیشرفت‌های عمده‌ای انجام شده است که ممکن است ارزش داشته باشد Rust را دوباره بررسی کنند.</li>
  <li>برای کسانی که Rust را توسعه می‌دهند، یک نسخه جدید نقطه‌ای برای گردهمایی پروژه به عنوان یک کل فراهم می‌کند.</li>
</ul>
<p>در زمان نگارش این متن، چهار نسخه از Rust در دسترس هستند: Rust 2015، Rust 2018، Rust 2021، و Rust 2024. این کتاب با استفاده از الگوها و قواعد نسخه Rust 2024 نوشته شده است.</p>
<p>کلید <code>edition</code> در فایل <em>Cargo.toml</em> نشان می‌دهد که کامپایلر باید از کدام نسخه برای کد شما استفاده کند. اگر این کلید وجود نداشته باشد، Rust به دلایل سازگاری با نسخه‌های قبلی از مقدار <code>2015</code> به‌عنوان نسخه پیش‌فرض استفاده می‌کند.</p>
<p>هر پروژه می‌تواند به یک نسخه غیر از نسخه پیش‌فرض 2015 مهاجرت کند. نسخه‌ها می‌توانند تغییرات ناسازگار داشته باشند، مانند اضافه کردن یک کلمه کلیدی جدید که با شناسه‌ها در کد تداخل دارد. اما تا زمانی که به این تغییرات مهاجرت نکنید، کد شما همچنان کامپایل خواهد شد حتی اگر نسخه کامپایلر Rust خود را ارتقا دهید.</p>
<p>تمام نسخه‌های کامپایلر Rust از هر نسخه‌ای که پیش از انتشار آن کامپایلر وجود داشته باشد پشتیبانی می‌کنند و می‌توانند کتابخانه‌هایی از هر نسخه پشتیبانی‌شده را به یکدیگر لینک کنند. تغییرات نسخه فقط بر نحوه تجزیه اولیه کد توسط کامپایلر تأثیر می‌گذارد. بنابراین، اگر از Rust 2015 استفاده می‌کنید و یکی از وابستگی‌های شما از Rust 2018 استفاده می‌کند، پروژه شما کامپایل خواهد شد و می‌تواند از آن وابستگی استفاده کند. وضعیت معکوس، جایی که پروژه شما از Rust 2018 و یک وابستگی از Rust 2015 استفاده می‌کند، نیز کار می‌کند.</p>
<p>برای روشن شدن: بیشتر ویژگی‌ها در همه نسخه‌ها در دسترس خواهند بود. توسعه‌دهندگان با استفاده از هر نسخه‌ای از Rust همچنان بهبودهایی را با انتشارهای پایدار جدید مشاهده خواهند کرد. اما در برخی موارد، عمدتاً زمانی که کلمات کلیدی جدید اضافه می‌شوند، برخی ویژگی‌های جدید ممکن است فقط در نسخه‌های بعدی در دسترس باشند. اگر می‌خواهید از چنین ویژگی‌هایی استفاده کنید، باید به نسخه‌های جدیدتر مهاجرت کنید.</p>
<p>برای جزئیات بیشتر، <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>راهنمای نسخه‌ها</em></a> کتاب کاملی درباره نسخه‌ها است که تفاوت‌های بین نسخه‌ها را فهرست می‌کند و توضیح می‌دهد که چگونه می‌توانید کد خود را با استفاده از <code>cargo fix</code> به نسخه جدید ارتقا دهید.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-و-ترجمههای-کتاب"><a class="header" href="#ضمیمه-و-ترجمههای-کتاب">ضمیمه و: ترجمه‌های کتاب</a></h2>
<p>برای منابع به زبان‌هایی غیر از انگلیسی. بیشتر آن‌ها هنوز در حال پیشرفت هستند؛ برای کمک یا اطلاع دادن از ترجمه جدید، به <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">برچسب ترجمه‌ها</a> مراجعه کنید!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li>简体中文: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>, <a href="https://github.com/RustLangES/rust-book-es">Español por RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ضمیمه-ی---چگونگی-توسعه-rust-و-rust-nightly"><a class="header" href="#ضمیمه-ی---چگونگی-توسعه-rust-و-rust-nightly">ضمیمه ی - چگونگی توسعه Rust و “Rust Nightly”</a></h2>
<p>این ضمیمه درباره چگونگی توسعه Rust و تأثیر آن بر شما به عنوان یک توسعه‌دهنده Rust است.</p>
<h3 id="ثبات-بدون-رکود"><a class="header" href="#ثبات-بدون-رکود">ثبات بدون رکود</a></h3>
<p>به عنوان یک زبان، Rust به <em>ثبات</em> کد شما بسیار اهمیت می‌دهد. ما می‌خواهیم Rust یک پایه محکم و قابل اعتماد باشد که بتوانید بر روی آن بسازید، و اگر همه چیز به طور مداوم تغییر می‌کرد، این امکان‌پذیر نبود. در عین حال، اگر نتوانیم با ویژگی‌های جدید آزمایش کنیم، ممکن است مشکلات مهمی را تا بعد از انتشار آن‌ها کشف نکنیم، زمانی که دیگر نمی‌توان تغییراتی ایجاد کرد.</p>
<p>راه‌حل ما برای این مشکل چیزی است که ما آن را “ثبات بدون رکود” می‌نامیم، و اصل راهنمای ما این است: شما هرگز نباید از ارتقاء به یک نسخه جدید از Rust پایدار بترسید. هر ارتقاء باید بدون دردسر باشد، اما همچنین ویژگی‌های جدید، باگ‌های کمتر، و زمان‌های کامپایل سریع‌تر را برای شما به ارمغان بیاورد.</p>
<h3 id="چو-چو-کانالهای-انتشار-و-حرکت-قطارها"><a class="header" href="#چو-چو-کانالهای-انتشار-و-حرکت-قطارها">چو، چو! کانال‌های انتشار و حرکت قطارها</a></h3>
<p>توسعه Rust بر اساس یک <em>برنامه زمانی قطار</em> عمل می‌کند. یعنی تمام توسعه‌ها در شاخه <code>master</code> مخزن Rust انجام می‌شود. انتشارها از مدل قطار انتشار نرم‌افزار پیروی می‌کنند، مدلی که توسط Cisco IOS و پروژه‌های نرم‌افزاری دیگر استفاده شده است. سه <em>کانال انتشار</em> برای Rust وجود دارد:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
</div>
<p>بیشتر توسعه‌دهندگان Rust عمدتاً از کانال پایدار استفاده می‌کنند، اما کسانی که می‌خواهند ویژگی‌های آزمایشی جدید را امتحان کنند ممکن است از کانال‌های nightly یا beta استفاده کنند.</p>
<p>در اینجا مثالی از نحوه کار فرآیند توسعه و انتشار آورده شده است: فرض کنید تیم Rust روی انتشار نسخه Rust 1.5 کار می‌کند. آن انتشار در دسامبر 2015 اتفاق افتاد، اما اعداد نسخه‌ای واقعی به ما ارائه می‌دهد. یک ویژگی جدید به Rust اضافه می‌شود: یک commit جدید به شاخه <code>master</code> اضافه می‌شود. هر شب، یک نسخه جدید nightly از Rust تولید می‌شود. هر روز یک روز انتشار است، و این نسخه‌ها به طور خودکار توسط زیرساخت انتشار ما ایجاد می‌شوند. بنابراین با گذشت زمان، انتشارهای ما به این صورت خواهند بود، هر شب:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>هر شش هفته، زمان آماده‌سازی یک انتشار جدید است! شاخه <code>beta</code> مخزن Rust از شاخه <code>master</code> که برای nightly استفاده می‌شود منشعب می‌شود. اکنون دو نسخه وجود دارد:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>بیشتر کاربران Rust به طور فعال از نسخه‌های beta استفاده نمی‌کنند، اما در سیستم CI خود علیه beta تست می‌گیرند تا به Rust کمک کنند که مشکلات احتمالی را شناسایی کند. در همین حال، هنوز هر شب یک نسخه nightly منتشر می‌شود:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>فرض کنید یک مشکل (regression) پیدا شود. خوشبختانه ما زمانی برای تست نسخه beta داشتیم قبل از اینکه مشکل وارد نسخه پایدار شود! اصلاح به شاخه <code>master</code> اعمال می‌شود، بنابراین nightly اصلاح می‌شود، و سپس این اصلاح به شاخه <code>beta</code> بازگردانده می‌شود، و یک نسخه جدید از beta تولید می‌شود:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>شش هفته پس از ایجاد اولین نسخه beta، زمان انتشار نسخه پایدار است! شاخه <code>stable</code> از شاخه <code>beta</code> تولید می‌شود:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>هورا! Rust 1.5 آماده است! اما یک چیز را فراموش کرده‌ایم: چون شش هفته گذشته است، ما به نسخه beta جدیدی از <em>نسخه بعدی</em> Rust، یعنی 1.6، نیاز داریم. بنابراین پس از اینکه شاخه <code>stable</code> از <code>beta</code> جدا شد، نسخه بعدی <code>beta</code> دوباره از <code>nightly</code> منشعب می‌شود:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>این مدل “قطار” نامیده می‌شود، زیرا هر شش هفته، یک انتشار “ایستگاه را ترک می‌کند”، اما همچنان باید از کانال beta عبور کند تا به یک انتشار پایدار تبدیل شود.</p>
<p>انتشارهای Rust هر شش هفته، مانند ساعت دقیق انجام می‌شوند. اگر تاریخ یک انتشار Rust را بدانید، می‌توانید تاریخ انتشار بعدی را بدانید: شش هفته بعد. یکی از جنبه‌های خوب داشتن انتشارهای برنامه‌ریزی‌شده هر شش هفته این است که قطار بعدی به زودی می‌آید. اگر یک ویژگی به طور اتفاقی یک انتشار خاص را از دست بدهد، نیازی به نگرانی نیست: انتشار بعدی در مدت کوتاهی اتفاق می‌افتد! این امر به کاهش فشار برای افزودن ویژگی‌های احتمالاً ناقص نزدیک به مهلت انتشار کمک می‌کند.</p>
<p>با تشکر از این فرآیند، شما همیشه می‌توانید نسخه بعدی Rust را بررسی کرده و برای خود تأیید کنید که ارتقاء به آن آسان است: اگر یک نسخه beta مطابق انتظار عمل نکند، می‌توانید آن را به تیم گزارش دهید و قبل از اینکه انتشار پایدار بعدی انجام شود، آن را اصلاح کنید! شکستن در یک نسخه beta نسبتاً نادر است، اما <code>rustc</code> همچنان یک نرم‌افزار است و باگ‌ها وجود دارند.</p>
<h3 id="زمان-نگهداری"><a class="header" href="#زمان-نگهداری">زمان نگهداری</a></h3>
<p>پروژه Rust از آخرین نسخه پایدار پشتیبانی می‌کند. وقتی یک نسخه پایدار جدید منتشر می‌شود، نسخه قدیمی به پایان عمر خود (EOL) می‌رسد. این به این معنی است که هر نسخه برای شش هفته پشتیبانی می‌شود.</p>
<h3 id="ویژگیهای-ناپایدار"><a class="header" href="#ویژگیهای-ناپایدار">ویژگی‌های ناپایدار</a></h3>
<p>یک نکته دیگر در این مدل انتشار وجود دارد: ویژگی‌های ناپایدار. Rust از تکنیکی به نام “پرچم‌های ویژگی” (feature flags) استفاده می‌کند تا تعیین کند چه ویژگی‌هایی در یک انتشار فعال هستند. اگر یک ویژگی جدید تحت توسعه فعال باشد، روی شاخه <code>master</code> قرار می‌گیرد و بنابراین، در nightly، اما پشت یک <em>پرچم ویژگی</em> قرار می‌گیرد. اگر به‌عنوان کاربر، مایلید ویژگی در حال توسعه را امتحان کنید، می‌توانید این کار را انجام دهید، اما باید از نسخه nightly Rust استفاده کرده و کد منبع خود را با پرچم مناسب برای فعال‌سازی آن علامت‌گذاری کنید.</p>
<p>اگر از نسخه beta یا پایدار Rust استفاده می‌کنید، نمی‌توانید از پرچم‌های ویژگی استفاده کنید. این نکته‌ای است که به ما اجازه می‌دهد از ویژگی‌های جدید به صورت عملی استفاده کنیم قبل از اینکه آن‌ها را برای همیشه پایدار اعلام کنیم. کسانی که مایلند از ویژگی‌های پیشرفته استفاده کنند، می‌توانند این کار را انجام دهند، و کسانی که تجربه‌ای پایدار و قابل اعتماد می‌خواهند می‌توانند با نسخه پایدار بمانند و مطمئن باشند که کد آن‌ها خراب نخواهد شد. ثبات بدون رکود.</p>
<p>این کتاب فقط شامل اطلاعات مربوط به ویژگی‌های پایدار است، زیرا ویژگی‌های در حال توسعه همچنان در حال تغییر هستند و مطمئناً بین زمانی که این کتاب نوشته شده و زمانی که در نسخه‌های پایدار فعال می‌شوند، متفاوت خواهند بود. می‌توانید مستندات مربوط به ویژگی‌هایی که فقط در nightly موجود هستند را به صورت آنلاین پیدا کنید.</p>
<h3 id="rustup-و-نقش-rust-nightly"><a class="header" href="#rustup-و-نقش-rust-nightly">Rustup و نقش Rust Nightly</a></h3>
<p>ابزار Rustup تغییر بین کانال‌های مختلف انتشار Rust را، به صورت جهانی یا بر اساس هر پروژه، آسان می‌کند. به طور پیش‌فرض، Rust پایدار نصب خواهد بود. برای نصب نسخه nightly، به عنوان مثال:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>همچنین می‌توانید تمام <em>ابزارهای موجود</em> (نسخه‌های Rust و اجزای مرتبط) که با <code>rustup</code> نصب کرده‌اید را ببینید. در اینجا مثالی از یک کامپیوتر ویندوزی یکی از نویسندگان آورده شده است:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>همان‌طور که می‌بینید، ابزار stable به طور پیش‌فرض تنظیم شده است. بیشتر کاربران Rust بیشتر وقت خود از stable استفاده می‌کنند. ممکن است بخواهید بیشتر وقت خود از stable استفاده کنید، اما در یک پروژه خاص از nightly استفاده کنید، زیرا به یک ویژگی پیشرفته علاقه دارید. برای انجام این کار، می‌توانید از <code>rustup override</code> در دایرکتوری آن پروژه استفاده کنید تا ابزار nightly را به‌عنوان ابزار مورد استفاده <code>rustup</code> در آن دایرکتوری تنظیم کنید:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>اکنون، هر بار که در دایرکتوری <em>~/projects/needs-nightly</em> دستور <code>rustc</code> یا <code>cargo</code> را فراخوانی کنید، <code>rustup</code> اطمینان حاصل می‌کند که شما از Rust nightly استفاده می‌کنید، نه نسخه پایدار پیش‌فرض. این ویژگی زمانی که پروژه‌های زیادی با Rust دارید، بسیار مفید است!</p>
<h3 id="فرآیند-rfc-و-تیمها"><a class="header" href="#فرآیند-rfc-و-تیمها">فرآیند RFC و تیم‌ها</a></h3>
<p>چگونه می‌توانید درباره این ویژگی‌های جدید اطلاعات کسب کنید؟ مدل توسعه Rust از یک فرآیند <em>درخواست نظرات (RFC)</em> پیروی می‌کند. اگر بهبود خاصی در Rust می‌خواهید، می‌توانید یک پیشنهاد بنویسید که به آن RFC گفته می‌شود.</p>
<p>هر کسی می‌تواند RFC بنویسد تا Rust را بهبود دهد، و این پیشنهادها توسط تیم Rust که از چندین زیرتیم موضوعی تشکیل شده است، بررسی و بحث می‌شوند. لیست کامل تیم‌ها <a href="https://www.rust-lang.org/governance">در وب‌سایت Rust</a> موجود است، که شامل تیم‌هایی برای هر بخش از پروژه می‌شود: طراحی زبان، پیاده‌سازی کامپایلر، زیرساخت، مستندات و موارد دیگر. تیم مربوطه پیشنهاد و نظرات را می‌خواند، نظرات خود را می‌نویسد، و در نهایت، توافقی برای پذیرش یا رد ویژگی حاصل می‌شود.</p>
<p>اگر ویژگی پذیرفته شود، یک issue در مخزن Rust باز می‌شود و کسی می‌تواند آن را پیاده‌سازی کند. فردی که آن را پیاده‌سازی می‌کند، ممکن است همان فردی نباشد که ویژگی را ابتدا پیشنهاد داده است! وقتی پیاده‌سازی آماده شد، روی شاخه <code>master</code> پشت یک پرچم ویژگی قرار می‌گیرد، همان‌طور که در بخش <a href="appendix-07-nightly-rust.html#unstable-features">“ویژگی‌های ناپایدار”</a><!-- ignore --> بحث شد.</p>
<p>پس از مدتی، زمانی که توسعه‌دهندگان Rust که از نسخه‌های nightly استفاده می‌کنند توانسته‌اند ویژگی جدید را امتحان کنند، اعضای تیم درباره این ویژگی، نحوه عملکرد آن در nightly و تصمیم‌گیری می‌کنند که آیا باید وارد Rust پایدار شود یا نه. اگر تصمیم بر ادامه باشد، پرچم ویژگی حذف می‌شود و ویژگی اکنون پایدار تلقی می‌شود! سپس این ویژگی وارد نسخه پایدار جدید Rust می‌شود.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
