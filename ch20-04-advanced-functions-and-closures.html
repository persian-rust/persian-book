<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>توابع و Closures پیشرفته - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="توابع-پیشرفته-و-closureها"><a class="header" href="#توابع-پیشرفته-و-closureها">توابع پیشرفته و Closureها</a></h2>
<p>این بخش به بررسی برخی از ویژگی‌های پیشرفته مربوط به توابع و Closureها می‌پردازد، از جمله Pointerهای تابع و بازگرداندن Closureها.</p>
<h3 id="pointerهای-تابع"><a class="header" href="#pointerهای-تابع">Pointerهای تابع</a></h3>
<p>ما درباره نحوهٔ ارسال کلوزرها به توابع صحبت کردیم؛ همچنین می‌توانید توابع معمولی را نیز به توابع دیگر ارسال کنید! این تکنیک زمانی مفید است که بخواهید تابعی را که از قبل تعریف کرده‌اید ارسال کنید، به‌جای آن‌که یک کلوزر جدید تعریف کنید. توابع به نوع <code>fn</code> (با f کوچک) تبدیل می‌شوند، که نباید با <code>Fn</code> که یک <code>trait</code> برای کلوزرهاست، اشتباه گرفته شود. نوع <code>fn</code> یک <em>پویتر به تابع</em> نامیده می‌شود. ارسال توابع با استفاده از پویترهای تابع این امکان را می‌دهد که از توابع به‌عنوان آرگومان به توابع دیگر استفاده کنید.</p>
<p>نحو مشخص‌کردن اینکه یک پارامتر از نوع پویتر تابع است، مشابه نحوهٔ تعریف کلوزرهاست؛ همان‌طور که در لیست 20-28 نشان داده شده است. در آنجا تابعی به نام <code>add_one</code> تعریف کرده‌ایم که ۱ واحد به پارامتر خود اضافه می‌کند. تابع <code>do_twice</code> دو پارامتر می‌گیرد: یک پویتر به تابعی که یک پارامتر از نوع <code>i32</code> می‌گیرد و مقدار <code>i32</code> برمی‌گرداند، و یک مقدار <code>i32</code>. تابع <code>do_twice</code> تابع <code>f</code> را دو بار با مقدار <code>arg</code> فراخوانی می‌کند، سپس نتایج این دو فراخوانی را با هم جمع می‌زند. تابع <code>main</code> تابع <code>do_twice</code> را با آرگومان‌های <code>add_one</code> و <code>5</code> فراخوانی می‌کند.</p>
<figure class="listing" id="listing-20-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<figcaption><a href="#listing-20-28">Listing 20-28</a>: استفاده از نوع <code>fn</code> برای پذیرش یک اشاره‌گر (Pointer) تابع به عنوان آرگومان</figcaption>
</figure>
<p>این کد مقدار <code>The answer is: 12</code> را چاپ می‌کند. ما مشخص کرده‌ایم که پارامتر <code>f</code> در <code>do_twice</code> یک <code>fn</code> است که یک پارامتر از نوع <code>i32</code> می‌گیرد و یک <code>i32</code> باز می‌گرداند. سپس می‌توانیم <code>f</code> را در بدنه تابع <code>do_twice</code> فراخوانی کنیم. در <code>main</code>، می‌توانیم نام تابع <code>add_one</code> را به عنوان آرگومان اول به <code>do_twice</code> ارسال کنیم.</p>
<p>برخلاف Closureها <code>fn</code> یک نوع است و نه یک ویژگی، بنابراین ما <code>fn</code> را به طور مستقیم به عنوان نوع پارامتر مشخص می‌کنیم، به جای اعلام یک پارامتر جنریک با یکی از ویژگی‌های <code>Fn</code> به عنوان محدودیت ویژگی.</p>
<p>Pointerهای تابع تمام سه ویژگی Closureها (<code>Fn</code>، <code>FnMut</code>، و <code>FnOnce</code>) را پیاده‌سازی می‌کنند، به این معنی که شما همیشه می‌توانید یک اشاره‌گر (Pointer) تابع را به عنوان آرگومان برای یک تابع که انتظار یک Closureها را دارد ارسال کنید. بهتر است توابع را با استفاده از یک نوع جنریک و یکی از ویژگی‌های Closureها بنویسید تا توابع شما بتوانند هم توابع و هم Closureها را بپذیرند.</p>
<p>با این حال، یک مثال از جایی که ممکن است بخواهید فقط <code>fn</code> را بپذیرید و نه Closureها زمانی است که با کد خارجی که Closureها ندارد تعامل می‌کنید: توابع C می‌توانند توابع را به عنوان آرگومان بپذیرند، اما C Closureها ندارد.</p>
<p>به‌عنوان مثالی از جایی که می‌توانید از یک کلوزر تعریف‌شده به‌صورت درجا یا از یک تابع نام‌گذاری‌شده استفاده کنید، بیایید نگاهی بیندازیم به یک استفاده از متد <code>map</code> که توسط <code>Iterator</code> در کتابخانه استاندارد فراهم شده است. برای استفاده از متد <code>map</code> به‌منظور تبدیل یک <code>vector</code> از اعداد به یک <code>vector</code> از رشته‌ها، می‌توانیم از یک کلوزر استفاده کنیم، همان‌طور که در لیست 20-29 نشان داده شده است.</p>
<figure class="listing" id="listing-20-29">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-29">Listing 20-29</a>: استفاده از یک کلوزر با متد <code>map</code> برای تبدیل اعداد به رشته‌ها</figcaption>
</figure>
<p>یا می‌توانیم به‌جای کلوزر، یک تابع را به‌عنوان آرگومان به <code>map</code> بدهیم. لیست 20-30 نشان می‌دهد که این کار چگونه انجام می‌شود.</p>
<figure class="listing" id="listing-20-30">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-30">Listing 20-30</a>: استفاده از تابع <code>String::to_string</code> با متد <code>map</code> برای تبدیل اعداد به رشته‌ها</figcaption>
</figure>
<p>توجه داشته باشید که باید از سینتکس کاملاً مشخصی که در بخش
<a href="ch20-02-advanced-traits.html#advanced-traits">«ویژگی‌های پیشرفته»</a><!-- ignore --> درباره آن صحبت کردیم استفاده کنیم،
زیرا توابع متعددی با نام <code>to_string</code> وجود دارند.</p>
<p>در این‌جا، از تابع <code>to_string</code> استفاده می‌کنیم که در <code>trait</code> به نام <code>ToString</code> تعریف شده
و کتابخانه استاندارد آن را برای هر نوعی که <code>Display</code> را پیاده‌سازی کرده باشد، پیاده‌سازی کرده است.</p>
<p>به یاد بیاورید که در بخش <a href="ch06-01-defining-an-enum.html#enum-values">«مقادیر enum»</a><!-- ignore --> از فصل ۶ اشاره کردیم
که نام هر واریانت <code>enum</code> که تعریف می‌کنیم، همچنین تبدیل به یک تابع سازنده (initializer function) می‌شود.
ما می‌توانیم این توابع سازنده را به‌عنوان فانکشن‌پوینترهایی که <code>closure trait</code>‌ها را پیاده‌سازی می‌کنند استفاده کنیم؛
این یعنی می‌توانیم این توابع سازنده را به‌عنوان آرگومان برای متدهایی که کلوزر دریافت می‌کنند مشخص کنیم،
همان‌طور که در لیست 31-20 مشاهده می‌کنید.</p>
<figure class="listing" id="listing-20-31">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-31">Listing 20-31</a>: استفاده از سازنده enum با متد <code>map</code> برای ایجاد نمونه‌ای از <code>Status</code> از روی اعداد</figcaption>
</figure>
<p>در این‌جا، با استفاده از تابع سازنده <code>Status::Value</code>، برای هر مقدار <code>u32</code> در بازه‌ای که <code>map</code> روی آن فراخوانی شده، نمونه‌هایی از <code>Status::Value</code> ایجاد می‌کنیم.
برخی افراد این سبک را ترجیح می‌دهند و برخی دیگر ترجیح می‌دهند از کلوزرها استفاده کنند.
هر دو روش به یک کد کامپایل می‌شوند، پس از هر سبکی که برای شما واضح‌تر است استفاده کنید.</p>
<h3 id="بازگرداندن-کلوزرها-closures-returning-closures"><a class="header" href="#بازگرداندن-کلوزرها-closures-returning-closures">بازگرداندن کلوزرها (closures) (Returning Closures)</a></h3>
<p>کلوزرها توسط <code>trait</code>ها نمایش داده می‌شوند، به این معنا که نمی‌توان آن‌ها را مستقیماً به عنوان مقدار بازگشتی برگرداند.
در بیشتر مواردی که ممکن است بخواهید یک <code>trait</code> را برگردانید، می‌توانید به جای آن از نوع مشخصی که آن <code>trait</code> را پیاده‌سازی می‌کند به‌عنوان مقدار بازگشتی تابع استفاده کنید.
اما معمولاً نمی‌توانید این کار را با کلوزرها انجام دهید، چون آن‌ها نوع مشخصی ندارند که قابل بازگشت باشد؛
برای مثال، اگر کلوزری مقداری از اسکوپ خود را کپچر کند، مجاز به استفاده از نوع اشاره‌گر تابع <code>fn</code> به‌عنوان نوع بازگشتی نیستید.</p>
<p>در عوض، معمولاً از سینتکس <code>impl Trait</code> که در فصل ۱۰ یاد گرفتیم استفاده می‌شود.
می‌توانید هر نوع تابعی را با استفاده از <code>Fn</code>، <code>FnOnce</code> و <code>FnMut</code> بازگردانید.
برای مثال، کدی که در لیست 20-32 آمده است، بدون مشکل کامپایل می‌شود.</p>
<figure class="listing" id="listing-20-32">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-32">Listing 20-32</a>: بازگرداندن یک کلوزر از تابع با استفاده از سینتکس <code>impl Trait</code></figcaption>
</figure>
<p>با این حال، همان‌طور که در بخش <a href="ch13-01-closures.html#closure-type-inference-and-annotation">“استنباط نوع کلوزر و حاشیه‌نویسی”</a><!-- ignore --> در فصل ۱۳ اشاره شد،
هر کلوزر همچنین نوع خاص خودش را دارد. اگر نیاز دارید با چندین تابع که امضای یکسانی دارند اما پیاده‌سازی متفاوتی دارند کار کنید،
باید از یک آبجکت <code>trait</code> برای آن‌ها استفاده کنید. ببینید چه اتفاقی می‌افتد اگر کدی مشابه لیست 20-33 بنویسید.</p>
<figure class="listing" id="listing-20-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre>
<figcaption><a href="#listing-20-33">Listing 20-33</a>: ایجاد یک <code>Vec&lt;T&gt;</code> از کلوزرهایی که توسط توابعی بازگردانده می‌شوند که نوع <code>impl Fn</code> دارند</figcaption>
</figure>
<p>در این‌جا دو تابع داریم به نام‌های <code>returns_closure</code> و <code>returns_initialized_closure</code>،
که هر دو مقدار <code>impl Fn(i32) -&gt; i32</code> را بازمی‌گردانند.
توجه داشته باشید که کلوزرهایی که این توابع بازمی‌گردانند با یکدیگر متفاوت‌اند،
حتی اگر هر دو <code>trait</code> یکسانی را پیاده‌سازی کنند.
اگر سعی کنیم این کد را کامپایل کنیم، Rust به ما اطلاع می‌دهد که این کار امکان‌پذیر نیست:</p>
<pre><code class="language-text">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --&gt; src/main.rs:2:44
   |
2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
9  | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:9:25&gt;)
              found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:13:46&gt;)
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>پیام خطا به ما می‌گوید که زمانی که ما یک <code>impl Trait</code> را بازمی‌گردانیم،
Rust یک <em>نوع مبهم</em> (opaque type) منحصربه‌فرد ایجاد می‌کند؛
نوعی که نمی‌توانیم جزئیات آن را ببینیم و همچنین نمی‌توانیم نوع تولیدشده توسط Rust را
حدس بزنیم یا خودمان بنویسیم. بنابراین، حتی اگر این توابع کلوزرهایی را بازگردانند
که <code>trait</code> یکسانی مانند <code>Fn(i32) -&gt; i32</code> را پیاده‌سازی می‌کنند،
نوع‌های مبهم تولیدشده توسط Rust برای هر کدام متفاوت‌اند.
(این مشابه نحوه‌ای است که Rust نوع‌های مشخص مختلفی برای بلوک‌های <code>async</code> متمایز تولید می‌کند،
حتی اگر خروجی آن‌ها یکسان باشد، همان‌طور که در بخش
<a href="ch17-03-more-futures.html">“کار با هر تعداد future”</a><!-- ignore --> در فصل ۱۷ دیدیم.)
ما پیش از این نیز چندین بار راه‌حل این مشکل را دیده‌ایم:
می‌توانیم از یک trait object استفاده کنیم، مانند نمونه‌ای که در Listing 20-34 نشان داده شده است.</p>
<figure class="listing" id="listing-20-34">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<figcaption><a href="#listing-20-34">Listing 20-34</a>: ساخت یک <code>Vec&lt;T&gt;</code> از کلوزرهایی که توسط توابعی بازمی‌گردند که مقدار <code>Box&lt;dyn Fn&gt;</code> را برمی‌گردانند تا نوع آن‌ها یکسان باشد</figcaption>
</figure>
<p>این کد بدون مشکل کامپایل خواهد شد. برای اطلاعات بیشتر در مورد trait object‌ها،
به بخش <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“استفاده از trait objectهایی که اجازه استفاده از مقادیر با نوع‌های متفاوت را می‌دهند”</a><!-- ignore -->
در فصل ۱۸ مراجعه کنید.</p>
<p>حال بیایید نگاهی به ماکروها بیندازیم!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-03-advanced-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-05-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-03-advanced-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-05-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
