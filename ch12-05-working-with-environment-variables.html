<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>کار با متغیرهای محیطی - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="کار-با-متغیرهای-محیطی"><a class="header" href="#کار-با-متغیرهای-محیطی">کار با متغیرهای محیطی</a></h2>
<p>ما باینری <code>minigrep</code> را با افزودن یک ویژگی اضافی بهبود می‌دهیم: گزینه‌ای برای جستجوی حساس‌نبودن به حروف کوچک و بزرگ که کاربر می‌تواند از طریق یک متغیر محیطی آن را فعال کند. می‌توانستیم این ویژگی را به‌صورت گزینه‌ای در خط فرمان پیاده‌سازی کنیم و از کاربران بخواهیم که هر بار آن را وارد کنند، اما با استفاده از یک متغیر محیطی، به کاربران اجازه می‌دهیم که فقط یک‌بار این متغیر را تنظیم کنند و در کل آن نشست ترمینال، تمام جستجوهای آن‌ها به‌صورت حساس‌نبودن به حروف انجام شود.</p>
<h3 id="نوشتن-یک-تست-شکستخورده-برای-تابع-search_case_insensitive"><a class="header" href="#نوشتن-یک-تست-شکستخورده-برای-تابع-search_case_insensitive">نوشتن یک تست شکست‌خورده برای تابع <code>search_case_insensitive</code></a></h3>
<p>ابتدا تابع جدیدی به نام <code>search_case_insensitive</code> به کتابخانه <code>minigrep</code> اضافه می‌کنیم که زمانی فراخوانی می‌شود که متغیر محیطی مقدار داشته باشد. ما همچنان از فرایند توسعه آزمون‌محور (TDD) پیروی می‌کنیم، بنابراین گام اول، نوشتن یک تست شکست‌خورده است. یک تست جدید برای تابع <code>search_case_insensitive</code> اضافه می‌کنیم و نام تست قبلی‌مان را از <code>one_result</code> به <code>case_sensitive</code> تغییر می‌دهیم تا تفاوت بین این دو تست واضح‌تر شود، همان‌طور که در لیست 12-20 نشان داده شده است.</p>
<figure class="listing" id="listing-12-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<figcaption><a href="#listing-12-20">Listing 12-20</a>: افزودن یک تست شکست‌خورده جدید برای تابع غیرحساس به حروف کوچک و بزرگ که قصد داریم اضافه کنیم</figcaption>
</figure>
<p>توجه کنید که ما متن تست قدیمی را نیز ویرایش کرده‌ایم. ما یک خط جدید با متن <code>"Duct tape."</code> با
حرف بزرگ <em>D</em> اضافه کرده‌ایم که نباید با عبارت جستجو <code>"duct"</code> در حالت حساس به حروف کوچک و
بزرگ مطابقت داشته باشد. تغییر دادن تست قدیمی به این صورت کمک می‌کند که مطمئن شویم عملکرد
جستجوی حساس به حروف کوچک و بزرگ که قبلاً پیاده‌سازی کرده‌ایم به طور تصادفی شکسته نمی‌شود.
این تست باید اکنون عبور کند و همچنان باید عبور کند در حالی که ما روی جستجوی غیرحساس به حروف
کار می‌کنیم.</p>
<p>تست جدید برای جستجوی غیرحساس به حروف کوچک و بزرگ از <code>"rUsT"</code> به عنوان عبارت جستجو استفاده
می‌کند. در تابع <code>search_case_insensitive</code> که قصد داریم اضافه کنیم، عبارت جستجوی <code>"rUsT"</code>
باید با خط حاوی <code>"Rust:"</code> با حرف بزرگ <em>R</em> و خط <code>"Trust me."</code> مطابقت داشته باشد، حتی اگر هر
دو حالت متفاوتی نسبت به عبارت جستجو داشته باشند. این تست شکست‌خورده ما است و به دلیل اینکه
هنوز تابع <code>search_case_insensitive</code> تعریف نشده است، کامپایل نخواهد شد. می‌توانید یک
پیاده‌سازی موقتی که همیشه یک وکتور خالی برمی‌گرداند اضافه کنید، مشابه کاری که برای تابع
<code>search</code> در لیستینگ 12-16 انجام دادیم تا تست کامپایل شده و شکست بخورد.</p>
<h3 id="پیادهسازی-تابع-search_case_insensitive"><a class="header" href="#پیادهسازی-تابع-search_case_insensitive">پیاده‌سازی تابع <code>search_case_insensitive</code></a></h3>
<p>تابع <code>search_case_insensitive</code> که در لیستینگ 12-21 نشان داده شده است، تقریباً مشابه تابع
<code>search</code> خواهد بود. تنها تفاوت این است که ما عبارت جستجو و هر خط را کوچک‌حرف می‌کنیم تا
صرف‌نظر از مورد ورودی‌ها، هنگام بررسی اینکه آیا خط شامل عبارت جستجو است، هر دو به یک مورد
تبدیل شوند.</p>
<figure class="listing" id="listing-12-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-21">Listing 12-21</a>: تعریف تابع <code>search_case_insensitive</code> برای کوچک‌حرف کردن عبارت جستجو و خط قبل از مقایسه آنها</figcaption>
</figure>
<p>ابتدا رشته <code>query</code> را به حروف کوچک تبدیل می‌کنیم و آن را در متغیر جدیدی با همان نام ذخیره می‌کنیم و مقدار اصلی <code>query</code> را شَدو (shadow) می‌کنیم. فراخوانی <code>to_lowercase</code> بر روی <code>query</code> ضروری است تا صرف‌نظر از این‌که کاربر عبارت مورد جستجوی خود را به صورت <code>"rust"</code>، <code>"RUST"</code>، <code>"Rust"</code> یا <code>"rUsT"</code> وارد کند، ما با آن گویی که <code>"rust"</code> وارد شده است برخورد کنیم و نسبت به حروف کوچک و بزرگ حساس نباشیم. هرچند <code>to_lowercase</code> نگاشت پایه‌ی Unicode را انجام می‌دهد، اما صد درصد دقیق نخواهد بود. اگر قصد نوشتن یک برنامه واقعی را داشتیم، نیاز به کار بیشتری در این بخش بود، اما از آن‌جا که این بخش در مورد متغیرهای محیطی است، نه Unicode، در همین حد باقی می‌مانیم.</p>
<p>توجه کنید که اکنون <code>query</code> یک رشته (<code>String</code>) به جای برش رشته (<code>string slice</code>) است، زیرا
فراخوانی <code>to_lowercase</code> داده‌های جدید ایجاد می‌کند به جای اینکه به داده‌های موجود اشاره کند.
به عنوان مثال، بگویید عبارت جستجو <code>"rUsT"</code> است: آن رشته شامل یک <code>u</code> یا <code>t</code> کوچک نیست که بتوانیم
استفاده کنیم، بنابراین باید یک <code>String</code> جدید شامل <code>"rust"</code> تخصیص دهیم. وقتی اکنون <code>query</code> را
به عنوان یک آرگومان به متد <code>contains</code> منتقل می‌کنیم، نیاز داریم که یک علامت <code>&amp;</code> اضافه کنیم
چون امضای <code>contains</code> به گونه‌ای تعریف شده است که یک برش رشته دریافت می‌کند.</p>
<p>بعداً یک فراخوانی به <code>to_lowercase</code> بر روی هر <code>line</code> اضافه می‌کنیم تا همه کاراکترها کوچک‌حرف
شوند. اکنون که <code>line</code> و <code>query</code> را به کوچک‌حرف تبدیل کرده‌ایم، مطمئن می‌شویم که مطابقت‌ها
صرف‌نظر از مورد عبارت جستجو پیدا شوند.</p>
<p>بیایید ببینیم آیا این پیاده‌سازی تست‌ها را پاس می‌کند یا خیر:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>عالی! تست‌ها پاس شدند. حالا بیایید تابع جدید <code>search_case_insensitive</code> را از تابع <code>run</code>
فراخوانی کنیم. ابتدا یک گزینه پیکربندی به ساختار <code>Config</code> اضافه می‌کنیم تا بین جستجوی حساس
به حروف کوچک و بزرگ و غیرحساس به حروف کوچک و بزرگ سوئیچ کنیم. افزودن این فیلد باعث ایجاد
خطاهای کامپایل می‌شود زیرا هنوز این فیلد را در هیچ جا مقداردهی نکرده‌ایم:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>We added the <code>ignore_case</code> field that holds a Boolean. Next, we need the <code>run</code>
function to check the <code>ignore_case</code> field’s value and use that to decide
whether to call the <code>search</code> function or the <code>search_case_insensitive</code>
function, as shown in Listing 12-22. This still won’t compile yet.</p>
<figure class="listing" id="listing-12-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>use minigrep::{search, search_case_insensitive};

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="#listing-12-22">Listing 12-22</a>: Calling either <code>search</code> or <code>search_case_insensitive</code> based on the value in <code>config.ignore_case</code></figcaption>
</figure>
<p>در نهایت، باید بررسی کنیم که آیا متغیر محیطی تنظیم شده است یا خیر. توابع مربوط به کار با متغیرهای محیطی در ماژول <code>env</code> از کتابخانه استاندارد قرار دارند که در بالای فایل <em>src/main.rs</em> از قبل در scope قرار دارد. برای بررسی اینکه آیا متغیر محیطی‌ای به نام <code>IGNORE_CASE</code> مقداری دارد یا نه، از تابع <code>var</code> در ماژول <code>env</code> استفاده می‌کنیم، همان‌طور که در لیست 12-23 نشان داده شده است.</p>
<figure class="listing" id="listing-12-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-23">Listing 12-23</a>: بررسی وجود مقدار در متغیر محیطی با نام <code>IGNORE_CASE</code></figcaption>
</figure>
<p>اینجا یک متغیر جدید به نام <code>ignore_case</code> ایجاد می‌کنیم. برای مقداردهی آن، تابع <code>env::var</code> را
فراخوانی کرده و نام متغیر محیطی <code>IGNORE_CASE</code> را به آن می‌دهیم. تابع <code>env::var</code> یک <code>Result</code>
برمی‌گرداند که در صورت تنظیم بودن متغیر محیطی به هر مقداری، مقدار <code>Ok</code> با مقدار متغیر محیطی را
دارد. اگر متغیر محیطی تنظیم نشده باشد، مقدار <code>Err</code> برگردانده می‌شود.</p>
<p>ما از متد <code>is_ok</code> روی <code>Result</code> استفاده می‌کنیم تا بررسی کنیم که آیا متغیر محیطی تنظیم شده است،
که نشان می‌دهد برنامه باید جستجو را به صورت غیرحساس به حروف کوچک و بزرگ انجام دهد. اگر متغیر
محیطی <code>IGNORE_CASE</code> به هیچ مقداری تنظیم نشده باشد، <code>is_ok</code> مقدار <code>false</code> برمی‌گرداند و برنامه
جستجو را به صورت حساس به حروف کوچک و بزرگ انجام می‌دهد. ما به مقدار متغیر محیطی نیازی نداریم، فقط
می‌خواهیم بررسی کنیم که آیا تنظیم شده است یا نه. بنابراین از <code>is_ok</code> به جای متدهایی مانند
<code>unwrap</code>، <code>expect</code> یا دیگر متدهای مرتبط با <code>Result</code> استفاده می‌کنیم.</p>
<p>ما مقدار متغیر <code>ignore_case</code> را به نمونه <code>Config</code> منتقل می‌کنیم تا تابع <code>run</code> بتواند این مقدار
را بخواند و تصمیم بگیرد که آیا باید تابع <code>search_case_insensitive</code> یا <code>search</code> را فراخوانی کند.</p>
<h3 id="امتحان-کردن-برنامه"><a class="header" href="#امتحان-کردن-برنامه">امتحان کردن برنامه</a></h3>
<p>حالا بیایید برنامه را امتحان کنیم! ابتدا برنامه را بدون تنظیم متغیر محیطی و با عبارت جستجوی
<code>to</code> اجرا می‌کنیم. این عبارت باید با هر خطی که شامل کلمه <em>to</em> به صورت تمام حروف کوچک باشد،
مطابقت داشته باشد:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
</code></pre>
<p>برنامه همچنان باید به درستی کار کند و تنها خطوطی که کاملاً با عبارت مطابقت دارند را برگرداند.
حالا برنامه را با متغیر محیطی <code>IGNORE_CASE</code> که به مقدار <code>1</code> تنظیم شده است اجرا می‌کنیم و
همان عبارت جستجو <em>to</em> را امتحان می‌کنیم:</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>در صورت استفاده از PowerShell، نیاز است که متغیر محیطی را تنظیم کنید و سپس برنامه را به صورت
دستورات جداگانه اجرا کنید:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>این دستور باعث می‌شود که <code>IGNORE_CASE</code> برای مدت زمان نشست ترمینال شما تنظیم باقی بماند. می‌توانید
آن را با دستور <code>Remove-Item</code> حذف کنید:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>برنامه باید خطوطی که شامل <em>to</em> هستند و ممکن است حروف بزرگ داشته باشند را برگرداند:</p>
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>عالی! حالا برنامه <code>minigrep</code> ما می‌تواند جستجوهای غیرحساس به حروف کوچک و بزرگ را انجام دهد که
با یک متغیر محیطی کنترل می‌شود. حالا شما می‌دانید چگونه گزینه‌هایی را که از طریق آرگومان‌های
خط فرمان یا متغیرهای محیطی تنظیم می‌شوند مدیریت کنید.</p>
<p>برخی برنامه‌ها اجازه می‌دهند که آرگومان‌ها و متغیرهای محیطی برای یک پیکربندی واحد استفاده شوند.
در این موارد، برنامه‌ها تصمیم می‌گیرند که یکی از آن‌ها اولویت داشته باشد. برای تمرین بیشتر،
سعی کنید حساسیت به حروف کوچک و بزرگ را از طریق یک آرگومان خط فرمان یا یک متغیر محیطی کنترل کنید.
تصمیم بگیرید که در صورت تنظیم یکی به حساس و دیگری به غیرحساس بودن، آرگومان خط فرمان یا متغیر
محیطی باید اولویت داشته باشد.</p>
<p>ماژول <code>std::env</code> ویژگی‌های مفید بسیاری برای کار با متغیرهای محیطی دارد: مستندات آن را بررسی کنید
تا ببینید چه امکاناتی در دسترس است.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-06-writing-to-stderr-instead-of-stdout.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
