<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>تعریف و نمونه‌سازی Structها - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="تعریف-و-نمونهسازی-structها"><a class="header" href="#تعریف-و-نمونهسازی-structها">تعریف و نمونه‌سازی Structها</a></h2>
<p>ساختارها مشابه تاپل‌ها هستند که در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> مورد بحث قرار گرفتند، به این معنا که هر دو شامل مقادیر مرتبط متعددی هستند. مانند تاپل‌ها، اجزای یک ساختار می‌توانند از انواع مختلفی باشند. اما برخلاف تاپل‌ها، در یک ساختار شما برای هر جزء داده نام تعیین می‌کنید تا معنای مقادیر روشن‌تر شود. افزودن این نام‌ها باعث می‌شود که ساختارها از تاپل‌ها انعطاف‌پذیرتر باشند: شما مجبور نیستید برای مشخص کردن یا دسترسی به مقادیر یک نمونه به ترتیب داده‌ها تکیه کنید.</p>
<p>برای تعریف یک ساختار، کلمه کلیدی <code>struct</code> را وارد کرده و نام کل ساختار را تعیین می‌کنیم. نام یک ساختار باید توصیف‌کننده اهمیت اجزای داده‌ای باشد که با هم گروه‌بندی می‌شوند. سپس، داخل آکولادها، نام‌ها و انواع اجزای داده‌ای را که به آن‌ها <em>فیلد</em> می‌گوییم، تعریف می‌کنیم. برای مثال، لیست ۵-۱ یک ساختار را نشان می‌دهد که اطلاعات مربوط به یک حساب کاربری را ذخیره می‌کند.</p>
<figure class="listing" id="listing-5-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-5-1">Listing 5-1</a>: تعریف یک ساختار <code>User</code></figcaption>
</figure>
<p>برای استفاده از یک <code>struct</code> پس از تعریف آن، باید یک <em>instance</em> از آن ایجاد کنیم
با مشخص کردن مقادیر مشخص برای هر یک از فیلدها.</p>
<p>برای ساختن یک instance، نام <code>struct</code> را می‌نویسیم
و سپس داخل کروشه‌ها جفت‌های <em><code>کلید: مقدار</code></em> قرار می‌دهیم؛
که در آن‌ها، کلیدها نام فیلدها هستند و مقادیر، داده‌هایی هستند که می‌خواهیم در آن فیلدها ذخیره کنیم.</p>
<p>لازم نیست فیلدها را به همان ترتیبی بنویسیم که در تعریف struct آمده‌اند.</p>
<p>به عبارت دیگر، تعریف <code>struct</code> مانند یک الگوی کلی برای نوع داده است
و instanceها آن الگو را با داده‌های مشخص پر می‌کنند تا مقادیر آن نوع را بسازند.</p>
<p>برای نمونه، می‌توانیم یک کاربر خاص را همان‌طور که در لیست ۵-۲ نشان داده شده تعریف کنیم.</p>
<figure class="listing" id="listing-5-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-2">Listing 5-2</a>: ایجاد یک نمونه از ساختار <code>User</code></figcaption>
</figure>
<p>برای به‌دست‌آوردن مقدار خاصی از یک ساختار، از نشانه‌گذاری نقطه استفاده می‌کنیم. به عنوان مثال، برای دسترسی به آدرس ایمیل این کاربر، از <code>user1.email</code> استفاده می‌کنیم. اگر نمونه قابل تغییر باشد، می‌توانیم مقدار را با استفاده از نشانه‌گذاری نقطه تغییر داده و در یک فیلد خاص مقداردهی کنیم. لیست ۵-۳ نشان می‌دهد که چگونه مقدار در فیلد <code>email</code> یک نمونه قابل تغییر <code>User</code> را تغییر دهیم.</p>
<figure class="listing" id="listing-5-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<figcaption><a href="#listing-5-3">Listing 5-3</a>: تغییر مقدار در فیلد <code>email</code> یک نمونه <code>User</code></figcaption>
</figure>
<p>توجه داشته باشید که کل نمونه باید قابل تغییر باشد؛ Rust به ما اجازه نمی‌دهد که فقط برخی از فیلدها را به صورت قابل تغییر علامت‌گذاری کنیم. مانند هر عبارت دیگری، می‌توانیم یک نمونه جدید از ساختار را به عنوان آخرین عبارت در بدنه یک تابع بسازیم تا به طور ضمنی آن نمونه جدید را بازگردانیم.</p>
<p>لیست ۵-۴ یک تابع <code>build_user</code> را نشان می‌دهد که یک نمونه از <code>User</code> را با ایمیل و نام کاربری مشخص برمی‌گرداند. فیلد <code>active</code> مقدار <code>true</code> می‌گیرد و <code>sign_in_count</code> مقدار <code>1</code> دریافت می‌کند.</p>
<figure class="listing" id="listing-5-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-5-4">Listing 5-4</a>: یک تابع <code>build_user</code> که یک ایمیل و نام کاربری می‌گیرد و یک نمونه <code>User</code> را بازمی‌گرداند</figcaption>
</figure>
<p>نوشتن نام پارامترهای تابع با همان نام فیلدهای ساختار منطقی است، اما تکرار نام‌های <code>email</code> و <code>username</code> برای هر دو فیلد و متغیرها کمی خسته‌کننده است. اگر ساختار فیلدهای بیشتری داشت، تکرار هر نام حتی آزاردهنده‌تر می‌شد. خوشبختانه، یک راه میانبر راحت وجود دارد!</p>
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="استفاده-از-میانبر-مقداردهی-فیلد"><a class="header" href="#استفاده-از-میانبر-مقداردهی-فیلد">استفاده از میانبر مقداردهی فیلد</a></h3>
<p>از آنجا که نام پارامترها و نام فیلدهای ساختار دقیقاً یکسان هستند، می‌توانیم از نحو <em>میانبر مقداردهی فیلد</em> برای بازنویسی <code>build_user</code> استفاده کنیم تا همان رفتار را داشته باشد اما تکرار <code>username</code> و <code>email</code> را نداشته باشد، همان‌طور که در لیست ۵-۵ نشان داده شده است.</p>
<figure class="listing" id="listing-5-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-5-5">Listing 5-5</a>: یک تابع <code>build_user</code> که از میانبر مقداردهی فیلد استفاده می‌کند زیرا پارامترهای <code>username</code> و <code>email</code> همان نام فیلدهای ساختار را دارند</figcaption>
</figure>
<p>اینجا، ما یک نمونه جدید از ساختار <code>User</code> می‌سازیم که فیلدی به نام <code>email</code> دارد. ما می‌خواهیم مقدار فیلد <code>email</code> را به مقداری که در پارامتر <code>email</code> تابع <code>build_user</code> وجود دارد تنظیم کنیم. از آنجا که فیلد <code>email</code> و پارامتر <code>email</code> نام یکسانی دارند، فقط نیاز داریم <code>email</code> بنویسیم، نه <code>email: email</code>.</p>
<h3 id="ایجاد-نمونهها-از-نمونههای-دیگر-با-استفاده-از-نحو-بهروزرسانی-struct"><a class="header" href="#ایجاد-نمونهها-از-نمونههای-دیگر-با-استفاده-از-نحو-بهروزرسانی-struct">ایجاد نمونه‌ها از نمونه‌های دیگر با استفاده از نحو به‌روزرسانی Struct</a></h3>
<p>اغلب مفید است که یک instance جدید از یک <code>struct</code> ایجاد کنیم
که بیشتر مقادیر آن از یک instance دیگر با همان نوع گرفته شده باشد،
اما برخی از مقادیر آن تغییر کرده باشند.
برای انجام این کار می‌توانید از <em>syntax به‌روزرسانی struct</em> استفاده کنید.</p>
<p>ابتدا، در لیست ۵-۶ نشان داده شده است که چگونه می‌توان یک نمونه جدید <code>User</code> در <code>user2</code> ایجاد کرد، بدون استفاده از نحو به‌روزرسانی. ما یک مقدار جدید برای <code>email</code> تنظیم می‌کنیم اما در غیر این صورت از همان مقادیر در <code>user1</code> که قبلاً در لیست ۵-۲ ایجاد شده است، استفاده می‌کنیم.</p>
<figure class="listing" id="listing-5-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-6">Listing 5-6</a>: ایجاد یک نمونه جدید <code>User</code> با استفاده از تمام مقادیر به جز یکی از <code>user1</code></figcaption>
</figure>
<p>با استفاده از نحو به‌روزرسانی Struct، می‌توانیم همان نتیجه را با کد کمتری به دست آوریم، همان‌طور که در لیست ۵-۷ نشان داده شده است. نحو <code>..</code> مشخص می‌کند که فیلدهای باقی‌مانده‌ای که به صورت صریح تنظیم نشده‌اند باید همان مقادیری را داشته باشند که در نمونه داده شده هستند.</p>
<figure class="listing" id="listing-5-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-7">Listing 5-7</a>: استفاده از نحو به‌روزرسانی Struct برای تنظیم یک مقدار جدید <code>email</code> برای یک نمونه <code>User</code> اما استفاده از مقادیر باقی‌مانده از <code>user1</code></figcaption>
</figure>
<p>کد در لیست ۵-۷ همچنین نمونه‌ای در <code>user2</code> ایجاد می‌کند که مقدار متفاوتی برای <code>email</code> دارد اما دارای مقادیر مشابهی برای فیلدهای <code>username</code>، <code>active</code> و <code>sign_in_count</code> از <code>user1</code> است. <code>..user1</code> باید در انتها بیاید تا مشخص کند که فیلدهای باقی‌مانده باید مقادیر خود را از فیلدهای مربوطه در <code>user1</code> دریافت کنند، اما می‌توانیم مقادیر را برای هر تعداد فیلدی که می‌خواهیم به هر ترتیبی مشخص کنیم، بدون توجه به ترتیب فیلدها در تعریف ساختار.</p>
<p>توجه داشته باشید که نحو به‌روزرسانی struct از <code>=</code> مانند عمل انتساب استفاده می‌کند؛
زیرا داده را <em>منتقل</em> می‌کند، همان‌طور که در بخش <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">«تعامل متغیرها و داده‌ها با Move»</a><!-- ignore --> دیدیم.
در این مثال، پس از ایجاد <code>user2</code> دیگر نمی‌توانیم از <code>user1</code> استفاده کنیم
چون <code>String</code> موجود در فیلد <code>username</code> از <code>user1</code> به <code>user2</code> منتقل شده است.
اگر برای <code>user2</code> مقادیر جدیدی از نوع <code>String</code> برای هر دو فیلد <code>email</code> و <code>username</code> مشخص کرده بودیم
و تنها از مقادیر <code>active</code> و <code>sign_in_count</code> از <code>user1</code> استفاده کرده بودیم،
آنگاه <code>user1</code> پس از ساختن <code>user2</code> همچنان معتبر باقی می‌ماند.
زیرا <code>active</code> و <code>sign_in_count</code> از نوع‌هایی هستند که <code>Copy</code> trait را پیاده‌سازی می‌کنند،
و بنابراین رفتاری که در بخش <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">«داده‌های فقط-پشته: Copy»</a><!-- ignore --> توضیح دادیم، اعمال می‌شود.
در این مثال، همچنان می‌توانیم از <code>user1.email</code> استفاده کنیم،
چون مقدار آن از <code>user1</code> خارج نشده است.</p>
<h3 id="استفاده-از-ساختارهای-tuple-بدون-فیلدهای-نامگذاریشده-برای-ایجاد-انواع-مختلف"><a class="header" href="#استفاده-از-ساختارهای-tuple-بدون-فیلدهای-نامگذاریشده-برای-ایجاد-انواع-مختلف">استفاده از ساختارهای Tuple بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف</a></h3>
<p>Rust همچنین از ساختارهایی که شبیه تاپل‌ها هستند پشتیبانی می‌کند که به آن‌ها <em>ساختارهای Tuple</em> می‌گویند. ساختارهای Tuple به دلیل نام ساختار معنای بیشتری دارند اما نام‌هایی برای فیلدهای خود ندارند؛ بلکه فقط نوع فیلدها را دارند. ساختارهای Tuple زمانی مفید هستند که بخواهید به کل تاپل یک نام بدهید و آن را به عنوان نوعی متفاوت از تاپل‌های دیگر مشخص کنید، و وقتی نام‌گذاری هر فیلد مانند یک ساختار معمولی طولانی یا زائد باشد.</p>
<p>برای تعریف یک ساختار Tuple، با کلمه کلیدی <code>struct</code> و نام ساختار شروع کنید و سپس نوع‌های موجود در تاپل را مشخص کنید. به عنوان مثال، در اینجا ما دو ساختار Tuple به نام‌های <code>Color</code> و <code>Point</code> تعریف و استفاده کرده‌ایم:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</figure>
<p>توجه داشته باشید که مقادیر <code>black</code> و <code>origin</code> از انواع متفاوتی هستند
چون آن‌ها instanceهای دو <code>tuple struct</code> مختلف‌اند.
هر <code>struct</code>ای که تعریف می‌کنید، نوع خاص خود را دارد،
حتی اگر فیلدهای داخل آن <code>struct</code> نوع‌های یکسانی داشته باشند.
برای مثال، یک تابع که پارامتری از نوع <code>Color</code> می‌گیرد،
نمی‌تواند یک <code>Point</code> را به عنوان آرگومان دریافت کند،
حتی اگر هر دو نوع از سه مقدار <code>i32</code> تشکیل شده باشند.
به جز این مورد، <code>tuple struct</code>ها شبیه به <code>tuple</code>ها هستند
از این جهت که می‌توانید آن‌ها را به اجزای منفردشان destructure کنید،
و با استفاده از <code>.</code> و اندیس، به مقدار خاصی دسترسی پیدا کنید.
برخلاف <code>tuple</code>ها، <code>tuple struct</code>ها نیاز دارند که هنگام destructure کردن،
نام نوع struct را مشخص کنید.
برای مثال، برای destructure کردن مقادیر موجود در <code>origin</code> به متغیرهای <code>x</code>، <code>y</code> و <code>z</code>،
باید بنویسیم: <code>let Point(x, y, z) = origin;</code></p>
<h3 id="ساختارهای-شبیه-به-unit-بدون-هیچ-فیلدی"><a class="header" href="#ساختارهای-شبیه-به-unit-بدون-هیچ-فیلدی">ساختارهای شبیه به Unit بدون هیچ فیلدی</a></h3>
<p>شما همچنین می‌توانید ساختارهایی تعریف کنید که هیچ فیلدی ندارند! این‌ها به عنوان <em>ساختارهای شبیه Unit</em> شناخته می‌شوند زیرا شبیه به نوع <code>()</code>، نوع Unit، رفتار می‌کنند که در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> مورد اشاره قرار گرفت. ساختارهای شبیه Unit زمانی مفید هستند که نیاز به پیاده‌سازی یک ویژگی بر روی یک نوع داشته باشید اما هیچ داده‌ای برای ذخیره در خود نوع نداشته باشید. ما ویژگی‌ها را در فصل ۱۰ بحث خواهیم کرد. در اینجا مثالی از اعلام و نمونه‌سازی یک ساختار شبیه Unit به نام <code>AlwaysEqual</code> آورده شده است:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</figure>
<p>برای تعریف <code>AlwaysEqual</code>، از کلمه کلیدی <code>struct</code>، نام دلخواه و سپس یک نقطه ویرگول استفاده می‌کنیم. نیازی به آکولاد یا پرانتز نیست! سپس می‌توانیم یک نمونه از <code>AlwaysEqual</code> را در متغیر <code>subject</code> با استفاده از همان نامی که تعریف کرده‌ایم، بدون هیچ آکولاد یا پرانتزی دریافت کنیم. تصور کنید که در آینده رفتاری را برای این نوع پیاده‌سازی خواهیم کرد که همه نمونه‌های <code>AlwaysEqual</code> همیشه با تمام نمونه‌های دیگر برابر باشند، شاید برای داشتن نتیجه‌ای مشخص برای اهداف آزمایشی. برای پیاده‌سازی آن رفتار نیازی به هیچ داده‌ای نداریم! شما در فصل ۱۰ خواهید دید که چگونه می‌توانید ویژگی‌ها را تعریف و آن‌ها را بر روی هر نوعی، از جمله ساختارهای شبیه به Unit، پیاده‌سازی کنید.</p>
<section class="note" aria-role="note">
<h3 id="مالکیت-دادههای-struct"><a class="header" href="#مالکیت-دادههای-struct">مالکیت داده‌های Struct</a></h3>
<p>در تعریف ساختار <code>User</code> در لیست ۵-۱، ما از نوع مالک <code>String</code> به جای نوع برش رشته <code>&amp;str</code> استفاده کردیم. این یک انتخاب عمدی است زیرا ما می‌خواهیم هر نمونه از این ساختار همه داده‌های خود را مالک باشد و این داده‌ها به مدت زمانی که کل ساختار معتبر است، معتبر باقی بمانند.</p>
<p>همچنین ممکن است ساختارهایی وجود داشته باشند که به داده‌های متعلق به چیز دیگری ارجاع می‌دهند، اما برای انجام این کار نیاز به استفاده از <em>طول عمر‌ها</em> داریم، یک ویژگی از Rust که ما در فصل ۱۰ مورد بحث قرار خواهیم داد. طول عمرها اطمینان حاصل می‌کنند که داده‌هایی که توسط یک ساختار ارجاع داده شده‌اند تا زمانی که ساختار معتبر است، معتبر باقی می‌مانند. بیایید بگوییم شما سعی دارید یک ارجاع را در یک ساختار ذخیره کنید بدون اینکه طول عمرها را مشخص کنید، مانند مثال زیر؛ این کار نخواهد کرد:</p>
</section>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</figure>
<p>کامپایلر شکایت خواهد کرد که به مشخص‌کننده‌های طول عمر نیاز دارد:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>در فصل ۱۰، ما بحث خواهیم کرد که چگونه این خطاها را برطرف کنید تا بتوانید ارجاع‌ها را در ساختارها ذخیره کنید، اما در حال حاضر، ما این خطاها را با استفاده از انواع مالک مانند <code>String</code> به جای ارجاع‌ها مانند <code>&amp;str</code> برطرف خواهیم کرد.</p>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
