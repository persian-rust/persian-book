<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>یک برنامه نمونه با استفاده از Structها - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="یک-برنامه-نمونه-با-استفاده-از-structها"><a class="header" href="#یک-برنامه-نمونه-با-استفاده-از-structها">یک برنامه نمونه با استفاده از Structها</a></h2>
<p>برای درک بهتر زمانی که ممکن است بخواهیم از ساختارها استفاده کنیم، بیایید یک برنامه بنویسیم که مساحت یک مستطیل را محاسبه کند. ما ابتدا با استفاده از متغیرهای جداگانه شروع می‌کنیم و سپس برنامه را بازنویسی می‌کنیم تا از ساختارها استفاده کند.</p>
<p>بیایید یک پروژه باینری جدید با Cargo به نام <em>rectangles</em> ایجاد کنیم که عرض و ارتفاع یک مستطیل را بر حسب پیکسل مشخص کرده و مساحت آن را محاسبه کند. لیست ۵-۸ یک برنامه کوتاه نشان می‌دهد که دقیقاً همین کار را در فایل <em>src/main.rs</em> پروژه ما انجام می‌دهد.</p>
<figure class="listing" id="listing-5-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<figcaption><a href="#listing-5-8">Listing 5-8</a>: محاسبه مساحت یک مستطیل که با متغیرهای عرض و ارتفاع جداگانه مشخص شده است</figcaption>
</figure>
<p>اکنون، این برنامه را با استفاده از دستور <code>cargo run</code> اجرا کنید:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>این کد با فراخوانی تابع <code>area</code> با هر یک از ابعاد موفق به محاسبه مساحت مستطیل می‌شود، اما می‌توانیم این کد را خواناتر و قابل درک‌تر کنیم.</p>
<p>مشکل این کد در امضای تابع <code>area</code> مشخص است:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>تابع <code>area</code> قرار است مساحت یک مستطیل را محاسبه کند، اما تابعی که نوشتیم دو پارامتر دارد و هیچ‌کجا در برنامه مشخص نیست که این پارامترها به هم مرتبط هستند. بهتر است عرض و ارتفاع را به صورت گروهی تعریف کنیم تا خوانایی و مدیریت کد بهتر شود. یکی از روش‌هایی که قبلاً در بخش <a href="ch03-02-data-types.html#the-tuple-type">«نوع Tuple»</a><!-- ignore --> فصل ۳ بحث کردیم این است که از تاپل‌ها استفاده کنیم.</p>
<h3 id="بازنویسی-با-استفاده-از-tupleها"><a class="header" href="#بازنویسی-با-استفاده-از-tupleها">بازنویسی با استفاده از Tupleها</a></h3>
<p>لیست ۵-۹ نسخه دیگری از برنامه ما را نشان می‌دهد که از تاپل‌ها استفاده می‌کند.</p>
<figure class="listing" id="listing-5-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<figcaption><a href="#listing-5-9">Listing 5-9</a>: مشخص کردن عرض و ارتفاع مستطیل با یک Tuple</figcaption>
</figure>
<p>از یک منظر، این برنامه بهتر است. تاپل‌ها کمی ساختار اضافه می‌کنند و اکنون ما فقط یک آرگومان ارسال می‌کنیم. اما از منظر دیگر، این نسخه کمتر واضح است: تاپل‌ها اجزای خود را نام‌گذاری نمی‌کنند، بنابراین باید به بخش‌های تاپل با استفاده از ایندکس‌ها دسترسی پیدا کنیم که محاسبات ما را کمتر شفاف می‌کند.</p>
<p>اگر بخواهیم مستطیل را روی صفحه نمایش بکشیم، جابه‌جایی عرض و ارتفاع اهمیتی ندارد، اما برای رسم آن اهمیت پیدا می‌کند! ما باید به خاطر داشته باشیم که <code>width</code> ایندکس <code>0</code> تاپل و <code>height</code> ایندکس <code>1</code> تاپل است. این کار حتی برای کسی که از کد ما استفاده می‌کند سخت‌تر خواهد بود و به اشتباهات بیشتری منجر می‌شود. چون معنای داده‌های ما در کد مشخص نشده است، احتمال خطا بیشتر می‌شود.</p>
<h3 id="بازنویسی-با-استفاده-از-structها-افزودن-معنای-بیشتر"><a class="header" href="#بازنویسی-با-استفاده-از-structها-افزودن-معنای-بیشتر">بازنویسی با استفاده از Structها: افزودن معنای بیشتر</a></h3>
<p>ما از ساختارها استفاده می‌کنیم تا با نام‌گذاری داده‌ها، معنای بیشتری به آن‌ها بدهیم. می‌توانیم تاپلی که استفاده می‌کنیم را به یک ساختار تبدیل کنیم که برای کل داده‌ها یک نام و همچنین برای بخش‌های مختلف آن نام‌هایی مشخص کنیم، همان‌طور که در لیست ۵-۱۰ نشان داده شده است.</p>
<figure class="listing" id="listing-5-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<figcaption><a href="#listing-5-10">Listing 5-10</a>: تعریف یک ساختار <code>Rectangle</code></figcaption>
</figure>
<p>در این‌جا یک <code>struct</code> تعریف کرده‌ایم و نام آن را <code>Rectangle</code> گذاشته‌ایم.<br />
درون آکولادها، فیلدهایی با نام‌های <code>width</code> و <code>height</code> تعریف کرده‌ایم<br />
که هر دو دارای نوع <code>u32</code> هستند. سپس، در تابع <code>main</code>، یک نمونه خاص از <code>Rectangle</code> ایجاد کرده‌ایم<br />
که <code>width</code> آن برابر با <code>30</code> و <code>height</code> آن برابر با <code>50</code> است.</p>
<p>تابع <code>area</code> ما اکنون با یک پارامتر تعریف شده است که آن را <code>rectangle</code> نامیده‌ایم و نوع آن یک ارجاع غیرقابل تغییر به یک نمونه از ساختار <code>Rectangle</code> است. همان‌طور که در فصل ۴ اشاره شد، ما می‌خواهیم ساختار را قرض بگیریم نه اینکه مالکیت آن را بگیریم. به این ترتیب، <code>main</code> مالکیت خود را حفظ می‌کند و می‌تواند همچنان از <code>rect1</code> استفاده کند. به همین دلیل است که از <code>&amp;</code> در امضای تابع و در جایی که تابع را فراخوانی می‌کنیم استفاده می‌کنیم.</p>
<p>تابع <code>area</code> به فیلدهای <code>width</code> و <code>height</code> در نمونه <code>Rectangle</code> دسترسی پیدا می‌کند (توجه داشته باشید که دسترسی به فیلدهای یک نمونه قرض‌گرفته‌شده باعث انتقال مقادیر فیلدها نمی‌شود، به همین دلیل است که اغلب قرض‌گیری ساختارها را مشاهده می‌کنید). امضای تابع <code>area</code> ما اکنون دقیقاً همان چیزی را می‌گوید که منظور ماست: مساحت <code>Rectangle</code> را با استفاده از فیلدهای <code>width</code> و <code>height</code> آن محاسبه کن. این کار نشان می‌دهد که عرض و ارتفاع به یکدیگر مرتبط هستند و نام‌های توصیفی به مقادیر می‌دهد، به جای استفاده از مقادیر ایندکس تاپل‌ها مانند <code>0</code> و <code>1</code>. این یک پیروزی برای شفافیت است.</p>
<h3 id="افزودن-قابلیتهای-مفید-با-traits-مشتقشده"><a class="header" href="#افزودن-قابلیتهای-مفید-با-traits-مشتقشده">افزودن قابلیت‌های مفید با Traits مشتق‌شده</a></h3>
<p>زمانی که در حال اشکال‌زدایی برنامه خود هستیم، مفید است که بتوانیم نمونه‌ای از <code>Rectangle</code> را چاپ کرده و مقادیر تمام فیلدهای آن را ببینیم. لیست ۵-۱۱ تلاش می‌کند با استفاده از ماکروی <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore --> که در فصل‌های قبلی استفاده کرده‌ایم، این کار را انجام دهد. با این حال، این کار موفق نخواهد بود.</p>
<figure class="listing" id="listing-5-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1}");
}</code></pre>
<figcaption><a href="#listing-5-11">Listing 5-11</a>: تلاش برای چاپ یک نمونه از <code>Rectangle</code></figcaption>
</figure>
<p>وقتی این کد را کامپایل می‌کنیم، با خطایی مواجه می‌شویم که پیام اصلی آن به این صورت است:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>ماکروی <code>println!</code> می‌تواند بسیاری از انواع فرمت‌بندی را انجام دهد، و به صورت پیش‌فرض، آکولادها به <code>println!</code> می‌گویند که از فرمت‌بندی‌ای که به نام <code>Display</code> شناخته می‌شود استفاده کند: خروجی‌ای که برای مصرف مستقیم کاربر نهایی در نظر گرفته شده است. انواع ابتدایی که تاکنون دیده‌ایم به صورت پیش‌فرض ویژگی <code>Display</code> را پیاده‌سازی می‌کنند زیرا تنها یک روش برای نمایش یک مقدار مانند <code>1</code> یا هر نوع ابتدایی دیگری به کاربر وجود دارد. اما با ساختارها، روش فرمت‌بندی خروجی کمتر واضح است زیرا امکانات بیشتری برای نمایش وجود دارد: آیا می‌خواهید از ویرگول استفاده شود یا خیر؟ آیا می‌خواهید آکولادها چاپ شوند؟ آیا تمام فیلدها باید نشان داده شوند؟ به دلیل این ابهام، Rust سعی نمی‌کند حدس بزند که ما چه می‌خواهیم، و ساختارها پیاده‌سازی‌ای برای <code>Display</code> ندارند که بتوان با <code>println!</code> و جایگزین <code>{}</code> استفاده کرد.</p>
<p>اگر به خواندن خطاها ادامه دهیم، به این یادداشت مفید خواهیم رسید:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>بیایید آن را امتحان کنیم! اکنون فراخوانی ماکروی <code>println!</code> به صورت <code>println!("rect1 is {rect1:?}");</code> خواهد بود. قرار دادن مشخص‌کننده <code>:?</code> داخل آکولادها به <code>println!</code> می‌گوید که می‌خواهیم از یک فرمت خروجی به نام <code>Debug</code> استفاده کنیم. ویژگی <code>Debug</code> به ما اجازه می‌دهد تا ساختار خود را به روشی که برای توسعه‌دهندگان مفید است چاپ کنیم تا مقدار آن را هنگام اشکال‌زدایی کد خود ببینیم.</p>
<p>کد را با این تغییر کامپایل کنید. خب، باز هم یک خطا دریافت می‌کنیم:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>اما باز هم کامپایلر یادداشتی مفید به ما می‌دهد:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>در واقع</em> قابلیت چاپ اطلاعات اشکال‌زدایی را دارد، اما باید به صورت صریح این قابلیت را برای ساختار خود فعال کنیم. برای انجام این کار، ویژگی بیرونی <code>#[derive(Debug)]</code> را دقیقاً قبل از تعریف ساختار اضافه می‌کنیم، همان‌طور که در لیست ۵-۱۲ نشان داده شده است.</p>
<figure class="listing" id="listing-5-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<figcaption><a href="#listing-5-12">Listing 5-12</a>: افزودن ویژگی برای مشتق کردن <code>Debug</code> و چاپ نمونه <code>Rectangle</code> با استفاده از فرمت اشکال‌زدایی</figcaption>
</figure>
<p>اکنون وقتی برنامه را اجرا می‌کنیم، هیچ خطایی دریافت نخواهیم کرد و خروجی زیر را خواهیم دید:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>عالی! این خروجی ممکن است زیباترین نباشد، اما مقادیر تمام فیلدها را برای این نمونه نشان می‌دهد که قطعاً در هنگام اشکال‌زدایی کمک می‌کند. زمانی که ساختارهای بزرگ‌تری داریم، مفید است که خروجی کمی آسان‌تر خوانده شود؛ در چنین مواردی می‌توانیم به جای <code>{:?}</code> از <code>{:#?}</code> در رشته <code>println!</code> استفاده کنیم. در این مثال، استفاده از سبک <code>{:#?}</code> خروجی زیر را ایجاد خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>روش دیگر برای چاپ مقدار با استفاده از فرمت <code>Debug</code>، استفاده از ماکروی <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a><!-- ignore --> است که مالکیت یک عبارت را می‌گیرد (برخلاف <code>println!</code>، که ارجاع می‌گیرد)، فایل و شماره خطی که فراخوانی <code>dbg!</code> در آن اتفاق می‌افتد همراه با مقدار حاصل از آن عبارت را چاپ می‌کند و مالکیت مقدار را بازمی‌گرداند.</p>
<p>Here is the continuation of the translation for <strong>“ch05-02-example-structs.md”</strong> into Persian:</p>
<p>در اینجا مثالی آورده شده است که در آن ما به مقدار اختصاص داده شده به فیلد <code>width</code> و همچنین مقدار کل ساختار در <code>rect1</code> علاقه‌مند هستیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>ما می‌توانیم <code>dbg!</code> را در اطراف عبارت <code>30 * scale</code> قرار دهیم و چون <code>dbg!</code> مالکیت مقدار عبارت را بازمی‌گرداند، فیلد <code>width</code> همان مقداری را خواهد داشت که اگر فراخوانی <code>dbg!</code> در آنجا وجود نداشت. ما نمی‌خواهیم <code>dbg!</code> مالکیت <code>rect1</code> را بگیرد، بنابراین از یک ارجاع به <code>rect1</code> در فراخوانی بعدی استفاده می‌کنیم. در اینجا خروجی این مثال آورده شده است:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>می‌توانیم ببینیم که اولین بخش خروجی از خط ۱۰ در <em>src/main.rs</em> آمده است، جایی که ما در حال اشکال‌زدایی عبارت <code>30 * scale</code> هستیم، و مقدار حاصل آن <code>60</code> است (فرمت‌بندی <code>Debug</code> که برای اعداد صحیح پیاده‌سازی شده است فقط مقدار آن‌ها را چاپ می‌کند). فراخوانی <code>dbg!</code> در خط ۱۴ از <em>src/main.rs</em> مقدار <code>&amp;rect1</code> را چاپ می‌کند که ساختار <code>Rectangle</code> است. این خروجی از فرمت‌بندی زیبا و مفید <code>Debug</code> برای نوع <code>Rectangle</code> استفاده می‌کند. ماکروی <code>dbg!</code> می‌تواند در هنگام تلاش برای درک رفتار کدتان بسیار مفید باشد!</p>
<p>علاوه بر ویژگی <code>Debug</code>، Rust تعدادی ویژگی برای ما فراهم کرده است که می‌توانیم با استفاده از ویژگی <code>derive</code> آن‌ها را به نوع‌های سفارشی خود اضافه کنیم و رفتار مفیدی ارائه دهند. این ویژگی‌ها و رفتار آن‌ها در <a href="appendix-03-derivable-traits.html">ضمیمه ج</a><!-- ignore --> فهرست شده‌اند. ما در فصل ۱۰ به نحوه پیاده‌سازی این ویژگی‌ها با رفتار سفارشی و همچنین نحوه ایجاد ویژگی‌های خود می‌پردازیم. همچنین بسیاری از ویژگی‌های دیگر به غیر از <code>derive</code> وجود دارند؛ برای اطلاعات بیشتر، به <a href="../reference/attributes.html">بخش «ویژگی‌ها» در مرجع Rust</a> مراجعه کنید.</p>
<p>تابع <code>area</code> ما بسیار خاص است: فقط مساحت مستطیل‌ها را محاسبه می‌کند. مفید خواهد بود اگر این رفتار را به صورت نزدیک‌تر با ساختار <code>Rectangle</code> مرتبط کنیم، زیرا این تابع با هیچ نوع دیگری کار نخواهد کرد. بیایید ببینیم که چگونه می‌توانیم با تبدیل تابع <code>area</code> به یک <em>متد</em> که برای نوع <code>Rectangle</code> تعریف شده است، این کد را بازنویسی کنیم.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-01-defining-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-03-method-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-01-defining-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-03-method-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
