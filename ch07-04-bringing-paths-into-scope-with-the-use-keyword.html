<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>وارد کردن مسیرها با کلمه کلیدی use - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="وارد-کردن-مسیرها-به-محدوده-با-کلمه-کلیدی-use"><a class="header" href="#وارد-کردن-مسیرها-به-محدوده-با-کلمه-کلیدی-use">وارد کردن مسیرها به محدوده با کلمه کلیدی <code>use</code></a></h2>
<p>نوشتن مسیرهای کامل برای فراخوانی توابع می‌تواند خسته‌کننده و تکراری باشد. در لیستینگ 7-7، چه مسیر مطلق یا نسبی را برای تابع <code>add_to_waitlist</code> انتخاب کنیم، هر بار که بخواهیم این تابع را فراخوانی کنیم باید <code>front_of_house</code> و <code>hosting</code> را نیز مشخص کنیم. خوشبختانه، راهی برای ساده‌تر کردن این فرآیند وجود دارد: می‌توانیم یک میانبر به یک مسیر با استفاده از کلمه کلیدی <code>use</code> ایجاد کنیم و سپس در هر جای دیگر محدوده، از نام کوتاه‌تر استفاده کنیم.</p>
<p>در لیستینگ 7-11، ماژول <code>crate::front_of_house::hosting</code> را به محدوده تابع <code>eat_at_restaurant</code> می‌آوریم تا فقط نیاز به مشخص کردن <code>hosting::add_to_waitlist</code> برای فراخوانی تابع <code>add_to_waitlist</code> در <code>eat_at_restaurant</code> داشته باشیم.</p>
<figure class="listing" id="listing-7-11">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-11">Listing 7-11</a>: وارد کردن یک ماژول به محدوده با <code>use</code></figcaption>
</figure>
<p>اضافه کردن <code>use</code> و یک مسیر در یک محدوده مشابه ایجاد یک لینک نمادین در فایل‌سیستم است. با اضافه کردن <code>use crate::front_of_house::hosting</code> در ریشه جعبه (crate)، <code>hosting</code> اکنون یک نام معتبر در آن محدوده است، درست مانند اینکه ماژول <code>hosting</code> در ریشه جعبه (crate) تعریف شده باشد. مسیرهایی که با <code>use</code> به محدوده آورده می‌شوند مانند هر مسیر دیگری حریم خصوصی را بررسی می‌کنند.</p>
<p>توجه کنید که <code>use</code> فقط میانبر را برای محدوده خاصی که در آن <code>use</code> استفاده شده ایجاد می‌کند. لیستینگ 7-12 تابع <code>eat_at_restaurant</code> را به یک زیرماژول جدید به نام <code>customer</code> منتقل می‌کند که سپس یک محدوده متفاوت از دستور <code>use</code> است، بنابراین بدنه تابع کامپایل نمی‌شود.</p>
<figure class="listing" id="listing-7-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<figcaption><a href="#listing-7-12">Listing 7-12</a>: دستور <code>use</code> تنها در همان حوزه‌ای (scope) اعمال می‌شود که در آن قرار دارد</figcaption>
</figure>
<p>خطای کامپایلر نشان می‌دهد که میانبر دیگر در ماژول <code>customer</code> اعمال نمی‌شود:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>توجه کنید که همچنین یک هشدار وجود دارد که <code>use</code> دیگر در محدوده خود استفاده نمی‌شود! برای رفع این مشکل، دستور <code>use</code> را نیز به داخل ماژول <code>customer</code> منتقل کنید، یا میانبر را در ماژول والد با <code>super::hosting</code> در داخل ماژول <code>customer</code> ارجاع دهید.</p>
<h3 id="ایجاد-مسیرهای-use-به-صورت-ایدیوماتیک"><a class="header" href="#ایجاد-مسیرهای-use-به-صورت-ایدیوماتیک">ایجاد مسیرهای <code>use</code> به صورت ایدیوماتیک</a></h3>
<p>در لیستینگ 7-11، ممکن است این سوال پیش بیاید که چرا ما <code>use crate::front_of_house::hosting</code> را مشخص کرده‌ایم و سپس <code>hosting::add_to_waitlist</code> را در <code>eat_at_restaurant</code> فراخوانی کرده‌ایم، به جای اینکه مسیر <code>use</code> را تا تابع <code>add_to_waitlist</code> مشخص کنیم تا همان نتیجه را به دست آوریم، همان‌طور که در لیستینگ 7-13 نشان داده شده است.</p>
<figure class="listing" id="listing-7-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-13">Listing 7-13</a>: وارد کردن تابع <code>add_to_waitlist</code> به محدوده با <code>use</code> که غیر ایدیوماتیک است</figcaption>
</figure>
<p>اگرچه هم لیستینگ 7-11 و هم لیستینگ 7-13 کار مشابهی انجام می‌دهند، لیستینگ 7-11 روش ایدیوماتیک برای وارد کردن یک تابع به محدوده با <code>use</code> است. وارد کردن ماژول والد تابع با <code>use</code> به این معنا است که باید ماژول والد را هنگام فراخوانی تابع مشخص کنیم. مشخص کردن ماژول والد هنگام فراخوانی تابع نشان می‌دهد که تابع به صورت محلی تعریف نشده است، در حالی که همچنان تکرار مسیر کامل را به حداقل می‌رساند. کد موجود در لیستینگ 7-13 مشخص نمی‌کند که <code>add_to_waitlist</code> کجا تعریف شده است.</p>
<p>از طرف دیگر، وقتی ساختارها، enumها، و سایر آیتم‌ها را با <code>use</code> وارد می‌کنیم، ایدیوماتیک است که مسیر کامل را مشخص کنیم. لیستینگ 7-14 روش ایدیوماتیک برای وارد کردن ساختار <code>HashMap</code> از کتابخانه استاندارد به محدوده جعبه (crate) باینری را نشان می‌دهد.</p>
<figure class="listing" id="listing-7-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<figcaption><a href="#listing-7-14">Listing 7-14</a>: وارد کردن <code>HashMap</code> به محدوده به روش ایدیوماتیک</figcaption>
</figure>
<p>هیچ دلیل قوی پشت این عرف نیست: این فقط کنوانسیونی است که در جامعه Rust به وجود آمده و افراد به خواندن و نوشتن کد Rust به این روش عادت کرده‌اند.</p>
<p>استثنای این عرف زمانی است که دو آیتم با نام یکسان را با دستورات <code>use</code> وارد محدوده می‌کنیم، زیرا Rust این اجازه را نمی‌دهد. لیستینگ 7-15 نشان می‌دهد که چگونه دو نوع <code>Result</code> را که نام یکسانی دارند اما از ماژول‌های والد متفاوتی می‌آیند وارد محدوده کنیم و چگونه به آن‌ها ارجاع دهیم.</p>
<figure class="listing" id="listing-7-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="#listing-7-15">Listing 7-15</a>: وارد کردن دو نوع با نام یکسان به یک محدوده نیازمند استفاده از ماژول‌های والد آن‌ها است.</figcaption>
</figure>
<p>همان‌طور که می‌بینید، استفاده از ماژول‌های والد دو نوع <code>Result</code> را از هم متمایز می‌کند. اگر به جای آن <code>use std::fmt::Result</code> و <code>use std::io::Result</code> مشخص کنیم، دو نوع <code>Result</code> در یک محدوده خواهیم داشت و Rust نمی‌تواند بفهمد منظور ما از <code>Result</code> کدام است.</p>
<h3 id="ارائه-نامهای-جدید-با-کلمه-کلیدی-as"><a class="header" href="#ارائه-نامهای-جدید-با-کلمه-کلیدی-as">ارائه نام‌های جدید با کلمه کلیدی <code>as</code></a></h3>
<p>یک راه‌حل دیگر برای مشکل وارد کردن دو نوع با نام یکسان به یک محدوده با <code>use</code> این است که پس از مسیر، با استفاده از <code>as</code> یک نام محلی جدید یا <em>نام مستعار</em> برای نوع مشخص کنیم. لیستینگ 7-16 راه دیگری برای نوشتن کد در لیستینگ 7-15 را نشان می‌دهد که در آن یکی از دو نوع <code>Result</code> را با استفاده از <code>as</code> تغییر نام داده‌ایم.</p>
<figure class="listing" id="listing-7-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="#listing-7-16">Listing 7-16</a>: تغییر نام یک نوع هنگام وارد کردن به محدوده با کلمه کلیدی <code>as</code></figcaption>
</figure>
<p>در دستور دوم <code>use</code>، ما نام جدید <code>IoResult</code> را برای نوع <code>std::io::Result</code> انتخاب کردیم، که با نوع <code>Result</code> از <code>std::fmt</code> که آن را نیز وارد محدوده کرده‌ایم، تضاد نخواهد داشت. هر دو لیستینگ 7-15 و 7-16 ایدیوماتیک در نظر گرفته می‌شوند، بنابراین انتخاب با شماست!</p>
<h3 id="دوباره-صادر-کردن-نامها-با-pub-use"><a class="header" href="#دوباره-صادر-کردن-نامها-با-pub-use">دوباره صادر کردن نام‌ها با <code>pub use</code></a></h3>
<p>وقتی با استفاده از کلیدواژه‌ی <code>use</code> یک نام را وارد حوزه‌ای می‌کنیم،<br />
آن نام تنها در همان حوزه خصوصی است که در آن وارد شده است.<br />
برای این‌که کد خارج از آن حوزه نیز بتواند به آن نام دسترسی داشته باشد،<br />
انگار که در همان حوزه تعریف شده است، می‌توانیم <code>pub</code> و <code>use</code> را با هم ترکیب کنیم.<br />
این تکنیک <em>re-exporting</em> نامیده می‌شود، زیرا در حالی که یک آیتم را وارد حوزه می‌کنیم،<br />
همزمان آن را برای دیگران نیز قابل دسترس می‌کنیم تا بتوانند آن را وارد حوزه‌ی خود کنند.</p>
<p>لیستینگ 7-17 کد موجود در لیستینگ 7-11 را با تغییر دستور <code>use</code> در ماژول ریشه به <code>pub use</code> نشان می‌دهد.</p>
<figure class="listing" id="listing-7-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-17">Listing 7-17</a>: در دسترس قرار دادن یک نام برای هر کدی که از محدوده جدید استفاده می‌کند با <code>pub use</code></figcaption>
</figure>
<p>قبل از این تغییر، کد خارجی باید تابع <code>add_to_waitlist</code> را با استفاده از مسیر <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> فراخوانی می‌کرد، که همچنین نیاز داشت ماژول <code>front_of_house</code> به عنوان <code>pub</code> علامت‌گذاری شود. حالا که این <code>pub use</code> ماژول <code>hosting</code> را از ماژول ریشه دوباره صادر کرده است، کد خارجی می‌تواند از مسیر <code>restaurant::hosting::add_to_waitlist()</code> استفاده کند.</p>
<p>Re-exporting زمانی مفید است که ساختار داخلی کد شما با نحوه‌ی تفکر برنامه‌نویسانی که از کد شما استفاده می‌کنند درباره‌ی دامنه، متفاوت باشد.
برای مثال، در این تمثیل رستوران، کسانی که رستوران را اداره می‌کنند درباره‌ی «بخش جلویی» (front of house) و «بخش پشتی» (back of house) فکر می‌کنند.
اما مشتریانی که به رستوران می‌آیند احتمالاً درباره‌ی قسمت‌های رستوران با چنین اصطلاحاتی فکر نمی‌کنند.
با استفاده از <code>pub use</code> می‌توانیم کد خود را با یک ساختار بنویسیم ولی ساختاری متفاوت را در معرض استفاده قرار دهیم.
این کار باعث می‌شود کتابخانه‌ی ما هم برای برنامه‌نویسانی که روی کتابخانه کار می‌کنند و هم برای برنامه‌نویسانی که از آن استفاده می‌کنند، به‌خوبی سازمان‌دهی شده باشد.
در فصل ۱۴، در بخش <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">“صادرات یک API عمومی راحت با استفاده از <code>pub use</code>”</a><!-- ignore -->،
مثال دیگری از <code>pub use</code> و تأثیر آن بر مستندات crate شما را بررسی خواهیم کرد.</p>
<h3 id="استفاده-از-بستههای-خارجی"><a class="header" href="#استفاده-از-بستههای-خارجی">استفاده از بسته‌های خارجی</a></h3>
<p>در فصل ۲، ما یک پروژه بازی حدس‌زنی برنامه‌ریزی کردیم که از یک بسته خارجی به نام <code>rand</code> برای تولید اعداد تصادفی استفاده می‌کرد. برای استفاده از <code>rand</code> در پروژه خود، این خط را به <em>Cargo.toml</em> اضافه کردیم:</p>
<figure class="listing">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</figure>
<p>اضافه کردن <code>rand</code> به عنوان یک وابستگی در <em>Cargo.toml</em> به Cargo می‌گوید که بسته <code>rand</code> و هرگونه وابستگی را از <a href="https://crates.io/">crates.io</a> دانلود کرده و <code>rand</code> را در پروژه ما در دسترس قرار دهد.</p>
<p>سپس، برای وارد کردن تعاریف crate <code>rand</code> به حوزه‌ی پکیج خود،
یک خط <code>use</code> اضافه کردیم که با نام crate، یعنی <code>rand</code>، آغاز شد
و آیتم‌هایی را که می‌خواستیم وارد حوزه کنیم، فهرست کردیم.
به یاد داشته باشید که در بخش <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“تولید یک عدد تصادفی”</a><!-- ignore --> در فصل ۲،
<code>trait</code> مربوط به <code>Rng</code> را وارد حوزه کردیم و تابع <code>rand::thread_rng</code> را فراخوانی نمودیم:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>اعضای جامعه Rust بسیاری از بسته‌ها را در <a href="https://crates.io/">crates.io</a> به اشتراک گذاشته‌اند، و وارد کردن هر یک از آن‌ها به بسته شما شامل این مراحل است: فهرست کردن آن‌ها در فایل <em>Cargo.toml</em> بسته شما و استفاده از <code>use</code> برای وارد کردن آیتم‌ها از جعبه (crate) آن‌ها به محدوده.</p>
<p>توجه داشته باشید که کتابخانه استاندارد <code>std</code> نیز یک جعبه (crate) خارجی برای بسته ما است. از آنجا که کتابخانه استاندارد همراه با زبان Rust ارائه می‌شود، نیازی به تغییر <em>Cargo.toml</em> برای گنجاندن <code>std</code> نداریم. اما برای وارد کردن آیتم‌ها از آن به محدوده بسته خود، باید به آن با <code>use</code> ارجاع دهیم. برای مثال، با <code>HashMap</code> از این خط استفاده می‌کردیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>این یک مسیر مطلق است که با <code>std</code>، نام جعبه (crate) کتابخانه استاندارد، شروع می‌شود.</p>
<h3 id="استفاده-از-مسیرهای-تو-در-تو-برای-سادهسازی-لیستهای-بزرگ-use"><a class="header" href="#استفاده-از-مسیرهای-تو-در-تو-برای-سادهسازی-لیستهای-بزرگ-use">استفاده از مسیرهای تو در تو برای ساده‌سازی لیست‌های بزرگ <code>use</code></a></h3>
<p>اگر از چندین آیتم تعریف‌شده در یک جعبه (crate) یا ماژول استفاده کنیم، فهرست کردن هر آیتم در خط خود می‌تواند فضای عمودی زیادی در فایل‌های ما اشغال کند. برای مثال، این دو دستور <code>use</code> که در بازی حدس‌زنی در لیستینگ ۲-۴ استفاده کردیم آیتم‌هایی از <code>std</code> را به محدوده می‌آورند:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>در عوض، می‌توانیم از مسیرهای تو در تو استفاده کنیم تا همان آیتم‌ها را در یک خط به محدوده بیاوریم. این کار را با مشخص کردن بخش مشترک مسیر، به دنبال آن دو نقطه دوبل و سپس یک لیست از بخش‌های متفاوت مسیرها در داخل آکولاد انجام می‌دهیم، همان‌طور که در لیستینگ 7-18 نشان داده شده است.</p>
<figure class="listing" id="listing-7-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-18">Listing 7-18</a>: مشخص کردن یک مسیر تو در تو برای وارد کردن چندین آیتم با پیشوند مشابه به محدوده</figcaption>
</figure>
<p>در برنامه‌های بزرگ‌تر، وارد کردن بسیاری از آیتم‌ها از یک جعبه (crate) یا ماژول مشابه با استفاده از مسیرهای تو در تو می‌تواند تعداد دستورات <code>use</code> جداگانه مورد نیاز را به طور قابل‌توجهی کاهش دهد.</p>
<p>ما می‌توانیم در هر سطحی از یک مسیر، از یک مسیر تو در تو استفاده کنیم، که این کار در مواقعی که دو دستور <code>use</code> دارای یک زیرمسیر مشترک هستند، مفید است. برای مثال، لیستینگ 7-19 دو دستور <code>use</code> را نشان می‌دهد: یکی که <code>std::io</code> را به محدوده وارد می‌کند و دیگری که <code>std::io::Write</code> را به محدوده وارد می‌کند.</p>
<figure class="listing" id="listing-7-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<figcaption><a href="#listing-7-19">Listing 7-19</a>: دو دستور <code>use</code> که یکی زیرمسیر دیگری است</figcaption>
</figure>
<p>بخش مشترک این دو مسیر، <code>std::io</code> است که مسیر کامل اولین دستور <code>use</code> را تشکیل می‌دهد. برای ترکیب این دو مسیر به یک دستور <code>use</code>، می‌توانیم از <code>self</code> در مسیر تو در تو استفاده کنیم، همان‌طور که در لیستینگ 7-20 نشان داده شده است.</p>
<figure class="listing" id="listing-7-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<figcaption><a href="#listing-7-20">Listing 7-20</a>: ترکیب مسیرهای موجود در لیستینگ 7-19 به یک دستور <code>use</code></figcaption>
</figure>
<p>این خط، <code>std::io</code> و <code>std::io::Write</code> را به محدوده وارد می‌کند.</p>
<h3 id="عملگر-glob"><a class="header" href="#عملگر-glob">عملگر Glob</a></h3>
<p>اگر بخواهیم <em>تمام</em> آیتم‌های عمومی تعریف‌شده در یک مسیر را به محدوده وارد کنیم، می‌توانیم آن مسیر را به همراه عملگر <code>*</code> مشخص کنیم:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>این دستور <code>use</code> تمام آیتم‌های عمومی تعریف‌شده در <code>std::collections</code> را وارد حوزه‌ی فعلی می‌کند.
در استفاده از عملگر glob دقت کنید!
استفاده از glob می‌تواند باعث شود تشخیص این‌که چه نام‌هایی در حوزه هستند
و یک نام استفاده‌شده در برنامه از کجا آمده، دشوارتر شود.
علاوه بر این، اگر وابستگی تغییراتی در تعاریف خود ایجاد کند، آن‌چه شما وارد کرده‌اید نیز تغییر می‌کند،
که ممکن است هنگام به‌روزرسانی وابستگی، باعث بروز خطای کامپایلر شود—
برای مثال، اگر وابستگی تعریفی با همان نامی اضافه کند که شما نیز در همان حوزه تعریف کرده‌اید.</p>
<p>عملگر glob اغلب هنگام تست برای وارد کردن تمام آیتم‌های تحت تست به ماژول <code>tests</code> استفاده می‌شود؛
در فصل ۱۱ در بخش <a href="ch11-01-writing-tests.html#how-to-write-tests">“چگونه تست بنویسیم”</a><!-- ignore --> درباره‌ی آن صحبت خواهیم کرد.
همچنین، عملگر glob گاهی در قالب الگوی prelude نیز به‌کار می‌رود؛
برای اطلاعات بیشتر درباره‌ی این الگو، به <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">مستندات کتابخانه‌ی استاندارد</a><!-- ignore --> مراجعه کنید.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
