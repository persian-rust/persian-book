<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>تمام مکان‌هایی که می‌توان از الگوها استفاده کرد - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="all-the-places-patterns-can-be-used"><a class="header" href="#all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>الگوها در بسیاری از جاها در راست ظاهر می‌شوند، و شما از آن‌ها زیاد استفاده کرده‌اید بدون اینکه متوجه شوید! این بخش تمام جاهایی که الگوها معتبر هستند را بررسی می‌کند.</p>
<h3 id="match-arms"><a class="header" href="#match-arms"><code>match</code> Arms</a></h3>
<p>همان‌طور که در فصل 6 بحث شد، ما از الگوها در بازوهای (arms) عبارات <code>match</code> استفاده می‌کنیم. به‌طور رسمی، عبارات <code>match</code> به‌صورت کلمه کلیدی <code>match</code>، یک مقدار برای مطابقت، و یک یا چند بازوی match که از یک الگو و یک عبارت برای اجرا در صورت مطابقت مقدار با الگوی آن بازو تشکیل شده‌اند، تعریف می‌شوند، مانند این:</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match &lt;em&gt;VALUE&lt;/em&gt; {
    &lt;em&gt;PATTERN&lt;/em&gt; =&gt; &lt;em&gt;EXPRESSION&lt;/em&gt;,
    &lt;em&gt;PATTERN&lt;/em&gt; =&gt; &lt;em&gt;EXPRESSION&lt;/em&gt;,
    &lt;em&gt;PATTERN&lt;/em&gt; =&gt; &lt;em&gt;EXPRESSION&lt;/em&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>برای مثال، در این‌جا عبارت <code>match</code> از لیستینگ 6-5 را داریم که روی یک مقدار از نوع <code>Option&lt;i32&gt;</code> در متغیر <code>x</code> تطبیق انجام می‌دهد:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>الگوها در این عبارت <code>match</code> شامل <code>None</code> و <code>Some(i)</code> هستند که در سمت چپ هر پیکان قرار دارند.</p>
<p>یکی از نیازمندی‌های عبارات <code>match</code> این است که باید به‌صورت <em>کامل</em> باشند، به این معنا که تمام حالات ممکن برای مقدار در عبارت <code>match</code> باید پوشش داده شوند. یکی از راه‌های اطمینان از اینکه همه حالات را پوشش داده‌اید این است که یک الگوی عمومی (catchall) برای بازوی آخر داشته باشید: برای مثال، یک نام متغیر که هر مقداری را مطابقت می‌دهد هرگز شکست نمی‌خورد و بنابراین تمام موارد باقی‌مانده را پوشش می‌دهد.</p>
<p>الگوی خاص <code>_</code> هر چیزی را مطابقت می‌دهد، اما هرگز به یک متغیر متصل نمی‌شود، بنابراین اغلب در بازوی آخر match استفاده می‌شود. الگوی <code>_</code> می‌تواند زمانی مفید باشد که بخواهید هر مقداری که مشخص نشده است را نادیده بگیرید، برای مثال. ما الگوی <code>_</code> را در بخش <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a Pattern”</a><!-- ignore --> بعداً در این فصل به‌طور مفصل بررسی خواهیم کرد.</p>
<h3 id="let-statements"><a class="header" href="#let-statements">let Statements</a></h3>
<p>پیش از این فصل، تنها به‌طور صریح از الگوها در <code>match</code> و <code>if let</code> استفاده کرده بودیم، اما در واقع در بخش‌های دیگری نیز از الگوها استفاده کرده‌ایم، از جمله در دستورات <code>let</code>. برای مثال، این انتساب ساده متغیر با استفاده از <code>let</code> را در نظر بگیرید:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>هر بار که از یک دستور <code>let</code> مانند این استفاده کرده‌اید، در حال استفاده از یک الگو بوده‌اید، حتی اگر متوجه آن نشده باشید! به‌طور رسمی‌تر، یک دستور <code>let</code> به این شکل است:</p>
<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>
<p>در دستوراتی مانند <code>let x = 5;</code> که یک نام متغیر در جایگاه PATTERN قرار دارد، آن نام متغیر در واقع شکل ساده‌ای از یک الگو است. Rust عبارت را با الگو مقایسه می‌کند و هر نامی را که پیدا کند اختصاص می‌دهد. بنابراین، در مثال <code>let x = 5;</code>، <code>x</code> الگویی است که به این معناست: «هر چیزی که این‌جا تطابق دارد را به متغیر <code>x</code> متصل کن.» از آن‌جا که نام <code>x</code> کل الگو را تشکیل می‌دهد، این الگو عملاً به این معناست: «هر چیزی که باشد، آن را به متغیر <code>x</code> متصل کن.»</p>
<p>برای دیدن جنبه‌ی تطبیق الگو در <code>let</code> به‌طور واضح‌تر، به کد موجود در لیست ۱۹-۱ نگاه کنید که از یک الگو با <code>let</code> برای تجزیه‌ی یک tuple استفاده می‌کند.</p>
<figure class="listing" id="listing-19-1">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-19-1">Listing 19-1</a>: استفاده از یک الگو برای تجزیه‌ی یک tuple و ساختن سه متغیر به‌صورت هم‌زمان</figcaption>
</figure>
<p>در این‌جا، ما یک tuple را با یک الگو تطبیق می‌دهیم. Rust مقدار <code>(1, 2, 3)</code> را با الگوی <code>(x, y, z)</code> مقایسه می‌کند و می‌بیند که این مقدار با الگو تطابق دارد، از این جهت که تعداد عناصر در هر دو یکی است. بنابراین Rust مقدار <code>1</code> را به <code>x</code>، مقدار <code>2</code> را به <code>y</code>، و مقدار <code>3</code> را به <code>z</code> اختصاص می‌دهد. می‌توانید این الگوی tuple را به‌عنوان تو در تویی از سه الگوی متغیر مجزا در نظر بگیرید.</p>
<p>اگر تعداد عناصر در الگو با تعداد عناصر در tuple تطابق نداشته باشد، نوع کلی تطابق نخواهد داشت و با خطای کامپایل مواجه خواهیم شد. برای مثال، لیست ۱۹-۲ تلاشی برای تجزیه‌ی یک tuple با سه عنصر به دو متغیر را نشان می‌دهد، که کار نخواهد کرد.</p>
<figure class="listing" id="listing-19-2">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-2">Listing 19-2</a>: ساخت نادرست الگویی که تعداد متغیرهای آن با تعداد عناصر در tuple هم‌خوانی ندارد</figcaption>
</figure>
<p>تلاش برای کامپایل این کد منجر به این خطای نوع می‌شود:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>برای رفع این خطا، می‌توانیم یک یا چند مقدار را با استفاده از <code>_</code> یا <code>..</code> نادیده بگیریم، همان‌طور که در بخش [«نادیده گرفتن مقادیر در یک الگو»][ignoring-values-in-a-pattern]<!-- ignore --> خواهید دید. اگر مشکل این باشد که متغیرهای زیادی در الگو داریم، راه‌حل این است که برخی متغیرها را حذف کنیم تا تعداد متغیرها با تعداد عناصر در tuple برابر شود.</p>
<h3 id="عبارات-شرطی-if-let"><a class="header" href="#عبارات-شرطی-if-let">عبارات شرطی if let</a></h3>
<p>در فصل ۶، در مورد نحوه‌ی استفاده از عبارات <code>if let</code> صحبت کردیم، عمدتاً به‌عنوان راهی کوتاه‌تر برای نوشتن معادل <code>match</code> که تنها یک حالت را تطبیق می‌دهد. به‌صورت اختیاری، <code>if let</code> می‌تواند یک بخش <code>else</code> نیز داشته باشد که در صورت عدم تطابق الگو، کدی را اجرا کند.</p>
<p>لیست ۱۹-۳ نشان می‌دهد که همچنین می‌توانیم <code>if let</code>، <code>else if</code>، و <code>else if let</code> را ترکیب کنیم. این کار انعطاف‌پذیری بیشتری نسبت به یک عبارت <code>match</code> به ما می‌دهد، که در آن تنها می‌توانیم یک مقدار را با الگوها مقایسه کنیم. همچنین، Rust الزام نمی‌کند که شرایط در زنجیره‌ی <code>if let</code>، <code>else if</code>، و <code>else if let</code> به یکدیگر مرتبط باشند.</p>
<p>کد موجود در لیست ۱۹-۳ تعیین می‌کند که پس‌زمینه‌ی شما بر اساس مجموعه‌ای از بررسی‌ها چه رنگی باشد. برای این مثال، متغیرهایی با مقادیر hardcoded ایجاد کرده‌ایم که یک برنامه واقعی ممکن است از ورودی کاربر دریافت کند.</p>
<figure class="listing" id="listing-19-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre></pre>
<figcaption><a href="#listing-19-3">Listing 19-3</a>: ترکیب <code>if let</code>، <code>else if</code>، <code>else if let</code> و <code>else</code></figcaption>
</figure>
<p>اگر کاربر یک رنگ مورد علاقه مشخص کند، از آن رنگ به‌عنوان پس‌زمینه استفاده می‌شود. اگر هیچ رنگ مورد علاقه‌ای مشخص نشده باشد و امروز سه‌شنبه باشد، رنگ پس‌زمینه سبز است. در غیر این صورت، اگر کاربر سن خود را به‌عنوان یک رشته مشخص کند و بتوانیم آن را با موفقیت به یک عدد تبدیل کنیم، رنگ یا بنفش یا نارنجی است، بسته به مقدار عدد. اگر هیچ‌کدام از این شرایط صدق نکند، رنگ پس‌زمینه آبی خواهد بود.</p>
<p>این ساختار شرطی به ما امکان پشتیبانی از نیازهای پیچیده را می‌دهد. با مقادیر سخت‌کدشده‌ای که در اینجا داریم، این مثال پیام <code>Using purple as the background color</code> را چاپ خواهد کرد.</p>
<p>می‌توانید ببینید که <code>if let</code> نیز می‌تواند متغیرهای جدیدی را معرفی کند که متغیرهای موجود را به همان روشی که بازوهای <code>match</code> انجام می‌دهند، پوشش می‌دهند: خط <code>if let Ok(age) = age</code> یک متغیر جدید به نام <code>age</code> معرفی می‌کند که حاوی مقدار داخل حالت <code>Ok</code> است و متغیر موجود <code>age</code> را پوشش می‌دهد. این بدان معناست که باید شرط <code>if age &gt; 30</code> را در داخل آن بلوک قرار دهیم: نمی‌توانیم این دو شرط را به‌صورت <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> ترکیب کنیم. متغیر جدید <code>age</code> که می‌خواهیم با 30 مقایسه کنیم تا شروع محدوده جدید با آکولاد معتبر نیست.</p>
<p>نقطه ضعف استفاده از عبارات <code>if let</code> این است که کامپایلر بررسی نمی‌کند که آیا همه حالات پوشش داده شده‌اند یا خیر، در حالی که با عبارات <code>match</code> این کار را انجام می‌دهد. اگر بلوک آخر <code>else</code> را حذف کنیم و بنابراین برخی موارد را پوشش ندهیم، کامپایلر به ما در مورد باگ احتمالی منطقی هشدار نمی‌دهد.</p>
<h3 id="while-let-conditional-loops"><a class="header" href="#while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>ساختار <code>while let</code> مشابه <code>if let</code> است و به ما این امکان را می‌دهد که یک حلقه‌ی <code>while</code> تا زمانی که یک الگو با موفقیت تطبیق یابد، اجرا شود. در لیست ۱۹-۴، یک حلقه‌ی <code>while let</code> را نشان می‌دهیم که منتظر دریافت پیام‌هایی است که بین نخ‌ها (threads) ارسال می‌شوند، اما در این مورد به جای بررسی یک مقدار از نوع <code>Option</code>، یک مقدار از نوع <code>Result</code> را بررسی می‌کنیم.</p>
<figure class="listing" id="listing-19-4">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-19-4">Listing 19-4</a>: استفاده از یک حلقه‌ی <code>while let</code> برای چاپ مقادیر تا زمانی که <code>rx.recv()</code> مقدار <code>Ok</code> برگرداند</figcaption>
</figure>
<p>این مثال مقادیر <code>1</code>، <code>2</code>، و سپس <code>3</code> را چاپ می‌کند. متد <code>recv</code> اولین پیام را از سمت گیرنده‌ی کانال دریافت کرده و یک <code>Ok(value)</code> برمی‌گرداند. زمانی که در فصل ۱۶ با <code>recv</code> آشنا شدیم، یا مستقیماً خطا را <code>unwrap</code> می‌کردیم، یا از آن به‌عنوان یک پیمایشگر (iterator) در یک حلقه‌ی <code>for</code> استفاده می‌کردیم. اما همان‌طور که در لیست ۱۹-۴ نشان داده شده است، می‌توانیم از <code>while let</code> نیز استفاده کنیم، زیرا متد <code>recv</code> هر بار که پیامی دریافت شود، یک <code>Ok</code> برمی‌گرداند، تا زمانی که فرستنده هنوز وجود داشته باشد، و زمانی که سمت فرستنده قطع شود، یک <code>Err</code> تولید می‌کند.</p>
<h3 id="حلقههای-for"><a class="header" href="#حلقههای-for">حلقه‌های <code>for</code></a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a
pattern. For example, in <code>for x in y</code>, the <code>x</code> is the pattern. Listing 19-5
demonstrates how to use a pattern in a <code>for</code> loop to <em>destructure</em>, or break
apart, a tuple as part of the <code>for</code> loop.</p>
<figure class="listing" id="listing-19-5">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-19-5">Listing 19-5</a>: Using a pattern in a <code>for</code> loop to destructure a tuple</figcaption>
</figure>
<p>کدی که در لیست ۱۹-۵ آمده است، خروجی زیر را چاپ خواهد کرد:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>ما با استفاده از متد <code>enumerate</code> یک پیمایشگر (iterator) را تطبیق می‌دهیم تا همراه با هر مقدار، اندیس آن مقدار را نیز تولید کند؛ این دو مقدار در قالب یک tuple قرار می‌گیرند. اولین مقداری که تولید می‌شود tupleای به شکل <code>(0, 'a')</code> است. هنگامی که این مقدار با الگوی <code>(index, value)</code> تطبیق داده می‌شود، <code>index</code> برابر با <code>0</code> و <code>value</code> برابر با <code>'a'</code> خواهد بود، و خط اول از خروجی چاپ می‌شود.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>پارامترهای تابع نیز می‌توانند الگو باشند. کد در فهرست 19-6، که تابعی به نام <code>foo</code> را تعریف می‌کند که یک پارامتر به نام <code>x</code> از نوع <code>i32</code> می‌گیرد، باید تا الان آشنا به نظر برسد.</p>
<figure class="listing" id="listing-19-6">
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-19-6">Listing 19-6</a>: یک امضای تابع از الگوها در پارامترها استفاده می‌کند</figcaption>
</figure>
<p>قسمت <code>x</code> یک الگو است! همان‌طور که با <code>let</code> انجام دادیم، می‌توانیم یک tuple را در آرگومان‌های یک تابع با الگو مطابقت دهیم. فهرست 19-7 مقادیر یک tuple را هنگام ارسال به یک تابع تجزیه می‌کند.</p>
<figure class="listing" id="listing-19-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<figcaption><a href="#listing-19-7">Listing 19-7</a>: یک تابع با پارامترهایی که یک tuple را تخریب می‌کنند</figcaption>
</figure>
<p>این کد پیام <code>Current location: (3, 5)</code> را چاپ می‌کند. مقادیر <code>&amp;(3, 5)</code> با الگوی <code>&amp;(x, y)</code> مطابقت دارند، بنابراین <code>x</code> مقدار <code>3</code> و <code>y</code> مقدار <code>5</code> است.</p>
<p>ما همچنین می‌توانیم از الگوها در لیست پارامترهای closureها به همان روشی که در لیست پارامترهای تابع استفاده می‌کنیم، استفاده کنیم، زیرا closureها شبیه به توابع هستند، همان‌طور که در فصل 13 بحث شد.</p>
<p>تا اینجا، چندین روش برای استفاده از الگوها را دیده‌اید، اما الگوها در هر جایی که از آن‌ها استفاده کنیم به یک شکل کار نمی‌کنند. در برخی مکان‌ها، الگوها باید غیرقابل‌رد (irrefutable) باشند؛ در شرایط دیگر، می‌توانند قابل‌رد (refutable) باشند. در بخش بعدی این دو مفهوم را بررسی خواهیم کرد.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-02-refutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-02-refutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
