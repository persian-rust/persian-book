<!DOCTYPE HTML>
<html lang="fa" class="light sidebar-visible" dir="rtl">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>توسعه قابلیت‌های کتابخانه با توسعه مبتنی بر تست - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/persian-rust/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="توسعه-قابلیتهای-کتابخانه-با-توسعه-آزمونمحور-tdd-یا-همان-test-driven-development"><a class="header" href="#توسعه-قابلیتهای-کتابخانه-با-توسعه-آزمونمحور-tdd-یا-همان-test-driven-development">توسعه قابلیت‌های کتابخانه با توسعه آزمون‌محور (TDD) یا همان (Test-Driven Development)</a></h2>
<p>اکنون که منطق جست‌وجو را در فایل <em>src/lib.rs</em> و جدا از تابع <code>main</code> داریم، نوشتن تست برای عملکرد اصلی کد بسیار آسان‌تر شده است.
می‌توانیم توابع را مستقیماً با آرگومان‌های مختلف فراخوانی کنیم و مقادیر بازگشتی را بررسی کنیم، بدون آن‌که نیاز باشد باینری خود را از طریق خط فرمان اجرا کنیم.</p>
<p>در این بخش، منطق جستجو را با استفاده از فرآیند توسعه آزمون‌محور (TDD) به برنامه <code>minigrep</code> اضافه خواهیم کرد. مراحل این فرآیند به شرح زیر است:</p>
<ol dir="rtl">
  <li>نوشتن یک تست که شکست می‌خورد و اجرای آن برای اطمینان از اینکه به دلیلی که انتظار داشتید شکست می‌خورد.</li>
  <li>نوشتن یا تغییر کد به اندازه‌ای که تست جدید پاس شود.</li>
  <li>بازسازی کدی که به تازگی اضافه یا تغییر داده شده و اطمینان از اینکه تست‌ها همچنان پاس می‌شوند.</li>
  <li>تکرار از مرحله ۱!</li>
</ol>
<p>TDD تنها یکی از روش‌های نوشتن نرم‌افزار است، اما می‌تواند به طراحی بهتر کد کمک کند. نوشتن تست قبل از نوشتن کدی که تست را پاس می‌کند، کمک می‌کند تا پوشش تست بالا در طول فرآیند حفظ شود.</p>
<p>ما با استفاده از TDD پیاده‌سازی قابلیت جستجوی رشته کوئری در محتوای فایل و تولید لیستی از خطوط مطابق با کوئری را توسعه خواهیم داد. این قابلیت را در تابعی به نام <code>search</code> اضافه خواهیم کرد.</p>
<h3 id="نوشتن-یک-تست-که-شکست-میخورد"><a class="header" href="#نوشتن-یک-تست-که-شکست-میخورد">نوشتن یک تست که شکست می‌خورد</a></h3>
<p>در فایل <em>src/lib.rs</em>، یک ماژول <code>tests</code> با یک تابع تست اضافه می‌کنیم، همان‌طور که در [فصل ۱۱][ch11-anatomy]<!-- ignore --> انجام دادیم.
تابع تست، رفتاری را که از تابع <code>search</code> انتظار داریم مشخص می‌کند: این تابع یک <code>query</code> و متنی برای جست‌وجو دریافت می‌کند، و تنها خطوطی از متن را که شامل <code>query</code> هستند بازمی‌گرداند.
لیست ۱۲-۱۵ این تست را نشان می‌دهد.</p>
<figure class="listing" id="listing-12-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
<figcaption><a href="#listing-12-15">Listing 12-15</a>: ایجاد یک تست شکست‌خورده برای تابع <code>search</code> به منظور پیاده‌سازی عملکرد مورد انتظار</figcaption>
</figure>
<p>این تست به دنبال رشته <code>"duct"</code> می‌گردد. متنی که در آن جستجو می‌کنیم شامل سه خط است که تنها یکی از آن‌ها شامل <code>"duct"</code> است (توجه داشته باشید که بک‌اسلش بعد از علامت نقل قول بازکننده به Rust می‌گوید که کاراکتر newline در ابتدای محتویات این literal رشته قرار ندهد). ما تأیید می‌کنیم که مقدار بازگردانده شده از تابع <code>search</code> تنها شامل خطی است که انتظار داریم.</p>
<p>هنوز قادر به اجرای این تست و مشاهده شکست آن نیستیم زیرا تست حتی کامپایل نمی‌شود: تابع <code>search</code> هنوز وجود ندارد! بر اساس اصول TDD، ما تنها به اندازه‌ای کد اضافه می‌کنیم که تست کامپایل و اجرا شود، با اضافه کردن یک تعریف از تابع <code>search</code> که همیشه یک بردار خالی بازمی‌گرداند، همانطور که در لیست ۱۲-۱۶ نشان داده شده است. سپس تست باید کامپایل و شکست بخورد زیرا یک بردار خالی با یک بردار شامل خط <code>"safe, fast, productive."</code> مطابقت ندارد.</p>
<figure class="listing" id="listing-12-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-16">Listing 12-16</a>: تعریف حداقل کد برای تابع <code>search</code> تا تست ما کامپایل شود</figcaption>
</figure>
<p>حال بیایید بررسی کنیم که چرا نیاز داریم یک lifetime صریح با نام <code>'a</code> در امضای تابع <code>search</code> تعریف کنیم و این lifetime را با آرگومان <code>contents</code> و مقدار بازگشتی استفاده کنیم.
به یاد بیاورید که در <a href="ch10-03-lifetime-syntax.html">فصل ۱۰</a><!-- ignore -->، پارامترهای lifetime مشخص می‌کردند که lifetime کدام آرگومان با lifetime مقدار بازگشتی مرتبط است.
در این‌جا، مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌هایی از رشته باشد که به بخش‌هایی از آرگومان <code>contents</code> رفرنس می‌دهند (نه آرگومان <code>query</code>).</p>
<p>متوجه می‌شوید که ما نیاز داریم یک طول عمر صریح <code>'a</code> در امضای تابع <code>search</code> تعریف کنیم و از آن طول عمر با آرگومان <code>contents</code> و مقدار بازگشتی استفاده کنیم. به یاد داشته باشید که در <a href="ch10-03-lifetime-syntax.html">فصل ۱۰</a> توضیح دادیم که پارامترهای طول عمر مشخص می‌کنند کدام طول عمر آرگومان به طول عمر مقدار بازگشتی متصل است. در این مورد، ما مشخص می‌کنیم که بردار بازگشتی باید شامل برش‌های رشته‌ای باشد که به برش‌های آرگومان <code>contents</code> اشاره دارند (نه آرگومان <code>query</code>).</p>
<p>به عبارت دیگر، به Rust می‌گوییم داده‌ای که توسط تابع <code>search</code> بازگردانده می‌شود به اندازه داده‌ای که به تابع <code>search</code> در آرگومان <code>contents</code> منتقل می‌شود زنده خواهد بود. این مهم است! داده‌ای که توسط یک برش مرجع داده می‌شود باید معتبر باشد تا مرجع نیز معتبر باشد؛ اگر کامپایلر فرض کند که ما در حال ساختن برش‌های رشته‌ای از <code>query</code> هستیم به جای <code>contents</code>، بررسی‌های ایمنی را به اشتباه انجام خواهد داد.</p>
<p>اگر طول عمرها را فراموش کنیم و سعی کنیم این تابع را کامپایل کنیم، این خطا را دریافت خواهیم کرد:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:1:51
  |
1 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                      ----            ----         ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
  |
1 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
  |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>کامپایلر Rust نمی‌تواند به‌صورت خودکار تشخیص دهد که کدام‌یک از دو پارامتر باید به مقدار بازگشتی مرتبط باشد، بنابراین باید این موضوع را به‌صراحت به آن اعلام کنیم.<br />
توجه داشته باشید که متن راهنمای خطا پیشنهاد می‌دهد که برای همه پارامترها و نوع بازگشتی، از یک پارامتر lifetime مشترک استفاده شود، که این پیشنهاد نادرست است!<br />
از آن‌جا که <code>contents</code> پارامتری است که تمام متن ما را در بر دارد و ما قصد داریم بخش‌هایی از آن متن را که با جستجو مطابقت دارند بازگردانیم، می‌دانیم که فقط <code>contents</code> باید با مقدار بازگشتی از طریق نگارش lifetime مرتبط شود.</p>
<p>دیگر زبان‌های برنامه‌نویسی نیازی ندارند آرگومان‌ها را به مقادیر بازگشتی در امضا متصل کنید، اما این تمرین با گذشت زمان آسان‌تر می‌شود. ممکن است بخواهید این مثال را با مثال‌های موجود در بخش <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“اعتبارسنجی مراجع با طول عمر”</a> از فصل ۱۰ مقایسه کنید.</p>
<h3 id="نوشتن-کدی-برای-پاس-کردن-تست"><a class="header" href="#نوشتن-کدی-برای-پاس-کردن-تست">نوشتن کدی برای پاس کردن تست</a></h3>
<p>در حال حاضر، تست ما به دلیل اینکه همیشه یک بردار خالی بازمی‌گرداند، شکست می‌خورد. برای رفع این مشکل و پیاده‌سازی <code>search</code>، برنامه ما باید این مراحل را دنبال کند:</p>
<ol dir="rtl">
  <li>تکرار از طریق هر خط از محتوای فایل.</li>
  <li>بررسی اینکه آیا خط شامل رشته کوئری ما هست یا نه.</li>
  <li>اگر خط شامل کوئری بود، آن را به لیست مقادیر بازگشتی اضافه کنیم.</li>
  <li>اگر نبود، کاری انجام ندهیم.</li>
  <li>لیست نتایجی که مطابقت دارند را بازگردانیم.</li>
</ol>
<p>بیایید هر مرحله را یکی‌یکی اجرا کنیم، با تکرار از طریق خطوط شروع می‌کنیم.</p>
<h4 id="تکرار-از-طریق-خطوط-با-متد-lines"><a class="header" href="#تکرار-از-طریق-خطوط-با-متد-lines">تکرار از طریق خطوط با متد <code>lines</code></a></h4>
<p>Rust یک متد مفید برای مدیریت تکرار خط به خط در رشته‌ها ارائه می‌دهد که به طور مناسبی <code>lines</code> نامیده شده است و همانطور که در لیست ۱۲-۱۷ نشان داده شده کار می‌کند. توجه داشته باشید که این کد هنوز کامپایل نخواهد شد.</p>
<figure class="listing" id="listing-12-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-17">Listing 12-17</a>: تکرار از طریق هر خط در <code>contents</code></figcaption>
</figure>
<p>متد <code>lines</code> یک iterator برمی‌گرداند. ما در <a href="ch13-02-iterators.html">فصل ۱۳</a> عمیقاً در مورد iteratorها صحبت خواهیم کرد، اما به یاد داشته باشید که قبلاً این روش استفاده از یک iterator را در <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">لیست ۳-۵</a> دیدید، جایی که از یک حلقه <code>for</code> با یک iterator برای اجرای کدی روی هر آیتم در یک مجموعه استفاده کردیم.</p>
<h4 id="جستجو-در-هر-خط-برای-کوئری"><a class="header" href="#جستجو-در-هر-خط-برای-کوئری">جستجو در هر خط برای کوئری</a></h4>
<p>اکنون، بررسی خواهیم کرد که آیا خط فعلی شامل رشته کوئری ما هست یا نه. خوشبختانه، رشته‌ها یک متد مفید به نام <code>contains</code> دارند که این کار را برای ما انجام می‌دهد! یک فراخوانی به متد <code>contains</code> را در تابع <code>search</code> اضافه کنید، همانطور که در لیست ۱۲-۱۸ نشان داده شده است. توجه داشته باشید که این کد همچنان کامپایل نخواهد شد.</p>
<figure class="listing" id="listing-12-18">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-18">Listing 12-18</a>: اضافه کردن قابلیت بررسی اینکه آیا خط شامل رشته موجود در <code>query</code> هست یا نه</figcaption>
</figure>
<p>در حال حاضر، ما در حال ایجاد قابلیت‌های بیشتر هستیم. برای اینکه کد کامپایل شود، نیاز داریم مقداری را از بدنه تابع بازگردانیم همانطور که در امضای تابع اشاره کردیم.</p>
<h4 id="ذخیره-خطوط-مطابق"><a class="header" href="#ذخیره-خطوط-مطابق">ذخیره خطوط مطابق</a></h4>
<p>برای تکمیل این تابع، نیاز داریم روشی برای ذخیره خطوط مطابق که می‌خواهیم بازگردانیم داشته باشیم. برای این کار، می‌توانیم یک بردار mutable قبل از حلقه <code>for</code> ایجاد کنیم و با استفاده از متد <code>push</code> یک خط را در بردار ذخیره کنیم. بعد از حلقه <code>for</code>، بردار را بازمی‌گردانیم، همانطور که در لیست ۱۲-۱۹ نشان داده شده است.</p>
<figure class="listing" id="listing-12-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-19">Listing 12-19</a>: ذخیره خطوط مطابق برای بازگرداندن آن‌ها</figcaption>
</figure>
<p>اکنون تابع <code>search</code> باید فقط خطوطی را که شامل <code>query</code> هستند بازگرداند، و تست ما باید پاس شود. بیایید تست را اجرا کنیم:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>تست ما پاس شد، بنابراین می‌دانیم که کار می‌کند!</p>
<p>در این مرحله، می‌توانیم فرصت‌هایی برای بازسازی پیاده‌سازی تابع جستجو در نظر بگیریم و در عین حال تست‌ها را پاس نگه داریم تا همان قابلیت را حفظ کنیم. کد در تابع جستجو چندان بد نیست، اما از برخی ویژگی‌های مفید iteratorها استفاده نمی‌کند. ما در <a href="ch13-02-iterators.html">فصل ۱۳</a> به این مثال بازخواهیم گشت، جایی که iteratorها را با جزئیات بررسی می‌کنیم و به نحوه بهبود آن می‌پردازیم.</p>
<h4 id="استفاده-از-تابع-search-در-تابع-run"><a class="header" href="#استفاده-از-تابع-search-در-تابع-run">استفاده از تابع <code>search</code> در تابع <code>run</code></a></h4>
<p>اکنون که تابع <code>search</code> کار می‌کند و تست شده است، باید تابع <code>search</code> را از تابع <code>run</code> فراخوانی کنیم. ما باید مقدار <code>config.query</code> و <code>contents</code> که <code>run</code> از فایل می‌خواند را به تابع <code>search</code> بدهیم. سپس <code>run</code> هر خطی که از <code>search</code> برگردانده شده را چاپ خواهد کرد:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>ما هنوز از یک حلقه <code>for</code> برای بازگرداندن هر خط از <code>search</code> و چاپ آن استفاده می‌کنیم.</p>
<p>اکنون باید کل برنامه به‌درستی کار کند! بیایید آن را امتحان کنیم، ابتدا با واژه‌ای مانند <em>frog</em> که باید دقیقاً یک خط از شعر امیلی دیکینسون را بازگرداند.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>عالی! حالا بیایید کلمه‌ای را امتحان کنیم که چندین خط را مطابقت دهد، مثل <em>body</em>:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>و در نهایت، مطمئن شویم که وقتی کلمه‌ای را جستجو می‌کنیم که در هیچ جای شعر وجود ندارد، مثل <em>monomorphization</em>، هیچ خطی دریافت نخواهیم کرد:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>عالی! ما نسخه کوچکی از یک ابزار کلاسیک ساختیم و چیزهای زیادی درباره نحوه ساختاردهی برنامه‌ها آموختیم. همچنین کمی درباره ورودی و خروجی فایل، طول عمر‌ها، تست کردن و تجزیه دستورات خط فرمان یاد گرفتیم.</p>
<p>برای تکمیل این پروژه، به طور مختصر نشان خواهیم داد که چگونه با متغیرهای محیطی کار کنیم و چگونه به خطای استاندارد (standard error) چاپ کنیم، که هر دو در هنگام نوشتن برنامه‌های خط فرمان مفید هستند.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
